<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE Archive SYSTEM "http://greenstone.org/dtd/Archive/1.0/Archive.dtd">
<Archive>
<Section>
  <Description>
    <Metadata name="gsdldoctype">indexed_doc</Metadata>
    <Metadata name="Language">en</Metadata>
    <Metadata name="Encoding">utf8</Metadata>
    <Metadata name="Title">The Intel Micrprocessors</Metadata>
    <Metadata name="URL">http://C:/Program Files/Greenstone/tmp/F153.html</Metadata>
    <Metadata name="UTF8URL">http://C:/Program Files/Greenstone/tmp/F153.html</Metadata>
    <Metadata name="gsdlsourcefilename">import\4_5981107341137806159.pdf</Metadata>
    <Metadata name="gsdlconvertedfilename">C:\Program Files\Greenstone\tmp\F153.html</Metadata>
    <Metadata name="OrigSource">F153.html</Metadata>
    <Metadata name="Source">4_5981107341137806159.pdf</Metadata>
    <Metadata name="SourceFile">4_5981107341137806159.pdf</Metadata>
    <Metadata name="Plugin">PDFPlugin</Metadata>
    <Metadata name="FileSize">54953278</Metadata>
    <Metadata name="FilenameRoot">4_5981107341137806159</Metadata>
    <Metadata name="FileFormat">PDF</Metadata>
    <Metadata name="srcicon">_iconpdf_</Metadata>
    <Metadata name="srclink_file">doc.pdf</Metadata>
    <Metadata name="srclinkFile">doc.pdf</Metadata>
    <Metadata name="NumPages">920</Metadata>
    <Metadata name="dc.Creator">brhane</Metadata>
    <Metadata name="dc.Subject">Chemistry</Metadata>
    <Metadata name="dc.Title">Introduction to Chemistry</Metadata>
    <Metadata name="dls.Organization">Natural Science|Chemistry|Books</Metadata>
    <Metadata name="ex.ExifTool.ExifToolVersion">8.57</Metadata>
    <Metadata name="ex.File.Directory">C:\Program Files\Greenstone\collect\ebook\import</Metadata>
    <Metadata name="ex.File.FileModifyDate">2018:12:10 02:59:40-08:00</Metadata>
    <Metadata name="ex.File.FileName">4_5981107341137806159.pdf</Metadata>
    <Metadata name="ex.File.FilePermissions">666</Metadata>
    <Metadata name="ex.File.FileSize">54953278</Metadata>
    <Metadata name="ex.File.FileType">PDF</Metadata>
    <Metadata name="ex.File.MIMEType">application/pdf</Metadata>
    <Metadata name="ex.PDF.Author">Barry B. brey</Metadata>
    <Metadata name="ex.PDF.CreateDate">2008:10:27 08:24:06Z</Metadata>
    <Metadata name="ex.PDF.Keywords">Lamchochiya</Metadata>
    <Metadata name="ex.PDF.Linearized">false</Metadata>
    <Metadata name="ex.PDF.ModifyDate">2011:11:08 06:55:28-02:00</Metadata>
    <Metadata name="ex.PDF.PDFVersion">1.6</Metadata>
    <Metadata name="ex.PDF.PageCount">920</Metadata>
    <Metadata name="ex.PDF.Producer">Adobe Acrobat 9.0 Paper Capture Plug-in</Metadata>
    <Metadata name="ex.PDF.Subject">Architecture&amp;#44; Prgramming and Interfacing</Metadata>
    <Metadata name="ex.PDF.Title">The Intel Micrprocessors</Metadata>
    <Metadata name="ex.XMP.CreateDate">2008:10:27 08:24:06Z</Metadata>
    <Metadata name="ex.XMP.Creator">Barry B. brey</Metadata>
    <Metadata name="ex.XMP.Description">Architecture&amp;#44; Prgramming and Interfacing</Metadata>
    <Metadata name="ex.XMP.DocumentID">uuid:995e6f60-0bc6-4e6b-869c-d35094ed0194</Metadata>
    <Metadata name="ex.XMP.Format">application/pdf</Metadata>
    <Metadata name="ex.XMP.InstanceID">uuid:be3bd83c-17e5-4e3c-b575-299681681dd2</Metadata>
    <Metadata name="ex.XMP.Keywords">Lamchochiya</Metadata>
    <Metadata name="ex.XMP.MetadataDate">2011:11:08 06:55:28-02:00</Metadata>
    <Metadata name="ex.XMP.ModifyDate">2011:11:08 06:55:28-02:00</Metadata>
    <Metadata name="ex.XMP.Producer">Adobe Acrobat 9.0 Paper Capture Plug-in</Metadata>
    <Metadata name="ex.XMP.Title">The Intel Micrprocessors</Metadata>
    <Metadata name="ex.XMP.XMPToolkit">Adobe XMP Core 4.2.1-c041 52.342996&amp;#44; 2008/05/07-20:48:00</Metadata>
    <Metadata name="Identifier">HASH017c82fc0b66cf2f28d0b14d</Metadata>
    <Metadata name="lastmodified">1544439580</Metadata>
    <Metadata name="lastmodifieddate">20181210</Metadata>
    <Metadata name="oailastmodified">1545141355</Metadata>
    <Metadata name="oailastmodifieddate">20181218</Metadata>
    <Metadata name="assocfilepath">HASH017c.dir</Metadata>
    <Metadata name="gsdlassocfile">doc.pdf:application/pdf:</Metadata>
  </Description>
  <Content>
&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;THE INTEL MICROPROCESSORS &lt;br /&gt;QnQ~/80QQ 8n18~/Qn188 Q02Q~ Q0386 uuuu UU, U I UI UU I ,U UU, UU , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486, Pentium, and Pentium Pro Processor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Architecture, Programming, and Interfacing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fourth Edition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BARRY B. BREY &lt;br /&gt;DeVry Institute of Technology &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Prentice-Hall International, Inc. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;ISBN 0-13-802745-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cover photo: Ted Horowitz!The Stock Market &lt;br /&gt;Editor: Charles E. Stewart, Jr. &lt;br /&gt;Production Coordination: Tim Flem, Custom Editorial Productions, Inc. &lt;br /&gt;Cover Designer: Brian Deep &lt;br /&gt;Production Manager: Deidra M. Schwartz &lt;br /&gt;Marketing Manager: Debbie Yamell &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This book was set in Times Roman by Custom Editorial Productions, Inc. and was printed and bound by &lt;br /&gt;Courier/Kendallville, Inc. The cover was printed by Phoenix Color Corp. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â© 1997 by Prentice-Hall, Inc. &lt;br /&gt;Simon &amp;amp; Schuster/A Viacom Company &lt;br /&gt;Upper Saddle River, New Jersey 07458 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All rights reserved. No part of this book may be reproduced, in any form or by any means, without permission &lt;br /&gt;in writing from the publisher. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This edition may be sold only in those countries to which it is consigned by Prentice-Hall International. It is not &lt;br /&gt;to be re-exported, and it is not for sale in the U.S.A., Mexico, or Canada. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Printed in the United States of America &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 9 8 7 6 5 4 3 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ISBN 0-13-802745-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Prentice-Hall International (UK) Limited, London &lt;br /&gt;Prentice-Hall of Australia Pty. Limited, Sydney &lt;br /&gt;Prentice-Hall Canada Inc., Toronto &lt;br /&gt;Prentice-Hall Hispanoamericana, S. A., Mexico &lt;br /&gt;Prentice-Hall of India Private Limited, New Delhi &lt;br /&gt;Prentice-Hall of Japan, Inc., Tokyo &lt;br /&gt;Simon &amp;amp; Schuster Asia Pte. Ltd., Singapore &lt;br /&gt;Editora Prentice-Hall do Brasil, Ltda., Rio de Janeiro &lt;br /&gt;Prentice-Hall, Inc., Upper Saddle River, New Jersey &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;This text is dedicated to the memory of my father, &lt;br /&gt;Wilmer A. Brey, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;who worked for over 40 years in the steel industry &lt;br /&gt;to provide America with the raw materials &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to become a great industrial power. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;PREFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This fourth edition text is written for the student in a course of study th~t requires a thorough &lt;br /&gt;knowledge of programming and interfacing of the Intel family of microprocessors. It is a very &lt;br /&gt;practical reference text for anyone interested in all programming and interfacing aspects of this &lt;br /&gt;important microprocessor family. Today, anyone functioning or striving to function in a field of &lt;br /&gt;study that uses computers must understand assembly language programming and interfacing. &lt;br /&gt;Intel microprocessors have gained wide applications in many areas of electronics, communica-&lt;br /&gt;tions, control systems, and particularly in desk1:Op computer systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORGANIZATION AND COVERAGE &lt;br /&gt;In order to cultivate a comprehensive approach to learning, each chapter of the text begins with &lt;br /&gt;a set of. objec:tives that briefly define the contents of the chapter. This is followed by the body of &lt;br /&gt;the chapter, which includes many programming applications that illustrate the main topics of the &lt;br /&gt;chapter. At the end of each chapter, a numerical summary, which doubles as a study guide, re-&lt;br /&gt;views the information presented in the chapter. Finally, questions and problems are provided to &lt;br /&gt;promote practice and mental exercise with the concepts presented in the chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This text contains many example programs, using the Microsoft MACRO assembler pro-&lt;br /&gt;gram, to provide an opportunity to learn how to program the Intel family of microprocessors. &lt;br /&gt;Operation of the programming environment includes the linker, library, macros, DOS function, &lt;br /&gt;and BIOS functions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also provided is a thorough description of each family member, memory systems, and var-&lt;br /&gt;ious I/O systems that include disk memory, ADC and DAC, 16550 UART, PIAs, timers, key-&lt;br /&gt;board/display controllers, arithmetic coprocessors, and video display systems. Also discussed &lt;br /&gt;are the personal computer system buses (ISA, VESA, and PCI). Through these systems, a prac-&lt;br /&gt;tical approach to microprocessor interfacing is learned. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;APPROACH &lt;br /&gt;Because the Intel family of microprocessors is quite diverse, this text initially concentrates on &lt;br /&gt;real mode programming, which is compatible with all versions of the Intel family of micro-&lt;br /&gt;processors. Instructions for each family member, which includes the 80386, 80486, Pentium, and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vii &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;viii PREFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro processors are compared and contrasted with the 8086/8088 microprocessors. This &lt;br /&gt;entire series of microprocessors is very similar, which allows more advanced versions to be &lt;br /&gt;learned once the basic 8086/8088 microprocessors are understood. Please note that the &lt;br /&gt;8086/8088 are still used in controllers, along with their updated counterparts, the 80186/80188 &lt;br /&gt;and 80386EX embedded controllers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In addition to fully explaining the programming and operation of the microprocessor, this &lt;br /&gt;text also explains the programming and operation of the numeric coprocessor (8087/802871 &lt;br /&gt;80387/80486/80487IPentiumlPentium Pro). The numeric coprocessor functions in a system to &lt;br /&gt;provide access to floating-point calculations that are important in applications such as control &lt;br /&gt;systems, video graphics, and computer-aided design (CAD). The numeric coprocessor allows a &lt;br /&gt;program to access complex arithmetic operations that are otherwise difticult to achieve with &lt;br /&gt;normal microprocessor programming. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also described are the pin-outs and functions of the 8086-80486 and PentiumlPentium Pro &lt;br /&gt;microprocessors. Interfacing is first developed using the 8088/8086 with some of the more &lt;br /&gt;common peripheral components. After learning the basics, a more advanced emphasis is placed &lt;br /&gt;on the 80186/80188, 80386, 80486, Pentium, and Pentium Pro microprocessors. Because of its &lt;br /&gt;similarity to the 8086 and 80386, coverage of the 80286 is minimized so that the 80386, 80486, &lt;br /&gt;Pentium, and Pentium Pro can be covered in complete detail. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;By studying the operation and programming of the microprocessor and numeric co-&lt;br /&gt;processor, as well as the interfacing of all family members, you will be provided with a working &lt;br /&gt;and practical background on the Intel family of microprocessors. On completion of a course of &lt;br /&gt;study based on this text, you should be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Develop control software to control an application interface to the 8086/8088, 80186/80188, &lt;br /&gt;80286, 80386, 80486, Pentium, and Pentium Pro microprocessors. Generally, the software &lt;br /&gt;developed will function on all versions of the microprocessor. This software also includes &lt;br /&gt;DOS-based applicatiQns. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ P[9gram.JJ,Â§ingJ2QS function cal.~.~o control the keyboard, video display s~!~m, and disk &lt;br /&gt;memory in assem~.!x language. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Use the BIOS functio_~~J!9l the keyboard, display, and various other components in the &lt;br /&gt;computer system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Develop software that uses macro sequences, procedures, conditional assembly directives, &lt;br /&gt;and flow control assembler di~~~ti~;;' ~.. ~~&amp;gt;'. ~ â¢. '. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Develop software that uses interrupt hooks and hot-keys to gain access to terminate,and slay &lt;br /&gt;resident software. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Program the numeric coprQf~sor (80287/80387/80486/804871PentiumlPentium Pro) to &lt;br /&gt;solve complex equations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Explain the differences between the ~!L!TlÂ£!~!~e.rs and highlight the features of each &lt;br /&gt;member. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Describe and use real and .Qfotected mod,e operation of the 80286, 80386, 80486, Pentium, &lt;br /&gt;and Pentium Pro microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Interface memory and I/O systcms to the microprocessor. &lt;br /&gt;----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Provide a detailed and comprehcnsive comparison of all famil):: I~_ers, thcir software, and &lt;br /&gt;hardware interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ Explain the operation of ~.~!!~Ly.!~e.&amp;lt;:l.Jystequ;. &lt;br /&gt;ry Interface small systems to the ISA, VESA local, an~R.9 Â£us in a personal computer system. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;PREFACE ix &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTENT OVERVIEW &lt;br /&gt;Chapter I introduces the Intel family of microprocessors, with an emphasis on the !!Iicro-&lt;br /&gt;pro~~~()r-based computer system. This first chapter servcs to introduce the microprocessor, &lt;br /&gt;its history, its operation, and the methods used to store data in a micn processor-based &lt;br /&gt;system. In this edition, we also include a coverage of number systems for those who are un-&lt;br /&gt;aware of them~'Chapter 2 explores the programming model of the microprocessor and system &lt;br /&gt;architecture. Both real and protected mode operation are explained in this second introduc-&lt;br /&gt;tory chapter. .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once an understanding of the basic machine is grasped, Chapters 3-6 ~xplain how each in-&lt;br /&gt;struction functions with the ~ntel family of microprocessorÂ§. As instructions are explained, simple &lt;br /&gt;applications are presented to illustrate their operation ~nd to develop basic programming concepts. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After the basis for programming is developed,'&amp;quot;Chapter 7 provides applications using the &lt;br /&gt;l!s_~embler program. These applications include programming using DOS-and BIOS function &lt;br /&gt;calls and the mo~se function calls. l!isk files are explained as well as keyboard and video opera-&lt;br /&gt;tion on a personal computer system. This chapter provides the tools required to develop virtually &lt;br /&gt;any program on a personal computer system. It also introduces the concept of interrupt hooks &lt;br /&gt;and !lOt-keys. &lt;br /&gt;~J!~Ptt::.f.~ introduces the ~()86/8088 family as a basis for learning the .Qasic memory and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;YQ interfacing concepts that follow in later chapters. This chapter shows the buffered system as &lt;br /&gt;well as the system timing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; Chapter 9 provides c.9_ll1plete detail on memory interface using both integrated decoders &lt;br /&gt;and programmable logic devices. Parity is illustrated as well as dynamic memory systems. The &lt;br /&gt;8-, 16-, 32-, and 64-bit memory systems are provided so that the 8086-80486 and Pentiuml &lt;br /&gt;~!lti~m Pro microprocessors ~an be interfaced to memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;?, Chapter 10 provides a detailed look at basic 110 interfacing by discussing PIAs, timers, &lt;br /&gt;keyboard/display interfaces, 16550 UART, and ADCIDAC. It also describes the interface of &lt;br /&gt;both DC and stepper motors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once these basic liD components and their interface to the microprocessor is understood, &lt;br /&gt;Chapters 11 and 12 provide detail on advanced liD techniques that include interrupts and direct &lt;br /&gt;memory access (DMA). Applications include a printer interface, real-time clock, disk memory, &lt;br /&gt;and video systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Chapter 13 details the operation and programming for the 8087-Pentium Pro family of &lt;br /&gt;arithmetic coprocessors. Today, few applications function efficiently without the power of the &lt;br /&gt;arithmetic coprocessor. Remember that all Intel microprocessors since the 80486 contain a &lt;br /&gt;coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Chapter 14 shows how tginterface small systems to the per~onal computer through the use &lt;br /&gt;of the ISA, VESA, and PCI bus interfaces. This chapter, new to this edition, provides a &lt;br /&gt;launchi~g-point f~r the many cards being designed for use in the personal computer embedded in &lt;br /&gt;control systems in the industry. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Chapters 15 and 16 provide detail on the advanced 80186/80188-80486 microprocessors. &lt;br /&gt;In these chapters, we explore the differences between these microprocessors and the 808618088, &lt;br /&gt;as well as their enhancements and features. Cache memory, as well as interleaved and burst &lt;br /&gt;memory, are described with the 80386 and S0486 microprocessors. Also described are memory &lt;br /&gt;management and memory paging. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Chapter 17 details the Pentium and Pentium Pro microprocessors. These new microproces-&lt;br /&gt;sors are based upon the original 8086/8088 and should carry Intel well into the next century. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Four appendixes are included to enhance the application of the text: &lt;br /&gt;1. Appendix A includes a complete listing of the DOS INT 21 H function calls. This appendix &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;also details the use of the assembler program and many of the BIOS function calls, including &lt;br /&gt;BIOS function call INT lOH. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;x PREFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Appendix B gives a complete listing of all 8086-Pentium Pro instructions, including many ex-&lt;br /&gt;ample instructions and machine coding in hexadecimal, as well as clock timing information. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Appendix C provides a compact list of all the instructions that change the flag bits. &lt;br /&gt;4. Appendix D provides answers for the even-numbered questions and problems from the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ACKNOWLEDGMENTS &lt;br /&gt;I would like to acknowledge the reviewers for this edition: John Paul Froehlich, University of &lt;br /&gt;Hartford, and Jeffrey B. Weaver, Pennsylvania College of Technology. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STAY IN TOUCH &lt;br /&gt;You can stay in touch with me through the Internet. My Internet site contains information about &lt;br /&gt;all of my textbooks and many important links that are specific to the personal computer, micro-&lt;br /&gt;processors, hardware, and software. Also available is a weekly lesson that details many of the as-&lt;br /&gt;pects of the personal computer. My Internet address is http://users1.ee.netlbrey/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LAB SUPPORT &lt;br /&gt;A lab manual, Instructor's Manual to Accompany The Intel Microprocessors: 808618088, &lt;br /&gt;80186, 80286, 80386, 80486, Pentium, and Pentium Pro Microprocessors: Architecture, Pro-&lt;br /&gt;gramming, and Inteifacing (ISBN: O-13-262981-X), is available from Prentice Hall to support &lt;br /&gt;the programming portion of this text. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;() 1-1 &lt;br /&gt;'&amp;quot; 1-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-3 &lt;br /&gt;(J 1-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-5 &lt;br /&gt;1-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction &lt;br /&gt;Chapter Objectives 1 &lt;br /&gt;A Historical Background 2 &lt;br /&gt;The Microprocessor-Based Personal Computer System 11 &lt;br /&gt;Number Systems 25 &lt;br /&gt;Computer Data Formats 31 &lt;br /&gt;Summary 39 &lt;br /&gt;Questions and Problems 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 45 &lt;br /&gt;Chapter Objectives 45 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f 2-1 Internal Microprocessor Architecture 45 &lt;br /&gt;t? 2-2 Real Mode Memory Addressing 51 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2-3 Protected Mode Memory Addressing 25 &lt;br /&gt;2-4 Memory Paging 60 &lt;br /&gt;2-5 Summary 64 &lt;br /&gt;2-6 Questions and Problems 65 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 68 &lt;br /&gt;Chapter Objectives 68 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3-1 Data-Addressing Modes 69 &lt;br /&gt;3-2 Program Memory-Addressing Modes 90 &lt;br /&gt;3-3 Stack Memory-Addressing Modes 92 &lt;br /&gt;3-4 Summary 95 &lt;br /&gt;3-5 Questions and Problems 98 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;45 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;68 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;xi &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;xii &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 10 1 &lt;br /&gt;Chapter Objectives 101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-1 MOV Revisited 102 &lt;br /&gt;4-2 PUSHIPOP 110 &lt;br /&gt;4-3 Load-Effective Address 115 &lt;br /&gt;4-4 String Data Transfers 118 &lt;br /&gt;4-5 Miscellaneous Data Transfer Instructions 124 &lt;br /&gt;4-6 Segment Override Prefix 129 &lt;br /&gt;4-7 Assembler Detail 130 &lt;br /&gt;4-8 Summary 139 &lt;br /&gt;4-9 Questions and Problems 141 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 144 &lt;br /&gt;Chapter Objectives 144 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-1 Addition, Subtraction, and Comparison 144 &lt;br /&gt;5-2 Multiplication and Division 155 &lt;br /&gt;5-3 BCD and ASCII Arithmetic 160 &lt;br /&gt;5-4 Basic Logic Instructions 163 &lt;br /&gt;5-5 Shift and Rotate 169 &lt;br /&gt;5-6 String Comparisons 173 &lt;br /&gt;5-7 Summary 175 &lt;br /&gt;5-8 Questions and Problems 177 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 180 &lt;br /&gt;Chapter Objectives 180 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6-1 The Jump Group 180 &lt;br /&gt;6-2 Controlling the Flow of an Assembly Language Program 190 &lt;br /&gt;6-3 Procedures 197 &lt;br /&gt;6-4 Introduction to Interrupts 203 &lt;br /&gt;6-5 Machine Control and Miscellaneous Instructions 206 &lt;br /&gt;6-6 Summary 210 &lt;br /&gt;6-7 Questions and Problems 212 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 215 &lt;br /&gt;Chapter Objectives 21:' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-1 Modular Programming 216 &lt;br /&gt;7-2 Using the Keyboard and Video Display 229 &lt;br /&gt;7-3 Data Conversions 243 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;144 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;180 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;215 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-4 Disk Files 253 &lt;br /&gt;7-5 Example Programs 263 &lt;br /&gt;7-6 Interrupt Hooks 270 &lt;br /&gt;7-7 Summary 281 &lt;br /&gt;7-8 Questions and Problems 282 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 285 &lt;br /&gt;Chapter Objectives 285 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-1 Pin-Outs and the Pin Function 285 &lt;br /&gt;8-2 Clock Generator (8284A) 291 &lt;br /&gt;8-3 Bus Buffering and Latching 294 &lt;br /&gt;8-4 Bus Timing 299 &lt;br /&gt;8-5 Ready and the Wait State 304 &lt;br /&gt;8-6 Minimum Mode Versus Maximum Mode 307 &lt;br /&gt;8-7 Summary 309 &lt;br /&gt;8-8 Questions and Problems 310 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 312 &lt;br /&gt;Chapter Objectives 312 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-1 Memory Devices 312 &lt;br /&gt;9-2 Address Decoding 324 &lt;br /&gt;9-3 8088 and 80188 (8-Bit) Memory Interface 332 &lt;br /&gt;9-4 8086,80186,80286, and 80386SX (16-Bit) Memory Interface &lt;br /&gt;9-5 80386DX and 80486 (32-Bit) Memory Interface 347 &lt;br /&gt;9-6 Pentium and Pentium Pro (64-Bit) Memory Interface &lt;br /&gt;9-7 Dynamic RAM 353 &lt;br /&gt;9-8 Summary 358 &lt;br /&gt;9-9 Questions and Problems &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 362 &lt;br /&gt;Chapter Objectives 362 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;359 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-1 Introduction to I/O Interface 362 &lt;br /&gt;10-2 I/O Port Address Decoding 369 &lt;br /&gt;10-3 The Programmable Peripheral Interface 375 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;350 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-4 The 8279 Programmable Keyboard/Display Interface 394 &lt;br /&gt;10-5 8254 Programmable Interval Timer 402 &lt;br /&gt;10-6 16550 Programmable Communications Interface 412 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;340 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-7 Analog-to-Digital (ADC) and Digital-to-Analog (DAC) Converters 419 &lt;br /&gt;10-8 Summary 426 &lt;br /&gt;10-9 Questions and Problems 427 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;xiii &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;285 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;312 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;362 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;xiv &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 430 &lt;br /&gt;Chapter Objectives 430 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11-1 Basic Interrupt Processing 430 &lt;br /&gt;11-2 Hardware Interrupts 439 &lt;br /&gt;11-3 Expanding the Interrupt Structure 445 &lt;br /&gt;11-4 8259A Programmable Interrupt ControlIer 448 &lt;br /&gt;11-5 Real-Time Clock 462 &lt;br /&gt;11-6 Summary 464 &lt;br /&gt;11-7 Questions and Problems 465 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 467 &lt;br /&gt;Chapter Objectives 467 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12-1 Basic DMA Operation 467 &lt;br /&gt;12-2 The 8237 DMA Controller 469 &lt;br /&gt;12-3 Shared-Bus Operation 483 &lt;br /&gt;12-4 Disk Memory Systems 500 &lt;br /&gt;12-5 Video Displays 508 &lt;br /&gt;12-6 Summary 515 &lt;br /&gt;12-7 Questions and Problems 515 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 517 &lt;br /&gt;Chapter Objectives 517 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-1 Data Formats for the Arithmetic Coprocessor 518 &lt;br /&gt;13-2 The 80X87 Architecture 522 &lt;br /&gt;13-3 Instruction Set 527 &lt;br /&gt;13-4 Programming with the Arithmetic Coprocessor 551 &lt;br /&gt;13-5 Summary 558 &lt;br /&gt;13-6 Questions and Problems 559 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 562 &lt;br /&gt;Chapter Objectives 562 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14-1 The ISA Bus 562 &lt;br /&gt;14-2 The Extended ISA (EISA) and VESA Loc;':1 Buses 569 &lt;br /&gt;14-3 The Peripheral Component Interconnect (PCl) Bus 573 &lt;br /&gt;14-4 Summary 582 &lt;br /&gt;14-5 Questions and Problems 582 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;430 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;467 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;517 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;562 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE 80186,80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Introduction 584 &lt;br /&gt;Chapter Objectives 584 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15-1 80186/80188 Arcnitecture 584 &lt;br /&gt;15-2 Programming the 80186/80188 Enhancements 594 &lt;br /&gt;15-3 80C188EB Example Interface 612 &lt;br /&gt;15-4 Introduction to the 80286 616 &lt;br /&gt;15-5 Summary 619 &lt;br /&gt;15-6 Questions and Problems 620 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;Introduction 622 &lt;br /&gt;Chapter Objectives 622 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-1 Introduction to the 80386 Microprocessor 623 &lt;br /&gt;16-2 Special 80386 Registers 636 &lt;br /&gt;16-3 80386 Memory Management 639 &lt;br /&gt;16-4 Moving to Protected Mode 647 &lt;br /&gt;16-5 Virtual 8086 Mode 659 &lt;br /&gt;16-6 The Memory Paging Mechanism 660 &lt;br /&gt;16-7 Introduction to the 80486 Microprocessor 665 &lt;br /&gt;16-8 Summary 675 &lt;br /&gt;16-9 Questions and Problems 676 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;Introduction 679 &lt;br /&gt;Chapter Objectives 679 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-1 Introduction to the Pentium Microprocessor 680 &lt;br /&gt;17-2 Special Pentium Registers 689 &lt;br /&gt;17-3 Pentium Memory Management 691 &lt;br /&gt;17-4 New Pentium Instructions 693 &lt;br /&gt;17-5 Introduction to the Pentium Pro Microprocessor 696 &lt;br /&gt;17-6 Special Pentium Pro Features 705 &lt;br /&gt;17-7 Summary 706 &lt;br /&gt;17-8 Questions and Problems 707 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;APPENDIXES &lt;br /&gt;A The Assembler, Disk Operating System, Basic I/O System, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mouse, and DPMI Memory Manager 709 &lt;br /&gt;B Instruction Set Summary 783 &lt;br /&gt;C Flag-Bit Changes 871 &lt;br /&gt;D Answers to Selected Even-Numbered Questions and Problems 873 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INDEX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;xv &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;584 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;622 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;679 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;709 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;901 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;f &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;THE INTEL MICROPROCESSORS &lt;br /&gt;8086/8088,80186/80188,80286,80386, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486, Pentium, and Pentium Pro Processor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Architecture, Programming, and Interfacing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fourth Edition &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CHAPTER 1 &lt;br /&gt;Introduction to the &lt;br /&gt;Microprocessor and Computer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This chapter provides an overview of the Intel family of microprocessors. Included is a &lt;br /&gt;discussion of the history of computers and the function of the microprocessor in the micro-&lt;br /&gt;processor-based computer system. Also introduced are the terms and jargon of the computer &lt;br /&gt;field so that computerese is understood and used when discussing microprocessors and &lt;br /&gt;computers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The block diagram, and a description of the function of each block, detail the operation &lt;br /&gt;of a computer system. The chapter also shows how the memory and input/output system of &lt;br /&gt;the personal computer function. Finally, the way that data are stored in the memory is pro-&lt;br /&gt;vided so that each data type can be used as software is developed. Numeric data are stored as &lt;br /&gt;integers, floating-point, and binary-coded decimal (BCD); alphanumeric data are stored using &lt;br /&gt;the ASCII (American Standard Code for Information Interchange) code. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Use appropriate computer terminology including bit, byte, data, real memory system, ex-&lt;br /&gt;panded memory system (EMS), extended memory system (XMS), DOS, BIOS, 110, and &lt;br /&gt;so forth. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Briefly detail the history of the computer and list applications performed by the computer. &lt;br /&gt;3. Provide an overview of the various 80X86 and Pentium/Pentium Pro family members. &lt;br /&gt;4. Draw the block diagram of a computer system and explain the purpose of each block. &lt;br /&gt;5. Describe the function of the microprocessor and detail its basic operation. &lt;br /&gt;6. Define the contents of the memory system in the personal computer. &lt;br /&gt;7. Convert between binary, decimal, and hexadecimal numbers. &lt;br /&gt;8. Differentiate and represent numeric and alphabetic information as integers, floating-point, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BCD, and ASCII data. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A HISTORICAL BACKGROUND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This first section outlines the historical events leading to the development of the microprocessor &lt;br /&gt;and, specifically, the extremely powerful and current 80X861 and Pentium and Pentium Pro2 mi-&lt;br /&gt;croprocessors. Although a study of history is not essential to understand the microprocessor, it &lt;br /&gt;provides a historical perspective on the fast-paced evolution of the computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Mechanical Age &lt;br /&gt;The idea of a computing system is not new-it existed long before modem electrical and elec-&lt;br /&gt;tronic devices were invented. The idea of calculating with a machine dates to before 500 B.c. &lt;br /&gt;when the Babylonians invented the abacus, the first mechanical calculator. The abacus, which &lt;br /&gt;uses strings of beads to perform calculations, was used by Babylonian priests to keep track of &lt;br /&gt;their vast storehouses of grain. The abacus, which was used extensively and is still in use today, &lt;br /&gt;was not improved until 1642, when Blaise Pascal, the mathematician, invented a calculator con-&lt;br /&gt;structed of gears and wheels. Each gear contained 10 teeth that, when moved one complete rev-&lt;br /&gt;olution, advanced a second gear one place. This is the same principle employed in a car's &lt;br /&gt;odometer mechanism and is the basis of all mechanical calculators. Incidentally, the PASCAL &lt;br /&gt;programming language is named in honor of Blaise Pascal for his pioneering work in mathe-&lt;br /&gt;matics and with the mechanical calculator. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The arrival of the first practical geared, mechanical machines used to compute information &lt;br /&gt;automatically dates to the early 1800s. This is before humans invented the light bulb or before &lt;br /&gt;much was known about electricity. In this dawn of the computer age, humans dreamed of me-&lt;br /&gt;chanical machines that could compute numerical facts with a program-not merely calculate &lt;br /&gt;facts as with a calculator. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;One early pioneer of mechanical computing machinery was Charles Babbage, who was &lt;br /&gt;aided by Augusta Ada Byron, the Countess of Lovelace. Babbage was commissioned in 1823 by &lt;br /&gt;the Royal Astronomical Society of Great Britain to produce a programmable calculating ma-&lt;br /&gt;chine. This machine was to generate navigational tables for the Royal Navy. He accepted the &lt;br /&gt;challenge and began to create what he called his Analytical Engine. This engine was a mechan-&lt;br /&gt;ical computer that stored 1,000 20-digit decimal numbers and a variable program that could &lt;br /&gt;modify the function of the machine so it could perform various calculating tasks. Input to his en-&lt;br /&gt;gine was through punched cards, much as computers in the 1950s and 1960s used punched cards. &lt;br /&gt;It is assumed that he obtained the idea of using punched cards from Joseph Jacquard, a &lt;br /&gt;Frenchman who used punched cards as input to a weaving machine he invented in 1801, which &lt;br /&gt;is today called Jacquard's loom. Jacquard's loom used punched cards to select intricate weaving &lt;br /&gt;patterns in the cloth that it produced. The punched cards programmed the loom. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After many years of work, Babbage's dream began to fade when he realized that the ma-&lt;br /&gt;chinists of his day were unable to create the mechanical parts needed to complete his work. The &lt;br /&gt;Analytical Engine required more than 50,000 machined parts, which could not be made with &lt;br /&gt;enough precision to allow his engine to function reliably. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Electrical Age &lt;br /&gt;The 1800s saw the advent of the electric motor (conceived by Michael Faraday); with it came a &lt;br /&gt;multitude of motor-driven adding machines. all based on the mechanical calculator developed by &lt;br /&gt;Blaise Pascal. These electrically driven mechanical calculators were common pieces of office &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'80X86 is shorthand notation that embodies the 8086. 8088. 80186. 80188, 80286, 80386, and 80486 microprocessors. &lt;br /&gt;2Pentium and Pentium Pro are registered trademarks of Intel Corporation and represent either the Pentium or the Pen-&lt;br /&gt;tium Pro processors in this text. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-1 A HISTORICAL BACKGROUND 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;equipment until well into the early 1970s, when the small hand-held electronic calculator, first &lt;br /&gt;introduced by Bomar, appeared. Monroe was also a leading pioneer of electronic calculators, but &lt;br /&gt;their machines were desktop, four-function models the size of cash registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In 1889, Herman Hollerith developed the punched card for storing data. Like Babbage, he &lt;br /&gt;too apparently borrowed the idea of a punched card from Jacquard. He also develvped a me-&lt;br /&gt;chanical machine-driven by one of the new electric motors-that counted, sorted, and collated &lt;br /&gt;information stored on punched cards. The idea of calculating by machinerj intrigued the United &lt;br /&gt;States government so much that Hollerith was commissioned to use his punched-card system to &lt;br /&gt;store and tabulate information for the 1890 census. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In 1896, Hollerith formed a company called the Tabulating Machine Company. This com-&lt;br /&gt;pany developed a line of machines that used punched cards for tabulation. After a number of &lt;br /&gt;mergers, the Tabulating Machine Company was formed into the International Business Ma-&lt;br /&gt;chines Corporation, now referred to more commonly as IBM, Inc. The punched cards used in &lt;br /&gt;computer systems are often called Hollerith cards in honor of Herman Hollerith. The 12-bit &lt;br /&gt;code used on a punched card is called the Hollerith code. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mechanical machines driven by electric motors continued to dominate the information &lt;br /&gt;processing world until the advent of the first electronic calculating machine in 1941 by a German &lt;br /&gt;inventor named Konrad Zuse. His calculating computer, the Z3, was used in aircraft and missile &lt;br /&gt;design during World War II for the German war effort. Had Zuse been given adequate funding &lt;br /&gt;by the German government, he most likely would have developed a much more powerful com-&lt;br /&gt;puter system. Zuse is today finally receiving some belated honor for his pioneering work in the &lt;br /&gt;area of digital electronics (which began in the 1930s) and for his Z3 computer system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It has recently been discovered (through the declassification of British military documents) &lt;br /&gt;that the first truly electronic computer was placed into operation in 1943 to break secret German &lt;br /&gt;military codes. This first electronic computer system, which used vacuum tubes, was invented by &lt;br /&gt;Alan Turing. Turing called his machine Colossus, most likely because of its size. A problem &lt;br /&gt;with Colossus was that although its design allowed it to break secret German military codes gen-&lt;br /&gt;erated by the mechanical Enigma machine, it could not solve other problems. Colossus was not &lt;br /&gt;programmable-it was a fixed-program computer system, which today is often called a special-&lt;br /&gt;purpose computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first general-purpose programmable electronic computer system was developed in &lt;br /&gt;1946 at the University of Pennsylvania. This first modem computer was called the ENIAC &lt;br /&gt;(Electronics Numerical Integrator and Calculator). The ENIAC was a huge machine con-&lt;br /&gt;taining over 17,000 vacuum tubes and over 500 miles of wires. This massive machine weighed &lt;br /&gt;over 30 tons, yet performed only about 100,000 operations per second. The ENIAC thrust the &lt;br /&gt;world into the age of electronic computers. The ENIAC was programmed by rewiring its cir-&lt;br /&gt;cuits-a process that took many workers several days to accomplish. The workers changed the &lt;br /&gt;electrical connections on plug-boards that looked much like early telephone switchboards. An-&lt;br /&gt;other problem with the ENIAC was the life of the vacuum tube components, which required fre-&lt;br /&gt;quent maintenance. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Breakthroughs that followed were the development of the transistor in 1948 at Bell Labs, fol-&lt;br /&gt;lowed by the invention of the integrated circuit in 1958 by Jack Kilby of Texas Instruments. The in-&lt;br /&gt;tegrated circuit led to the development of digital integrated circuits (RTL or resistor-to-transistor &lt;br /&gt;logic) in the 1960s and the first microprocessor in 1971 at Intel Corporation. At this time Intel, and &lt;br /&gt;one of its engineers, Marcian E. Hoff, developed the 4004 microprocessor-the device that started &lt;br /&gt;the microprocessor revolution that continues today at an ever-accelerating pace. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming Advancements &lt;br /&gt;Now that programmable machines had been developed, programs and programming languages &lt;br /&gt;began to appear. As mentioned, the first truly programmable electronic computer system was &lt;br /&gt;programmed by rewiring its circuits. This proved too cumbersome for practical application, so &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;early in the evolution of computer systems, computer languages began to appear to control the &lt;br /&gt;computer. The first such language was machine language, which was constructed of ones and &lt;br /&gt;zeros using binary codes that were stored in the computer's memory system in groups called pro-&lt;br /&gt;grams. This was more efficient than rewiring a machine to program it, but it was still extremely &lt;br /&gt;time consuming to develop a program because of the sheer number of codes required. John von &lt;br /&gt;Neumann, the mathematician, was the first to develop a system that accepted instructions and &lt;br /&gt;stored them in a memory. Computers are often called von Neumann machines in honor of John &lt;br /&gt;von Neumann. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once computer systems such as the UNIVAC I and II became available in the early 1950s, &lt;br /&gt;assembly language was used to simplify the chore of entering binary code into a computer as its &lt;br /&gt;instructions. The assembler allowed the programmer to use mnemonic codes such as ADD for &lt;br /&gt;addition in place of a binary number such as 01000111, which is cryptic. Even though assembly &lt;br /&gt;language was an aid to programming, it wasn't until Grace Hopper developed the first high-level &lt;br /&gt;programming language called FLOW-MATIC in 1957 that computers became easier to pro-&lt;br /&gt;gram. Also in 1957, IBM developed FORTRAN (FORmula TRANslator) for its computer sys-&lt;br /&gt;tems. The FORTRAN language allowed programmers to develop programs that used fonnulas to &lt;br /&gt;solve mathematical problems. Note that FORTRAN is still used by some scientists for computer &lt;br /&gt;programming. Another similar language introduced about a year after FORTRAN was ALGOL &lt;br /&gt;(ALGOrithmic Language). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first truly successful and widespread programming language for business applications &lt;br /&gt;was COBAL (COmputer Business Oriented Algorithmic Language). Although COBAL &lt;br /&gt;usage has diminished somewhat in recent years, it is stilI a major player in many large business &lt;br /&gt;systems. Another fairly popular business language is RPG (Report Program Generator), &lt;br /&gt;which allows programming by specifying the fonn of the input, output, and calculations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Since these early days of programming, additional languages have appeared. Some of the &lt;br /&gt;more common are BASIC, C/C++, PASCAL, and ADA. The BASIC and PASCAL languages &lt;br /&gt;were both designed as teaching languages, but have escaped the classroom and are used in many &lt;br /&gt;computer systems. The BASIC language is probably the easiest of all to learn. Some estimates &lt;br /&gt;indicate that the BASIC language is used in the personal computer for 80 percent of the pro-&lt;br /&gt;grams written by users. Recently, a new version of BASIC called VISUAL BASIC has appeared, &lt;br /&gt;so programming in the Windows environment has become easier. The VISUAL BASIC lan-&lt;br /&gt;guage may eventually supplant C/C++ and PASCAL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the scientific community, C/C++ and PASCAL appear as control programs. Both lan-&lt;br /&gt;guages, and especially C/C++, allow the programmer almost complete control over the program-&lt;br /&gt;ming environment and computer system. In many cases, C/C++ is replacing some of the low-&lt;br /&gt;level, machine control software normally reserved for assembly language. Even so, assembly &lt;br /&gt;language still plays an important role in programming. Most video games written for the per-&lt;br /&gt;sonal computer are written almost exclusively in assembly language. Assembly language is also &lt;br /&gt;interspersed with C/C++ and PASCAL to perform machine control functions efficiently. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ADA language is used heavily by the Department of Defense. The ADA language was &lt;br /&gt;named in honor of Augusta Ada Byron, Countess of Lovelace. The Countess worked with &lt;br /&gt;Charles Babbage in the early 1800s in the development of his Analytical Engine. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Microprocessor Age &lt;br /&gt;The wor'd's first microprocessor, the Intel 4004, was a 4-bit microprocessor-a programmable &lt;br /&gt;conlr(lller on a chip-that was meager by today's standards. It addressed a mere 4,096 4-bit wide &lt;br /&gt;memory locations. (A bit is a binary digit with a value of one or zero. A 4-bit wide memory lo-&lt;br /&gt;cation is often called a nibble.) The 4004 instruction set contained only 45 instructions. It was &lt;br /&gt;fabricated with the then-current state-of-the-art P-channel MOSFET technology that only al-&lt;br /&gt;lowed it to execute instructions at the slow rate of 50 KIPs (kilo-instructions per second). This &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-1 A HISTORICAL BACKGROUND 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;was slow when compared to the 100,000 instructions executed per second by the 30-ton ENIAC &lt;br /&gt;computer in 1946. The main difference was that the 4004 weighed much less than an ounce. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;At first, applications abounded for this device. The 4-bit microprocessor debuted in early &lt;br /&gt;video game systems and small microprocessor-based control systems. One such early video &lt;br /&gt;game, a shuffleboard game, was produced by BaIley. The main problems with this early micro-&lt;br /&gt;processor were its speed, word width, and memory size. The evolution of the 4-bit micro-&lt;br /&gt;processor ended when Intel released the 4040, an updated version of thc carlicr 4004. The 4040 &lt;br /&gt;operated at a higher speed, although it lacked improvements in word width and memory size. &lt;br /&gt;Other companies, particularly Texas Instruments (TMS-I 000), also produced 4-bit microproces-&lt;br /&gt;sors. The 4-bit microprocessor still survives in low-end applications such as microwave ovens &lt;br /&gt;and smaIJ ~ontrol systems and is still available from some microprocessor manufacturers. Most &lt;br /&gt;calculators are also still based on 4-bit microprocessors that process 4-bit BCD (binary-coded &lt;br /&gt;decimal) codes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Later in 1971, realizing that the microprocessor was a commercially viable product, Intel &lt;br /&gt;Corporation released the 8008-an extended 8-bit version of the 4004 microprocessor. The 8008 &lt;br /&gt;addressed an expanded memory size (16K bytes) and contained additional instructions (a total of &lt;br /&gt;48) that provided an opportunity for its application in more advanced systems. (A byte is gener-&lt;br /&gt;ally an 8-bit wide binary number and a K is 1,024 bytes. Often, memory size is specified in &lt;br /&gt;K bytes.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As engineers developed more demanding uses for the 8008 microprocessor, they discov-&lt;br /&gt;ered that its somewhat small memory size, slo&amp;quot;&amp;quot; speed, and instruction set limited its usefulness. &lt;br /&gt;Intel recognized these limitations and, in 12ZJ, introduced the80~0 microprocessor-the first of &lt;br /&gt;the modern 8-bit microprocessors. About six months after Intel released the 8080 microprocessor, &lt;br /&gt;Motorola Corporation introduced its l'v!&amp;lt;::6800 microprocessor. The floodgates opened and the &lt;br /&gt;8080--and, to a lesser degree, the MC6800--ushered in the age of the microprocessor. Soon, &lt;br /&gt;other companies began to introduce their own versions of the 8-bit microprocessor. Table I-I &lt;br /&gt;lists several of these early microprocessors and their manufacturers. Of these early micro-&lt;br /&gt;processor producers, only I~t~1 and Motorola continue successfully to introduce newer and im-&lt;br /&gt;proved versions of the microprocessor. Zilog still manufactures microprocessors, but has &lt;br /&gt;remained in the background, deciding to concentrate, fairly succeÂ·ssfully, on !!lic;rocontrollers &lt;br /&gt;and embedded controllers instead of general-purpose microprocessors. Rockwell has all but &lt;br /&gt;abandoned microprocessor development in favor of modem circuitry. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;What Was Special about the BOBO? Not only could the 8080 address more memory and execute &lt;br /&gt;additional instructions, but it executed them 10 times faster than the 8008. An addition that took &lt;br /&gt;20 flS (50,000 instructions per second) on an 8008-based system required only 2.0 flS (500,000 &lt;br /&gt;instructions per second) on an 8080-based system. Also, the 8080 was compatible with TTL &lt;br /&gt;(transistor-transistor logic), whereas the 8008 was not directly compatible. This made interfacing &lt;br /&gt;much easier and less expensive. The 8080 could also address four times more memory (64K &lt;br /&gt;bytes) than the 8008 (16K bytes). These improvements were responsible for ushering in the era &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-1 Early &lt;br /&gt;8-bit microprocessors Manufacturer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fairchild &lt;br /&gt;Intel &lt;br /&gt;MOS Technology &lt;br /&gt;Motorola &lt;br /&gt;National Semiconductor &lt;br /&gt;Rockwell International &lt;br /&gt;Zilog &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Part Number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F-8 &lt;br /&gt;8080 &lt;br /&gt;6502 &lt;br /&gt;MC6800 &lt;br /&gt;IMP-8 &lt;br /&gt;PPS-8 &lt;br /&gt;Z-8 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;of the 8080 and the continuing saga of the microprocessor. Incidentally, the first personal com-&lt;br /&gt;puter, the MITS Altair 8800, was released in 1974. (Note that the number 8800 was probably &lt;br /&gt;chosen to avoid copyright violations with Intel.) The BASIC language interpreter, written for the &lt;br /&gt;Altair 8800 computer, was developed by Bill Gates-the founder of Microsoft Corporation. The &lt;br /&gt;assembler program for the Altair 8800 was written by Digital Research Corporation, which now &lt;br /&gt;produces DR-DOS for the personal computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8085 Microprocessor. In 1977, Intel Corporation introduced an updated version of the &lt;br /&gt;8080-the 8085. This was to be the last 8-bit general-purpose microprocessor developed by Intel. &lt;br /&gt;Although only slightly more advanced than an 8080, the 8085 executed software at an even higher &lt;br /&gt;speed. An addition that took 2.0 Ils (500,000 instructions per second) on the 8080 required only &lt;br /&gt;1.3 IlS (769,230 instructions per second) on the 8085. The main advantages of the 8085 were its &lt;br /&gt;internal clock generator, internal system controller, and higher clock frequency. This higher level &lt;br /&gt;of component integration reduced the 8085's cost and increased its usefulness. Intel has managed &lt;br /&gt;to sell well over 100 million copies of the 8085, including the 8085s manufactured by other li-&lt;br /&gt;censed second sources, such as Advandel Micro Devices (AMD); there are over 200 million of &lt;br /&gt;these microprocessors in existence. Applications that contain the 8085 are still being used and de-&lt;br /&gt;signed and will likely continue to be popular well into the future. Another company that sold 500 &lt;br /&gt;million 8-bit microprocessors is Zilog Corporation, which produced the Z-80 microprocessor. &lt;br /&gt;The Z-80 is machine language code compatible with the 8085, which means that there are well &lt;br /&gt;over 700 million microprocessors that execute 8085/Z-80 compatible code! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Modern Microprocessor &lt;br /&gt;In 1976., Intel released the ..s086 microprocessor; a year or so later, it released the 8088. Both de-&lt;br /&gt;vices were l6-bit microprocessors, which executed instructions in as little as 400 ns (2.5 MIPs or &lt;br /&gt;2.5 million instructions per second). This represented a major improvement over the execution &lt;br /&gt;speed of the 8085. In addition, the 8086 and 8088 addressed 1M bytes of memory, 16 times more &lt;br /&gt;memory than the 8085. (A 1M byte memory contains 1,024K byte-sized memory locations, or &lt;br /&gt;1,048,576 bytes.) This higher execution speed and larger memory size allowed the 8086 and &lt;br /&gt;8088 to replace smaller minicomputers in many applications. One other feature found in the &lt;br /&gt;8086/8088 was a small 4- or 6-byte instruction cache or queue that prefetches a few instructions &lt;br /&gt;before they are executed. The queue sped the operation of many sequences of instructions and &lt;br /&gt;proved to be the basis for the much larger instruction caches found in modern microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The increase in memory size and additional instructions of the 8086 and 8088 have led to &lt;br /&gt;many sophisticated applications for microprocessors. Improvements to the instruction set in-&lt;br /&gt;cluded a multiply-and-divide instruction, which were missing on earlier microprocessors. Also, &lt;br /&gt;the number of instructions increased from 45 on the 4004, to 246 on the 8085, to well over &lt;br /&gt;20,000 variations on the 8086 and 8088 microprocessors. Note that these microprocessors were &lt;br /&gt;called CISC (complex instruction set computers) because of the number and complexity of in-&lt;br /&gt;structions. The additional instructions eased the task of developing efficient and sophisticated &lt;br /&gt;applications even though their number was at first overwhelming and time consuming to learn. &lt;br /&gt;The 16-bit microprocessor also provided more internal register storage space than the 8-bit mi-&lt;br /&gt;croprocessor. The additional registers allowed software to be written more efficiently. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 16-bit microprocessor evolved mainly because of the need for larger memory systems. &lt;br /&gt;The popularity of the Intel family was ensured in 1981 when IBM Corporation decided to use the &lt;br /&gt;8088 microprocessOl ,n its personal computer. Applications such as spreadsheets, word proces-&lt;br /&gt;sors, spelling checkers, and computer-based thesauruses were memory intensive and required &lt;br /&gt;more than the 64K bytes of memory found in 8-bit microprocessors to execute efficiently. The &lt;br /&gt;16-bit 8086 and 8088 provided 1M bytes of memory for these applications. Soon, even 1M byte &lt;br /&gt;of memory proved limiting for large spreadsheets and other applications. This led Intel to intro-&lt;br /&gt;duce the 80286 microprocessor, an updated 8086, in 1983. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-1 A HISTORICAL BACKGROUND 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80286 Microprocessor. The 80286 microprocessor (also a 16-bit architecture micro-&lt;br /&gt;processor) was almost identical to the 8086 and 8088 except it addressed a 16M byte memory &lt;br /&gt;system instead of a I M byte system. The instmction set of the 80286 was also almost identical to &lt;br /&gt;the 8086 and 8088 except for a few additional instmctions that managed the extra 15M bytes of &lt;br /&gt;memory. The clock speed of the 80286 was increased, so it executed some instructions in as little &lt;br /&gt;as 250 ns (4.0 MIPs) with the original release 8.0 MHz version. Si!.~~ .. c.h~!1ges also occurred in &lt;br /&gt;the inte.mal execution of the instructions that led Lo an eight-fold increase in speed for many in-&lt;br /&gt;stmctions when compared to 8086/8088 instructions. .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 32-bit Microprocessor. Applications began to demand faster microprocessor speeds, more &lt;br /&gt;memory, and wider data paths. This led to the arrival of the 80386, in 1986, by Intel Corporation. &lt;br /&gt;The 80386 represented a major overhaul of the 16-bit 8086-80286 microprocessor's architec-&lt;br /&gt;ture. The 80386 was Intel's first practical 32-bit microprocessor that contained a 32-bit data bus &lt;br /&gt;and a 32-bit memory address. (Note that Intel produced an earlier, although unsuccessful, 32-bit &lt;br /&gt;microprocessor called the iapx-432.) Through these 32-bit buses, the 80386 addressed up to 4G &lt;br /&gt;bytes of memory. (IG of memory contains 1,024M or 1,073,741,824 locations.) A 4G byte &lt;br /&gt;memory can store an astounding 1,000,000 typewritten, double-spaced pages of data. The 80386 &lt;br /&gt;was also available in a few modified versions such as the 80386SX, which addressed 16M bytes &lt;br /&gt;of memory through a 16-bit data and 24-bit address bus, and the 80386SLl80386SLC, which ad-&lt;br /&gt;dressed 32M bytes of memory through a 16-bit data and 25-bit address bus. An 80386SLC ver-&lt;br /&gt;sion contained an internal cache memory that allowed it to process data at even higher rates. In &lt;br /&gt;1995, Intel released the 80386EX microprocessor. The 80386EX is called an embedded PC, &lt;br /&gt;containing all the components of the AT class personal computer on a single integrated circuit. &lt;br /&gt;The 80386EX also contains 24 lines for input/output data, a 26-bit address bus, a 16-bit data bus, &lt;br /&gt;a DRAM refresh controller, and programmable chip selection logic. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Applications requiring higher microprocessor speeds and large memory systems include &lt;br /&gt;software systems that use a GYI or graphical user interface. Modern graphical displays often &lt;br /&gt;contain 256,000 or more picture elements (pixels or pels). The least sophisticated VGA (vari-&lt;br /&gt;able graphics array) video display has a resolution of ~40 pixels per scanning line with 480 &lt;br /&gt;scanning lines. In order to display one scree~of information, each picture element must be &lt;br /&gt;changed. This requires a high-speed microprocessor. Many new software packages use this type &lt;br /&gt;of video interface. These GUI-based packages require high micropr()cessor speeds and often ilc-&lt;br /&gt;celerated video adapters for quicl~ and efficient manipulation of video text and graphical data. &lt;br /&gt;The most striking system, which -r~quires high-speed computing for its graphical display inter-&lt;br /&gt;face, is Microsoft Corporation's Windows.3 We often call a GUI a WYSIWYG (what you see is &lt;br /&gt;what you get) display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 32-bit microprocessor is needed because of the size of its data bus, which transfers &lt;br /&gt;real (single-precision floating-point).numbers that require 32-bit wide memory. In order to effi-&lt;br /&gt;ciently process 32-bit real numbers, the microprocessor must efficiently pass them between itself &lt;br /&gt;and memory. If they pass through an 8-bit data bus, it takes four read or write cycles; when &lt;br /&gt;passed through a 32-bit data bus, however, only one read or write cycle is required. This signifi-&lt;br /&gt;cantly increases the speed of any program that manipulates.L~'!.1 numbers. Most high-level lan-&lt;br /&gt;guages, spreadsheets, anl database management systems use real numbers for data storage. Real &lt;br /&gt;numbers are also used in graphical design packages that use vectors to plot images on the video &lt;br /&gt;screen. These include such&amp;quot;CADCcomputer aided drafting/design) systems as ~UTOCAD, &lt;br /&gt;ORCAD, and so forth. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Besides providing higher clocking speeds, the 80386 included a memory management unit &lt;br /&gt;that allowed memory resources to be allocated and managed by the operating system. Earlier &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ &lt;br /&gt;~Windows is a registered trademark of Microsoft Corporation and is currently available as version 3.1, 3 II, and &lt;br /&gt;Windows 95. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessors left memory management c.8-mpletely to the software. The 80386 included &lt;br /&gt;hardware circuitry for memory management and memory assignment, which improved its effi-&lt;br /&gt;ciency and reduced software overhead. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The instruction set of the 80386 microprocessor was upward compatible with the earlier &lt;br /&gt;8086, 8088, and 80286 microprocessors. Additional instructions referenced the 32-bit registers &lt;br /&gt;and managed the memory system. Note that memory management instructions and techniques &lt;br /&gt;used by the 80286 were also compatible with the 80386 microprocessor. These features allowed &lt;br /&gt;older, 16-bit software to operate on the 80386 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80486 Microprocessor. In 1989, Intel released the 80486 microprocessor, which incorpo-&lt;br /&gt;rated an 80386-like microprocessor, an 80387-like numeric coprocessor, and an 8K byte cache &lt;br /&gt;memory system into one integrated package. Although the 80486 was not radically different from &lt;br /&gt;the 80386, it did include one substantial change. The internal structure of the 80486 was modified &lt;br /&gt;from the 80386 so about half of its instructions executed in one clock instead of two clocks. Be-&lt;br /&gt;cause the 80486 was available in a 50 MHz version, about half of its instructions executed in 25ns &lt;br /&gt;(50 MIPs). The average speed improvement for a typical mix of instructions was about 50 percent &lt;br /&gt;over the 80386 operated at the same clock speed. Later versions of the 80486 executed instruc-&lt;br /&gt;tions at even higher speeds with a 66 MHz double-clocked version (80486DX2). The double-&lt;br /&gt;clocked 66 MHz version executed instructions at the rate of 66 MHz, with memory transfers &lt;br /&gt;executed at the rate of 33 MHz. A triple-clocked version from Intel, the 80486DX4, improved the &lt;br /&gt;internal execution speed to 100 MHz with memory transfers at 33 MHz. Note that the 80486DX4 &lt;br /&gt;executed instructions at about the same speed as the 60 MHz Pentium. It also contained an ex-&lt;br /&gt;panded 16K byte cache in place of the standard 8K byte cache found on earlier 80486 micro-&lt;br /&gt;processors. Recently, Advanced Micro Devices (AMD) has produced a triple-clocked version that &lt;br /&gt;runs with a bus speed of 40 MHz and a clock speed of 120 MHz. The future promises to bring mi-&lt;br /&gt;croprocessors that internally execute instructions at rates of up to 250 MHz or higher. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Other versions of the 80486 were called Overdrive4 processors. The Overdrive processor &lt;br /&gt;was actually a double-clocked version of the 80486DX that replaced an 80486SX or slower &lt;br /&gt;speed 80486DX. When the Overdrive processor was plugged into its socket, it disabled or re-&lt;br /&gt;placed the 80486SX or 80486DX and functioned as a doubled-clocked version of the micro-&lt;br /&gt;processor. For example, if an 80486SX operating at 25 MHz was replaced with an Overdrive &lt;br /&gt;microprocessor, it functioned as a 80486DX2 50 MHz microprocessor using a memory transfer &lt;br /&gt;rate of 25 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 1-2 lists many microprocessors produced by Intel and Motorola with information &lt;br /&gt;about their word and memory sizes. Other companies produce microprocessors, but none have &lt;br /&gt;attained the success of Intel and, to a lesser degree, Motorola. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium Microprocessor. The Pentium, introduced in 1993, was similar to the 80386 and &lt;br /&gt;80486 microprocessors. This microprocessor was originally labeled the P5 or 80586, but Intel &lt;br /&gt;decided not to use a number because it appeared to be impossible to copyright a number. The &lt;br /&gt;two introductory versions of the Pentium operated with a clocking frequency of 60 MHz and &lt;br /&gt;66 MHz and a speed of 110 MIPs, with a higher frequency 100 MHz one and one-half clocked &lt;br /&gt;version operating at 150 MIPs. The double-clocked Pentium, operating at 120 MHz and 133 MHz, &lt;br /&gt;was also available, as were higher speed versions (200 Mhz). Another difference was that the &lt;br /&gt;cache size was increased to 16K bytes from the 8K cache found in the basic version of the 80486. &lt;br /&gt;The Pentium contains an 8K byte instruction cache and an 8K byte data cache. This allowed a &lt;br /&gt;program transfering a large amoul.t of memory data still to benefit from a cache. The memory &lt;br /&gt;system containcd up to 4G bytes, with the data bus width increased from the 32-bits found in the &lt;br /&gt;80386 and 80486 to a full 64-bits. The data bus transfer speed wass either 60 MHz, or 66 MHz &lt;br /&gt;depending on the version of the Pentium. This wider data bus width accommodated double-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40verdrive is a registered trademark of Intel Corporation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-1 A HISTORICAL BACKGROUND 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-2 Many modern Intel and Motorola microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Manufacturer Part Data Bus Width Memory Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Intel 8048 8 2K internal &lt;br /&gt;8051 8 8K internal &lt;br /&gt;8085A 8 64K &lt;br /&gt;8086 16 1M &lt;br /&gt;8088 8 1M &lt;br /&gt;8096 16 8K internal &lt;br /&gt;80186 16 1M &lt;br /&gt;80188 8 1M &lt;br /&gt;80251 8 16K internal &lt;br /&gt;80286 16 16M &lt;br /&gt;80386EX 16 64M &lt;br /&gt;80386DX 32 4G &lt;br /&gt;80386SL 16 32M &lt;br /&gt;80386SLC 16 32M + 1 K cache &lt;br /&gt;80386SX 16 16M &lt;br /&gt;80486DXlDX2 32 4G + 8K cache &lt;br /&gt;80486SX 32 4G + 8K cache &lt;br /&gt;80486DX4 32 4G + 16K cache &lt;br /&gt;Pentium 64 4G + 16K cache &lt;br /&gt;Pentium Overdrive (P24T) 32 4G + 16K cache &lt;br /&gt;Pentium Pro processor 64 64G + 16K L1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cache + 256K L2 cache &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Motorola 6800 8 64K &lt;br /&gt;6805 8 2K &lt;br /&gt;6809 8 64K &lt;br /&gt;68000 16 16M &lt;br /&gt;68008Q 8 1M &lt;br /&gt;68008D 8 4M &lt;br /&gt;68010 16 16M &lt;br /&gt;68020 32 4G &lt;br /&gt;68030 32 4G + 256 cache &lt;br /&gt;68040 32 4G + 8K cache &lt;br /&gt;68050 32 Proposed,butnever &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;released &lt;br /&gt;68060 64 4G + 16K cache &lt;br /&gt;PowerPC 64 4G + 32K cache &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;precision floating-point numbers used for ~~:~peed vt:ctor-generated graphical displays. It also &lt;br /&gt;transfered data between the memory system and microprocessor at a higher rate. This should &lt;br /&gt;allow virtual reality and software to operate at more realistic rates on current and future Pentium-&lt;br /&gt;based platforms. The widened da~abus and higher execution speed of the Pentium should also &lt;br /&gt;allow full-frame video displays that operate at scan rates of 30 Hz or higher--comparable to &lt;br /&gt;commerci~l television. ~. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Recently, Intel has released the long-awaited Pentium OverDrive (P24T) for older 80486 &lt;br /&gt;systems that operate at either 63 MHz or 83 MHz clock. The 63 MHz version upgrades older &lt;br /&gt;80486DX2 50 MHz systems, and the 83 MHz version upgrades the 80486DX2 66 MHz systems. &lt;br /&gt;The upgraded 83 MHz system performs at a rate somewhere between a 66 MHz Pentium and a &lt;br /&gt;75 MHz Pentium. If older VESA local bus video and disk caching controUers seein too expensive &lt;br /&gt;to toss out, the Pentium OverDrive represents an ideal upgrade path from the 80486 to the Pentium. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Probably the most ingenious feature of the Pentium is its dual integer proces.~ors. The Pen-&lt;br /&gt;tium executes two instr!lctions, not dependent on each other, simultaneously because it contains &lt;br /&gt;two independent internal integer processors called supe!.~~r technology. This allows the Pen-&lt;br /&gt;tium to often execute two instructions per clocking period. Another feature that enhances perfor-&lt;br /&gt;mance is a jump prediction techn()lo,gy that speeds the execution of programs that include loops. &lt;br /&gt;As with the 80486, the Pentium also employs an internal floating-point coprocessor to handle &lt;br /&gt;floating-point data, albeit at about a five times speed improvement. These features portend con-&lt;br /&gt;tinued success for the Intel family of microprocessors. They also may allow the Pentium to re-&lt;br /&gt;place some of the RISC (reduced instruction set computer) machines that currently execute &lt;br /&gt;one instruction per clock. Note that some newer RISC processors execute more than one instruc-&lt;br /&gt;tion per clock through the introduction of superscaIer technology. Motorola, 1.EPle. and.lRM &lt;br /&gt;have recently produced the PowerPC, a RISC microprocessor that has two integer units and one &lt;br /&gt;floating-point unit. The PowerPC certainly boosts the performance of the Apple Macintosh, but &lt;br /&gt;at present is slow at emulating the Intel family of microprocessors. Tests indicate that the current &lt;br /&gt;emulation software executes DOS and Windows applications at a speed slower than the &lt;br /&gt;80486SX 25 MHz microprocessor. Because of this, the Intel family should survive for many &lt;br /&gt;years in personal computer systems. Note that there are currently 4 million Apple MacintoshS &lt;br /&gt;systems and well over 160 million personal computers based on Intel microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to compare the speeds of various microprocessors, Intel devised the iCOMP rating &lt;br /&gt;index. This index is a composite of SPEC92, ZD Bench, and Power Meter. Figure 1-1 shows the &lt;br /&gt;relative speeds of the 80386DX 25 MHz version at the low end to the Pentium 133 MHz version &lt;br /&gt;at the high end of the spectrum. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro Microprocessor. The latest entry from Intel is the Pentium Pro microprocessor, &lt;br /&gt;formerly code-named the P6 microprocessor. The Pentium Pro microprocessor contains 21 mil-&lt;br /&gt;lion t~rs, 3 inte~ru;:;-it~, as well as a floating-point unit to increase the perform~of &lt;br /&gt;most software. The basic clock frequency is 150 MHz and 166MHz in the initial offering made &lt;br /&gt;available in late 1995. In addition to the internal 16K level one (Ll) cache (8K for data and 8K &lt;br /&gt;for instructions), the Pentium Pro microprocessor also contains a 256K level two (L2) cache. &lt;br /&gt;OneÂ· other significant change is that the Pentium Pro processor uses three ~~&amp;amp;!!.es so it &lt;br /&gt;can execute up to three instructions at a time, which can conflict and still execute in parallel. This &lt;br /&gt;represents a change from the Pentium, which executes two instructions simultaneously as long as &lt;br /&gt;they do not conflict. The Pentium Pro microprocessor has been ~~l!Iiz~&amp;lt;! to execute 32-bit code &lt;br /&gt;efficiently; for this reason it is often bundled with 'Y!ndows NT rather than with normal versions &lt;br /&gt;of Windows 95. Still another change is that the Pentium Pro can address either a 4G byte &lt;br /&gt;memory system or a 64G byte memory system. The Pentium Pro has a 3Â§~bit address bus if con-&lt;br /&gt;figured for a 64G memory system. -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;No one can really make accurate predictions, but the success of the Intel family should &lt;br /&gt;continue for quite a few years. What may occur is a change to RISC technology, but more likely &lt;br /&gt;a change to a new technology being developed jointly by Intel and Hewlett-Packard will take &lt;br /&gt;place. Even this new technology will undoubtedly embody the CISC instruction set of the 80X86 &lt;br /&gt;family of microprocessors so that software for the system will survive. The basic premise behind &lt;br /&gt;this technology is that many microprocessors will communicate directly with one another, al-&lt;br /&gt;lowing parallel processing without any change to the instruction set or program. Currently, the &lt;br /&gt;superscaler technology uses many microprocessors, but they all share the same register set. This &lt;br /&gt;new untried technology, to be uscu in the P7, contains many microprocessors that each contain &lt;br /&gt;their own register sets that are linked with the other microprocessors' registers. This technology &lt;br /&gt;should offer true parallel processing without writing a'2Y.~!,~.~~al program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5Macintosh is a registered trademark of Apple Computer Corporation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-2 THE MICROPROCESSOR-BASED PERSONAL COMPUTER SYSTEM 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-1 The Intel &lt;br /&gt;iCOMP index. Pentium 133 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 120 &lt;br /&gt;Pentium 100 &lt;br /&gt;Pentium 90 &lt;br /&gt;Pentium 75 &lt;br /&gt;Pentium 83* &lt;br /&gt;Pentium 66 &lt;br /&gt;Pentium 60 &lt;br /&gt;Pentium 63* &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 100 200 300 400 500 600 700 800 900 1000 1100 1200 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: : : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: : : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;319: &lt;br /&gt;:297 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;249 &lt;br /&gt;23J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4860X4100 &lt;br /&gt;486 OX4 75 &lt;br /&gt;486 OX2 66 &lt;br /&gt;486 OX 50 &lt;br /&gt;486 OX2 50 &lt;br /&gt;486 SX2 50 &lt;br /&gt;486 OX 33 &lt;br /&gt;486 SX2 40 &lt;br /&gt;486 SX 33 &lt;br /&gt;486 OX 25 &lt;br /&gt;486 SX 25 &lt;br /&gt;486 SX 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: j80 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;386 OX 33 &lt;br /&gt;386 SX 33 &lt;br /&gt;386 OX 25 &lt;br /&gt;386 SX 25 &lt;br /&gt;386 SX 20 &lt;br /&gt;386 SX 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1!56 &lt;br /&gt;145 &lt;br /&gt;~13e &lt;br /&gt;.... 12~ &lt;br /&gt;-.100 &lt;br /&gt;.~8 &lt;br /&gt;r-~8 &lt;br /&gt;.56 &lt;br /&gt;'iII149 &lt;br /&gt;i1111 39: &lt;br /&gt;I11III32: &lt;br /&gt;iiII 22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: â¢ = Pentium OverDrive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1000 &lt;br /&gt;815 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I iill 735 : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: 610: &lt;br /&gt;583 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;567 &lt;br /&gt;510: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;443 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;435 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE MICROPROCESSOR-BASED PERSONAL COMPUTER SYSTEM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Computer systems have undergone many changes recently. Machines that once filled large areas &lt;br /&gt;have been reduced to small desktop computer systems because of the microprocessor. Even &lt;br /&gt;though these desktop computers are compact, they possess computing power that was only &lt;br /&gt;dreamed of a few years ago. Million-dollar mainframe computer systems, developed in the early &lt;br /&gt;1980s, are not as powerful as the 80486-, Pentium-, or Pentium Pro- based computers of today. &lt;br /&gt;In fact, many smaller companies are replacing their _~!ri_flframe computers with microprocessor-&lt;br /&gt;based systems. Companies such as DEC (Digital Equipment Corporation) have stopped pro-&lt;br /&gt;ducing mainframe computer systems in order to concentrate their resources on microprocessor-&lt;br /&gt;based computer systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section shows the structure of the microprocessor-based personal computer system. &lt;br /&gt;This structure includes information about the memory and operating system used in many mi-&lt;br /&gt;croprocessor-based computer systems. '--,,-,,- .&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Refer to Figure 1-2 for the block diagram of the personal computer. This diagram also ap-&lt;br /&gt;plies to any computer system from the early mainframe computers to the latest microprocessor-&lt;br /&gt;based systems. The block diagram is composed of three blocks that are interconnected by buses. &lt;br /&gt;(A bus is a set of common connections that carry the same type of information. For example, the &lt;br /&gt;address bus, which contains 20 or more connections, conveys the memory address to the memory.) &lt;br /&gt;These blocks and their functions in a personal computer are outlined in this section of the text. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dynamic RAM (DRAM) &lt;br /&gt;Static RAM (SRAM) &lt;br /&gt;Cache &lt;br /&gt;Read-only (ROM) &lt;br /&gt;Flash memory &lt;br /&gt;EEPROM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086 &lt;br /&gt;8088 &lt;br /&gt;80186 &lt;br /&gt;80188 &lt;br /&gt;80286 &lt;br /&gt;80386 &lt;br /&gt;80486 &lt;br /&gt;Pentium &lt;br /&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1/0 system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Printer &lt;br /&gt;Serial communications &lt;br /&gt;Floppy disk drive &lt;br /&gt;Hard disk drive &lt;br /&gt;Mouse &lt;br /&gt;CD-ROM drive &lt;br /&gt;Plotter &lt;br /&gt;Keyboard &lt;br /&gt;Monitor &lt;br /&gt;Tape backup &lt;br /&gt;Scanner &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-2 The block diagram of a microprocessor-based computer system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ The Memory and liD S~!el!l. &lt;br /&gt;,.&amp;lt;= -. -== . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory structure of all Intel 80X86- and Pentium-based personal computer systems are sim-&lt;br /&gt;ilar. This includes the first personal computers based on the 8088 introduced in 1981 by IBM to &lt;br /&gt;the most powerful, high-speed versions of today based on the Pentium Pro processor. Figure 1-3 &lt;br /&gt;illustrates the memory map of a personal computer system. This map applies to any IBM personal &lt;br /&gt;computer or any of the many IBM compatible clones that are in existence. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory systejll is divided into three main Qarts: TPA (transient program area), &lt;br /&gt;system area, and XMS (extended memory system). The !xp..~!l:!i~ropr?c.~s.s&amp;lt;?r in your com-&lt;br /&gt;puter determines whether an extended memory syste.m...ex.ists. If the computer is based upon an &lt;br /&gt;01der.8086 or 8Q88 (a PC6 or XT7 ), the TPA ands.Y~!~!!UlrelJ.~_exist, but there is DO e4tended &lt;br /&gt;memory area. The PC and XT contain 640K bytes ofTPA and 384K bytes of system memory for &lt;br /&gt;a total memory size of 1M byte. We often call the first 1M byte of memory the real memory be-&lt;br /&gt;cause each Intel microprocessor is designed to function in this area in its real mode of operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Computer systems based on the 80286 throughlh~2!!i!!-.m not only contain the TPA &lt;br /&gt;(640K bytes) and system area (384K bytes); they may also contain extended memory. These &lt;br /&gt;machines are .2f!~ncalledAT8cl&amp;lt;l.s~!I!~chines. The PS/1 and PS/2, produced by IBM, are other &lt;br /&gt;versions of the same basic memory design. Sometimes these machines are also referred to as ISA &lt;br /&gt;(industry standard architecture) or EISA (extended ISA) machines. The PS/2 is referred to as &lt;br /&gt;a micro-channel9 architecture system or an ISA system, depending on the model number. Re-&lt;br /&gt;cently, a new bus, the PCI (peripheral control interconnect) bus, is being used in almost all &lt;br /&gt;Pentium- and Pentium Pro-processor-based systems. Extended memory contains up to 15M &lt;br /&gt;bytes in the 80286- and 80386SX-based computer and up to 4,095M bytes in the 80386DX-, &lt;br /&gt;80486-, and Pentium-based computer in addition to the first 1M byte of real memory. The Pen-&lt;br /&gt;tium Pro processor-based computer system can have up to 1M less than 4G or 64G of extended &lt;br /&gt;memory. The ISA machine contains an 8-bit peripheral bus used to iJ'tcrface 8-bit devices to the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6PC is a trademark of IBM Corporation for the personal computer. &lt;br /&gt;7XT is a trademark of IBM Corporation for the extended technology personal computer. &lt;br /&gt;MAT is a trademark of IBM Corporation used to designate an advanced class computer system. &lt;br /&gt;&amp;quot;MicroÂ·channel is a registered trademark of IBM Corporation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-2 THE MICROPROCESSOR-BASED PERSONAL COMPUTER SYSTEM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-3 The memory &lt;br /&gt;map of the personal computer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Extended memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- -~ / &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System area &lt;br /&gt;384K bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TPA &lt;br /&gt;640K bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15M bytes in the 8028(, or 80386SX &lt;br /&gt;31 M bytes in the 80386SUSLC &lt;br /&gt;63M bytes in the 80386EX &lt;br /&gt;4,095M bytes in the 80386DX, 80486, and Pentium &lt;br /&gt;64G bytes in the Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 M bytes of real (conventional) memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;computer in the 8088/8088-based PC or XT computer system. The AT class machine, also called &lt;br /&gt;an ISA machine, uses a l6-bit peripheral bus for interface and may contain an 80286 or above &lt;br /&gt;microprocessor. The EISA bus is a 32-bit peripheral interface bus found in a few older &lt;br /&gt;80386DX- and 80486-based systems. Note that each of these buses is compatible with the earlier &lt;br /&gt;versions. That is, an 8-bit interface card functions in the 16-bit ISA or 32-bit EISA bus standards; &lt;br /&gt;likewise, a 16-bit interface card functions in the 16-bit ISA or 32-bit EISA standard. Another bus &lt;br /&gt;type found in many 80486-based personal computers is called the VESA 10 local bus or VL bus. &lt;br /&gt;The local bus interfaces ~i~k and video to the microprocessor ~~ the local bus level. This allows &lt;br /&gt;32-bit interfaces to function at the same clocking speed as the microprocessor. A recent modifi-&lt;br /&gt;cation to the VESA local bus supports the ~4-bit data bus of the Pentiumplicroprocessor and &lt;br /&gt;competes directly with the PCI bus, although it has generated little if any interest. Th'lJSi\\. and &lt;br /&gt;E!~~tl:ll:!dards function at o~lY~}v1Hz, which reduces the performance of disk and video inter-&lt;br /&gt;faces using these standards. The E~~ .. bus is either a }l~ or 64-bit bus that is specifically designed &lt;br /&gt;to function with the Pentium and Pentium Pro microprocessors at a b.us speed of 60 or 66 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;!h?JPA The transient program area (TPA) holds theoperatmg system and q!~~rprograms that &lt;br /&gt;control the computer system. The TPA also stores any currently active or inactive application &lt;br /&gt;p.!:.~ggWIS. The length of the TP A is 64QK: bytes. As mentioned, this area of memory holds the &lt;br /&gt;operating system, which requires a portion of ilie TP A. In practice, the amount of memory re-&lt;br /&gt;~ai~i~g for application software i~ Â·about 2.~8K bytes if MSDOSII version 6.x is used as an op-&lt;br /&gt;erating system. Earlier versions of MSDOS required more of the TP A and often l~ft only 530K &lt;br /&gt;bytes or less for application programs. Another operating system found in some personal com-&lt;br /&gt;puters is PCDOSI2 Both PCDOS and MSDOS are compatible, so either function in the same &lt;br /&gt;manner with application programs. Windows and OS1213 are other operating systems that are &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOVES A is the Video Electronic Standards Association. &lt;br /&gt;II MSDOS (Microsoft Disk Operating System) is a registered trademark of Microsoft Corporation. &lt;br /&gt;12PCODS (Personal Computer Disk Operating System) is a registered trademark of IBM Corporation. &lt;br /&gt;L10S/2 (Operating System version 2) is a registered trademark of IBM Corporation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-4 The memory &lt;br /&gt;map of the TPA in a personal &lt;br /&gt;computer. (Note that this map &lt;br /&gt;will vary between systems.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9FFFF &lt;br /&gt;MSDOS program &lt;br /&gt;9FFFO~ ________________________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Free TPA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBE30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COMMAND.COM &lt;br /&gt;OB490 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Device drivers &lt;br /&gt;such as MOUSE.SYS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02530 &lt;br /&gt;MSDOS program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01160 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00700 &lt;br /&gt;10.SYS program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOS communications area &lt;br /&gt;00500 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIOS communications area &lt;br /&gt;00400 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt vectors &lt;br /&gt;00000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;compatible with DOS and also allow DOS programs to execute. The DOS (disk operating &lt;br /&gt;system) controls the way that the disk memory is organized and controlled as well as the func-&lt;br /&gt;tion and control of the some of the JJO devices connected to the system. Figure 1--4 shows the or-&lt;br /&gt;ganization of the TP A in a computer system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory map shows how the many areas of the TP A are used for system programs, &lt;br /&gt;data, and drivers. It also shows a large area of memory available for application programs. To the &lt;br /&gt;left of each area is a hexadecimal number that represents the memory addresses that begin and &lt;br /&gt;end each data area. Hexadecimal memory addresses or memory locations are used to number &lt;br /&gt;each byte of the memory system. (A hexadecimal number is a number represented in radix 16 &lt;br /&gt;or base 16 with each digit representing a value from 0-9 and A-F. We often end a hexadecimal &lt;br /&gt;number with an H to indicate that it is a hexadecimal value. For example, I 234H is 1~34 hexa-&lt;br /&gt;decimal. We also represent hexadecimal data as Ox1234 for a 1234 hexadecimal.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Interrupt vectors access various features of the DOS, BIOS (basic I/O system), and &lt;br /&gt;applications. The BIOS is a collection of programs stored in either a read-only (ROM) or flash &lt;br /&gt;memory that operate many of the JJO devices connected to your computer system. Note that a &lt;br /&gt;flash memory is an EEPROM (electrically erasable read-only memory) that is erased in the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-2 THE MICROPROCESSOR-BASED PERSONAL COMPUTER SYSTEM 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;system electrically, while the ROM is a device that must be programmed in a special machine &lt;br /&gt;called an EPROM programmer for an EPROM (erasable/programmable read-only memory) &lt;br /&gt;or at the factory when a ROM is fabricated. These programs are stored in the system area defined &lt;br /&gt;later in this section of the chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The BIOS and DOS communications areas c.2.!1taintransient data used by programs to ac-&lt;br /&gt;cess J!Qdevices and the intem~Lfeatures of the computer system. (Refer to Appendix A for a &lt;br /&gt;complete listing if the BIOS and DOS communications areas.) These are stored in thc TPA so &lt;br /&gt;they ~'ln be chang&amp;quot;(;(ra~th~ system operates. Note that the TPA contains read/write memory &lt;br /&gt;(called RAM or random access memory) so it can change as a program executes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;c The IO.SYS is a program that loads into the TPA from th(! disk whenever an MSDOS or &lt;br /&gt;PCDOS system is started. The IO.SYS contains programs that allow DOS to use the ~eyboard, &lt;br /&gt;yiqeo display, printer, and ~ther VO devices often found in the computer system. The IO.SYS &lt;br /&gt;program links DOS to the programs stored on the BIOS ROM. &lt;br /&gt;&amp;quot; The MSDOS (PCDOS) program occupies two areas of memory. One area is 16 bytes in &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;length and is located at the top of the TP A; the other is much larger and is located near the &lt;br /&gt;bottom of the TP A. The MSDOS program controls the operation of the computer system. The &lt;br /&gt;size of the MSDOS area depends on the version of MSDOS installed in the computer memory &lt;br /&gt;and how the MSDOS program is installed. If DOS is installed in high memory with the &lt;br /&gt;HIMEM.SYS driver, most of the TPA is free-~o hold application pr~grams. Note that high &lt;br /&gt;iTiemory is described late&amp;quot;fÂ·i~ this text and only applies to 80286 or newer microprocessors. &lt;br /&gt;The-sTz~ ~f the driver area and number of dri~ers change from one computer to another. Dri-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vers are progra;;s that control installaQ\\e VO deYkes such as a.!!l.Quse, qis]( cache, haruiscanner, and &lt;br /&gt;CD-R_QM l11emory (Compact Disc Read-Only Memory), as welLa,sprograms. Drivers are nor-&lt;br /&gt;mally files that have an extension of .SYS, such as MOUSE.SYS, in DOS version 3.2 and later, the &lt;br /&gt;files have an extension of .EXE, such as EMM386.EXE. Because few computer systems are iden-&lt;br /&gt;tical, the driver area varies in size and contains different numbers and types of drivers .. ~2!e, that &lt;br /&gt;even though tp.es~ J:1~Â§ Ji~tC (jotused by Windows, they are ~IJ llsed to execute DOS application, &lt;br /&gt;even with Windows 95. Windows uses a file called ~YÂ§}EM.~ to 19a.d cIriy~rs llsed by Windows. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The COMMAND.COM program--command processor-contr0.s, the operation of the com-&lt;br /&gt;puter fr~111. the keyboard. The COMMAND.COM program processes the DOS commands as they &lt;br /&gt;are typed from the keyboard. For example, if DIR is typed, the COMMAND. COM program dis-&lt;br /&gt;plays a directory of the disk files in the current disk directory. If the COMMAND.COM program is &lt;br /&gt;~.a..sJ&amp;lt;g, the computer ~~.J!Ilot be used from the keyboard. Never erase COMN!AND.COM, IO.SYS, &lt;br /&gt;or MS12...Qi).SYS programs to make room for other software or your computer will not function. &lt;br /&gt;Note t!I!lt.theseprograms can b,e reloaded to the disk if erased ~ith the SYS.COM program located &lt;br /&gt;in the DOS directory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The free TPA area holds application programs as they are executed. These application pro-&lt;br /&gt;grams include wQ(Qprocessors, sprea!!sheet programs, C@programs, and so forth. The TP A &lt;br /&gt;also holds T~BJterminate and stay resident) programs that remain in memory in an !nactive state &lt;br /&gt;until activated i?ya_hot-key sequence or other event sucha~ an interrupt. A calculator program is &lt;br /&gt;an example of a TSR program that activates whenever a~ ALT-C key (hot-key) is typed.i\\.hot-&lt;br /&gt;~~yis a combination of keys on the keyboard that activate a TSR program. A TSR program is &lt;br /&gt;often also called a pop~up program because, when activated, it appears to pop up inside another &lt;br /&gt;program. If Windows is installed and in use, it also uses a portion of the TP A to store informa-&lt;br /&gt;tion that allo~s it to access extended memory. &amp;quot;. &lt;br /&gt;!:~~Â§ystf!Â£TIllf:ea, The system area, although smaller than the TPA, is just as important. The &lt;br /&gt;system area contain~-2~ograms on either a read-only memory (ROM) or flash memory and also &lt;br /&gt;areas of read/write (RAM) memory for data storage. Figure (-5 shows the system area of a typ-&lt;br /&gt;ical computer system. As with the map of the TPA, this map also includes the hexadecimal &lt;br /&gt;memory addresses of the various areas. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-5 The system &lt;br /&gt;area of a typical personal &lt;br /&gt;computer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FOOOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EOOOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;caooo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COCCO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOOOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOOOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIOS system ROM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BASIC langu~ge ROM &lt;br /&gt;(only on early PCs) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Free area &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-----------------_._----------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hard disk controller ROM &lt;br /&gt;LAN controller ROM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Video BIOS ROM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Video RAM &lt;br /&gt;(text area) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.-----------------------------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Video RAM &lt;br /&gt;(graphics area) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first area of the system space contains ~~M and video control programs &lt;br /&gt;on ROM or flash memory. This area generally ~C}llocation...M0QQ.!I and extends to location &lt;br /&gt;C7FFFH. The size and amount of memory used depends on the type of video display adapter at-&lt;br /&gt;tached to the system. Display. adapters that are often attached to a computer include the earlier &lt;br /&gt;CGA (color graphics adapter) and EGA (enhanced graphics adapter) or one of the many &lt;br /&gt;newer forms of VGA (variable graphics array). Generally, the video RAM located at &lt;br /&gt;AOOOOH-AFFFFH stores graphical or bit-mapped data and the memory at BOOOOH-BFFFFH &lt;br /&gt;stores text data. The videOBiOS, located on a ROM or flash memory, is found at locations &lt;br /&gt;COOOOH-C7FFFH and contains programs that cm;trol the video display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If a hard disk memory is attached to the computer, the interface card might contain a ROM. &lt;br /&gt;The ROM, often found with older MFM or RLL hard disk drives, holds low-level format soft-&lt;br /&gt;ware at location C8000H. The size, location, and presence of the ROM depends on the type of &lt;br /&gt;hard disk adapter attached to the computer. &lt;br /&gt;~ The area ~~OQH-DFFFFH is often open or free. This area is used for the ex-&lt;br /&gt;panded memory system (EMS) in a PC or XT system or the upper memory system in an AT &lt;br /&gt;system. Its use depends on the system and its configuration. The expanded memory system al-&lt;br /&gt;lows a 64K byte page frame of memory to be used by application programs. This 64K byte page &lt;br /&gt;frame (usually location DOOOOH-DFFFFH) is used to expand the memory system by switching &lt;br /&gt;in pages of memory from the EMS into this range of memory addresses. Note that the informa-&lt;br /&gt;tion is addressed in the page frame as 16K byte-sized pages of data that are swapped with pages &lt;br /&gt;from the EMS. Figure 1--6 shows the expanded memory system. Most application programs that &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-2 THE MICROPROCESSOR-BASED PERSONAL COMPUTER SYSTEM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-6 The expanded &lt;br /&gt;memory system showing a &lt;br /&gt;page frame &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System area &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DFFFF~----t' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64K-byte &lt;br /&gt;page frame &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOOOO ~----t' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Expanded memory &lt;br /&gt;system (EMS) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64K-byte &lt;br /&gt;page 255 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;=.--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64K-byte &lt;br /&gt;page 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64K-byte &lt;br /&gt;page 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64K-byte &lt;br /&gt;page 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;state they are LIM 4.0 driver compatible can use expanded memory. The LIM 4.0 memory man-&lt;br /&gt;agement driver is the result of Lotus, Intel, and Microsoft standard_~ziI1g access to expanded &lt;br /&gt;mt?~~l)'_systems. Note that expand~~_~e~()ry is slow bl!cause the change to a new 16K byte &lt;br /&gt;memory page requires action by the driver. Also no!('!_t!t_~texpanded memory ~as designed to ex-&lt;br /&gt;pand t~e meIl!?ry system of the e~!y_?086/8088-based computer systems. In most cases, except &lt;br /&gt;for some DOS...:-!J~ed games that US!! the s()und card, expanded memory should be avoided in the &lt;br /&gt;80386- through the Pentium Pro-based systems. -&lt;br /&gt;-'-----M~~a&amp;quot;ry locations EOOOOH-EFFFFH contain the cassette BASIC language on ROM &lt;br /&gt;found in early IBM personal computer systems. This area is oft~~()Jlen ()r free in newer com-&lt;br /&gt;puter systems. In ~werE_s~!Ils, we qften back~fiU this area with ex!ra}:~AM called upper &lt;br /&gt;memory or upper memory blocks. Each upper memory block t~1K bytes in length. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Finally, the system BIQS!{OM is located in the top 64K bytes of the system area &lt;br /&gt;(FOOOOH-FFFFFH). This ROl\\.:L&amp;lt;::ogtrols the operation of the basic 110 devices connected to the &lt;br /&gt;computer system. It ~~s_not control the operation of the videOsy~tem, which has i.ts own BIOS &lt;br /&gt;ROM at location COOOOH. The first part of the BIOS (FOOOOH-F7FFFH) contains programs that &lt;br /&gt;set up the COm]:nlter; the second part contains procedures that control the basic liD system. Once &lt;br /&gt;the--syste~ is set up, upper memory blocks at locations EOO-()()H-E7FFFH are available, if &lt;br /&gt;EMM386.EXE is installed. Also available for upper memory blocks are locations BOOOOH-&lt;br /&gt;B7FFFH, provided black and w~ite video is not needed in the CGA mode. &lt;br /&gt;JfQJp~Jb The 110 (input/output) space in a computer system extends from 110 port OOOOH to &lt;br /&gt;port FFFFH. (An 110 port address is similar to a memory address except that instead of ad-&lt;br /&gt;dressing memory, it addresses an 110 device.) The 110 devices allow the microprocessor to com-&lt;br /&gt;municate between itself and the outside world. The 110 space allows the computer to access up to &lt;br /&gt;64K different 8-bit 110 devices. A great number of these locations are available for expansion in &lt;br /&gt;most computer systems. Figure 1-7 shows the 110 map found in many personal computer systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 110 area contains two major sections. The area below I/O location 0500H is consid-&lt;br /&gt;ered reserved f,Q!:system devices, with many depicted in Figure 1-7. The remaining area is avail-&lt;br /&gt;able 110 space for expansion that extends from liD port 0500H-FFFFH. Note that some main &lt;br /&gt;boards in the computer system can also use other addresses above 0500H. Generally, liD ad-&lt;br /&gt;dresses between Q_QQQJI-:-OQFFH address componen_ts_ ()n!he main bOiU&amp;quot;d of the computer, while &lt;br /&gt;addresses between ~_Og~-=:Q500H addressdevic~s l()cated on plug-in cards. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;18 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-7 The 1/0 map &lt;br /&gt;of a personal computer &lt;br /&gt;showing some of the many &lt;br /&gt;areas of 1/0 devices &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFr-----------------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03F8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03FO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0378 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0320 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02F8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0060 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0040 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 expansion area &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/' &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COM1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Floppy disk controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CGAadapter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LPT1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hard disk controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COM2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8255 (PIA) &lt;br /&gt;Timer (8253) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Various 110 devices that control the operation of the system are usually not directly ad-&lt;br /&gt;dressed. Instead, the BIOS ROM addresses these basic devices, which can vary slightly in loca-&lt;br /&gt;tion and function from one computer to the next. Access to most 110 devices should always be &lt;br /&gt;made through DOS or BIOS function calls to maintain compatibility from one computer system &lt;br /&gt;to another. The map shown in Figure 1-7 is provided as a guide to illustrate the 110 space in the &lt;br /&gt;system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,&amp;quot; The DOS Operating System &lt;br /&gt;~ =--&amp;quot;'&amp;quot; .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The operating system is the program that operates the computer. This text assumes that the oper-&lt;br /&gt;ating system is either MSDOS or PCDOS, which are by far the most common operating systems &lt;br /&gt;found in over 160 million personal computers (85 percent, according to a recent PC magazine l4 &lt;br /&gt;article). The Windows operating system is available to 65 million personal computers, according &lt;br /&gt;to the same article. Windows 95 will undoubtedly replace Windows as an important operating &lt;br /&gt;system. The operating system is stored on a disk that is either placed in one of the floppy disk &lt;br /&gt;drives or found on a hard disk drive that is either resident to the computer or to a local area net-&lt;br /&gt;work (LAN). Some dedicated systems store the DOS on a ROM. An example is the Tandy Cor-&lt;br /&gt;poration personal computer. Each time that the computer is powered ul? Q!:~1!et, the operating &lt;br /&gt;system ~ from_tile c!i.!iKOr LAN. We call this operation Â£'ootinglf!..f!.Â§)!!.!.!m. Once DOS is in-&lt;br /&gt;stalled in the memory by the boot, it controls the operation of the computer system, its 110 de-&lt;br /&gt;vices, and application programs. In addition to the DOS operating system, other operating &lt;br /&gt;sys t ms are sometimes used to control or operate the computer. As listed in a recent article, these &lt;br /&gt;other operating systems include Windows from Microsoft, with over 65 million users; OS/2 from &lt;br /&gt;IBM, with over 4 million users; UNIX from AT&amp;amp;T, with over 2.0 million users; and many others. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14PC Magazine is a Ziff-Davis publication. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-2 THE MICROPROCESSOR-BASED PERSONAL COMPUTER SYSTEM 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first task of the DOS operating system, after loading into memory, is to use a file &lt;br /&gt;called the CONFIG.SYS file, which should not be erased. This file specifics various drivers that &lt;br /&gt;load into the memory, setting up or configuring the machine for operation. Example I-I lists an &lt;br /&gt;example CONFIG.SYS file for DOS version 6.x. Note that the statements in this file vary from &lt;br /&gt;machine to machine, and the one illustrated is just an example. &lt;br /&gt;EXAMPLE 1-1 &lt;br /&gt;REM DOS VERSION 6.22 CONFIG.SYS FILE &lt;br /&gt;DEVICE=C:\\DOS\\HIMEM.SYS &lt;br /&gt;DEVICE=C:\\DOS\\EMM386.EXE NOEMS i=c800-efff &lt;br /&gt;DOS=UMB &lt;br /&gt;FILES=30 &lt;br /&gt;BUFFERS=lO &lt;br /&gt;SHELL=C:\\DOS\\COMMAND.COM C:\\DOS\\ /E:2048 /P &lt;br /&gt;DOS=HIGH &lt;br /&gt;DEVICEHIGH C:\\LASERLIB\\SONY_CDU.SYS &lt;br /&gt;DEVICEHIGH C:\\DOS\\SETVER.EXE &lt;br /&gt;DEVICEHIGH C:\\MOUSE1\\MOUSE.SYS &lt;br /&gt;LASTDRIVE=F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first statement (REM) is a remark that merely identifies this file and is optional. The &lt;br /&gt;second line infurms the system to .!()a~th~Â·HiMEM.SYS ~Ij.'1er that allows ~RP~~-me~ory blocks &lt;br /&gt;to be used and &amp;lt;;llso provides high me~o~ytothe system. (A driver is a program that controls an &lt;br /&gt;VO device or some other function and is load~!!J2s:fQr:(!.5)!h(!r programs by the CONFIG.SYS &lt;br /&gt;file.) High memory is a section of memory that exis!~!;&amp;gt;~_ginning at 10catiOl!J00000H and ends &lt;br /&gt;at lOFEFFH, just above the first 1M byte of memory, to be used for programs in the 80286-&lt;br /&gt;through the Pentium-based system. This driver allows a DQ,~,:based system access tgJM plus &lt;br /&gt;64K!;&amp;gt;y~es of memory. This extra 64K byte section-ofhigh memory holds most of the MSDOS &lt;br /&gt;version 5.0 and above, freeing additional space in the TPA. &amp;quot; . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first four statements in this CONFIG.SYS file set up the .I}!!!!!Q~~fE}(:s, Quffers, stacks, &lt;br /&gt;and file c:~Jr.2IQi2.~J~s required to execute various programs. These settings should be adequate for &lt;br /&gt;just about any program loaded into memory using DOS. In general, if a program requires more &lt;br /&gt;buffers, and so forth, the documentation indicates that the CONFIG.SYS file must be changed to &lt;br /&gt;reflect an increased need. Many IE,2.&amp;lt;!~m programs automatically. adjllst the CONFIG.SYS file &lt;br /&gt;when installed by changing ~~Â§e.Parametersor by adding.additional statements: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In'orderto enable the upper memory blocks, available only in an 80386-, 80486-, or Pen-&lt;br /&gt;tium-based system, the EMM386.EXE (extended memory manager) program is loaded into &lt;br /&gt;memory. The extended memory manager is a driver that ~~Ilit~sexpanded memory in ~xtended &lt;br /&gt;~~mory and also the extended memory system. This program back-fills free areas of memory &lt;br /&gt;within the system area so that programs can be loaded into this-area and accessed directly by &lt;br /&gt;DOS applications. The I=c800-efff switch tells EMM386.EXE to use memory area C8000H-&lt;br /&gt;EFFFFH for ~pel&amp;quot; !Ile!llory or upper memory blocks (UMB). Driv~~s_and programs are loaded &lt;br /&gt;into upper memory, freeing even more area in the TPA for application programs. Before using &lt;br /&gt;the &amp;quot;r;&amp;quot;c800-efff switch, make sure that your computer does not contain any system ROMIRAM &lt;br /&gt;in this area of the meni&amp;quot;ory. Note that NOEMS tells EMM386.EXE to ex~jude expanded &lt;br /&gt;memOry~Expanded memory can also &amp;quot;iJe installed by replacing NOEMS with a number that indi-&lt;br /&gt;&amp;quot;~~t;;~. how much&amp;quot; extended memory to allocate to LIM 4.0 expand~d memory system (EMS). &lt;br /&gt;Today, most-systems ,sh()Uld not use expanded memory. If expanded memory is required, the &lt;br /&gt;NOEMS is replaced with ~AM_.L024 to enable 1,()2,! bytes of expanded memory. The &lt;br /&gt;FRAME=DOOO statement places the p~~JraJ11e fo~ -exp,!nded memory at location pOOOOH-&lt;br /&gt;DFFFFH if expanded memory is enabled. If DOS version 6.0 or higher is in use, tJ::it! NOEMS &lt;br /&gt;statement stiiipr~vides access to EMS on an as-needed ba~~'through a driver called VCPI (vir-&lt;br /&gt;~.-. -~-.' .. ~-- &amp;quot;,,;:-.- - - '&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tual control program interface). The VCPI program dynamical!tallocates EMS if a program &lt;br /&gt;requires it and then releases it after the program completes execution. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;20 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The next two commands inform the system to provide upper memory blocks (DOS=UMB) &lt;br /&gt;and also dictate how many files can be opened at the same time (FILES=30). The BUFFERS &lt;br /&gt;statement informs DOS to allocate 10 buffers to open for file transfer areas. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The SHELL command specifies the command processor used with DOS. In this example, &lt;br /&gt;the COMMAND. COM file is the command processor (also selected by default) using the E:2048 &lt;br /&gt;fP switches. The E:2048 switch sets the environment size to 2,048 bytes. The environment space &lt;br /&gt;stores shared keywords and other information used by all applications in the system. An example &lt;br /&gt;is the statement SET TEMP=C:\\TEMP, which informs applications that the temporary directory &lt;br /&gt;is on the C disk drive in a directory called TEMP. The SET command can be used to assign key-&lt;br /&gt;words at the DOS command prompt or in the AUTOEXEC.BAT file. The fP switch tells the com-&lt;br /&gt;mand processor to make COMMAND.COM permanent. If COMMAND.COM is not permanent, &lt;br /&gt;it must be loaded into memory from the disk each time that DOS returns to the command prompt. &lt;br /&gt;Although this may free a small amount of memory, the constant access to the disk for the COM-&lt;br /&gt;MAND.COM program increases wear and tear on the disk drive and also lengthens the time re-&lt;br /&gt;quired to retum to the DOS prompt. This is followed by the command DOS=HIGH, which &lt;br /&gt;informs the system to load DOS into the high memory area created by the HIMEM.SYS driver. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The next three lines use the DEVICEHIGH command, which loads drivers and programs &lt;br /&gt;into the upper memory blocks allocated by the EMM386.EXE driver. In the CONFIG.SYS file &lt;br /&gt;illustrated, three drivers are loaded into upper memory blocks beginning at location C8000H. &lt;br /&gt;The first is a program that operates a Sony CD-ROM drive, the second loads a program called &lt;br /&gt;SETVER, and the third loads the MOUSE driver. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The last statement in the CONFIG.SYS file illustrated shows the LASTDRIVE statement. &lt;br /&gt;This tells DOS which is the last disk drive connected to your computer system. By using the &lt;br /&gt;LASTDRIVE statement, more memory can be freed for use in the TP A. Each drive requires a &lt;br /&gt;buffer area; if you use the actual last drive with this statement, extra memory is made available. &lt;br /&gt;Other drivers may also be loaded into memory using the CONFIG.SYS file, such as a &lt;br /&gt;PRINT.SYS driver, ANSI.SYS driver, or any other program that functions as a driver. Driver &lt;br /&gt;programs normally contain t!Je DO~!!gQ.IL.SY_S used to indicate a system file. Be very &lt;br /&gt;careful when changing the CONFIG.SYS file, because an error locks up the ~er system &lt;br /&gt;(except for DOS 6.0 and above, which can exit this type of system lockup). Once the computer &lt;br /&gt;is 10c!c!!c!f:1.P ~.Y.'!SQ!,!!:!QÂ·SYSEfor, the only way t.2-~is to Q.Q.Q.LQfLILR_QS floppy disk &lt;br /&gt;t~_(mtains Jh~QP(!!:l:I.ting~y~tem with a f~I!~i().Il~l}g.cQNEKi..syS file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once the operating system completes its configuration, as dictated by CONFIG.SYS, the &lt;br /&gt;AUTOEXEC.BAT (automatic execution batch) file is executed by the computer. If none exists, &lt;br /&gt;the computer asks for the time and date. Example 1-2 shows a typical AUTOEXEC.BAT file. This &lt;br /&gt;is only an example; variations often occur from system to system. The AUTOEXEC.BAT file con-&lt;br /&gt;tains commands that execute when power is first applied to the computer. These are the same com-&lt;br /&gt;mands that could be typed from the keyboard, but the AUTOEXEC.BAT saves us from doing so &lt;br /&gt;each time the computer is powered up. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-2 &lt;br /&gt;PATH C:\\DOS;C:\\;C:\\MASM\\B1N;C:\\MASM\\B1NB\\;C:\\UT1L1TY &lt;br /&gt;SET BLASTER=A220 17 Dl T3 &lt;br /&gt;SET 1NCLUDE=C:\\MASM\\1NCLUDE\\ &lt;br /&gt;SET HELPF1LES=C:\\~SM\\HELP\\Â·.HLP &lt;br /&gt;SET 1NIT=C: \\MASM' JIIT\\ &lt;br /&gt;SET ASMEX=C: \\11ASM\\SAHPLES \\ &lt;br /&gt;SET TMP=C:\\MASM\\TMP &lt;br /&gt;SET SOUND=C: \\SB &lt;br /&gt;LOADHIGH C:\\LASERLIB\\HSCDF:\\.EXE /D:SONY_OOl /L:F /M:IO &lt;br /&gt;LOADHIGH C:\\LASERLIB\\LLTSR.EXE ALT-Q &lt;br /&gt;LOADHIGH C:\\DOS\\FASTOPEN C:=256 &lt;br /&gt;LOADHIGH C:\\DOS\\DOSKEY /BUFSIZE=1024 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-2 THE MICROPROCESSOR-BASED PERSONAL COMPUTER SYSTEM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOADHIGH C:\\LASERLIB\\PRINTF.COM &lt;br /&gt;DOSKEY GO=C:\\WINDOWS\\WIN /3 &lt;br /&gt;GO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PATH statement specifies the search paths whenever a program name is typed at the &lt;br /&gt;command line. The order of th~patb ~earch is the same as the order of the paths in the path state-&lt;br /&gt;ment. For example, if PROG is type~~at the command line, the machine first searches C:\\DOS, &lt;br /&gt;then the rout din::ctory C:\\, then C:'lrvlASM\\BIN and so forth until the program named PROG is &lt;br /&gt;found. If it isn'_t found, the command interpreter (COMMAND.COM) informs the user that the &lt;br /&gt;program iS2.ot found. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The SET statement, as introduced earlier, sets a variable name to a path. This allows names &lt;br /&gt;to be associated with paths for batch programs. It's also used to set command strings (environ-&lt;br /&gt;ments) for various programs. The first SET command sets the environment for the sound blaster &lt;br /&gt;card. The second SET command set~INCLUDE to the path C:\\MASM\\lNCLUDE\\. Note that &lt;br /&gt;the SET statements are_stored in the DOS environment space that was reserved in the &lt;br /&gt;CONFIG.syS file using the SHELL statement. If the environment becomes too large, you must &lt;br /&gt;-chang~ &amp;quot;t~e -SBJ~LL statemeni-~~llow more space. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOAD HIGH or LH places programs into upper memory blocks defined by the &lt;br /&gt;EMM386.EXE program. LOADHIGH is used at any DOS command prompt for loading a pro-&lt;br /&gt;giam into the high (upper) I!lem()ry area as long,as-ihe-computer is an .Â§0386 or above. The &lt;br /&gt;second-last command in this AUTOEXEC.BAT file uses the QOs~y program to define a &lt;br /&gt;macro for the woc&amp;lt;:LGO. Here the word GQjs assigned the character_~tIj'lgC;::\\WINDOWS\\:WIN &lt;br /&gt;/3. The COMMAND.COM program will then interpret the_~Qr~ GO so th_a_t_the Windows pro-&lt;br /&gt;gram ex~~e~.lll1ytime that the word QQJs typed on the keyboard at th~I:&amp;gt;0S prompt. This last &lt;br /&gt;command then runs Windows. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TheJll1lgI9Jt~Q~_~Â§s,o,r &lt;br /&gt;At the heart of the microprocessor-based computer system is the microprocessor integrated cir-&lt;br /&gt;cuit. The microprocessor is the controlling element in a computer system and is sometimes re-&lt;br /&gt;ferred to as the CPU (central processing unit). The microprocessor controls memory andpO &lt;br /&gt;through a series of connections call~~~ll~es. Buses seleC:~~l1pO or memory device, tran..sfer data &lt;br /&gt;between an VO device or m~mory and the microprocessor, and controUhe VO and memory &lt;br /&gt;system. M~~~ry and VO are controlled through instructions that are stored in the memory and &lt;br /&gt;exec.!.l~&amp;lt;?cI by th~ microprocessor. ' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The microprocessor performs three main tasks for the computer system: (1) data transfer &lt;br /&gt;between itself and the memory or VO systems, (2) simple arithmetic and logic operations, and &lt;br /&gt;(3) program flow via simple decisions. Albeit these are simple tasks, but through them, the mi-&lt;br /&gt;croprocessor performs virtually any series of operations or tasks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The power of the microprocessor is in: its ability to execute millions of instructions per &lt;br /&gt;second from a program or software (group of instructions) stored in the memory system. This &lt;br /&gt;stor~Q&amp;quot;pr()gr~1Il co_ncept has made the microprocessor and computer system ~_ very powerful de-&lt;br /&gt;vice. Recall that Babbage also wanted to use the stored program concept inhis Analytical Engine. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 1-3 sIlOws&amp;quot;&amp;quot;the arithmetic and logic operations executed by the Intel family of mi-&lt;br /&gt;croprocessors. These operations are very basic, but through them, very complex problems are &lt;br /&gt;solved. Data are operated upon from the memory system or internal registers. Data widths are &lt;br /&gt;variable and include a byte (8-bits), word (16-bits), and doubleword (32-bits). Note that only &lt;br /&gt;the 80386 through the Pentium directly manipulate .~-, 16-, and 32-bit numbers. The earlier &lt;br /&gt;8086-80286 directly manipulate,8- and 16-bit numbers, but not 32-bit numbers. The 80486DX &lt;br /&gt;and Pentium also contain a numeric coprocessor that allows them to perform- complex calcula-&lt;br /&gt;tions using floating-point arithmetic. The numeric coprocessor was an additional component in &lt;br /&gt;the 8086- through the 80386-based personal computer. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;22 CHAPTER 1 INTROOUCTION TO THE MICROPROCESSOR ANO COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-3 Simple &lt;br /&gt;arithmetic and logic &lt;br /&gt;operations &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addition &lt;br /&gt;Subtraction &lt;br /&gt;Multiplication &lt;br /&gt;Division &lt;br /&gt;AND &lt;br /&gt;OR &lt;br /&gt;NOT &lt;br /&gt;NEG &lt;br /&gt;Shift &lt;br /&gt;Rotate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Comment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Logical multiplication &lt;br /&gt;Logical addition &lt;br /&gt;Logical inversion &lt;br /&gt;Arithmetic inversion &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another feature that makes the microprocessor powerful is its ability to make simple deci-&lt;br /&gt;sions. Decisions are based upon numerical facts. For example, a microprocessor can decide if a &lt;br /&gt;number is zero, if it is positive, and so forth. These simple decisions allow the microprocessor to &lt;br /&gt;modify the program flow so programs appear to think through these simple decisions. Table 1-4 &lt;br /&gt;lists the decision-making abilities of the Intel family of microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Buses. A bus is a common group of wires that interconnect components in a computer system. &lt;br /&gt;The buses that interconnect the sections of a computer system transfer address, data, and control in-&lt;br /&gt;formation between the microprocessor and its memory and 110 systems. In the microprocessor-&lt;br /&gt;based computer system, three buses exist for this transfer of information: address, data, and control. &lt;br /&gt;Figure 1-8 shows how these buses interconnect various system components such as the micro-&lt;br /&gt;processor, read/write memory (RAM), read-only memory (ROM), and a few 110 devices. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address bus requests a memory location from the memory or an 110 location from the 110 &lt;br /&gt;devices. If 110 is addressed. the address bus contains a 16-bit 110 address from OOOOH-FFFFH. The &lt;br /&gt;16-bit 110 address or port number selects one of 64K different 110 devices. If memory is addressed, &lt;br /&gt;the address bus contains a memory address. The memory address varies in width with the different &lt;br /&gt;versions of the microprocessor. The 8086 and 8088 address 1M byte of memory using a 20-bit ad-&lt;br /&gt;dress that selects locations OOOOOH-FFFFFH. The 80286 and 80386SX address 16M bytes of &lt;br /&gt;memory using a 24-bit address that selects locations OOOOOOH-FFFFFFH. The 80386SL, 80386SLC, &lt;br /&gt;and 80386EX address 32M bytes of memory using a 25-bit address that selects locations &lt;br /&gt;OOOOOOOH-IFFFFFFH. The 80386DX, 80486SX, and 80486DX address 4G bytes of memory &lt;br /&gt;using a 32-bit address that selects locations OOOOOOOOH-FFFFFFFFH. The Pentium also addresses &lt;br /&gt;4G bytes of memOlY, but it uses a 64-bit data bus to access up to 8 bytes of memOlY at a time. The &lt;br /&gt;Pentium Pro processor has a 64-bit data bus and a 32-bit address bus that addresses 4G bytes of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-4 Decisions &lt;br /&gt;found in 8086-80486 and &lt;br /&gt;Pentium/Pentium Pro &lt;br /&gt;microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Decision &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Zero &lt;br /&gt;Sign &lt;br /&gt;Carry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Parity &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Overflow &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Comment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Test a number for zero or not-zero &lt;br /&gt;Test a number for positive or negative &lt;br /&gt;Test for a carry after addition or a borrow after &lt;br /&gt;subtraction &lt;br /&gt;Test a number for an even or an odd number of &lt;br /&gt;ones &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Test for an overflow that indicates an invalid &lt;br /&gt;signed result after addition or subtraction &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-2 THE MICROPROCESSOR-BASED PERSONAL COMPUTER SYSTEM 23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;~p &amp;lt;:,, ______ ~_.,_TD-at-?_h-U-S_,~_r~--------._~_.------_. &lt;br /&gt;MWTCI------.-t.I \\ 1---.--t.I \\:- 1-----IAr - r-: &lt;br /&gt;MRDCi-------H - f- - ~ &lt;br /&gt;IOWC 1-------+-1 - r- T - ~ &lt;br /&gt;~I---t-i ~\\I V\\/ t ~r----t~VV-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Read-only &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Read/write &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAM &lt;br /&gt;Keyboard Printer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-8 The block diagram of a computer system showing the address, data, and control &lt;br /&gt;bus structure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory from location OOOOOOOOH-FFFFFFFFH or a 36-bit address bus that addresses 640 bytes of &lt;br /&gt;memory at locations OOOOOOOOOH-FFFFFFFFFH depending on its configuration. Refer to Table 1-5 &lt;br /&gt;for a complete listing of bus and memory sizes on the Intel family of microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The data bus transfers information between the microprocessor and its memory and 110 ad-&lt;br /&gt;dress space. Data transfers vary in size from 8-bits wide to 64-bits wide in various members of the &lt;br /&gt;Intel microprocessor family. The 8088 contains an 8-bit data bus that transfers 8-bits of data at a &lt;br /&gt;time. The 8086, 80286, 80386SL, 80386SX, and 80386EX transfer 16-bits of data through their &lt;br /&gt;data buses; the 80386DX, 80486SX, and 80486DX transfer 32-bits of data; and finally, the Pen-&lt;br /&gt;tium and Pentium Pro transfer 64-bits of data. The advantage of a wider data bus is speed in ap-&lt;br /&gt;plications that us~ wide data. For example, if a 32-bit number is stored in memory, it takes the &lt;br /&gt;8088 microprocessor four transfer operations to complete because its data bus is only 8-bits wide. &lt;br /&gt;The 80486 accomplishes the same task with one transfer because its. data bus is 32-bits wide. &lt;br /&gt;Figure 1-9 shows the memory widths and sizes of the 8086-80486 and Pentium microprocessors. &lt;br /&gt;Notice how the memory sizes and organizations differ between various members of the Intel &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-5 The Intel family of microprocessor bus and memory sizes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microprocessor Data Bus Width Address Bus Width Memory Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086 16 20 1M &lt;br /&gt;8088 8 20 1M &lt;br /&gt;80186 16 20 1M &lt;br /&gt;80188 8 20 1M &lt;br /&gt;80286 16 24 16M &lt;br /&gt;80386SX 16 24 16M &lt;br /&gt;80386DX 32 32 4G &lt;br /&gt;80386EX 16 26 64M &lt;br /&gt;80486 32 32 4G &lt;br /&gt;Pentium 64 32 4G &lt;br /&gt;Pentium OverDrive 32 32 4G &lt;br /&gt;Pentium Pro 64 32 4G &lt;br /&gt;Pentium Pro 64 36 64G &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;24 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HIgh bank Low bank &lt;br /&gt;(Odd bank) (Even bank) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFF FFFFFF FFFFFE &lt;br /&gt;FFFFE FFFFFO FFFFFC &lt;br /&gt;FFFFO FFFFFB FFFFFA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;----.----------- ---------------- -----.----------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f+--Bbits- ~Bbits_ _Bbits_ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1M byte BM byles BM bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--------------- ---------------- ----------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00002 000005 000004 &lt;br /&gt;00001 000003 000002 &lt;br /&gt;00000 000001 000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07-00 015-0B 07-00 &lt;br /&gt;BOBB microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B086 microprocessor (memory is only 1 M bytes) &lt;br /&gt;B0286 microprocessor &lt;br /&gt;80386SX microprocessor &lt;br /&gt;B0386SL microprocessor (memory is 32M bytes) &lt;br /&gt;B03B6SLC microprocessor (memory is 32M byles) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank 3 Bank 2 Bank 1 Bank 0 &lt;br /&gt;FFFFFFFF FFFFFFFE FFFFFFFO FFFFFFFC &lt;br /&gt;FFFFFFFB FFFFFFFA FFFFFFF9 FFFFFFF8 &lt;br /&gt;FFFFFFF7 FFFFFFF6 FFFFFFF5 FFFFFFF4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---------------- --.------------- ----------------&lt;br /&gt;.-.-------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f+--Bbits- ~Bbits_ ~ B bits --:----+ ~Bbits_ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lG byle lG byte lG byte lG byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---------------- --.------------- ---------------- ----------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOOOB OOOOOOOA 00000009 OOOOOOOB &lt;br /&gt;00000007 00000006 00000005 00000004 &lt;br /&gt;00000003 00000002 00000001 00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;031-024 023-016 015-0B 07-00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B03B60X microprocessor &lt;br /&gt;B04B6SX microprocessor &lt;br /&gt;B04860X microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-9 The physical memory systems of the 8086 through the Prentium Pro microprocessors &lt;br /&gt;----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessor family. In all family members, the memory is numbered by byte. Notice that the &lt;br /&gt;Pentium and Pentium Pro processors both contain a 64-bit wide data bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The control bus contains lines that select the memory or I/O and cause them to perform a read &lt;br /&gt;or a write operation. In most computer systems, there are four control bus connections: MRDC &lt;br /&gt;(memory read control), MWTC (memory write control), IORC (110 read control), and IOWC &lt;br /&gt;(110 write control). Note that the over-bar indicates that the control sJ'~nal is active-low-that is. it is &lt;br /&gt;active when a logic zero appears on the control line. For example, if rOWC = 0, the microprocessor is &lt;br /&gt;writing data from the data bus to an I/O device whose address appears on the address bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The microprocessor reads the contt;nts of a 111l:l11ory location by sending the memory an ad-&lt;br /&gt;dress through the address bus. Next, it sends the memory read control ~ignal (MRDC) to cause &lt;br /&gt;memory to read data. Finally the data read from the memory are passed to the microprocessor &lt;br /&gt;through the data bus. Whenever a memory write, I/O write, or I/O read uccurs, the same sequence &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-3 NUMBER SYSTEMS 25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank 7 Bank 6 BankS Bank 4 &lt;br /&gt;FFFFFFFF FFFFFFFE FFFFFFFO FFFFFFFC &lt;br /&gt;FFFFFFF7 FFFFFFF6 FFFFFFF5 FFFFFFF4 &lt;br /&gt;FFFFFFEF FFFFFFEE FFFFFFEO FFFFFFEC &lt;br /&gt;~ .. - - - - - ----- - - - --.------------- ---------------- ----------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f-+--- 8 bits -- f-+--- 8 bits -- f+._- 8 bits -- ~8blts __ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;512M bytes 512M bytes 512M bytes 512M bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.--------------- ---------------- ---------------- ----------------00000017 00000016 00000015 00000014 &lt;br /&gt;OOOOOOOF OOOOOOOE 00000000 OOOOOOOC &lt;br /&gt;00000007 00000006 00000005 00000004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;063-056 055--048 047-040 039-032 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank 3 Bank 2 Bank 1 BankO &lt;br /&gt;FFFFFFFB FFFFFFFA FFFFFFF9 FFFFFFF8 &lt;br /&gt;FFFFFFF3 FFFFFFF2 FFFFFFF1 FFFFFFFO &lt;br /&gt;FFFFFFEB FFFFFFEA FFFFFFE9 FFFFFFE8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-------------.-- ---------------- -----.---.------ ----------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-+-- 8 bits __ -+-- 8 bits __ ~8bits __ -+-- 8 bits __ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;512M bytes 512M bytes 512M bytes 1G byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---------------- -----.---------- --.--.---.------ .--------.------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000013 00000012 00000011 00000010 &lt;br /&gt;OOOOOOOB OOOOOOOA 00000009 00000008 &lt;br /&gt;00000003 00000002 00000001 00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;031-024 023-016 015--08 07-00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium/Pentium Pro microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-9 (continued) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ensues except that different control signals are issued and the data flow out of the microprocessor &lt;br /&gt;through its data bus for a write operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NUMBER SYSTEMS &lt;br /&gt;The use of the microprocessor requires a working knowledge of binary, decimal, and hexadec-&lt;br /&gt;imal number systems. This section of the text provides a background for those unfamiliar with &lt;br /&gt;number systems. Conversions between decimal and binary and decimal and hexadecimal, as &lt;br /&gt;well as between binary and hexadecimal, are described. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Digits &lt;br /&gt;Before numbers are converted from one number base to another, the digits of a number system &lt;br /&gt;must be understood. Early in our education, we learned that a decimal or base 10 number was &lt;br /&gt;constructed with 10 digits: 0 through 9. The first digit in any numbering system is always a zero. &lt;br /&gt;For example, a base 8 (octal) number contains 8 digits: 0 through 7; a base 2 (binary) number &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;26 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;contains 2 digits: 0 and I. If the base of a number exceeds 10, the additional digits use the letters &lt;br /&gt;of the alphabet beginning with an A. For example, a base 12 number contains 12 digits: 0 &lt;br /&gt;through 9 followed by A for 10 and B for 11. Note that a base 10 number does not contain a 10 &lt;br /&gt;digit just as a base S number does not contain an 8 digit. The most common number systems used &lt;br /&gt;with computers are decimal, binary, octal, and hexadecimal (base 16). Each system is described &lt;br /&gt;and used in this section of the chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Positional Notation &lt;br /&gt;Once the digits of a number system are understood, larger numbers are constructed using posi-&lt;br /&gt;tional notation. In grade school, one learned that the position to the left of the units position was &lt;br /&gt;the tens position, the position to the left of the tens position was the hundreds position, and so &lt;br /&gt;forth. What probably was not learned was that the units position has a weight of 10Â° or 1; the tens &lt;br /&gt;position has a weight of 101 or 10; and the hundreds position has a weight of 102 or 100. The &lt;br /&gt;powers of the positions are critical in understanding numbers in other numbering systems. The &lt;br /&gt;position to the left of the radix (number base) point, called a decimal point only in the decimal &lt;br /&gt;system, is always the units position in any number system. For example, the position to the left &lt;br /&gt;of the binary point is 2Â° or 1; while the position to the left of the octal point is SO or 1. In any case, &lt;br /&gt;any number raised to its zero power is always 1 or the units position. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The position to the left of the units position is always the number base raised to the first &lt;br /&gt;power; in a decimal system this is 101 or 10. In a binary system it is 21 or 2, and in an octal &lt;br /&gt;system it is SI or S. Therefore, an 11 decimal has a different value than an 11 binary. The 11 dec-&lt;br /&gt;imal is composed of 1 ten plus 1 unit and has a value of 11 units, while the 11 binary is composed &lt;br /&gt;of 1 two plus 1 unit for a value of 3 units. The 11 octal has a value of 9 units. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the decimal system, positions to the right of the decimal point have negative powers. &lt;br /&gt;The first digit to the right of the decimal point has a value of 10-1 or 0.1. In the binary system, the &lt;br /&gt;first digit to the right of the binary point has a value of 2-1 or 0.5. In general, the principles that &lt;br /&gt;apply to decimal numbers also apply to numbers in any other number system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 1-3 shows a 110.101 in binary (often written as 110.101 2), It also shows the &lt;br /&gt;power and weight or value of each digit position. To convert a binary number to decimal, add the &lt;br /&gt;weights of each digit to form its decimal equivalent. The 110.1012 is equivalent to a 6.625 in &lt;br /&gt;decimal (4 + 2 + 0.5 + 0.125). Notice that this is the sum of 22 (or 4) plus 21 (or 2), but 2Â° (or 1) &lt;br /&gt;is not added because there are no digits under this position. The fraction part is composed of 2-1 &lt;br /&gt;(0.5) plus 2-3 (or .125), but there is no digit under the 2-2 (or .25). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-3 &lt;br /&gt;Power 2&amp;quot; 21 2Â° 2. 1 2 -2 2- 3 &lt;br /&gt;Weight 4 2 1 0.5 0.25 .125 &lt;br /&gt;Number 1 1 0 1 0 1 &lt;br /&gt;Numeric Value 4 + 2 + 0 + 0.5 + 0 + 0.125 6.625 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that the conversion technique is applied to a base 6 number such as 25.26, Ex-&lt;br /&gt;ample 1-4 shows this number placed under the powers and weights of each position. In this ex-&lt;br /&gt;ample, there is a 2 under 61, which has a value of 1210 (2 x 6), and a 5 under 6Â° which has a value &lt;br /&gt;of 5 (5 x 1). The whole number portion has a decimal value of 12 + 5 or 17. The number to the &lt;br /&gt;right of the hex point is a 2 under 6-1 which has a value of .333 (2 x .167). The number 25.26, &lt;br /&gt;therefore, has a decimal value of 17.333. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-4 &lt;br /&gt;Power 6' 6' 6 1 &lt;br /&gt;weight 6 1 .167 &lt;br /&gt;Number 2 5 2 &lt;br /&gt;Numeric Value 12 + 5 + 0.333 17.333 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-3 NUMBER SYSTEMS 27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conversion to Decimal &lt;br /&gt;The prior examples have shown that to convert from any number base to decimal, determine the &lt;br /&gt;weights of each position of the number and then sum the weights to form the decimal equivalent. &lt;br /&gt;Suppose that a 125.78 octal is converted to decimal. To accomplish this conversion, first write &lt;br /&gt;down the weights of each position of the number. This appears in Example 1-5. The value of &lt;br /&gt;125.78 is 85.875 decimal or 1 x 64 plus 2 x 8 plus 5 x I plus 7 x .125. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-5 &lt;br /&gt;Power 82 8 ' 8Â° 8 -1 &lt;br /&gt;Weight 64 8 1 .125 &lt;br /&gt;Number 1 2 3 7 &lt;br /&gt;Numeric Value 64 + 16 + 5 + .875 ~ 85.875 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that the weight of the position to the left of the units position is 8. This is 8 times 1. &lt;br /&gt;Then notice that the weight of the next position is 64 or 8 times 8. If another position existed, it &lt;br /&gt;would be 64 times 8 or 512. To find the weight of the next higher-order position, multiply the &lt;br /&gt;weight of the current position by the number base (or 8 in this example). To calculate the weights &lt;br /&gt;of position to the right of the radix point, divide by the number base. In the octal system, the po-&lt;br /&gt;sition immediately to the right of the octal point is 1/8 or .125. The next position is .125/8 or &lt;br /&gt;.015625, which can also be written as 1/64. Also note that the number in Example 1-5 can also be &lt;br /&gt;written as the decimal number 857/8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 1-6 shows the binary number 11011.0111 written with the weights and powers &lt;br /&gt;of each position. If these weights are summed, the value of the binary number converted to dec-&lt;br /&gt;imal is 27.4375. &lt;br /&gt;-~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-6 &lt;br /&gt;Power 2&amp;quot; 2 3 22 2' 2Â° r' 2 -2 2- 3 2 -4 &lt;br /&gt;Weight 16 8 4 2 1 0.5 0.25 .125 .0625 &lt;br /&gt;Number 1 0 1 1 0 1 1 1 &lt;br /&gt;Numeric Value 16 + 8 + 4 + 2 + 1 + 0 + .25 + .125 + .0625 = 27.4375 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It is interesting to note that 2-1 is also liz, 2-2 is 1/4, and so forth. It is also interesting to note &lt;br /&gt;that 2-4 is 1/16 or 0.625. The fractional part of this number is 7/16 or .4375 decimal. Notice that &lt;br /&gt;0111 is a 7 in binary code for the numerator and the rightmost one is in the 1116 position for the &lt;br /&gt;denominator. Other examples are the binary fraction of .101 is 5/8 and the binary fraction of &lt;br /&gt;.001101 is 13/64. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hexadecimal numbers are often used with computers. A 6A.CH (H for hexadecimal) is il-&lt;br /&gt;lustrated with its weights in Example 1-7. The sum of its digits are 106.75 or 1063/4. The whole &lt;br /&gt;number part is represented with 6 x 16 plus 10 (A) x 1. The fraction part is 12 (C) as a numerator &lt;br /&gt;and 16 (16-1) as the denominator, or 12/16, which is reduced to 3/4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-7 &lt;br /&gt;Power 16 ' 16Â° 16-1 &lt;br /&gt;Weight 16 1 .0625 &lt;br /&gt;Number 6 A C &lt;br /&gt;Numeric Value 96 + 10 + .75 106.75 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conversion from Decimal &lt;br /&gt;Conversions from decimal to other number systems are more difficult to accomplish than con-&lt;br /&gt;version to decimal. To convert the whole number portion of a number to decimal, divide by the &lt;br /&gt;radix. To convert the fractional portion, mUltiply by the radix. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;28 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whole Number Conversion from Decimal. To convert a decimal whole number to another num-&lt;br /&gt;ber system, divide by the radix and save the remainders as significant digits of the result. An al-&lt;br /&gt;gorithm for this conversion follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. Divide the decimal number by the radix (number base). &lt;br /&gt;2. Save the remainder (fIrst remainder is the least significant digit.) &lt;br /&gt;3. Repeat steps I and 2 until the quotient is zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, to convert a 10 decimal to binary, divide it by 2. The result is 5, with a re-&lt;br /&gt;mainder of O. The first remainder is the units position of the result, in this example a O. Next di-&lt;br /&gt;vide the 5 by 2. The result is 2 with a remainder of 1. The 1 is the value of the two's (21) position. &lt;br /&gt;Continue the division until the quotient is a zero. Example 1-8 shows this conversion process. &lt;br /&gt;The result is written as 10102 from the bottom to the top. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-8 &lt;br /&gt;2) 10 remainder = 0 &lt;br /&gt;2 f5 remainder = 1 &lt;br /&gt;2 IT remainder 0 &lt;br /&gt;2)1 remainder = 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To convert a 10 decimal into base 8, divide by 8 as shown in Example 1-9. A 10 decimal &lt;br /&gt;is a 12 octal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-9 &lt;br /&gt;8) 10 remainder = 2 &lt;br /&gt;8r-i remainder = 1 &lt;br /&gt;-0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conversion from decimal to hexadecimal is accomplished by dividing by 16. The remain-&lt;br /&gt;ders will range in value from 0 through 15. Any remainder of 10 though 15 is then converted to &lt;br /&gt;the letters A through F for the hexadecimal number. Example 1-10 shows the decimal number &lt;br /&gt;109 converted to a 6DH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-10 &lt;br /&gt;16) 109 remainder = 13 (D) &lt;br /&gt;16) 6 remainder = 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Converting from a Decimal Fraction. Conversion from a decimal fraction to another number &lt;br /&gt;base is accomplished with multiplication by the radix. For example, to convert a decimal fraction &lt;br /&gt;into binary, multiply by 2. After the multiplication, the whole number portion of the result is &lt;br /&gt;saved as a significant digit of the result and the fractional remainder is again multiplied by the &lt;br /&gt;radix. When the fraction remainder is zero, multiplication ends. Note that some numbers are &lt;br /&gt;never-ending. That is, a zero is never a remainder. An algorithm for conversion from a decimal &lt;br /&gt;fraction follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Multiply the decimal fraction by the radix (number base). &lt;br /&gt;2. Save the whole number portion of the result (even if zero) as a digit. Note that the first result &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;is written immediately to the right of the radix point. &lt;br /&gt;3. Repeat steps 1 and 2 using the fractional part of step 2 until the fractional part of step 2 is &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a .125 decimal is converted to binary. This is accomplished with multipli-&lt;br /&gt;cations by 2 as illustrated in Example 1-11. Notice that the multiplication continues until the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-3 NUMBER SYSTEMS 29 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;fractional remainder is zero. The whole number portions are written as the binary fraction &lt;br /&gt;(0.001) in this example. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-11 &lt;br /&gt;.125 &lt;br /&gt;x~~2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0.25 digit is 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.25 &lt;br /&gt;x _~2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0.5 digit is 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.5 &lt;br /&gt;x _2 &lt;br /&gt;1.0 digit is 1. The result is written as 0.001 binary &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This same technique is used to convert a decimal fraction into any number base. Example &lt;br /&gt;1-12 shows the same decimal fraction of .125 from Example 1-11 converted to octal by multi-&lt;br /&gt;plying by 8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-12 &lt;br /&gt;.125 &lt;br /&gt;x~~8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1.0 digit is 1. The result is written as 0.1 octal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conversion to a hexadeci~al fraction appears in Example 1-13. Here a decimal.046875 is &lt;br /&gt;converted to hexadecimal by mUltiplying by 16. Note that a .046875 is a O.OCH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-13 &lt;br /&gt;.046875 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;x 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.75 &lt;br /&gt;x~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0.75 digit is 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12.0 digit is 12 (C). The result is written as O.OC hexadecimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Binary-Coded Hexadecimal &lt;br /&gt;Binary-coded hexadecimal (BCH) is used to represent hexadecimal data in binary code. A bi-&lt;br /&gt;nary-coded hexadecimal number is a hexadecimal number written so that each digit is repre-&lt;br /&gt;sented by a 4-bit binary number. The values for the BCH digits appear in Table 1-6. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hexadecimal numbers are represented in BCH code by converting each digit to BCH code &lt;br /&gt;with a space between each coded digit. Example 1-14 shows a 2AC converted to BCH code. &lt;br /&gt;Note that eac~ BCH digit is separated by a space. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-14 &lt;br /&gt;2AC = 0010 1010 1100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The purpose of BCH code is to allow a binary version of a hexadecimal number to be &lt;br /&gt;written in a form that can easily be converted between BCH and hexadecimal. Example 1-15 &lt;br /&gt;shows a BCH coded number converted back to hexadecimal code. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-15 &lt;br /&gt;1000 0011 1101 . 1110 83D.E &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;30 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-6 Binary-coded &lt;br /&gt;hexadecimal (BCH) code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Complements &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hexadecimal Digit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;1 &lt;br /&gt;2 &lt;br /&gt;3 &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;6 &lt;br /&gt;7 &lt;br /&gt;8 &lt;br /&gt;9 &lt;br /&gt;A &lt;br /&gt;B &lt;br /&gt;C &lt;br /&gt;D &lt;br /&gt;E &lt;br /&gt;F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BCHCode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0001 &lt;br /&gt;0010 &lt;br /&gt;0011 &lt;br /&gt;0100 &lt;br /&gt;0101 &lt;br /&gt;0110 &lt;br /&gt;0111 &lt;br /&gt;1000 &lt;br /&gt;1001 &lt;br /&gt;1010 &lt;br /&gt;1011 &lt;br /&gt;1100 &lt;br /&gt;1101 &lt;br /&gt;1110 &lt;br /&gt;1111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;At times, data are stored in complement foml to represent negative numbers. There are two sys-&lt;br /&gt;tems that are used to represent negative data: radix and radix -1 complements. The earliest &lt;br /&gt;system was the radix -1 complement, where each digit of the number is subtracted from the &lt;br /&gt;radix to generate the radix -1 complement to represent a negative number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 1-16 shows how the 8-bit binary number 01001100 is one's (radix -I) comple-&lt;br /&gt;mented to represent it as a negative value. Notice that each digit of the number is subtracted from &lt;br /&gt;the radix to generate the radix -1 (one's) complement. In this example, the negative of 0 1 00 11 00 &lt;br /&gt;is 10110011. The same technique can be applied to any number system as illustrated in Example &lt;br /&gt;1-17, where the fifteen's (radix -I) complement of a 5eD hexadecimal is computed by sub-&lt;br /&gt;tracting each digit from a fifteen. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-16 &lt;br /&gt;222 2 2 2 2 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- 0 1 0 0 110 0 &lt;br /&gt;1 0 1 1 0 011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-17 &lt;br /&gt;15 15 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 C D &lt;br /&gt;A 3 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Today, the radix -1 complement is not used by itself, but it is used as a step for finding the &lt;br /&gt;radix complement. The radix complement is the way that negative numbers are represented in &lt;br /&gt;modern computer systems, where the radix -I complement was used in the early days of com-&lt;br /&gt;puter technology. The main problem with the radix -1 complement is that a negative or a posi-&lt;br /&gt;tive zero exits, where in the radix complement system, only a positive zero can exist. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To form the radix complement, first find the radix -1 complement and then add a one to &lt;br /&gt;the result. Example 1-18 shows how the number 0100 1000 is converted to a negative value by &lt;br /&gt;two's (radix) complementing it. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-4 COMPUTER DATA FORMATS 31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-18 &lt;br /&gt;2 2 2 2 2 2 2 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- 0 1 0 0 1 0 0 0 &lt;br /&gt;1 0 1 1 0 1 1 1 (one's com!-,lem&amp;quot;nt) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ 0 0 0 0 0 0 0 1 &lt;br /&gt;1 0 1 1 1 0 0 0 (two's complement) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To prove that a 0 lOO 1000 is the inverse (negative) of a 1011 0 Ill, add the two together to form &lt;br /&gt;an 8-digit result. The ninth digit is dropped and the result is zero because a 0100 1000 is a posi-&lt;br /&gt;tive 72, while a 1011 0111 is a negative 72. The same technique applies to any number system. &lt;br /&gt;Example 1-19 shows how the inverse of a 345 hexadecimal is found by first fifteen's comple-&lt;br /&gt;menting the number and then by adding one to the result to form the sixteen's complement. As &lt;br /&gt;before, if the original 3-digit number 345 is added to the inverse of CBB, the result is a 3-digit &lt;br /&gt;000. As before, the fourth bit (carry) is dropped. This proves that 345 is the inverse of CBB. Ad-&lt;br /&gt;ditional information about one's and two's complements is presented with signed numbers in the &lt;br /&gt;next section of the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-19 &lt;br /&gt;15 15 15 &lt;br /&gt;_3 __ 4_--.2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C B A (fifteen's complement) &lt;br /&gt;+ 0 0 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eBB (sixteen's complement) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COMPUTER DATA FORMATS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Successful programming requires a precise understanding of data formats. In this section, many &lt;br /&gt;common computer data formats are described as used with the Intel family of microprocessors. &lt;br /&gt;Commonly, data appear as ASCII, BCD, signed and unsigned integers, and floating point num-&lt;br /&gt;bers (real numbers). Other forms are available, but are not presented here because they are not &lt;br /&gt;commonly found. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCII Data &lt;br /&gt;ASCII (American Standard Code for Information Interchange) data represent alphanumeric &lt;br /&gt;characters in the memory of a computer system (see Table 1-7). The standard ASCII code is a 7 -bit &lt;br /&gt;code with the eighth and most-significant bit used to hold parity in some systems. If ASCII data are &lt;br /&gt;used with a printer, the most-significant bit is a 0 for alphanumeric printing, and 1 for graphics &lt;br /&gt;printing. In the personal computer, an extended ASCII character set is selected by placing a logic 1 &lt;br /&gt;in the left most bit. Table 1-8 shows the extended ASCII character set using code 80H-FFH. The &lt;br /&gt;extended ASCII characters store some foreign letters and punctuation, Greek characters, mathe-&lt;br /&gt;matical characters, box-drawing characters, and other special characters. Note that extended char-&lt;br /&gt;acters can vary from one printer to another. The list provided is designed to be used with the IBM &lt;br /&gt;ProPrinterl5 and also matches the special character set found with some word processors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ASCII control characters, also listed in Table 1-7, perform control functions in a com-&lt;br /&gt;puter system, including clear screen, backspace, line feed, etc. To enter the control codes through &lt;br /&gt;the computer keyboard, the control key is held down while typing a letter. To obtain the control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15The IBM ProPrinter is a product of IBM Corporation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;32 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-7 ASCII code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;First &lt;br /&gt;OX &lt;br /&gt;1X &lt;br /&gt;2X &lt;br /&gt;3X &lt;br /&gt;4X &lt;br /&gt;5X &lt;br /&gt;6X &lt;br /&gt;7X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Second &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XO X1 X2 X3 X4 X5 X6 X7 X8 X9 XA XI:! XC XO XE XF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NUL SOH STX ETX EOT ENQ ACK BEL BS HT LF VT FF CR SO SI &lt;br /&gt;OLE OC1 OC2 OC3 OC4 NAK SYN ETB CAN EM SUB ESC FS GS RS US &lt;br /&gt;SP &lt;br /&gt;0 1 &lt;br /&gt;@ A &lt;br /&gt;P Q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;# $ % &amp;amp; ( ) + / &lt;br /&gt;2 3 4 5 6 7 8 9 &amp;lt; = &amp;gt; ? &lt;br /&gt;B C 0 E F G H I J K L M N 0 &lt;br /&gt;R S T U V W X Y Z [ \\ 1 1\\ &lt;br /&gt;b c d e f 9 h k I m n 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s u v w x y z { I } &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;code OIH, type a control A; the control code 02H is obtained by typing a control B, etc. Note that the &lt;br /&gt;control codes appear on the screen, from the DOS prompt, as &amp;quot;A for control A, &amp;quot;B for control B, and &lt;br /&gt;so forth. Also note that the carriage return code (CR) is the enter key on most modern keyboards. &lt;br /&gt;The purpose of CR is to returq the cursor or print-head to the left margin. Another code that ap-&lt;br /&gt;pears in many programs is the line feed code (LF), which moves the cursor down one line. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To use Tables 1-7 or 1-8 for converting alphanumeric or control characters into ASCII &lt;br /&gt;characters, firs~ locate the alphanumeric code for conversion. Next, find the first digit of the &lt;br /&gt;hexadecimal ASCII code. Then find the second digit. For example, the capital letter A is ASCII &lt;br /&gt;code 41H, and the lowercase letter a is ASCII code 61H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCII data are most often stored in memory using a special directive to the assembler pro-&lt;br /&gt;gram called define byte(s), or DB. (The assembler is a program that is used to program a com-&lt;br /&gt;puter in its native binary machine language.) The DB directive, along with several examples of &lt;br /&gt;its usage with ASCII-coded character strings, is listed in Example 1-20. Notice how each char-&lt;br /&gt;acter string is surrounded by apostrophes (')-nevpr !lse the quote ('). Also notice that the as-&lt;br /&gt;sembler lists the ASCII-coded value for each character to the left of the character string. To the &lt;br /&gt;far left is the hexadecimal memory location where the character string is first stored in the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-8 Extended ASCII code as printed by the IBM ProPrinter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;First Second &lt;br /&gt;XO Xl X2 X3 X4 XS X6 X72&amp;lt;8 X9 XAXB XC XDXE XF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OX Â©? e â¢ â¢ + ~ â¢ a 0 Il d' !f )t J'J -Â¢-&lt;br /&gt;IX .. ... !! ~ Â§ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;! L- A T &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8X ~ ii e a a a a c; e e e 'i 1 i A A &lt;br /&gt;9X E ce lE 0 0 0 U 11 Y 6 D rt. Â£ Â¥ Pt f &lt;br /&gt;AX a i 6 U fi N a 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;., ~ 1-4 i Â« Â» r-&lt;br /&gt;BX I ~~~~~ ! i t t l 1 ~I ~ 11 ~ .ll :l 1 ex L T J i I~ = JL DX II T If I: F If + r â¢ I 'i â¢ EX IX P r 1t ~ 0 }l y &amp;lt;I&amp;gt; e Q 0 00 P E n &lt;br /&gt;FX Â± ~ :5: r J '&amp;quot; 0 ..[ n 2 â¢ -&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-4 COMPUTER DATA FORMATS 33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory system. For example, the character string WHAT is stored beginning at memory ad-&lt;br /&gt;dress OOID, and the first letter is stored as 57 (W), followed by 68 (H), and so forth. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-20 &lt;br /&gt;0000 42 61 72 72 79 NAMES DB 'Barry B. Brey' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 42 2E 20 42 &lt;br /&gt;72 65 79 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOD 57 68 65 72 65 MESS DB 'Where can it be?' &lt;br /&gt;20 63 61 6E 20 &lt;br /&gt;69 74 20 62 65 &lt;br /&gt;3F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlD 57 68 61 74 20 WHAT DB 'What is on first.' &lt;br /&gt;69 73 20 6F 6E &lt;br /&gt;20 66 69 72 73 &lt;br /&gt;74 2E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BCD (Binary-Coded Decimal) Data &lt;br /&gt;Binary-coded decimal (BCD) information is stored in either packed or unpacked forms. &lt;br /&gt;Packed BCD data are stored as two digits per byte and unpacked BCD data are stored as one &lt;br /&gt;digit per byte. The range of a BCD digit extends from 00002 to 10012, or 0-9 decimal. Un-&lt;br /&gt;packed BCD data are often returned from a keypad or keyboard, while packed BCD data are &lt;br /&gt;used for some of the instructions included for BCD addition and subtraction in the instruction &lt;br /&gt;set of the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 1-9 shows some decimal numbers converted to both the packed and unpacked BCD &lt;br /&gt;forms. Applications that require BCD data are point-of-sales terminals and almost any device &lt;br /&gt;that performs a minimal amount of simple arithmetic. If a system requires complex arithmetic, &lt;br /&gt;BCD data is seldom used because there is no simple and efficient method of performing complex &lt;br /&gt;BCD arithmetic. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 1-21 shows how to use the assembler to define both packed and unpacked BCD &lt;br /&gt;data. In all cases, the convention of storing the least-significant data first is followed. This means &lt;br /&gt;that to store an 83 into memory the 3 is stored first, followed by the 8. Also note that with packed &lt;br /&gt;BCD data the letter H (hexadecimal) follows the number to ensure that the assembler stores the &lt;br /&gt;BCD value rather than a decimal value for packed BCD data. Notice how the numbers are stored &lt;br /&gt;in memory as unpacked, one digit per byte, or packed as 7wo digits per byte. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-21 / &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Unpacked BCD data (least-significant data first) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 03 04 as &lt;br /&gt;0003 07 08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NUMB 1 DB &lt;br /&gt;NUMB 2 DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3,4,5 &lt;br /&gt;7,8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;defines the number 543 &lt;br /&gt;;defines the number 87 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Packed BCD data (least-significant data first) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0005 37 34 &lt;br /&gt;0007 03 45 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NUMB 3 DB &lt;br /&gt;NUMB 4 DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34H,37H &lt;br /&gt;3,45H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;defines the number 3437 &lt;br /&gt;;defines the number 4503 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 1-9 Packed and unpacked BCD data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 &lt;br /&gt;623 &lt;br /&gt;910 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Packed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 0010 &lt;br /&gt;0000 0110 0010 0011 &lt;br /&gt;0000 1001 0001 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unpacked &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0001 0000 001 a &lt;br /&gt;0000 0110 0000 0010 0000 0011 &lt;br /&gt;0000 1001 0000 0001 0000 0000 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;34 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unsigned byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Signed byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-10 The unsigned and signed bytes illustrating the weights of each binary-bit &lt;br /&gt;position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte-Sized Data &lt;br /&gt;Byte-sized data are stored as unsigned and signed integers. Figure 1-10 illustrates both the un-&lt;br /&gt;signed and signed forms of the byte-sized integer. The difference in these forms is the weight of &lt;br /&gt;the leftmost bit position. Its value is 128 for the unsigned integer and minus 128 for the signed &lt;br /&gt;integer. In the signed integer format, the leftmost bit represents the sign bit of the number as well &lt;br /&gt;as a weight of minus 128. For example, an 80H represents a value of 128 as an unsigned number; &lt;br /&gt;as a signed number, it represents a value of minus 128. Unsigned integers range in value from &lt;br /&gt;OOH-FFH (0-255). Signed integers range in value from -128 to 0 to +127. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Although negative signed numbers are represented in this way, they are stored in the two's &lt;br /&gt;complement form. The method of evaluating a signed number, using the weights of each bit po-&lt;br /&gt;sition, is much easier than the act of two's complementing a number to find its value. This is es-&lt;br /&gt;pecially true in the world of calculators designed for programmers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever a number is two's complemented, its sign changes from negative to positive or &lt;br /&gt;positive to negative. For example, the number 00001000 is a +8. Its negative value (-8) is found by &lt;br /&gt;two's complementing the +8. To form a two's complement, first one's complement the number. To &lt;br /&gt;one's complement a number, invert each bit of a number from zero to one or from one to zero. &lt;br /&gt;Once the one's complement is formed, the two's complement is found by adding a one to the one's &lt;br /&gt;complement. Example 1-22 shows how numbers are two's complemented using this technique. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-22 &lt;br /&gt;+8 00001000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11110111 (one's complement) &lt;br /&gt;+ 1 &lt;br /&gt;-8 11111000 (two's complement) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another, and probably simpler, technique for two's complementing a number starts with the &lt;br /&gt;rightmost digit. Start writing down the number from right to left. Write the number exactly as it ap-&lt;br /&gt;pears until the first one. Write down the first one, and then invert of complement all remaining ones &lt;br /&gt;to its left. Example 1-23 shows this t ,,-;hnique with the same number as in Example 1-22. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-23 &lt;br /&gt;+8 = 00001000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1000 (write number to first 1) &lt;br /&gt;1111 (invert the remaining bits) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-8 11111000 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-4 COMPUTER DATA FORMATS 35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To store 8-bit data in memory using the assembler program, use the DB directive as in &lt;br /&gt;prior examples. Example 1-24 lists many forms of 8-bit numbers stored in memory using the as-&lt;br /&gt;sembler program. Notice in this example that a hexadecimal number is defined with the letter H &lt;br /&gt;following the number and that a decimal number is written as is without anything special. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0001 &lt;br /&gt;0002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003 &lt;br /&gt;0004 &lt;br /&gt;0005 &lt;br /&gt;0006 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FE &lt;br /&gt;87 &lt;br /&gt;47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9C &lt;br /&gt;64 &lt;br /&gt;FF &lt;br /&gt;38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;unsigned byte-sized data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATAl &lt;br /&gt;DATA2 &lt;br /&gt;DATA 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;254 &lt;br /&gt;87H &lt;br /&gt;71 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Signed byte-sized data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA4 &lt;br /&gt;DATA5 &lt;br /&gt;DATA 6 &lt;br /&gt;DATA7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-100 &lt;br /&gt;+100 &lt;br /&gt;-1 &lt;br /&gt;56 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define 254 decimal &lt;br /&gt;;define 87 hexadecimal &lt;br /&gt;;define 71 decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define a -100 decimal &lt;br /&gt;;define a +100 decimal &lt;br /&gt;;define a -1 decimal &lt;br /&gt;;define a 56 decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Word-sized Data &lt;br /&gt;A word (16-bits) is formed with two bytes of data. The least-significant byte is always stored in the &lt;br /&gt;lowest-numbered memory location, and the most-significant byte in the highest. This method of &lt;br /&gt;stori~g a n~mber is called the little endian format. An alternate method, not used with the Intel family &lt;br /&gt;of microprocessors, is called the big endian format. With the big endian format, numbers are stored &lt;br /&gt;with the lowest location containing the most-significant data. The big endian format is used with the &lt;br /&gt;Motorola family of microprocessors. Figure 1-11 (a) shows the weights of each bit position in a word &lt;br /&gt;of data, and Figure 1-11 (b) shows how the number 1234H appears when stored in the memory loca-&lt;br /&gt;tion 3000H and 300IH. The only difference between a signed and an unsigned word is the leftmost bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;lt;0 &lt;br /&gt;C&amp;gt; &lt;br /&gt;o &lt;br /&gt;..,f &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;co &lt;br /&gt;v &lt;br /&gt;o &lt;br /&gt;C\\i &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3003H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3002H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3001H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2FFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;lt;0 &lt;br /&gt;L{) &lt;br /&gt;(\\j &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;co (\\j &amp;lt;0 co &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I I, I I I &lt;br /&gt;(a) Unsigned word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12H - High-order byte &lt;br /&gt;~--------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34H - Low-order byte &lt;br /&gt;~--------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) The contents of memory location 3000H and 3001 H are the word 1234H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- Binary weights &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-11 The storage format for a 16-bit word in (a) a register and (b) two bytes of memory &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;36 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;position. In the unsigned form, the leftmost bit is unsigned; in the signed form, its weight is a -32,768. &lt;br /&gt;As with byte-sized signed data, the signed word is in two's complement form when representing a &lt;br /&gt;negative number. Also notice that the low order byte is stored in the lowest-numbered memory loca-&lt;br /&gt;tion (3000H) and the high-order byte is stored in the highest-numbered location (3001H). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 1-25 shows several signed and unsigned word-sized data stored in memory using &lt;br /&gt;the assembler program. Notice that the define word(s) directive or OW causes the assembler to &lt;br /&gt;store words in the memory instead of bytes as in prior examples. Also notice that the word data &lt;br /&gt;is displayed by the assembler in the same form as entered. For example, a 1000H is displayed by &lt;br /&gt;the assembler as a 1000. This is for our convenience, because the number is actually stored in the &lt;br /&gt;memory as a 00 10 in two consecutive memory bytes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 09FO &lt;br /&gt;0002 87AC &lt;br /&gt;0004 02C6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0006 CBA8 &lt;br /&gt;0008 00C6 &lt;br /&gt;OOOA FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Unsigned word-sized data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATAl DW &lt;br /&gt;DATA2 D'.-.J &lt;br /&gt;DATA3 DW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2544 &lt;br /&gt;87ACH &lt;br /&gt;710 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Signed word-sized data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA4 DW -13400 &lt;br /&gt;DATA5 DW +198 &lt;br /&gt;DATA6 DW -1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define 2544 decimal &lt;br /&gt;;define 87AC hexadecimal &lt;br /&gt;;define 710 decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define a -13400 decimal &lt;br /&gt;;define a +198 decimal &lt;br /&gt;;define a -1 decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Doubleword-sized Data &lt;br /&gt;Doubleword-sized data requires four bytes of memory because it is a 32-bit number. Double-&lt;br /&gt;word data appear as a product after a multiplication and also as a dividend before a division. In the &lt;br /&gt;80386 through the Pentium, memory and registers are also 32-bits in width. Figure 1-12 shows &lt;br /&gt;the form used to store doublewords in the memory and the binary weights of each bit position. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When a double word is stored in memory, its least-significant byte is stored in the lowest-&lt;br /&gt;numbered memory location and its most-significant byte is stored in the highest-numbered &lt;br /&gt;memory location using the little endian format. Recall that this is also true for word-sized data. &lt;br /&gt;For example, a 12345678H that is stored in memory location 00IOOH-00103H is stored with the &lt;br /&gt;78H in memory location 00100H, the 56H in location OOlOlH, the 34H in location OO102H, and &lt;br /&gt;the 12H in location OOl03H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To define doubleword-sized data, use the assembler directive define doubleword(s) or DO. &lt;br /&gt;Example 1-26 shows both signed and unsigned numbers stored in memory using the DO directive. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0003E1CO &lt;br /&gt;0004 87AC1234 &lt;br /&gt;0008 00000046 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC FFEB8058 &lt;br /&gt;0010 000000C6 &lt;br /&gt;0014 FFFFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Unsigned doubleword-sized data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATAl DD &lt;br /&gt;DATA2 DD &lt;br /&gt;DATA3 DD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;254400 ;define 254400 4ecimal &lt;br /&gt;87AC1234H ;define 87AC1234 hexadecimal &lt;br /&gt;70 ;define 70 decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Signed doubleword-sized data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA4 DD &lt;br /&gt;DATA5 DD &lt;br /&gt;DATA6 DD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-1343400 &lt;br /&gt;+198 &lt;br /&gt;-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define a -1343400 decimal &lt;br /&gt;;define a +198 decimal &lt;br /&gt;,1efine a -1 rlecimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Integers may also be stored in memory that is of any width. The [onns listed here are standard &lt;br /&gt;forms, but that doesn't mean that a 128-byte wide integer can't be stored in the memory. The micro-&lt;br /&gt;processor is flexible enough to allow any size data. When nonstandard width numbers are stored in &lt;br /&gt;memory, the DB directive is nomla1ly used to store them. For example, the 24-bit number l23456H &lt;br /&gt;is stored using a DB 56H,34H, 12H directive. Note that this conforms to the little endian format. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;co ,.. ,.. &lt;br /&gt;'&amp;quot; '&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(0 (0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;c;; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; 05 :0: &amp;lt;0-C'l 0 .n ,.. &lt;br /&gt;&amp;quot;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;- C'l r-: ,,; co ,.. ,.. &lt;br /&gt;&amp;quot;- u:i 05 q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;(0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;oJ &lt;br /&gt;'&amp;quot; '&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;co &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &amp;quot;-r-: &lt;br /&gt;N &lt;br /&gt;.; &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-4 COMPUTER DATA FORMATS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,.. &lt;br /&gt;'&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;co &lt;br /&gt;(0 C'l N co ,.. '&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(0 &lt;br /&gt;co ,.. 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;&amp;quot;- co ,.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; 05 .; r-: (0 C'l '&amp;quot; co &lt;br /&gt;,.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;-&lt;br /&gt;(0 co ,.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;'&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;- 05 .; r-: 05 &lt;br /&gt;'&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;q &lt;br /&gt;'&amp;quot; (0 co C\\I (0 co v &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;&amp;quot;- co 0&amp;gt; 0&amp;gt; ,.. .; oJ M '&amp;quot; &amp;quot;- '&amp;quot; O'l 0&amp;gt; 'V C\\I '&amp;quot; (0 co r-: ,,; u:i C'l 0 0_ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;(0 LriNcD T'&amp;quot;&amp;quot; 000 ~ '&amp;quot; '&amp;quot; ,.. '&amp;quot; (0 (0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;05 .; oJ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;N (0 '&amp;quot; ~ Â«S V- C\\i y--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; '&amp;quot; &lt;br /&gt;~ (0 '&amp;quot; ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I I I I I I I I I I I I I I I I I I &lt;br /&gt;(a) Unsigned doubleword &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00103H &lt;br /&gt;00102H &lt;br /&gt;00101H &lt;br /&gt;00100H &lt;br /&gt;OOOFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l2H &lt;br /&gt;34H &lt;br /&gt;56H &lt;br /&gt;78H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- High-order byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--- Low-order byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) The contents of memory location 00100H -O0103H are the doubleword l2345678H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;co ,.. '&amp;quot; ~ --Binary weights &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-12 The storage format for a 32-bit word in (a) a register and (b) in four bytes of memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Real Numbers &lt;br /&gt;Because many high-level languages use the Intel family of microprocessors, real numbers are often &lt;br /&gt;encountered. A real number, or as it is often called, a floating-point number, contains two parts: a &lt;br /&gt;manti~~, significand, or fracJ.iQn and an exponent. Figure 1-13 depicts both the 4- and 8-byte &lt;br /&gt;fu~ of real numbers as they are stored iii any Intel system. Note that the 4-byte real number is &lt;br /&gt;called single-precision and the lHJyte form is called double-precision. The form presented here is &lt;br /&gt;the same form specified by the IEEE16 standard, IEEE-754, version 10.0. This standard has been &lt;br /&gt;adopted as the standard form of real numbers with virtually all high-level programming languages &lt;br /&gt;and many applicatioris packages. The standard also applies to cJata manipulated by Jhe numeric co-&lt;br /&gt;processor in the perso~l computer. Figure 1-13 (a) shows the single-precision form that contains &lt;br /&gt;a sign-bit, an 8-Qit exponent, and l!2.4-bit fraction (mantissa). Note that because applications often &lt;br /&gt;require doubie~preciSl.onfloating-point numbers [see Figure 1-13 (b)], the Pentium with its 64-bit &lt;br /&gt;data bus performs memory transfers at twice the speed of the 80386/80486 microprocessor;;:'&amp;quot; &lt;br /&gt;~&amp;gt;-&amp;quot; â¢â¢ ........--- -- â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Simple arithmetic indicates that it should take 33 bits to store all three pieces of data. Not &lt;br /&gt;true-the 24-bit mantissa contains an implied (hidden) one-bit that allows the mantissa to repre-&lt;br /&gt;sent 24-bits while being stored in only 23-bits. The hidde'D' bit is the first bit of the normalized &lt;br /&gt;real n-ilmber. When normalizing a number, it is adjusted so that its value is at least 1, but less than &lt;br /&gt;2_ For example, if a ~ 2 is converted to binary (11002), it is normalized and the result is a 1.1 x 23. &lt;br /&gt;The !is not stored in the 23-bit mantissa portion of the number. The 1 is the hidden one-bit. &lt;br /&gt;Table 1-10 shows the single-precision form of this number and others. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The exponent is stored as a .~t~sedexponent. With the single-precision form of the real &lt;br /&gt;number, the bias is 127 (7FH); with the double-precision form, it i~JP2.3 (3FFH). The bias adds &lt;br /&gt;to the exponent before is stored into the exponent portion of the floating-point number. In the &lt;br /&gt;previous example, there is an exponent ()f23, represented as a biased exponent of 127 + 3 or 130 &lt;br /&gt;(82H) in the single-precision form or as 1026 (402H) in the double-precision form. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are two exceptions to the rules for floating-point numbers. The number 0.0 is stored &lt;br /&gt;as all zeros. The number infinity is stored as all ones in the exponent and all zeros in the mantissa. &lt;br /&gt;The sign-bit indicates a Â± 0.0 or a Â± 00. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IOIEEE is the Institute of Electrical and Electronic5Engineers. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;38 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;\\ â¢ I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 30 23 22 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exponent Significand &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ (a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;63 62 52 51 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exponent Significand &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ (b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1-13 The floating-point numbers (a) single-precision using a bias of 7FH, and &lt;br /&gt;(b) double-precision using a bias of 3FFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with other data types, the assembler can be used to define real numbers in both single-&lt;br /&gt;and double-precision forms. Because single-precision numbers are 32-bit numbers, use the DD &lt;br /&gt;directive or use the define quadwords(s) or DQ directive to define 64-bit double-precision real &lt;br /&gt;numbers. Optional directives for real numbers are REAL4, REAL8, and REALlO for defining &lt;br /&gt;single-, double-, and extended precision real numbers. Example 1-27 shows numbers defined in &lt;br /&gt;real number format. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-27 &lt;br /&gt;;Single-precision real numbers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 3F9DF3B6 NUMB 1 DD 1. 234 ; define 1. 234 &lt;br /&gt;0004 ClBB3333 NUMB 2 DD -23.4 ; define -23.4 &lt;br /&gt;0008 43D20000 NGl'lB3 RE.:;L4 4.2E2 ;define 420 &lt;br /&gt;OOOC 3F9DF3B6 NG11B4 RE.:;L4 1. 234 ;define a 4-byte real number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Double-precision real numbers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 NUNE5 DQ 123.4 ; define 123.4 &lt;br /&gt;405ED9999999999A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0018 NUMB 6 REAL8 -23.4 ;define -23.4 &lt;br /&gt;ClBB333333333333 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0028 NUMB 7 REAL8 123.4 ;define an 8-byte real number &lt;br /&gt;405ED9999999999A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Extended-precision real numbers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0030 lJUNB8 REALIO 123.4 ;define a 10-byte real number &lt;br /&gt;4005F6CCCCCCCCCCCCCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Decimal Binary Normalized Sign Biased Exponent Mantissa &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+12 1100 1.1 x 23 0 10000010 1000000 00000000 00000000 &lt;br /&gt;-12 1100 -1.1 x 23 1 10000010 1 ('~OOOO 00000000 00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+100 1100100 1.1001 x 26 0 10000101 1001000 00000000 00000000 &lt;br /&gt;-1.75 1.11 -1.11 x 2Â° 1 01111111 11 00000 00000000 00000000 &lt;br /&gt;+0.25 .01 1.0 x 2-2 0 01111101 0000000 00000000 00000000 &lt;br /&gt;+0.0 0 0 0 00000000 0000000 00000000 00000000 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-5 SUMMARY 39 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. The mechanical computcr age began with the advent of the abacus in 500 B.c. This first me-&lt;br /&gt;chanical calculator remained unchanged until 1642 when Blaise Pascal improved it. An &lt;br /&gt;early first mechanical computer system was the Analytical Engine developed by Charles &lt;br /&gt;Babbage in 1823. Unfortunately, this machine never functioned because of the inability to &lt;br /&gt;create the necessary machine parts. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The first electronic calculating machine was developed during World War II by Konrad &lt;br /&gt;Zuse, an early pioneer of digital electronics. His computer, the Z3, was used in aircraft and &lt;br /&gt;missile design for the German war effort. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The first electronic computer, which used vacuum tubes, was placed into operation in 1943 &lt;br /&gt;to break secret German military codes. This first electronic computer system, the Colossus, &lt;br /&gt;was invented by Alan Turing. Its only problem was that the program was fixed and could not &lt;br /&gt;be changed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. The first general-purpose programmable electronic computer system was developed in 1946 &lt;br /&gt;at the University of Pennsylvania. This first modern computer was called the ENIAC (Elec-&lt;br /&gt;tronics Numerical Integrator and Calculator). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The first high-level programming language called FLOW-MATIC was developed for the &lt;br /&gt;UNIVAC I computer by Grace Hopper in the early 1950s. This led to FORTRAN and other &lt;br /&gt;early programming languages. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. The world's first microprocessor, the Intel 4004, was a 4-bit microprocessor-a program-&lt;br /&gt;mable controller on a chip-that was meager by today's standards. It addressed a mere &lt;br /&gt;4,096 4-bit memory locations. Its instruction set contained only 45 different instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Microprocessors that are common today include the 8086/8088, which were the first 16-bit &lt;br /&gt;microprocessors. Following these early 16-bit machines were the 80286, 80386, 80486, &lt;br /&gt;Pentium, and Pentium Pro processors. With each newer version, improvements followed &lt;br /&gt;that increased the processor's speed and performance. From all indications, this process of &lt;br /&gt;speed and performance improvement will continue. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Microprocessor-based personal computers contain memory systems that include three main &lt;br /&gt;areas: TPA (transient program area), system area, and extended memory. The TPA holds ap-&lt;br /&gt;plication programs, the operating system, and drivers. The system area contains memory &lt;br /&gt;used for video display cards, disk drives, and the BIOS ROM. The extended memory area is &lt;br /&gt;available only to the 80286 through t~e Pentium microprocessor in an AT -style personal &lt;br /&gt;computer system. \\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The 8086/8088 address 1M byte of memory from location OOOOOH-FFFFFH. The 80286 and &lt;br /&gt;80386SX address 16M bytes of memory from location OOOOOOH FFFFFFH: The 80386SL &lt;br /&gt;addresses 32M bytes of memory from location OOOOOOOH-IFFFFFFH. The 80386DX, &lt;br /&gt;80486, Pentium, and Pentium Pro processors address 4G bytes of memory from location &lt;br /&gt;OOOOOOOOH FFFFFFFFH.ln addition, the Pentium Pro can run with a 36-bit address and ac-&lt;br /&gt;cess up to 64G bytes of memory from location OOOOOOOOOH through FFFFFFFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. All versions of the 8086-80486 and Pentium microprocessor address 64K bytes of 110 ad-&lt;br /&gt;dress space. These 110 ports are numbered from OOOOH-FFFFH with 110 ports OOOOH-&lt;br /&gt;04FFH reserved for use by the personal computer system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II. The operating system in many personal computers is either MSDOS (Microsoft disk operating &lt;br /&gt;system) or PCDOS (personal computer disk operating system from IBM). The operating system &lt;br /&gt;performs the task of operating or controlling the computer system along with its 110 devices. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The microprocessor is the controlling element in a computer system. The microprocessor &lt;br /&gt;performs data transfers, simple arithmetic and logic operations, and makes simple decisions. &lt;br /&gt;The microprocessor executes programs stored in the memory system to perform complex &lt;br /&gt;operations in short periods of time. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;40 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. All computer systems contain three buses to control memory and I/O. The address bus is &lt;br /&gt;used to request a memory location or I/O device. The data bus transfers data between the mi-&lt;br /&gt;croprocessor and its memory and I/O spaces. The control bus controls the memory and I/O &lt;br /&gt;and requests reading or writing of data. Control is accomplished with 10RC (I/O read con-&lt;br /&gt;trol), 10WC (lIO write control), MRDC (memory read control), and MWTC (memory write &lt;br /&gt;control). &amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Numbers are converted from any number base to decimal by noting the weights of each po-&lt;br /&gt;sition. The weight of the position to the left of the radix point is always the units position in &lt;br /&gt;any number system. The position to the left of the units position is always the radix times &lt;br /&gt;one. Succeeding positions are detennined by multiplying by the radix. The weight of the po-&lt;br /&gt;sition to the right of the radix point is always detennined by dividing by the radix. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. Conversion from a whole decimal number to any other base is accomplished by dividing by &lt;br /&gt;the radix. Conversion from a fractional decimal number is accomplished by multiplying by &lt;br /&gt;the radix. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. Hexadecimal data are represented in hexadecimal fonn or at times in a code called binary-&lt;br /&gt;coded hexadecimal (BCH). A binary-coded hexadecimal number is one that is written with &lt;br /&gt;a 4-bit binary number that represents each hexadecimal digit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. The ASCII code is used to store alphabetic or numeric data. The ASCII code is a 7 -bit code &lt;br /&gt;and can have an eighth bit used to extend the character set from 128 codes to 256 codes. The &lt;br /&gt;carriage return (enter) code returns the print head or cursor to the left margin. The line feed &lt;br /&gt;code moves the cursor or print head down a line. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. Binary-coded decimal (BCD) data are sometimes used in a computer system to store dec-&lt;br /&gt;imal data. This data is stored in either packed (two digits per byte) or unpacked (one digit &lt;br /&gt;per byte) fonn. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. Binary data are stored as a byte (8-bits), word (16-bits), or doubleword (32-bits) in a com-&lt;br /&gt;puter system. This data may be unsigned or signed. Signed negative data are always stored &lt;br /&gt;in the two's complement fonn. Data that are wider than 8-bits are always stored using the &lt;br /&gt;little end ian fonnat. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. Floating-point data are used in computer system to store whole, mixed, and fractional num-&lt;br /&gt;bers. A floating-point number is composed of a sign, a mantissa, and an exponent. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21. We use the assembler directive DB to define bytes, DW to define words, DD to define dou-&lt;br /&gt;blewords, and DQ to define quadwords. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22. Example 1-28 shows the assembly language fonnats for storing numbers as bytes, words, &lt;br /&gt;doublewords, and real numbers. Also shown are ASCII-coded character strings. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1-28 &lt;br /&gt;;ASCII data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 54 68 69 73 20 69 MES1 DB 'This is a character string in ASCII' &lt;br /&gt;73 20 61 20 63 68 &lt;br /&gt;61 72 61 63 74 65 &lt;br /&gt;72 20 73 74 72 69 &lt;br /&gt;6E 67 20 69 6E 20 &lt;br /&gt;41 53 43 49 49 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0023 53 6F 20 69 73 20 MES2 DB 'So is this' &lt;br /&gt;74 68 69 73 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; BYTE data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002D 17 DATAl DB 23 ;23 decimal &lt;br /&gt;002E DE DATA2 DB -34 ;-34 decimal &lt;br /&gt;002F 34 DATA3 DB 34H ;34 hexadecimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; WORD data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0030 1000 DATA4 DW 1000H ;1000 hexadecimal &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1-6 QUESTIONS AND PROBLEMS 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0032 FF9C W\\TA5 DW -100 ;-100 decimal &lt;br /&gt;0034 OOOC DATA6 DW +12 ;=12 decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; DOUBLEWORD data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0(;36 00001000 DATA7 DD 1000H ;1000 hexadecimal &lt;br /&gt;003.; FFFFFED4 DATA8 DD -300 ;-300 decimal &lt;br /&gt;003E 00012345 DATA9 DD 12345H ;12345 hexadecimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Real data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0042 4015C28F DATAl 0 REAL4 2.34 ;2.34 decimal &lt;br /&gt;0046 COOCCCCD DATAll REAL4 -2.2 ;-2.2 decimal &lt;br /&gt;004A DATA12 REAL8 100.3 ;100.3 decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4059133333333333 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-6 QUESTIONS AND PROBLEMS &lt;br /&gt;1. Who developed the Analytical Engine? &lt;br /&gt;2. The 1890 census used a new device called a punched card. Who developed the punched &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;card? &lt;br /&gt;3. Who was the founder of the IBM Corporation? &lt;br /&gt;4. Who developed the first electronic calculator? &lt;br /&gt;5. The first truly electronic computer system was developed for what purpose? &lt;br /&gt;6. The first general-purpose programmable computer was called the ______ _ &lt;br /&gt;7. The world's first microprocessor was developed in 1971 by _____ _ &lt;br /&gt;8. Who was the Countess of Lovelace? &lt;br /&gt;9. Who developed the first high-level programming language called FLOW-MATIC? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. What is a vo'}&amp;lt;N~ann machine? &lt;br /&gt;11. Which 8-bit microprocessor ushered in the age of the microprocessor? &lt;br /&gt;12. The 8085 microprocessor, introduced in 1977, has sold copies. &lt;br /&gt;13. Which Intel microprocessor was the first to address 1M bytes of memory? &lt;br /&gt;14. The 80386SL addresses bytes of memory. &lt;br /&gt;15. How much memory is available to the 80486 microprocessor? &lt;br /&gt;16. When did Intel introduce the Pentium microprocessor? &lt;br /&gt;17. When did Intel introduce the Pentium Pro processor? &lt;br /&gt;18. Which Intel microprocessor can address 64G of memory? &lt;br /&gt;19. What is the acronym MIPs? &lt;br /&gt;20. What is the acronym CISC? &lt;br /&gt;21. A binary bit stores a or a ______ _ &lt;br /&gt;22. A computer K is equal to bytes. &lt;br /&gt;23. A computer M is equal to K bytes. &lt;br /&gt;24. A computer G is equal to M bytes. &lt;br /&gt;25. How many typewritten pages of information are stored in a 4G byte memory system? &lt;br /&gt;26. The first 1M byte of memory in a computer system contains a and a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_______ area. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27. How much memory is found in the transient program area? &lt;br /&gt;28. How much memory is found in the systems area'? &lt;br /&gt;29. The 8086 microprocessor addresses bytes of memory. &lt;br /&gt;30. The 80286 microprocessor addresses bytes of memory. &lt;br /&gt;31. Which microprocessors address 4G bytes of memory? &lt;br /&gt;32. Memory above the first 1M byte is called memory. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;42 CHAPTER 1 INTRODUCTION TO THE MICROPROCESSOR AND COMPUTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33. What is the BIOS? &lt;br /&gt;34. What is DOS? &lt;br /&gt;35. What is the difference between an XT and an AT computer system? &lt;br /&gt;36. What is the VESA local bus? &lt;br /&gt;37. The ISA bus holds -bit interface cards. &lt;br /&gt;38. What is the XMS? &lt;br /&gt;39. What is the EMS? &lt;br /&gt;40. A driver is stored in the area. &lt;br /&gt;41. What is a TSR? &lt;br /&gt;42. How is a TSR often accessed? &lt;br /&gt;43. What is the purpose of the CONFIG.SYS file? &lt;br /&gt;44. What is the purpose of the AUTOEXEC.BA T file? &lt;br /&gt;45. The COMMAND.COM program processes what information? &lt;br /&gt;46. The personal computer system addresses bytes of I/O space. &lt;br /&gt;47. Where is the high memory located in a personal computer? &lt;br /&gt;48. The DEVICE or DEVICEHIGH statement is found in what file? &lt;br /&gt;49. Where are the upper memory blocks used by MSDOS version 5.0 or 6.2? &lt;br /&gt;50. Where is the video BIOS? &lt;br /&gt;51. Draw the block diagram of a computer system. &lt;br /&gt;52. What is the purpose of the microprocessor in a microprocessor-based computer system? &lt;br /&gt;53. List the three buses found in all computer systems. &lt;br /&gt;54. Which bus transfers the memory address to the I/O device or to the memory device? &lt;br /&gt;55. Which control signal causes the memory to perform a read operation? &lt;br /&gt;56. What is the purpose of the 10RC signal? &lt;br /&gt;57. If the MRDC signal is a logic 0, which operation is performed by the microprocessor? &lt;br /&gt;58. Convert the following binary numbers into decimal: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) 1101.01 &lt;br /&gt;(b) 111001.0011 &lt;br /&gt;(c) 10101l.0101 &lt;br /&gt;(d) 111.0001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;59. Convert the following octal numbers into decimal: &lt;br /&gt;(a) 234.5 &lt;br /&gt;(b) 12.3 &lt;br /&gt;(c) 7767.07 &lt;br /&gt;(d) 123.45 &lt;br /&gt;(e) 72.72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;60. Convert the following hexadecimal numbers into decimal: &lt;br /&gt;(a) A3.3 &lt;br /&gt;(b) 129.C &lt;br /&gt;(c) AC.DC &lt;br /&gt;(d) FAB.3 &lt;br /&gt;(e) BB8.0D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;61. Convert the following decimal integers into binary, octal, and hexadecimal: &lt;br /&gt;(a) 23 &lt;br /&gt;(b) 107 &lt;br /&gt;(c) 1238 &lt;br /&gt;(d) 92 &lt;br /&gt;(e) 173 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62. Convert the following decimal numbers into binary, octal, and hexadecimal: &lt;br /&gt;(a) 625 &lt;br /&gt;(b) .00390625 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 2 '. &lt;br /&gt;The Microprocessor and Its Architecture &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This chapter presents the microprocessor as a programmable device by first looking at its internal &lt;br /&gt;programming model and then at how it addresses its memory space. The architecture of the entire &lt;br /&gt;family ofIntel microprocessors is presented simultaneously, as are the ways that the family mem-&lt;br /&gt;bers address the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The addressing modes for this powerful family of microprocessors are described for both the &lt;br /&gt;real and protected modes of operation. Real mode memory exists at locations OOOOOH-FFFFFH-&lt;br /&gt;the first 1M byte of the memory system-and is present on all versions of the microprocessor. Pro-&lt;br /&gt;tected mode memory exists at any location in the entire memory system, but is only available to the &lt;br /&gt;80286-Pentium Pro and not the earlier 8086 or 8088 microprocessors. Protected mode memory for &lt;br /&gt;the 80286 contains 16M bytes; for the 80386-Pentium, 40 bytes; and for the Pentium Pro, 640 bytes . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;............... -----~ &lt;br /&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Describe the function and purpose of each program-visible register in the 8086-80486 and &lt;br /&gt;Pentium /Pentium Pro microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Detail the flag register and the purp,ose of each flag bit. &lt;br /&gt;3. Describe how memory is accessed using real mode memory-addressing techniques. &lt;br /&gt;4. Describe how memory is accessed using protected mode memory-addressing techniques. &lt;br /&gt;5. Describe the program-invisible registers found within the 80286, 80386, 80486, Pentium, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and Pentium Pro microprocessors. &lt;br /&gt;6. Detail the operation of the memory paging mechanism. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTERNAL MICROPROCESSOR ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before a program is written or any instruction investigated, the internal configuration of the mi-&lt;br /&gt;croprocessor must be known. This section of the chapter details the program-visible internal ar-&lt;br /&gt;chitecture of the 8086-80486 and the PentiumlPentium Pro microprocessors. Also detailed are &lt;br /&gt;the function and purpose of each of these internal registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;45 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;46 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Programming Model &lt;br /&gt;The programming model of the 8086 through the Pentium Pro is considered program visible be-&lt;br /&gt;cause its registers are used during programming and are specified by the instructions. Other reg-&lt;br /&gt;isters, detailed later in this chapter, are considered program invisible because they are not &lt;br /&gt;addressable directly during applications programming, but may be used indirectly during system &lt;br /&gt;programming. Only the 80286 and above contain the program-invisible registers used to control &lt;br /&gt;and operate the protected memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 2-1 illustrates the programming model of the 8086 through the Pentium Pro micro-&lt;br /&gt;processor. The earlier 8086, 8088, and 80286 microprocessors contain 16-bit internal architectures, &lt;br /&gt;a subset of the registers shown in Figure 2-1. The 80386, 80486, Pentium, and Pentium Pro micro-&lt;br /&gt;processors contain full 32-bit internal architectures. The architectures of the earlier 8086 through the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-1 The program-&lt;br /&gt;ming model of the Intel 8086 &lt;br /&gt;through the Pentium Pro 32Â·bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;names &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;::- namies &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f ~:,:~~ &lt;br /&gt;EAX AH ~x OJ' AL Accumulator &lt;br /&gt;EBX BH ~x &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BL Base index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECX CH dx }' CL Count &lt;br /&gt;EDX DH dx T DL Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP SP Stack pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBP BP Base pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDI DI Destination index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESI SI Source index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EIP ~ _______ + ____ IP ___ -; Instruction pointer &lt;br /&gt;EFLAGS L. _______ -'-___ F_L_A_G_S __ --I Flags &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: &lt;br /&gt;1 Â° The shaded areas registers exist ony on the &lt;br /&gt;80386 through the Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The FS and GS register have no special &lt;br /&gt;names. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Extra &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-1 INTERNAL MICROPROCESSOR ARCHITECTURE 47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 are fully upward compatible to the 80386 through the Pentium Pro. The shaded areas in this &lt;br /&gt;illustration represent registers that are not found in the 8086, 8088, or 80286 microprocessors and &lt;br /&gt;are enhance'tnents provided on the 80386, 80486. Pentium, and Pentium Pro microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The pr~gramming model contains 8-, 16-. and 32-bit registers. The 8-bit registers are AH, &lt;br /&gt;AL, BH, BL, CH. CL, DH, and DL and are referred to when an instruction is formed using these &lt;br /&gt;two-letter designations. For example, an ADD AL,AH instruction adds the 8-bit contents of AH &lt;br /&gt;to AL. (Only AL changes due to this instruction.) The 16-bit registers are AX, BX, CX, DX, SP, &lt;br /&gt;BP, DI, SI, IP, FLAGS, CS, DS, ES, SS, FS, and GS. These registers are also referenced with &lt;br /&gt;these two-letter designations. For example, an ADD DX,CX instruction adds the 16-bit contents &lt;br /&gt;of CX to DX. (Only DX changes due to this instruction.) The extended 32-bit registers are la-&lt;br /&gt;beled EAX, EBX, ECX, EDX, ESP, EBP, EDI, ESI, EIP, and EFLAGS. These 32-bit extended &lt;br /&gt;registers and 16-bit registers FS and GS are available only in the 80386 and above. These regis-&lt;br /&gt;ters are referenced by the designations FS or GS for the two new 16-bit registers and by a three-&lt;br /&gt;letter designation for the 32-bit registers. For example, an ADD ECX,EBX instruction adds the &lt;br /&gt;32-bit contents of EBX to ECX. (Only ECX changes due to this instruction.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Some registers are general-purpose or multipurpose registers, while some have special &lt;br /&gt;purposes. The multipurpose registers include EAX, EBX, ECX, EDX, EBP, EDI, and ESJ. &lt;br /&gt;These registers hold various data sizes (bytes, words, or doublewords) and are used for almost &lt;br /&gt;any purpose as dictated by a program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Multipurpose Registers. The multipurpose registers include EAX, EBX, ECX, EDX. El)B'; &lt;br /&gt;EDI, and ESI. 13 r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;(accumulator) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX &lt;br /&gt;(base index) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECX &lt;br /&gt;(count) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDX &lt;br /&gt;(data) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBP &lt;br /&gt;(base pointer) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ED! &lt;br /&gt;(destination index) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX is referenced as a 32-bit register (EAX), as a 16-bit register &lt;br /&gt;(AX), or as either of two 8-bit registers AH and AL. Note that &lt;br /&gt;if an 8- or 16-bit register is addressed, only that portion of the 32-bit &lt;br /&gt;register changes without aff(,:cting !he remaining bits. The accumu-&lt;br /&gt;lator is used for instnlctions such as multiplication, division, and &lt;br /&gt;some of the adjustment instructions. For these instructions, the &lt;br /&gt;accumulator has a special purpose, but is generally considered a &lt;br /&gt;mUltipurpose register. In the 80386 and above, the EAX register &lt;br /&gt;may also hold the offset address of a location in the memory system. &lt;br /&gt;EBX is addressable as EBX, BX, BH, or BL. The BX register &lt;br /&gt;sometimes holds the offset address of a location in the memory &lt;br /&gt;system in all versions of the microprocessor. In the 80386 and &lt;br /&gt;above, EBX also can address memory data. &lt;br /&gt;ECX is a general-purpose register that also holds the count for &lt;br /&gt;various instructions. In the 80386 and above, the ECX register can &lt;br /&gt;also hold the offset address of memory data. Instructions that use a &lt;br /&gt;count are the repeated string instructions (REPIREPEI REPNE), &lt;br /&gt;shift, rotate, and LOOPILOOPD instructions. The shift and rotate &lt;br /&gt;instructions use CL as the count, the repeated string instructions use &lt;br /&gt;CX, and LOOPILOOPD instructions use either CX or ECX. &lt;br /&gt;EDX is a general-purpose register that holds a part of the result &lt;br /&gt;from a multiplication or part of the dividend before a division. In &lt;br /&gt;the 80386 and above, this register can also address memory data. &lt;br /&gt;EBP points to a memory location in all versions of the micropro-&lt;br /&gt;cessor for memory data transfers. This register is addressed as either &lt;br /&gt;BP orEBP. &lt;br /&gt;EDI often addresses string destination data for the string instructions. &lt;br /&gt;It also functions as either a 32-bit (EDI) or 16-bit (DI) general-&lt;br /&gt;purpose register. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;48 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESI &lt;br /&gt;(source index) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESI is used as either ESI or S1. The source index register often &lt;br /&gt;addresses source string data for the string instructions. Like EDI, &lt;br /&gt;ESI also functions as a general-purpose register. As a 16-bit &lt;br /&gt;register, it is addressed as SI; as a 32-bit register, as ESI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Special-purpose Registers. The special-purpose registers include EIP, ESP, EFLAGS, and the &lt;br /&gt;segment registers CS, DS, ES, SS, FS, and GS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EIP &lt;br /&gt;(instruction pointer) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP &lt;br /&gt;(stack pointer) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EFLAGS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EIP addresses the next instruction in a section of memory defined &lt;br /&gt;as a code segment. This register is IP (l6-bits) when the micropro-&lt;br /&gt;cessor operates in the real mode and EIP (32-bits) when the 80386 &lt;br /&gt;and above operate in the protected mode. Note that the 8086, 8088, &lt;br /&gt;and 80286 do contain EIP, and only the 80286 and above operate &lt;br /&gt;in the protected mode. The instruction pointer, which points to the &lt;br /&gt;next instruction in a program, is used by the microprocessor to find &lt;br /&gt;the next sequential instruction in a program located within the code &lt;br /&gt;segment. The instruction pointer can be modified with a jump or a &lt;br /&gt;call instruction. &lt;br /&gt;ESP addresses an area of memory called the stack. The stack memory &lt;br /&gt;stores data through this pointer and is explained in this chapter with &lt;br /&gt;instructions that address stack data. This register is referred to as SP &lt;br /&gt;if used as a 16-bit register and ESP if referred to as a 32-bit register. &lt;br /&gt;EFLAGS indicate the condition of the microprocessor as well as &lt;br /&gt;control its operation. Figure 2-2 shows the flag registers of all ver-&lt;br /&gt;sions of the microprocessor. Note that the flags are upward compa-&lt;br /&gt;tible from the 8086/8088 to the Pentium Pro microprocessors. The &lt;br /&gt;8086-80286 microprocessors contain a FLAG register (16-bits), &lt;br /&gt;while the 80386 and above contain an EFLAG register (32-bit &lt;br /&gt;extended flag register). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The rightmost five flag bits and the overflow flag change after many arithmetic and logic &lt;br /&gt;instructions execute. Some of the flags are also used to control features found in the micro-&lt;br /&gt;processor. Following is a list of each flag bit with a brief description of their function. As in-&lt;br /&gt;structions are introduced in subsequent chapters, additional detail on the flag bits is provided. &lt;br /&gt;The rightmost five flags and the overflow flag are changed by most arithmetic and logic opera-&lt;br /&gt;tions, while data transfers do not affect them. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C (carry) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P (parity) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A (auxiliary carry) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry holds the carry after addition or the borrow after subtraction. &lt;br /&gt;The carry flag also indicates error conditions as dictated by some &lt;br /&gt;programs and procedures. This is especially true of the DOS func-&lt;br /&gt;tion calls detailed in later chapters and Appendix A. &lt;br /&gt;Parity is a logic 0 for odd parity and a logic I for even parity. Parity &lt;br /&gt;is a count of ones in a number expressed as even or odd. For ex-&lt;br /&gt;ample, if a number contains three binary one bits, it has odd parity. &lt;br /&gt;If a number contains zero one bits, it has even parity. The parity &lt;br /&gt;flag finds little application in modern programming and was im-&lt;br /&gt;plemented in early Intel microprocessors for checking data in data &lt;br /&gt;communkations environments. Today, parity checking is often &lt;br /&gt;accomplished by the data communications equipment instead of by &lt;br /&gt;the microprocessor. &lt;br /&gt;The auxiliary carry holds the carry (half-carry) after addition or the &lt;br /&gt;borrow after subtraction between bits positions 3 and 4 of the result. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-1 INTERNAL MICROPROCESSOR ARCHITECTURE 49 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-2 The EFLAG &lt;br /&gt;and FLAG register counts for &lt;br /&gt;the entire 80X86 and Pentium &lt;br /&gt;microprocessor family &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Z (zero) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S (sign) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T (trap) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I (interrupt) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D (direction) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o (overflow) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IOPL &lt;br /&gt;(110 privilege level) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;----8086/8088/80186/80188--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1----+------80286 &lt;br /&gt;f+---+---+-----80386/8986DX----l~1 &lt;br /&gt;1--+---+----I------80486SX-----I~1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1---+-+---+----I----Pentlum/Pentlum Pro~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This highly specialized flag bit is tested by the DAA and DAS in-&lt;br /&gt;structions to adjust the value of AL after a BCD addition or subtrac-&lt;br /&gt;tion. Otherwise, the A flag bit is not used by the microprocessor or &lt;br /&gt;any other instructions. &lt;br /&gt;The zero flag shows that the result of an arithmetic or logic opera-&lt;br /&gt;tion is zero. If Z = 1, the result is zero; if Z = 0, the result is not zero. &lt;br /&gt;The sign flag holds the arithmetic sign of the result after an arith-&lt;br /&gt;metic or logic instruction executes. If S = 1, the sign bit (leftmost &lt;br /&gt;bit of a number) is set or negative; if S = 0, the sign bit is cleared or &lt;br /&gt;positive. &lt;br /&gt;The trap flag enables trapping through an on-chip debugging fea-&lt;br /&gt;ture. (A program is debugged to find an error or bug.) If the T flag &lt;br /&gt;is enabled (1), the microprocessor interrupts the flow of the pro-&lt;br /&gt;gram on conditions as indicated by the debug registers and control &lt;br /&gt;registers. If the T flag is a logic 0, the trapping (debugging) feature &lt;br /&gt;is disabled. The CodeView program can use the trap feature and &lt;br /&gt;debug registers to debug faulty software. &lt;br /&gt;The interrupt flag controls the operation of the INTR (interrupt re-&lt;br /&gt;quest) input pin. If 1= 1, the INTR pin is enabled; if 1= 0, the INTR &lt;br /&gt;pin is disabled. The state of the I flag bit is controlled by the STI &lt;br /&gt;(set I flag) and CLI (clear I flag) instructions. &lt;br /&gt;The direction flag selects either the increment or decrement mode &lt;br /&gt;for the DI and/or SI registers during string instructions. If D = 1, the &lt;br /&gt;registers are automatically ~I!!~!1j~d; if D = 0, the registers are &lt;br /&gt;automatically increillented. The D flag iSSet&amp;quot;~ith the SID (set &lt;br /&gt;direction) and cleared with the CLD (clear direction) instructions. &lt;br /&gt;Overflows occur when signed numbers are added or subtracted. An &lt;br /&gt;overflow indicates that the result has exceeded the capacity of the &lt;br /&gt;machine. For example, if a 7FH (+ 127) is added-using an 8-bit &lt;br /&gt;addition-to a OlH (+1), the result is 80H (-128). This result rep-&lt;br /&gt;resents an overflow condition indicated by the overflow flag for &lt;br /&gt;signed addition. For unsigned operations, the overflow flag is &lt;br /&gt;ignored. &lt;br /&gt;IOPL is used in protected mode operation to select the privilege &lt;br /&gt;level for I/O devices. If the current privilege level is higher or more &lt;br /&gt;trusted than the IOPL, then VO e~ecutes without hind~ance. If the &lt;br /&gt;IOPLis lower than the current privilege level, an interrupt occurs, &lt;br /&gt;causing execution to suspend. Note that an IOPL of 00 is the &lt;br /&gt;highest or most trusted; if IOPL is 11, it's the lowest or least &lt;br /&gt;trusted. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;50 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NT (nested task) The nested task flag indicates that the current task is nested within &lt;br /&gt;another task in protected mode operation. This flag is set when the &lt;br /&gt;task is nested by software. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RF (resume) The resume flag is used with debugging to control the resumption &lt;br /&gt;of execution after the next instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VM (virtual mode) The VM flag bit selects virtual mode operation in a protected mode &lt;br /&gt;system. A virtual mode system allows multiple DOS memory &lt;br /&gt;partitions that are 1 M byte in length to coexist in the memory &lt;br /&gt;system. Essentially, this allows the system program to execute &lt;br /&gt;multiple DOS programs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AC (alignment check) The alignment check flag bit activates if a word or doubleword is &lt;br /&gt;addressed on a non-word or non-doubleword boundary. Only the &lt;br /&gt;80486SX microprocessor contains the alignment check bit that is &lt;br /&gt;primarily used by its companion numeric coprocessor, the &lt;br /&gt;80487SX, for synchronization. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIF (virtual &lt;br /&gt;interrupt flag) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The VIF is a copy of the interrupt flag bit available to the Pentium! &lt;br /&gt;Pentium Pro microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIP (virtual &lt;br /&gt;interrupt pending) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIP provides information about a virtual mode interrupt for the &lt;br /&gt;PentiumlPentium Pro microprocessors. This is used in multitasking &lt;br /&gt;environments to provide the operating system with virtual interrupt &lt;br /&gt;flags and interrupt pending information. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ID (identification) The ID flag indicates that the Pentium/Pentium Pro microprocessors &lt;br /&gt;support the CPUID instruction. The CPUID instruction provides the &lt;br /&gt;system with information about the Pentium microprocessor, such as &lt;br /&gt;its version number and manufacturer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment Registers. Additional registers, called segment registers, generate memory addresses &lt;br /&gt;when combined with other registers in the microprocessor. There are either four or six segment &lt;br /&gt;registers in various versions of the microprocessor. A segment register functions differently in &lt;br /&gt;the real mode when compared to the protected mode operation of the microprocessor. Detail on &lt;br /&gt;their functions in real and protected mode is provided later in this chapter. Following is a list of &lt;br /&gt;each segment register along with its function in the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS (code) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS (data) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES (extra) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SS (stack) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The code segment is a section of memory that holds the code (programs and &lt;br /&gt;procedures) used by the microprocessor. The code segment register defines &lt;br /&gt;the starting address of the section of memory holding code. In real mode &lt;br /&gt;operation, it defines the start of a 64K byte section of memory; in protected &lt;br /&gt;mode, it selects a descriptor that describes the starting address and length of a &lt;br /&gt;section of memory holding code. The code segment length is limited to 64K &lt;br /&gt;bytes in the 8088-80286 and 40 bytes in the 80386 and above when these &lt;br /&gt;microprocessors operate in the protected mode. &lt;br /&gt;The data segment is a section of memory that contains most data used by a &lt;br /&gt;program. Data are accessed in the data segment by an offset address or the &lt;br /&gt;contents of other registers that hold the offset address. As with the code &lt;br /&gt;segment and other segments, the length is limited to 64K bytes in the &lt;br /&gt;8086-80286 and 40 bytes in the 80386 and above. &lt;br /&gt;The extra segment is an additional data segment used by some of the string &lt;br /&gt;instructions to hold destination data. &lt;br /&gt;The stack segment defines the area of memory used for the stack. Th,,: loca-&lt;br /&gt;tion of the current entry point in the stack segment is determined by the stack &lt;br /&gt;pointer register. The BP register also addresses data within the stack segment. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-2 REAL MODE MEMORY ADDRESSING 51 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FS and GS The FS and OS segments are supplemental segment registers available in the &lt;br /&gt;80386, 80486, Pentium, and Pentium Pro microprocessors to allow two &lt;br /&gt;additional memory segments for access by programs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REAL MODE MEMORY ADDRESSING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80286 and above operate in either the real or protected mode. Only the 8086 and 8088 op-&lt;br /&gt;erate exclusively in the real mode. This section of the text details the operation of the micro-&lt;br /&gt;processor in the real mode. Real mode operation allows the microprocessor to address only the &lt;br /&gt;first 1M byte of memory space-even the Pentium microprocessor. Note that the first 1M byte of &lt;br /&gt;memory is called either the real memory or conventional memory system. Both the MSDOS or &lt;br /&gt;peDOS operating systems assume that the microprocessor is operated in the real mode at all &lt;br /&gt;Jimes. Real mode operation allows applicat~0E:~oftware written for_!he 8086/8088, which con-&lt;br /&gt;tain only Li\\1byte of memory, to function in the 80286 and above without changing the software. &lt;br /&gt;At present, 95 percent of all software in use is designed to operate in the real mode. This will &lt;br /&gt;most likely change as Windows 95 becomes the new 32-bit operating platform. The upward &lt;br /&gt;compatibility of software is partially responsible for the continuing success of the Intel family of &lt;br /&gt;microprocessors. In all cases, each of these microprocessors begins operation in the real mode by &lt;br /&gt;default whenever power is applied or the microprocessor is reset. Note that the DOS environ-&lt;br /&gt;ment is a real mode environment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segments and Offsets &lt;br /&gt;A combination of a segment address and an offset address access a memory location in the real &lt;br /&gt;mode. All real mode memory addresses consist of a segment address plus an offset address. The &lt;br /&gt;segment address, located within one of the segment registers, defines the beginning address of &lt;br /&gt;any 64K-byte memory segment. The offset address selects any location within the 64K-byte &lt;br /&gt;memory segment. Figure 2-3 shows how the segment plus offset addressing scheme selects a &lt;br /&gt;memory location. This illustration shows a memory segment that begins at location 10000H and &lt;br /&gt;ends at location IFFFFH-64K bytes in length. It also shows how an offset, sometimes called a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-3 The real mode &lt;br /&gt;memory-addressing scheme, &lt;br /&gt;using a segment address plus &lt;br /&gt;an offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Real mode memory FFFFFD &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--1FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 FOOO 1+ Offset = FOOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64K-byte &lt;br /&gt;segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment registe &lt;br /&gt;10000 1 0 0 o I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;52 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;displacement, of FOOOR selects location IFOOOH in the memory system. Note that the offset or &lt;br /&gt;displacement is the distance above the start of the segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The segment register in Figure 2-3 contains a 1000H, yet it addresses a starting segment at &lt;br /&gt;location lOOOOR. In the real mode, each segment register is internally appended with a OR on its &lt;br /&gt;rightmost end. This fonns a 20-bit memory address, allowing it to access the start of a segment &lt;br /&gt;~e boundary within the first 1M byte of memory. This is required in the micro-&lt;br /&gt;processor to generate a 20-bit memory address. For example, if a segment register contains a &lt;br /&gt;1200H, it addresses a 64K-byte memory segment beginning at location 12000H. Likewise, if a &lt;br /&gt;segment register contains a 1201H, it addresses a memory segment beginning at location &lt;br /&gt;12010H. Because of the internally appended OH, real mode segments can only begin at a 16-byte &lt;br /&gt;boundary in the memory system. This 16-byte boundary is often called a paragraph. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because a real mode segment of memory is 64K in length, once the beginning address is &lt;br /&gt;known, the ending address is found by adding FFFFH. For example, if a segment register con-&lt;br /&gt;tains 3000H, the first address of the segment is 30000H and the last address is 30000H + FFFFH &lt;br /&gt;or 3FFFFH. Table 2-1 shows several examples of segment register contents and the starting and &lt;br /&gt;ending addresses of the memory segments selected by each segment address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The offset address is added to the start of the segment to address a memory location in the &lt;br /&gt;memory segment. For example, if the segment address is 1000H and the offset address is 2000R, &lt;br /&gt;the microprocessor addresses memory location 12000R. The segment and offset address is &lt;br /&gt;sometimes written as 1000:2000 for a segment address of 1000R with an offset of 2000R. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80286 (with special external circuitry) and the 80386 through the Pentium Pro, an &lt;br /&gt;extra 64K minus 16 bytes of memory is addressable when the segment address is FFFFH and the &lt;br /&gt;!!IMEM.SX.~_E.riv~Â§iI!Â§J~U~_~i!1 the system. This area of memory (OFFFFOH-I0FFEFH) is re-&lt;br /&gt;ferred to as high memory. When an address is generated using a segment address ofFFFFH, the &lt;br /&gt;A20 address pin is set (if supported) when an offset is added. For example, if the segment ad-&lt;br /&gt;dress is FFFFH and the offset address is 4000R, the machine addresses memory location &lt;br /&gt;FFFFOR + 4000H or 103FFOH. If A20 is not supported, the address generated is 03FFOH be-&lt;br /&gt;cause A20 remains a logic zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Some addressing modes combine more than one register and an offset value to fonn an offset &lt;br /&gt;address. When this occurs, the sum of these values may exceed FFFFH. For example, the address &lt;br /&gt;accessed in a segment whose segment address is 3000H and whose offset address is specified as the &lt;br /&gt;sum of FOOOR plus 3000H will access memory location 32000R, instead of location 42000R. &lt;br /&gt;When the FOOOH and 3000R are added, they fonn a 16-bit (modulo 16) sum of2000H used as the &lt;br /&gt;offset address and not 12000H, the true sum. Note that the carry of I (FOOOR + 3000H = 12000H) &lt;br /&gt;is dropped for this addition to form the offset address of 2000R. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Default Segment and Offset Registers &lt;br /&gt;The microprocessor has a set of rules that apply to segments whenever memory is addressed. &lt;br /&gt;These rules, which apply in either the real or protected mode, define the segment register and &lt;br /&gt;offset register combination used by certain addressing modes. For example, the code segment &lt;br /&gt;register is always used with the instruction pointer to address the next instruction in a program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 2-1 Example &lt;br /&gt;segment addresses Segment Register Starting Address Ending Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2000H &lt;br /&gt;2001H &lt;br /&gt;21000H &lt;br /&gt;ABOOH &lt;br /&gt;1234H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20000H &lt;br /&gt;20010H &lt;br /&gt;21000H &lt;br /&gt;ABOOOH &lt;br /&gt;12340H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2FFFFH &lt;br /&gt;3000Ff-. &lt;br /&gt;30FFFH &lt;br /&gt;BAFFFH &lt;br /&gt;2233FH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-2 REAL MODE MEMORY ADDRESSING 53 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 2-2 8086-80486 &lt;br /&gt;and Pentium/Pentium Pro &lt;br /&gt;default 16-bit segment and &lt;br /&gt;offset address combinations &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;SS &lt;br /&gt;OS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IP &lt;br /&gt;SP or BP &lt;br /&gt;BX, 01, SI, an 8-bit number &lt;br /&gt;or a 16-bit number &lt;br /&gt;01 for string instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Special Purpose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction address &lt;br /&gt;Stack address &lt;br /&gt;Data address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;String destination address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This combination is CS:IP or CS:EIP depending upon the microprocessor's mode of operation. &lt;br /&gt;The code segment register defines the start of the code segment and the instruction pointer lo-&lt;br /&gt;cates the next instruction within the code segment. This combination (CS:IP or CS:EIP) locates &lt;br /&gt;the next instruction executed by the microprocessor. For example, if CS = l400H and IPIEIP = &lt;br /&gt;1200H, the microprocessor fetches its next instruction from memory location 14000H + 1200H &lt;br /&gt;or 15200H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another of the default combinations is the stack. Stack data are referenced through the &lt;br /&gt;stack segment at the memory location addressed by either the stack pointer (SPIESP) or the base &lt;br /&gt;pointer (BPIEBP). These combinations are referred to as SS:SP (SS:ESP) or SS:BP (SS:EBP). &lt;br /&gt;For example, if SS = 2000H and BP = 3000H, the microprocessor addresses memory location &lt;br /&gt;23000H for a stack segment memory location. Note that in real mode, only the rightmost 16-bits &lt;br /&gt;of the extended register address a location within the memory segment. In the 80386-Pentium &lt;br /&gt;Pro, nev~Ipla&amp;lt;::e a number larger than, EFFFH into an offset register if the microprocessor is op-&lt;br /&gt;eratedT~the real mode. This causes the system to halt and indicate an addressing error. &lt;br /&gt;Â·----6ther defaults are shown in Tabl~ -2':&amp;quot;2 for addressing memory using any Intel micro-&lt;br /&gt;processor with 16-bit registers. Table 2-3 shows the defaults assumed in the 80386 and above &lt;br /&gt;when using 32-bit registers. Note that the 80386 and above have a far greater selection of seg-&lt;br /&gt;ment/offset address combinations than do the 8086 through the 80286 microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8086-80286 microprocessors allow four memory segments, and the 80386 and above &lt;br /&gt;allow six memory segments. Figure 2-4 shows a system that contains four memory segments. &lt;br /&gt;Note that a memory segment can touch or even overlap if 64K bytes of memory are not required &lt;br /&gt;~~ _a_~~.gment. Think of segments as windo.~~.that can be mo~ed over any area of memory to ac-&lt;br /&gt;cess dl:lta or code. Also note that a program canh,ave more than four or six segments, but can &lt;br /&gt;only access four o!s!)(segments 'It a time. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SupposelUl application program requires 1000H bytes of memory for its code, 190H bytes &lt;br /&gt;of memory for its data, and 200H bytes of memory for its stack. This application does not require &lt;br /&gt;an extra segment. When this program is placed in the memory system by DOS, it is loaded in the &lt;br /&gt;TPA at ~~e first available area of ~IllOry _a~?~e t!Je d~yers and qtl1~~.l'PA_programs. This area &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 2-3 80386,80486, &lt;br /&gt;Pentium, and Pentium Pro &lt;br /&gt;default 32-bit segment and &lt;br /&gt;offset address combinations &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;SS &lt;br /&gt;OS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES &lt;br /&gt;FS &lt;br /&gt;GS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EIP &lt;br /&gt;ESP and EBP &lt;br /&gt;EAX, EBX, ECX, EOX, ESI, EOI, an &lt;br /&gt;8-bit number, or a 32-bit number &lt;br /&gt;EOI for string instructions &lt;br /&gt;No default &lt;br /&gt;No default &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Special Purpose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction address &lt;br /&gt;Stack address &lt;br /&gt;Data address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;String destination address &lt;br /&gt;General address &lt;br /&gt;General address &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;54 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory FIGURE 2-4 A memory &lt;br /&gt;system showing the place-&lt;br /&gt;ment of four memory &lt;br /&gt;segments &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFFL:J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;59000 &lt;br /&gt;58FFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;49000 &lt;br /&gt;48FFF &lt;br /&gt;44000 &lt;br /&gt;43FFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34000 &lt;br /&gt;33FFF &lt;br /&gt;30000 &lt;br /&gt;2FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20000 &lt;br /&gt;1FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 &lt;br /&gt;OFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Extra &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-i 4 900 IES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-i 340 0 Iss &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-i 2 0 0 0 Ics &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-i 1 0 ooiDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;is indicated by a free-pointer that is maintained by DOS. Program loading is handled automati-&lt;br /&gt;cally by the program loader located within DOS. Figure 2-5 shows how this application is stored &lt;br /&gt;in the memory system. The segments show an overlap because the amount of data in them does not &lt;br /&gt;require 64K bytes of memory. The side view of the segments clearly shows the overlap and how &lt;br /&gt;segments can be moved to any area of memory by changing the segment starting address. Fortu-&lt;br /&gt;nately, DOS calculates and assigns segment starting addresses. This is explained in Chapter 7, &lt;br /&gt;which details the operation of the assembler, BIOS, and DOS for an assembly language program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment and Offset Addressing Scheme Allows Relocation &lt;br /&gt;The segment and offset addressing scheme seems unduly complicated. It is complicated, hut it &lt;br /&gt;also affords an advantage to the system. This complicated scheme of segment plus offsct ad-&lt;br /&gt;dressing allows programs to be relocated in the memory system. It also allows programs written &lt;br /&gt;to function in the real mode to operate in a protected mode system. A relocatable program is one &lt;br /&gt;that can be placed into any area of memory and executed without change. Relocatable data are &lt;br /&gt;data that can be placed in any area of memory and used without any change to the program. The &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-2 REAL MODE MEMORY ADDRESSING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-5 An application &lt;br /&gt;program containing a code, &lt;br /&gt;data, and stack segment &lt;br /&gt;loaded into a DOS system &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Imaginary side &lt;br /&gt;view detailing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;segment overlap &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;t &lt;br /&gt;a &lt;br /&gt;c &lt;br /&gt;k D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a &lt;br /&gt;t &lt;br /&gt;a C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory FFFFFL:] &lt;br /&gt;-./&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0A480 &lt;br /&gt;0A47F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack &lt;br /&gt;OA280 &lt;br /&gt;OA27F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAOFO &lt;br /&gt;OAOEF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Code &lt;br /&gt;090FO &lt;br /&gt;0908F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOS and drivers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000001...-_____ -1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--l o A 2 8 Iss &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--l o A 0 F IDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--l 0 9 0 F Ics &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s~gfl1ent and offset addressing scheme allows both programs and data to be ~elocated without &lt;br /&gt;~!lang!n.Ka,nything in the programs or data. This is ideal for use in a general-purpose computer &lt;br /&gt;system where not all machines contain the same memory areas. The personal computer memory &lt;br /&gt;structure is different from machine to machine, requiring relocatable software and data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because memory is addressed within a segment by an offse.t&amp;lt;id.dress, the memory segment &lt;br /&gt;can be moved to any place in the me.Jl1ory sy-stem without cha!1ging any of the offset addresses. &lt;br /&gt;This is accomplished by moving th~f:~!ireprogram, as a block, to ~_new arealmd then changing &lt;br /&gt;only the con_~_nti&amp;gt;QJ the.segment registers. If an instruction is 4 bytes above the start of the seg-&lt;br /&gt;ment, its offset address is 4. If the entire program is moved to a new area of memory, this offset &lt;br /&gt;address of 4 still points to 4 bytes above the start of the segment. Only the conten!s of the seg-&lt;br /&gt;ment register must be ciuingecl to address the program in the new area of memory. Without this &lt;br /&gt;feature, a program would have to be extensively rewritten or altered before it is moved. This &lt;br /&gt;would require additional time or_ many versions of a program for the many different configura-&lt;br /&gt;tions of computer systems. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;56 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2-3 \\I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROTECTED MODE MEMORY ADDRESSING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Protected mode memory addressing (80286 and above) allows access to data and programs lo-&lt;br /&gt;cated above the first 1M byte of memory as well as within the first 1M byte of memory. Ad-&lt;br /&gt;dressing this extended section of the memory system requires a change to the segment plus offset &lt;br /&gt;addressing scheme used with real mode memory addressing. When data and programs are ad-&lt;br /&gt;dressed in extended memory, the offset address is still used to access information located within &lt;br /&gt;the memory segment. The difference is that the segment address, as discussed with real mode &lt;br /&gt;memory addressing, is no longer present in the protected mode. In place of the segment address, &lt;br /&gt;the segment register contains a selector that selects a descriptor from a descriptor table. The de-&lt;br /&gt;scriptor describes the memory segment's location, length, and access rights. Because the seg-&lt;br /&gt;ment register and offset address still access memory, protected mode instructions are identical to &lt;br /&gt;real mode instructions. In fact, most programs written to function in the real mode will function &lt;br /&gt;without change in the protected mode. The difference between modes is in the way that the seg-&lt;br /&gt;ment register is interpreted by the microprocessor to access the memory segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selectors and Descriptors &lt;br /&gt;The selector, located in the segment register, selects one of 8, 192 descriptors from one of two ta-&lt;br /&gt;bles of descriptors. The descriptor describes the location, length, and access rights of the seg-&lt;br /&gt;ment of memory. Indirectly, the segment register still selects a memory segment, but not directly &lt;br /&gt;as in the real mode. For example, in the real mode, ifCS = 0008H, the code segment begins at lo-&lt;br /&gt;cation 00080H. In the protected mode, this segment number can address any memory location in &lt;br /&gt;the entire system for the code segment, as explained shortly. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are two descriptor tables used with the segment registers: one contains global de-&lt;br /&gt;scriptors and the other contains local descriptors. The global descriptors contain segment defi-&lt;br /&gt;nitions that apply to all programs, while the local descriptors are usually unique to an &lt;br /&gt;application. Each descliptor table contains 8,192 descriptors, so a total of 16,384 descriptors are &lt;br /&gt;available to an application at any time. Because the descriptor describes a memory segment, this &lt;br /&gt;allows up to 16,384 memory segments to be described for each application. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 2-6 shows the format of a descriptor for the 80286 through the Pentium Pro. Note &lt;br /&gt;that each descriptor is 8 bytes in length, so the global and local descriptor tables are each a max-&lt;br /&gt;~~--,~~------imum of Q:1-K bytes in l~h. Descriptors for the 80286 and the 80386 through the Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;differ slightly, but the 80286 descriptor is upward compatible. &lt;br /&gt;The base address portion of the descriptor indicates the starting location of the memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;segment. For the 80286 microprocessor, the base address is a 24-bit address, so segments begin &lt;br /&gt;at any location in its 16M bytes of memory. Note that the paragraph boundary limitation is re-&lt;br /&gt;moved in these microprocessors when operated in the protected mode. The 80386 and above use &lt;br /&gt;a 32-bit base address that allows segments to begin at any location in its 4G bytes of memory. &lt;br /&gt;Notice how the 80286 descriptor's base address is upward compatible to the 80386 through the &lt;br /&gt;Pentium Pro descriptor because its most-significant 8-bits are OOH. Refer to Chapter 17 for addi-&lt;br /&gt;tional detail on the 64G memory address space provided by the Pentium Pro processor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The segment limit contains the last offset address found in a segment. For example, if a &lt;br /&gt;segment begins at memory location FOOOOOH and ends at location FOOOFFH, the base address is &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;------------FOOOOOH and the ~. For the 80286 microprocessor, the base address is FOOOOOH and &lt;br /&gt;the limit is OOFFH. For the 80386 and above, the base address is OOFOOOOOH and the limit is &lt;br /&gt;OOOFFH. Notice that the 80286 has a 16-bit limit, and the 80386 through the Pentium Pro have a &lt;br /&gt;20-bit limit. The 80286 accesses memory segments that are between 1 and 64K bytes in length. &lt;br /&gt;The 80386 and above access memory segments that are between 1 and 1M byte or 4K and 4G &lt;br /&gt;bytes in length. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-3 PROTECTED MODE MEMORY ADDRESSING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 descriptor 80386/80486/Pentium/Pentium Pro descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 00000000 6 &lt;br /&gt;7~ __________ ~ ____________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base (B31-B24) illl )I~I Limit GOO V (L19-L16) 7 6 &lt;br /&gt;Access rights Base (B23-B 16) 4 &lt;br /&gt;5~ __________ ~ ____________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Access rights Base (B23--B 16) &lt;br /&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 &lt;br /&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base (B15-BO) 2 &lt;br /&gt;3~ ________________________ ~ 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base (B15-BO) 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 I Limit (L 15-LO) I 0 I Limit (L 15-LO) I 0 1~ ______________ ~&lt;br /&gt;FIGURE 2-6 The descriptor formats for the 80286 and 80386/80486/Pentium/Pentium Pro &lt;br /&gt;microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;57 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There is another feature found in the 80386 through the Pentium Pro descriptor that is not &lt;br /&gt;found in the 80286 descriptor: the G bit or granularity bit. If G = 0, the limit specifies a segment &lt;br /&gt;limit of from .!.to IMbyte in length. If G = I, the value of the limit is multiplied by 4K bytes (ap-&lt;br /&gt;pended with OOOH). If G = I, the limit is anymultipleof 4Kbytes. This allows a segment length &lt;br /&gt;of 4K to 4G bytes in steps of 4K bytes. The reason that the segment length is 64K bytes in the &lt;br /&gt;80286 is that the offset address is always 16-bits because of its 16-bit internal architecture. The &lt;br /&gt;80386 and above use a 32-bit architecture, which allows an offset address, in the protected mode &lt;br /&gt;oPEation, of the 32-bits. Thts_32-bit offset address allows segment lengths of 4G bytes, and the &lt;br /&gt;16-bit offset address allows segment lengths of 64K bytes. Operating systems operate in either a &lt;br /&gt;16- or 32-bit environment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The A V bit, in the 80386 and above descriptor, is used by some operating systems to indi-&lt;br /&gt;cate that the segment is available (AV = I) or not available (A V = 0). The D bit indicates how the &lt;br /&gt;80386 through the Pentium Pro instructions access register and memory data in the protected or &lt;br /&gt;real mode. If D = 0, the instructions are 16-bit instructions compatible with the 8086-80286 mi-&lt;br /&gt;croprocessors. This means that the instructions use 16-bit offset addresses and 16-bit registers by &lt;br /&gt;default. This mode is often called the 16-bit instruction mode. IfD = I, the instructions are 32-bit &lt;br /&gt;instructions. By default, the 32-bit instruction mode assumes that all offset addresses as well as all &lt;br /&gt;registers are 32-bits. Note that the default for register size and offset address size can be over-&lt;br /&gt;ri_c!.c!.e I1 iIlE()th the 16- and 32-bit instruction modes. Both the MSDOS and PCDOS operating sys-&lt;br /&gt;tems requi~~_~hat the instructions are always used in the 16-bit instruction mode. Window~J .. l &lt;br /&gt;also requires that the 16-bit instruction mode is selected. Note that the 32-bit instruction mode is &lt;br /&gt;only accessible in a protected-mode system such as Windows NT, Windows 95, or OS/2. More &lt;br /&gt;detail on these modes and their application to the instruction set appears in Chapters 3 and 4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The access rights byte (see Figure 2-7) controls access to the protected mode memory &lt;br /&gt;segment. This byte describes ho\\\\, the segment functions in the system. The access rights byte al-&lt;br /&gt;lows complete control over the segment. If the segment is a data segment, the direction of growth &lt;br /&gt;is specified. If the segment gro&amp;quot;&amp;quot;s beyond its limit, the microprocessor's program is interrupted, &lt;br /&gt;indicating a general protectionfault. You can even specify if a data segment can be written or is &lt;br /&gt;write-protected. The code segment is also controlled in a similar fashion and can have reading &lt;br /&gt;inhibited to protect software. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Descriptors are chosen from the descriptor table by the segment register. Figure 2-8 shows &lt;br /&gt;how the segment registerturictions in the protected mode system. The segment register contains &lt;br /&gt;3,J 3~bitselector field, a table selector bit, and a requested privilege level field. The 13-bit se-&lt;br /&gt;lector chooses o.n(!of the 8,192 descriptors from the descriptor taple. The TI bit selects either the &lt;br /&gt;globaldescriptor table (TI = 0) or the local descriptor table (TI = I). The requested privilege &lt;br /&gt;lev~ICRPL) request~the access privilege-level of a memory segment. The highest privilege level &lt;br /&gt;isOO and t4e lowest is II. If the reguestedprivilege level matches or is higher in priority than the &lt;br /&gt;privilege level set by the access rights byte, access is granted. For example, if the requested priv-&lt;br /&gt;ilege- level is 10 and the access rights byte sets the segment privilege level at II, access is granted &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;58 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;765432 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P DPL S E ED RfIN A &lt;br /&gt;Ie &lt;br /&gt;L~ I 'L A = 0 Segment not accessed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A = 1 Segment has been accessed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E=O Descriptor describes a data segment &lt;br /&gt;ED = 0 Segment expands upward (data segment) &lt;br /&gt;ED = 1 Segment expands downward (stack segment) &lt;br /&gt;W=O Data may not be written &lt;br /&gt;W=1 Data may be written &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E 1 Descriptor describes code segment &lt;br /&gt;C = 0 Ignore descriptor privilege level &lt;br /&gt;C = 1 Abide by privilege level &lt;br /&gt;R = 0 Code segment may not be read &lt;br /&gt;R = 1 Code segment may be read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S = 0 System descriptor &lt;br /&gt;S = 1 Code or data segment descriptor &lt;br /&gt;DLP = Sets the descriptor privilege level &lt;br /&gt;p=o Descriptor is undefined &lt;br /&gt;P = 1 Segment contains a valid base and limit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: Some of the letters used to describe the bits in the access rights bytes vary in Intel documentation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-7 The access rights byte for the 80286, 80386, 80486, Pentium, and Pentium Pro &lt;br /&gt;descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;because 10 is higher in priority than privilege level 11. Privilege levels are used in multi-user en-&lt;br /&gt;vironments. If the privilege level is violated, the system normally indicates a privilege violation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 2-9 shows how the segment register, containing a selector, chooses a descriptor &lt;br /&gt;from the global descriptor table. The entry in the global descriptor table selects a segment in the &lt;br /&gt;memory system. In this illustration, DS contains 0008H, which accesses the descriptor number &lt;br /&gt;1 from the global descriptor table using a requested privilege level of 00. Descriptor number 1 &lt;br /&gt;contains a descriptor that defines the base address as 00100000H with a segment limit of &lt;br /&gt;OOOFFH. This means that a value of 0008H loaded into DS causes the microprocessor to use &lt;br /&gt;memory locations OOlOOOOOH-OOIOOOFFH for the data segment with this example descriptor &lt;br /&gt;table. Note that descriptor zero is called the null descriptor and may not be used for accessing &lt;br /&gt;memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r--------__ _ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RPL = Requested privilege level where &lt;br /&gt;00 is the highest and 11 is the lowest &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TI = 0 Global descriptor table &lt;br /&gt;TI = 1 Local descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selects one descriptor from 8,192 descriptors &lt;br /&gt;in either the global or the local descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-8 The contents of a segment register during protected-mode operation of the &lt;br /&gt;80286, 80386, 80486, Pentium, or Pentium Pro microprocessor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-3 PROTECTED MODE MEMORY ADDRESSING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Global descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 -&lt;br /&gt;o 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Descriptor 1 9 2 &lt;br /&gt;1 0 &lt;br /&gt;o 0 &lt;br /&gt;o 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS o 0 &lt;br /&gt;I o 0 0 8 I â¢ F F -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;[ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100100 &lt;br /&gt;1000FF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000 &lt;br /&gt;OFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;59 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-9 Using the OS register to select a descriptor from the global descriptor table. In this &lt;br /&gt;example, the OS register accesses memory locations 1 00000H-1 OOOFFH as a data segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Program-invisible Registers &lt;br /&gt;The global and local descriptor tabl~ are found in the I!lem()ry system. In order to access and &lt;br /&gt;s;7cify the address of these tables;-ihe 80286, 80386, 80486, Pentium, and Pentium Pro contain &lt;br /&gt;program-invisible registers. The program invisible registers are not directly addressed by software, &lt;br /&gt;so they are given this name, although some of these registers ~ accessed Qythe system software. &lt;br /&gt;Figure 2-10 illustrates the program-invisible registers as they appear in the 80286 through the Pen-&lt;br /&gt;tium Pro. The~eregisters control the microprocessor when operated in the protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each of the .~~gJ:l1en! registers contains a program-invisible portion used in the prot~cted &lt;br /&gt;mode. The program-invisible portion of these registers is often called cache memory because a &lt;br /&gt;cache is any memory that stores information. This cache is -not to be confused with the normal &lt;br /&gt;level 1 or level 2 caches found with the microprocessor. The prograll!::iE_~!~ible portion of the &lt;br /&gt;seg~~J.lt !(!gi~ter is loaded with ~he base address, limit, and access rights each time the E-uIllber in &lt;br /&gt;the segment register is changed. When a new segment number is placed in a segment register, the &lt;br /&gt;microprocessor accesses a descriptor table and loads the descriptor into the program invisible &lt;br /&gt;cache portion of the segment register. It is held there and used to access the memory segment &lt;br /&gt;until the segment number is again changed. This allows the microprocessor to access a memory &lt;br /&gt;segment repeatedly without referring back to the descriptor table for each access, hence the term &lt;br /&gt;cac;he. - -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The GDTR (global descriptor table register) and IDTR (interrupt descriptor table reg-&lt;br /&gt;ister) contain the base address of the descriptor table and its limit. The limit of each descriptor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;60 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment registers Descriptor cache &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS I-------~ Base address Limit Access &lt;br /&gt;DS 1-____________ --1 &lt;br /&gt;ES I-______ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SS I-______ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FS I---------------f &lt;br /&gt;GS L..-_____ ...... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TR I I I Base address Limit Access LDTR~------------~ ~-----------+----------~~----~ &lt;br /&gt;Descriptor table addresses &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GDTR~ ____ B_a_se_ad_d_re_s_s ____ r-___ L_im_i_t __ ~ &lt;br /&gt;IDTR &lt;br /&gt;~------------------~--------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Program invisible &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: &lt;br /&gt;1. The 80286 does not contain FS and GS nor the program-invisible portions of these registers. &lt;br /&gt;2. The 80286 contains a base address that is 24-bits and a limit that is 16-bits. &lt;br /&gt;3. The 80386/80486/Pentium/Pentium Pro contain a base address that is 32-bits and a limit that is 20-bits. &lt;br /&gt;4. The access rights are 8-bits in the 80286 and 12-bits in the 80386/80486/Pentium. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-10 The program-invisible register within the 80286,80386,80486, Pentium, and &lt;br /&gt;Pentium Pro microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;table is 16-bits because the maximum table length is 64K bytes. When protected mode operation &lt;br /&gt;is desired, the address of the global descriptor table and its limit are loaded into the GDTR. Be-&lt;br /&gt;fore using protected mode, the interrupt descriptor table and the IDTR must also be initialized. &lt;br /&gt;More detail is provided on protected mode operation in Chapters 16-17. At this point, the pro-&lt;br /&gt;gramming and additional description of these registers are impossible. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The location of the local descriptor table is selected from the global descriptor table. One &lt;br /&gt;of the global descriptors is set up to address the local descriptor table. To access the local de-&lt;br /&gt;scriptor table, the LDTR (local descriptor table register) is loaded with a selector, just as a seg-&lt;br /&gt;ment register is loaded with a selector. This selector accesses the global descriptor table and &lt;br /&gt;loads the base address, limit, and access rights of the local descriptor table into the cache portion &lt;br /&gt;oftheLDTR. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The (task register) holds a selector that accesses a descriptor that defines a task. A task is &lt;br /&gt;most often a procedure or application program. The descriptor for the procedure or application &lt;br /&gt;program is stored in the global descriptor table, so access can be controlled through the privilege &lt;br /&gt;levels. The task register allows a context or task switch in about 17 j.1S. Task switching allows the &lt;br /&gt;microprocessor to switch between tasks in a fairly short amount of time. The task switch allows &lt;br /&gt;multitasking systems to switch from one task to another in a simple and orderly fashion. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MEMORY PAGING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory paging mechanism located within the 80386 and above allows any physical &lt;br /&gt;memory location to be assigned to any linear address. The linear address is defined as the address &lt;br /&gt;generated by a program. With the memory paging unit, the linear address is invisibly translated &lt;br /&gt;into any physical address. This allows an application written to function at a spec'ific address to be &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-4 MEMORY PAGING 61 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M P D T P V &lt;br /&gt;C S E S VM CR4 Pentium/Pentium Pro only &lt;br /&gt;E E D I E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PP &lt;br /&gt;Page directory base address CW CR3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page fault linear address CR2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reserved CR1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P C N A W N E T E M P &lt;br /&gt;G D W M P E T S M P E CRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ex) CD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-11 The control register structure of the microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;relocated through the paging mechanism. It also allows memory to be placed into areas where no &lt;br /&gt;memory exists. An example is the upper memory blocks provided by EMM386.EXE. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The EMM386.EXE program reassigns extended memory, in 4K blocks, to the system &lt;br /&gt;memory between the video BIOS and the system BIOS ROMS to provide upper memory blocks. &lt;br /&gt;Without the paging mechanism, the use of this area of memory is impossible. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Paging Registers &lt;br /&gt;The paging unit is controlled by the contents of the microprocessor's control registers. Refer to &lt;br /&gt;Figure 2-11 for the contents of control registers CRO through CR3. Note that these registers are &lt;br /&gt;only available to the 80386 through the Pentium Pro microprocessors. Also note that the Pen-&lt;br /&gt;tiumlPentium Pro contain an additional control register labeled CR4 that controls extensions pro-&lt;br /&gt;vided in the PentiumlPentium Pro microprocessors. One of these features is a 4M byte page that &lt;br /&gt;is enabled by setting bit position 4 or CR4. Refer to Chapter 17 for additional detail on 4M byte &lt;br /&gt;memory paging. Note that at this time no operating system supports 4M byte memory paging. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The registers important to the paging unit are CRO and CR3. The leftmost bit (PG) position &lt;br /&gt;of CRO selects paging' when placed at a logic 1 level. If the PG bit is cleared (0), the linear ad-&lt;br /&gt;dress generated by the program becomes the physical address use~ to access memory. If the PG &lt;br /&gt;bit is set 0), the linear address is converted to a physical address through the paging mechanism. &lt;br /&gt;The paging mechanism functions in both the real and protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The contents of CR3 contain the page dire~tory base address and the PCD and PWT bits. &lt;br /&gt;The PCD and PWT bits control the operation of the PCD and PWT pins on the microprocessor. &lt;br /&gt;If PCD is set (1), the PCD pin becomes a logic one durin~ bus cycles that are not pages. This al-&lt;br /&gt;lows the external hardware to control the level 2 cache' memory. (Note that the level 2 cache &lt;br /&gt;memory is an external high-speed memory. It functions as a buffer between the microprocessor &lt;br /&gt;and the main DRAM memory system.) The PWT bit also appears on the PWT pin during bus cy-&lt;br /&gt;cles that are not pages to control the write-through cache in the system. The page directory base &lt;br /&gt;address locates the page directory for the page translation unit. Note that this address locates the &lt;br /&gt;page directory at any 4K boundary in the memory system, because it is appended internally with &lt;br /&gt;a OOOH. The page directory contains l,024 directory entries of four bytes each. Each page direc-&lt;br /&gt;tory entry addresses a page table that contains 1,024 entries. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;62 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Directory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C\\J~ &lt;br /&gt;C\\J C\\J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6543210 &lt;br /&gt;DAPPUWP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CW &lt;br /&gt;DT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Present &lt;br /&gt;Writable &lt;br /&gt;User defined &lt;br /&gt;Write-through &lt;br /&gt;Cache disable &lt;br /&gt;Accessed &lt;br /&gt;Dirty (0 in page directory) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-12 The format for the linear address (a) and a page directory or page table entry (b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The linear address, as it is generated by the software, is broken into three sections that are &lt;br /&gt;used to access the page directory entry, page table entry, and page offset address. Figure 2-12 &lt;br /&gt;shows the linear address and its makeup for paging. Notice how the leftmost 10 bits address an &lt;br /&gt;entry in the page directory. For linear address 00000000H-003FFFFFH, the first entry of the page &lt;br /&gt;directory is accessed. Each page directory entry represents a 4M byte section of the memory &lt;br /&gt;system. The contents of the page directory select a page table that is indexed by the next 10 bits of &lt;br /&gt;the linear address (bit positions 12-21). This means that address OOOOOOOOH-OOOOOFFFH selects &lt;br /&gt;page directory entry 0 and page table entry O. Notice that this is a 4K byte address range. The offset &lt;br /&gt;part of the linear address (bit positions 0-11) next selects a byte in the 4K byte memory page. In &lt;br /&gt;Figure 2-12, if the page table 0 entry contains address OOlOOOOOH, then the physical address is &lt;br /&gt;00100000H-00100FFFH for linear address OOOOOOOOH-OOOOOFFFH. This means that when the &lt;br /&gt;program accesses a location between OOOOOOOOH and OOOOOFFFH, the microprocessor physically &lt;br /&gt;addresses location 001 OOOOOH-OO I OOFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the act of repaging a 4K byte section of memory requires access to the page di-&lt;br /&gt;rectory and a page table, both located in memory, Intel has incorporated a cache called the TLB &lt;br /&gt;(translation look-aside buffer). In the 80486 microprocessor, the cache holds the 32 most re-&lt;br /&gt;cent page translation addresses. This means that the last 32 page table translations are stored in &lt;br /&gt;the TLB, so if the same area of memory is accessed, the address is already present in the TLB &lt;br /&gt;and access to the page directory and page tables is not required. This speeds program execution. &lt;br /&gt;If a translation is not in the TLB, then the page directory and page table must be accessed, which &lt;br /&gt;requires additional execution time. The Pentium and Pe~tium Pro both contain a separate TLB &lt;br /&gt;for each of their instruction and data caches. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Page Directory and Page TablE &lt;br /&gt;Figure 2-13 shows the page directory, a few page tables, and some memory pages. There is only &lt;br /&gt;one page directory in the system. The page directory contains 1,024 doubleword addresses that &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CR3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2-4 MEMORY PAGING 63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory pages &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dir Page Offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page tables &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page directory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The pagl,g meOha'I'\\' the 80386, 80486, Pe,lI&amp;quot;m, a,d P,&amp;quot;II&amp;quot;m Pro mlocoprooe,&amp;quot;oc &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;locate up to 1,024 page tables. The page directory and each page table are 4K bytes in length. If &lt;br /&gt;the entire 4G bytes of memory are paged, the system must allocate 4K bytes of memory for the &lt;br /&gt;page directory and 4K times 1,024 or 4M bytes for the 1,024 page tables. This represents a con-&lt;br /&gt;siderable investment in memory resources. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The DOS system and EMM386.EXE use page tables to redefine the area of memory be-&lt;br /&gt;tween locations C8000H-EFFFFH as upper memory blocks. They do this by repaging extended &lt;br /&gt;memory to back-fill this part of the conventional memory system to allow DOS access to addi-&lt;br /&gt;tional memory. Suppose that the EMM386.EXE program allows access to 16M bytes of ex-&lt;br /&gt;tended and conventional memory through paging, and locations C8000H-EFFFFH must be &lt;br /&gt;repaged to locations 110000-138000H with all other areas of memory paged to their normal 10-&lt;br /&gt;cations. Such a scheme is depicted in Figure 2-14. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Here the page directory contains four entries. Recall that each entry in the page directory &lt;br /&gt;corresponds to 4M bytes of physical memory. The system also contains four page tables with &lt;br /&gt;1,024 entries each. Recall that each entry in the page table repages 4K bytes of physical memory. &lt;br /&gt;This scheme requires a total of 16K of memory for the four page tables and 16 bytes of memory &lt;br /&gt;for the page directory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with DOS, the Windows program also repages the memory system. At present, Win-&lt;br /&gt;dows 3.11 only supports paging for 16M bytes of memory because of the amount of memory re-&lt;br /&gt;quired to store the page tables. On the Pentium and Pentium Pro microprocessors, pages can be &lt;br /&gt;either 4K bytes in length or 4M bytes in length. Although no software currently supports the 4M &lt;br /&gt;byte pages, as the Pentium Pro and more advanced versions such as the P7 pervade the personal &lt;br /&gt;computer scene, operating systems of the future will undoubtedly begin to support 4M byte &lt;br /&gt;memory pages. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;64 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 2-14 The page &lt;br /&gt;directory, page table 0, 00003FFG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00003FF8 &lt;br /&gt;00003FF4 &lt;br /&gt;00003FFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page table 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003F003 &lt;br /&gt;and two memory pages. &lt;br /&gt;Note how the address of &lt;br /&gt;page 000C8000-000C9000 &lt;br /&gt;has been moved to &lt;br /&gt;00110000-00110FFF. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003E003 &lt;br /&gt;0003D003 &lt;br /&gt;0003C003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00110FFF ~ &lt;br /&gt;00110FFE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2-5 SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00003328 &lt;br /&gt;00003324 &lt;br /&gt;00003320 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00003008 &lt;br /&gt;00003004 &lt;br /&gt;00003000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000200G &lt;br /&gt;00002008 &lt;br /&gt;00002004 &lt;br /&gt;00002000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00112003 &lt;br /&gt;00111003 &lt;br /&gt;00110003 &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00002003 &lt;br /&gt;00001003 &lt;br /&gt;00000003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00003003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page directory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00110002 ~ &lt;br /&gt;00110001 &lt;br /&gt;00110000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page 000G8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOFFF ~ &lt;br /&gt;OOOOOFFE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000002 ~ &lt;br /&gt;00000001 &lt;br /&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page OOOOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The prograf!1ming model of the 8086 through 80286 contains 8- and l6-bit registers. The &lt;br /&gt;programming model of the 80386 and above contains 8-, 16-, and 32-bit extended registers &lt;br /&gt;as well as t~o additional l6-bit segment registers: FS and GS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The 8-bit registers are AR, AL, BR, BL, CR, CL, DR, and DL. The l6-bit registers are AX, &lt;br /&gt;BX, CX, DX, SP, BP, DI, and SI. The segment registers are CS, DS, ES, SS, FS, and GS. The &lt;br /&gt;32-bit extended registers are EAX, EBX, ECX, EDX, ESP, EBP, EDI, and ESI. In addition, the &lt;br /&gt;microprocessor contains an instruction pointer (lPIEIP) and flag register (FLAGS or EFLAGS). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. All real mode memory addresses are a combin~tion of a segment address plus an offset ad-&lt;br /&gt;dress. The starting location of a segment is defined by the l6-bit number in the segment reg-&lt;br /&gt;ister that is appended with a hexadecimal zero to its rightmost end. The offset address is a &lt;br /&gt;l6-bit number added to the 20-bit segment address to form the real mode memory address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. All instructions (code) are accessed by the combination of CS (segment address) plus IP or &lt;br /&gt;EIP (offset address). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Data are normally referenced through a combination of the DS (data segment) and either an &lt;br /&gt;offset address or the contents of a register ~ha~ contains the offset address. The 8086 through &lt;br /&gt;the Pentium Pro use BX, DI, and SI as default offset registers for data if 16-bit registers are &lt;br /&gt;selected. The 80386 and above can use the 32-bit registers EAX, EBX, ECX, EDX, EDI, &lt;br /&gt;and ESI as default offset registers for data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Protected ~ode operation allows memory above the first 1M byte to be accessed by the &lt;br /&gt;80286 throu~h the Pentium Pro microprocessors. This extended memory system (XMS) is &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2-6 QUESTIONS AND PROBLEMS 65 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;accessed via a segment address plus an offset address, just as in the real mode. The differ-&lt;br /&gt;ence is that the segment address is not held in the segment register. In the protected mode, &lt;br /&gt;the segment starting address is stored in a descriptor that is selected by the segment register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. A protected mode descriptor contains a base address, limit, and access rights byte. The base &lt;br /&gt;address locates the starting address of the mert10ry segment. The limit defines the last loca-&lt;br /&gt;tion of the segment. The access rights byte defines how the memory segment is accessed via &lt;br /&gt;a program. The 80286 microprocessor allows a memory segment to start at any of its 16M &lt;br /&gt;bytes of memory using a 24-bit base address. The 80386 and above allow a memory seg-&lt;br /&gt;ment to begin at any of their 40 bytes of memory using a 32-bit base address. The limit is a &lt;br /&gt;16-bit number in the 80286 and a 20-bit number in the 80386 and above. This allows an &lt;br /&gt;80286 memory segment limit of 64K bytes and an 80386 and above memory segment limit &lt;br /&gt;of either 1M byte (0 = 0) or 40 bytes (0 = 1). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. The segment register contains three fields of information in the protected mode. The leftmost &lt;br /&gt;13 bits of the segment register address one of 8,192 descriptors from a descriptor table. The &lt;br /&gt;TI bit accesses either the global descriptor table (TI = 0) or the local descriptor table (TI = 1). &lt;br /&gt;The rightmost 2 bits of the segment register select the requested priority level for the &lt;br /&gt;memory segment access. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The program invisible registers are used by the 80286 and above to access the descriptor ta-&lt;br /&gt;bles. Each segment register contains a cache portion that is used in protected mode to hold &lt;br /&gt;the base address, limit, and access rights acquired from a descriptor. The cache allows the &lt;br /&gt;microprocessor to access the memory segment without again referring to the descriptor table &lt;br /&gt;until the segment register's contents are changed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. A memory page is 4K bytes in length. The linear address, as generated iJy a prQgram, can be &lt;br /&gt;mapped- to -ariY- physicaTadd~~~~ through the pagIng mechanis~-fo~nd within the 80386 &lt;br /&gt;thrOugn~thePentium Pro microprocessors. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. Memory paging is accomplished through control registers ~BO and ~R3. The PObit of CRO &lt;br /&gt;enables paging and the contents of CR3 addresses the page directory. The p;ge directory &lt;br /&gt;contains upÂ·-toÂ· 1:024 page table addresses used to access paging tables. The page table con-&lt;br /&gt;tains 1,024 entriesthatlocate the physical address Of~i4K byte memory page. --&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The TLB (translation look-aside buffer) caches the 32 most recent page table translations. &lt;br /&gt;This precludes page table translation if the translation resides in the TLB, speeding the exe-&lt;br /&gt;cution of software. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. What are program-visible registers? &lt;br /&gt;2. The 80286 addresses registers that are 8- and - bits wide. &lt;br /&gt;3. The extended registers are addressable by which microprocessors? &lt;br /&gt;4. The extended BX register is addressed as ______ , &lt;br /&gt;5. Which register holds a count for some instructions? &lt;br /&gt;6. What is the purpose of the IPIEIP register? &lt;br /&gt;7. The carry flag bit is set by what arithmetic operations? &lt;br /&gt;8. Will an overflow occur if a signed FFH is added to a signed 01H? &lt;br /&gt;9. A number that contains 3 one bits is said to have parity. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Which flag bit controls the INTR pin on the microprocessor? &lt;br /&gt;11. Which microprocessors contain an FS segment register? &lt;br /&gt;12. What is the purpose of a segment register in the real mode operation of the microprocessor? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;66 CHAPTER 2 THE MICROPROCESSOR AND ITS ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. In the real mode, show the starting and ending addresses of each segment located by the fol-&lt;br /&gt;lowing segment register values: &lt;br /&gt;(a) 1000H &lt;br /&gt;(b) 1234H &lt;br /&gt;(c) 2300H &lt;br /&gt;(d) EOOOH &lt;br /&gt;(e) ABOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Find the memory address of the next instruction executed by the microprocessor, when op-&lt;br /&gt;erated in the real mode, for the following CS:IP combinations: &lt;br /&gt;(a) CS = 1000H and IP = 2000H &lt;br /&gt;(b) CS = 2000H and IP = 1000H &lt;br /&gt;(c) CS = 2300H and IP = lAOOH &lt;br /&gt;(d) CS = lAOOH and IP = BOOOH &lt;br /&gt;(e) CS = 3456H and IP = ABCDH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. Real mode memory addresses allow access to memory below which address? &lt;br /&gt;16. Which register or registers are used as an offset address for string instruction destinations in &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the 80486 microprocessor? &lt;br /&gt;17. Which 32-bit register or registers are used as an offset address for data segment data in the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 microprocessor? &lt;br /&gt;18. The stack memory is addressed by a combination of the segment plus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;______ offset. &lt;br /&gt;19. If the base pointer (BP) addresses memory, the segment contains the data. &lt;br /&gt;20. Determine the memory location addressed by the following real mode 80286 register com-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;binations: &lt;br /&gt;(a) DS = 1000H and DI = 2000H &lt;br /&gt;(b) DS = 2000H and SI = 1002H &lt;br /&gt;(c) SS = 2300H and BP = 3200H &lt;br /&gt;(d) DS = AOOOH and BX = 1000H &lt;br /&gt;(e) SS = 2900H and SP = 3AOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21. Determine the memory location addressed by the following real mode 80386 register com-&lt;br /&gt;binations: &lt;br /&gt;(a) DS = 2000H and EAX = 00003000H &lt;br /&gt;(b) DS = lAOOH and ECX = 00002000H &lt;br /&gt;(c) DS = COOOH and ESI = OOOOAOOOH &lt;br /&gt;(d) SS = 8000H and ESP = 00009000H &lt;br /&gt;(e) DS = 1239H and EDX = 0000A900H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22. Protected mode memory addressing allows access to which area of the memory in the 80286 &lt;br /&gt;microprocessor? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;23. Protected mode memory addressing allows access to which area of the memory in the Pen-&lt;br /&gt;tium microprocessor? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24. What is the purpose of the segment register in protected mode memory addressing? &lt;br /&gt;25. How many descriptors are accessible in the global descriptor table in the protected mode? &lt;br /&gt;26. For an 80286 descriptor that contains a base address of AOOOOOH and a limit of 1000H, what &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;starting and ending locations are addressed by this descriptor? &lt;br /&gt;27. For an 80486 descriptor that contains a base address of 01000000H, a limit ofOFFFFH, and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G = 0, what starting and ending locations are addressed by this descriptor? &lt;br /&gt;28. For a Pentium descriptor that contains a base address of 00280000H, a limit of OOOlOH, and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G = I, what starting and ending locations are addressed by this descriptor? &lt;br /&gt;29. If the DS register contains 0020H, in a protected mode system, which global descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;entry is accessed? &lt;br /&gt;30. If DS = 0103H, in a protected mode system, the requested privilege level is _____ _ &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2-6 QUESTIONS AND PROBLEMS 67 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31. If DS = 0105H, in a protected mode system, which entry, table, and requested privilege level &lt;br /&gt;are selected? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32. What is the maximum length of the global descriptor table in the Pentium microprocessor? &lt;br /&gt;33. Code a descriptor that describes a memory segment that begins at location 210000H and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ends at location 21001 FH. This memory segment is a code segrn ~nt that can be read. The de-&lt;br /&gt;scriptor is for an 80286 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. Code a descriptor that describes a memory segment that begins at location 03000000H and &lt;br /&gt;ends at location 05FFFFFFH. This memory segment is a data segment that grows upward in &lt;br /&gt;the memory system and can be written. The descriptor is for an 80386 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;35. Which register locates the global descriptor table? &lt;br /&gt;36. How is the local descriptor table addressed in the memory system? &lt;br /&gt;37. Describe what happens when a new number is loaded into a segment register when the mi-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;croprocessor is operated in the protected mode. &lt;br /&gt;38. What are the program-invisible registers? &lt;br /&gt;39. What is the purpose of the GDTR? &lt;br /&gt;40. How many bytes are found in a memory page? &lt;br /&gt;41. What register is used to enable the paging mechanism in the 80386, 80486, Pentium, and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro microprocessors? &lt;br /&gt;42. How many 32-bit addresses are stored in the page directory? &lt;br /&gt;43. Each entry in the page directory translates how much linear memory into physical memory? &lt;br /&gt;44. If the microprocessor sends linear address 00200000H to the paging mechanism, which &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;paging directory entry is accessed, and which page table entry is accessed? &lt;br /&gt;45. What value is placed in the page table to redirect linear address 20000000H-30000000H? &lt;br /&gt;46. What is the purpose of the TLB located within the 80486 microprocessor? &lt;br /&gt;47. Use the Internet to locate the Texas Instruments web page and write a report that details the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;types of memory devices manufactured by Texas Instruments. &lt;br /&gt;48. Use the Internet to locate the Intel web page and list the types of embedded microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;available. &lt;br /&gt;49. Use the Internet to locate the AMD web page and list the types of microprocessors produced. &lt;br /&gt;50. Use the Internet to find web sites that list facts about Intel microprocessors and write a paper &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;that details at least two microprocessors. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;68 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 3 &lt;br /&gt;Addressing Modes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Efficient software development for the microprocessor requires a complete familiarity with &lt;br /&gt;the addressing modes employed by each instruction. In this chapter, the MOV (move data) &lt;br /&gt;instruction is used to describe the data-addressing modes. The MOV instruction transfers bytes &lt;br /&gt;or words of data between registers or between registers and memory in the 8086 through the &lt;br /&gt;80286 and bytes, words, or doublewords in the 80386 and above. In describing the program &lt;br /&gt;memory-addressing modes, the CALL and JMP instructions show how to modify the flow of &lt;br /&gt;the program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The data-addressing modes include register, ~dil!te, 1iL~t, reg!st~!:.inq!.r_ect, base-&lt;br /&gt;p.il!Â§:&amp;quot;.i!ll!ex, r~ister r:,,&amp;lt;!~tive, and b~.~..rdrui)-:,!;.;;plus-i~x in the 8086 through the 80286 mi-&lt;br /&gt;croprocessors. The 80386 and above also include a scaled-index mode of addressing memory &lt;br /&gt;data. The program memory-addressing modes include program relative, direct, and indirect. &lt;br /&gt;The operation of the stack memory is explained so that the PUSH and POP instructions are &lt;br /&gt;understood. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Explain the operation of each data-addressing mode. &lt;br /&gt;2. Use the data-addressing modes to form assembly language statements. &lt;br /&gt;3. Explain the operation of each program memory-addressing mode. &lt;br /&gt;4. Use the program memory-addressing modes to form assembly and machine language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;statements. &lt;br /&gt;5. Select the appropriate addressing mode to accomplish a given task. &lt;br /&gt;6. Detail the difference between addressing memory data using real mode and protected mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;operation. &lt;br /&gt;7. Describe the sequence of events that place data onto the stack or remove data from the stack. &lt;br /&gt;8. Explain how a data structure is placed in memory and used with software. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES 69 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the MOY instruction is common and flexible, it provides a basis for the explanation of &lt;br /&gt;the data-addressing modes. Figure 3-1 illustrates the MOY instruction and defines tbe direction &lt;br /&gt;of data flow. The source is to the right and the destination is to the left, next to the opcode MOY. &lt;br /&gt;(An opcode or operation code tells the microprocessor which operation to perfoim.) This direc-&lt;br /&gt;tion of flow, which is applied to all instructions, initially seems awkward. We naturally assume &lt;br /&gt;that things move from left to right, where as here they move from right to left. Notice that a &lt;br /&gt;comma always separates the destination from the source in an instruction. Also note that ll1emory-&lt;br /&gt;to-memory transfers are not allowed by any instruction except for th~.MOYS instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In Figure 3-1, the MOY AX,BX instruction transfers the word contents of the source reg-&lt;br /&gt;ister (BX) into the destination register (AX). The source never changes, but the destination al-&lt;br /&gt;most always changes. l It is essential to remember that a MOY instruction always copies the &lt;br /&gt;source data into the destination. The MOY never actually picks up the data and moves it. Also &lt;br /&gt;note that the flag register remains unaffected by most data transfer instructions. &lt;br /&gt;Fig~re 3-2 shows all possible variations of the data-addressing modes using the MOY in-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;struction. This illustration helps to show how each data-addressing mode is formulated with the &lt;br /&gt;MOY instruction and also serves as a reference. Note that these are the same data-addressing &lt;br /&gt;modes found with all versions of the Intel microprocessor, except for the scaled-index addressing &lt;br /&gt;mode, which is only found in the 80386 through the Pentium Pro. The data-addressing modes are: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register &lt;br /&gt;addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Immediate &lt;br /&gt;addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Direct &lt;br /&gt;addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Transfers a copy of a byte or word from the source register or memory &lt;br /&gt;location to the destination register or memory location. (Example: the &lt;br /&gt;MOY CX,DX instruction copies the word-sized contents of register &lt;br /&gt;DX into register CX.) In the 80386 and above, a doubleword can be &lt;br /&gt;transferred from the source register or memory location to the desti-&lt;br /&gt;nation register or memory location. (Example: the MOY ECX,EDX &lt;br /&gt;instruction copies the doubleword-sized contents of register EDX &lt;br /&gt;into register ECX.) &lt;br /&gt;Transfers the source-immediate byte or word of data into the destina-&lt;br /&gt;tion register or memory location. (Example: the MOY AL,22H instruc-&lt;br /&gt;tion copies a byte-sized 22H into register AL.) In the 80386 and above, &lt;br /&gt;a c\\oubleword of immediate data can be transferred into a register or &lt;br /&gt;memory location. (Example: the MOY EBX,12345678H instruction &lt;br /&gt;copies a doubleword-sized 12345678H into the 32-bit wide EBX register.) &lt;br /&gt;Moves a byte or word between a memory location and a register. The &lt;br /&gt;instruction set does not support a memory-to-memory transfer, except &lt;br /&gt;for the MOYS instruction. (Example: the MOY CX,LIST instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-1 The MOV in-&lt;br /&gt;struction showing the source, &lt;br /&gt;destination, and direction of &lt;br /&gt;data flow &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;n &lt;br /&gt;MOV AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 Lurce &lt;br /&gt;Destination &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lThe exceptions are the eMP and TEST instructions. which never change the destination. These instructions are de-&lt;br /&gt;scribed in later chapters. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Type &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Immediate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Direct &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register indirect &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base-plus-index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register relative &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base relative-plus-index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Scaled index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CH,3AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [1234Hj,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [BX],CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [BX+Slj,BP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CL,[BX+4] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV ARRAY[BX+SI],DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [EBX+2 x ESlj,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Source &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register &lt;br /&gt;BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address Generation Destination &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I ~;i.~ OS x 10H + OISP _____ _ AX I 10000H + 1234H L--___ ~ &lt;br /&gt;Register OS x 10H + BX _____ _ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CL 10000H + 0300H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I-Re~~l OS x 10H + BX + SI &lt;br /&gt;SP 10000H + 0300H + 0200H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I -~Jdm-r~-~-l OS x 10H + BX + 4 _____ __ 10304H 10000H + 0300H + 4 &lt;br /&gt;Register OS x 1 OH + ARRAY + BX + SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX 10000H + 1000H + 0300H + 0200H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register OS x 10H + EBX + 2 x ESI _ &lt;br /&gt;AX â¢ 10000H + 00000300H + 00000400H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: EBX = 00000300H, ESI = 00000200H, ARRAY = 1000H, and OS = 1000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-2 8086-Pentium-Pro data-addressing modes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-...J &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;::r: &lt;br /&gt;Â» &lt;br /&gt;-0 &lt;br /&gt;--I &lt;br /&gt;m &lt;br /&gt;::JJ &lt;br /&gt;w &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â» &lt;br /&gt;Cl &lt;br /&gt;Cl &lt;br /&gt;::JJ &lt;br /&gt;m &lt;br /&gt;en &lt;br /&gt;en &lt;br /&gt;z: &lt;br /&gt;G) &lt;br /&gt;S &lt;br /&gt;o &lt;br /&gt;Cl &lt;br /&gt;m &lt;br /&gt;en &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES 71 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register indirect &lt;br /&gt;addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base-plus-index &lt;br /&gt;addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register relative &lt;br /&gt;addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base relative-plus-&lt;br /&gt;index addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Scaled-index &lt;br /&gt;addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;copies the word-sized contents of memory location LIST into register &lt;br /&gt;CX.) In the 80386 and above, a doubleword-sized memory location can &lt;br /&gt;also be addressed. (Example: the MOV ESI,LIST instruction copies a &lt;br /&gt;32-bit number, stored in four consecutive bytes of memory, from loca-&lt;br /&gt;tion LIST into register ESI.) &lt;br /&gt;Transfers a byte or word between a register and a memory location &lt;br /&gt;a~&amp;lt;!ressed by an index or base regi;t(;~.T-he index and base registers are &lt;br /&gt;BP, BX, DI, and SI. (Example: the MOV AX,[BX] instruction copies &lt;br /&gt;the word-sized data from the data segment offset address indexed by &lt;br /&gt;BX into register AX.) In the 80386 and above, a byte, word, or double-&lt;br /&gt;word is transferred between a register and a memory location addressed &lt;br /&gt;by any register: EAX, EBX, ECX, EDX, EBP, EDI, or ESI. (Example: &lt;br /&gt;the MOV AL,[ECX] instruction loads AL from the data segment offset &lt;br /&gt;address selected by the contents of ECX.) &lt;br /&gt;Transfers a byte or word between a register and the memory location &lt;br /&gt;addressed by a base register (BP or BX) plus an index register (DI or &lt;br /&gt;SI). (Example: the MOV [BX+DI],CL instruction copies the byte-&lt;br /&gt;sized contents of register CL into the data segment memory location &lt;br /&gt;addressed by BX plus DI.) In the 80386 and above, any register EAX, &lt;br /&gt;EBX, ECX, EDX, EBP, EDI, or ESI may be combined to generate the &lt;br /&gt;memory address. (Example: the MOV [EAX+EBX],CL instruction &lt;br /&gt;copies the byte-sized contents of register CL into the data segment &lt;br /&gt;memory location addressed by EAX plus EBX.) &lt;br /&gt;Moves a byte or word between a register and the memory location &lt;br /&gt;addressed by an index or base register plus a displacement. (Example: &lt;br /&gt;MOV AX,[BX+4] or MOV AX,ARRAY[BX]. The first instruction &lt;br /&gt;loads AX from the data segment address formed by BX plus 4. The &lt;br /&gt;second instruction loads AX from the data segment memory location &lt;br /&gt;in ARRAY plus the contents of BX.) The 80386 and above use any &lt;br /&gt;register to address memory. (Example: MOV AX,[ECX+4] or MOV &lt;br /&gt;AX,ARRAY[EBX]. The first instruction loads AX from the data seg-&lt;br /&gt;ment address formed by ECX plus 4. The second instruction loads &lt;br /&gt;AX from the data segment memory location ARRA Y plus the con-&lt;br /&gt;tents of EBX.) &lt;br /&gt;Transfers a byte or word between a register and the memory location &lt;br /&gt;addressed by a base and an index register plus a displacement. (Example: &lt;br /&gt;MOV AX,ARRA Y[BX+DI] or MOV AX,[BX+Dl+4]. These instruc-&lt;br /&gt;tions both load AX from a data segment memory location. The first &lt;br /&gt;instruction uses an addies;;-t'orinecfby adding ARRAY, BX, and DI; &lt;br /&gt;the second, by adding BX, DI, and 4.) (An 80386 and above example: &lt;br /&gt;MOV EAX,ARRA Y[EBX+ECX] loads EAX from the data segment &lt;br /&gt;memory location accessed by the sum of ARRAY, EBX, and ECX.) &lt;br /&gt;Is available only in ~~_~Q}8QJ:llrough the Pentiu~,Pro )llicroprocessors. &lt;br /&gt;The second register of a pair of registers is modified by the scale factor &lt;br /&gt;of2X, 4X, or 8X to generate the operand !l!eII1gryadgress. (Example: &lt;br /&gt;a MOV EDX,[EAX+4*EBX] instruction loads EDX from the data &lt;br /&gt;segment memory location addressed by EAX plus 4 times EBX.) Scal-&lt;br /&gt;ing allows access to word (2X), doubleword (4X), or quadword (8X) &lt;br /&gt;memory ~ay data. Not~that a scaling factor of IX also exists, but it &lt;br /&gt;is normally implied and does not appear in the instruction. The MOV &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register Addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,[EBX+ECX] is an example where the scaling factor is a one. Al-&lt;br /&gt;ternately, the instruction can be rewritten as MOV AL,[EBX+ 1 *ECX]. &lt;br /&gt;Another example is a MOV AL,[2*EBX] instruction, which uses &lt;br /&gt;only one scaled register to address memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register addressing is the most common form of data addressing and, once the register names &lt;br /&gt;are learned, is the easiest to apply. The microprocessor contains the following 8-bit registers &lt;br /&gt;used with register addressing: AH, AL, BH, BL, CH, CL, DH, and DL. Also present are the fol-&lt;br /&gt;lowing 16-bit registers: AX, BX, CX, OX, SP, BP, SI, and 01. In the 80386 and above, the ex-&lt;br /&gt;tended 32-bit registers are EAX, EBX, ECX, EOX, ESP, EBP, EDI, and ESI. With register &lt;br /&gt;addressing, some MOV instructions and the PUSH and POP instructions also use the 16-bit seg-&lt;br /&gt;ment registers (CS, ES, OS, SS, FS, and OS). It is important for instructions to use registers that &lt;br /&gt;are the same size. Never mix an 8-bit register with a 16-bit register, an 8-bit register with a 32-bit &lt;br /&gt;register, or a 16-bit register with 32-bit register, because this is not allowed by the micro-&lt;br /&gt;processor and results in an error when assembled. This is even true when a MOV AX,AL or a &lt;br /&gt;MOV EAX,AL instruction may seem to make sense. Of course, the MOV AX,AL or MOV &lt;br /&gt;EAX,AL instructions are not allowed, because these registers are of different sizes. Note that a &lt;br /&gt;few instructions, such as SHL OX,CL, are exceptions to this rule, as indicated in later chapters. &lt;br /&gt;It is also important to note that none of the MOYiMtructions affect the flagjJits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 3-1 shows many variations of register move instructions. It is impossible to show all &lt;br /&gt;of the many possible combinations. For example, just the 8-bit subset of the MOV instruction &lt;br /&gt;has 64 different variations. A segment-to-segment register MOV instruction is virtually the only &lt;br /&gt;type of register MOV instruction not allowed. Also note that the code segment register may not &lt;br /&gt;be changed by a MOV instruction, because the address of the next instruction is found in both &lt;br /&gt;IPIEIP and CS. If only CS were changed, the address of the next instruction would be unpre-&lt;br /&gt;dictable. Therefore, changing the CS register with a MOV instruction is not allowed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 3-3 shows the operation of the MOV BX,CX instruction. Note that the source reg-&lt;br /&gt;ister's contents do not change. but the destination register's contents do change. This instruction &lt;br /&gt;moves (copies) a l234H from register CX into register BX. This erases the old contents (76AFH) &lt;br /&gt;of register BX, but the contents of CX remain unchanged. The contents of the destination register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Examples of &lt;br /&gt;the register-addressed Assembly Language Size Operation &lt;br /&gt;instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,BL 8-bits Copies BL into AL &lt;br /&gt;MOVCH,CL 8-bits Copies CL into CH &lt;br /&gt;MOVAX,CX 16-bits Copies CX into AX &lt;br /&gt;MOV SP,BP 16-bits Copies BP into SP &lt;br /&gt;MOV OS,AX 16-bits Copies AX into OS &lt;br /&gt;MOV SI,OI 16-bits Copies 01 into SI &lt;br /&gt;MOV BX,ES 16-bits Copies ES into BX &lt;br /&gt;MOV ECX,EBX 32-bits Copies EBX into ECX &lt;br /&gt;MOV ESP,EOX 32-bits Copies EOX into ESP &lt;br /&gt;MO I ES,OS Not allowed (segment-to-segment) &lt;br /&gt;MOV BL,OX Not allowed (mixed sizes) &lt;br /&gt;MOVCS,AX Not allowed (the code segment register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;may not be the destination register) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-3 The effect of &lt;br /&gt;executing the MOV BX, ex &lt;br /&gt;instruction at the point just &lt;br /&gt;before the BX register &lt;br /&gt;changes. Note that only the &lt;br /&gt;rightmost 16-bits of register &lt;br /&gt;EBX change. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 2 3 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 A C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;73 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 A F &lt;br /&gt;'&amp;lt;' &amp;quot;' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 3 4 1 234 ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or destination memory location change for all instructions except the eMP and TEST instruc-&lt;br /&gt;tions. Note that the MOY BX,eX instruction does not affect the leftmost 16-bits of register EBX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 3-1 shows a sequence of assembled instructions that copy various data between 8-, &lt;br /&gt;16-, and 32-bit registers. As mentioned, the act of moving data from one register to another only &lt;br /&gt;changes the destination register, never the source. The last instruction in this example (MOY eS,AX) &lt;br /&gt;~ss~llltJles without error, but calls(!s groblems if executed. If only the contents of es change without &lt;br /&gt;changing IP, the next step in the program is unknown and the program consequently goes awry. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-1 &lt;br /&gt;0000 8B C3 ; copy contents of BX into AX &lt;br /&gt;0002 8A CE ; copy the contents of DH into CL &lt;br /&gt;0004 8A CD ; copy the contents of CH into CL &lt;br /&gt;0006 6618B C3 ; copy the contents of EBX into EAX &lt;br /&gt;0009 6618B D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,BX &lt;br /&gt;MOV CL,DH &lt;br /&gt;MOV CL,CH &lt;br /&gt;MOV EAX,EBX &lt;br /&gt;MOV EBX,EAX &lt;br /&gt;MOV ECX,EAX &lt;br /&gt;MOV EDX,EAX &lt;br /&gt;MOV AX,CS &lt;br /&gt;MOV DS,AX &lt;br /&gt;MOV CS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; copy EAX into EBX, ECX, and EDX &lt;br /&gt;OOOC 6618B C8 &lt;br /&gt;OOOF 6618B DO &lt;br /&gt;0012 8C C8 ;copy CS into DS &lt;br /&gt;0014 8E D8 &lt;br /&gt;0016 8E C8 ;assembles, but will cause problems &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Immediate Addressing &lt;br /&gt;Another data-addressing mode is immediate addressing. The term immediate implies that the data &lt;br /&gt;immediately follow the hexadecimal opcode in the memory. Also note that immediate data are &lt;br /&gt;constant data, while the data transferred from a register are variable data. Immediate addressing &lt;br /&gt;operates upon a byte or word of data. In the 80386 through the Pentium Pro microprocessors im-&lt;br /&gt;mediate addressing also operates on doubleword data. The MOY immediate instruction transfers a &lt;br /&gt;copy of the immediate data into a register or a memory location. Figure 3-4 shows the operation of &lt;br /&gt;a MOY EAX,13456H instruction. This instruction copies the 13456H from the instruction,located &lt;br /&gt;in the memory immediately following the hexadecimal opcode, into register EAX. As with the &lt;br /&gt;MOV instruction illustrated in Figure 3-3, the source data overwrite the destination data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In symbolic assembly language, the symbol # precedes immediate data in some assem-&lt;br /&gt;blers.2 The MOY AX,#3456H instruction is an example. Most assemblers do~not use lhe .# &lt;br /&gt;symbol but represent immediate data as shown in the MOV AX,3456H instruction. In this text, &lt;br /&gt;the # symbol is not used for immediate data. The most common assemblers-Intel ASM, Mi-&lt;br /&gt;crosoft MASM3, and Borland T ASM4--do not use the # symbol for immediate data, but older &lt;br /&gt;assembI~r~-used with some Hewlett-Packard logic development systems do, as may others. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2This is true for the assembler provided by Hewlett-Packard in some development systems. &lt;br /&gt;!MASM (MACRO assembler) is a trademark of Microsoft Corporation. &lt;br /&gt;-IT ASM (Turbo assembler) is a trademark of Borland Corporation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;74 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-4 The operation &lt;br /&gt;of the MOV EAX,3456H in-&lt;br /&gt;struction. This instruction &lt;br /&gt;copies the immediate data &lt;br /&gt;(13456H) into EAX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register array Program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The symbolic assembler portrays immediate data in many ways. The letter H appends &lt;br /&gt;hexadecimal data. If hexadecimal data begin with a letter, the assembler requires that the data &lt;br /&gt;start with a O. For example, to represent a hexadeci~, a OF2H is used in assembly language. &lt;br /&gt;In s~e assemblers (though not in MASM, TASM, or this text), hexadecimal data are repre-&lt;br /&gt;sented with an 'h, as in MOV AX,#'h1234. Decimal data are represented as is, and require no &lt;br /&gt;special codes or adjustments. An example is the 100 decimal in the MOV AL,lOO instruction. &lt;br /&gt;An ASCII-coded character or characters may be depicted in the immediate form if the ASCII &lt;br /&gt;data are enclosed in apostrophes. An example is the MOV BH,' A' instruction, which moves an &lt;br /&gt;ASCII-coded _A (~Â·1~2.i~.!.~.1.!&amp;lt;g!~ter BH. Be careful to use the apostr.91!h.e (') for ASCII data, and &lt;br /&gt;not the single quotation mark n. Binary data are represented if the binary number is followed by &lt;br /&gt;the letter B or, in some assemblers, the letter Y. Table 3-2 shows many different variations of &lt;br /&gt;MOV instructions that apply immediate data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 3-2 shows various immediate instructions in a short program that places a OOOOH &lt;br /&gt;into the 16-bit registers AX, BX, and CX. This is followed by instructions that use register ad-&lt;br /&gt;dressing to copy the contents of AX into registers SI, DI, and BP. This is a complete program &lt;br /&gt;that uses programming models for assembly and execution. The .MODEL TINY statement di-&lt;br /&gt;rects the assembler to assemble the program into a single segment. The .CODE statement or di-&lt;br /&gt;rective indicates the start of the code segment; the .STARTUP statement indicates the starting &lt;br /&gt;instruction in the program; and the .EXIT statement causes the program to exit to DOS. The &lt;br /&gt;END statement indicates the end of the program file. This program can be assembled with &lt;br /&gt;MASM and executed with CodeView5 (CV) to view its execution. To store the program into the &lt;br /&gt;system, use either the DOS EDIT program or Programmer's WorkBench6 (PWB). Note that a &lt;br /&gt;TINY program assembles as a command (.COM) program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 B8 0000 &lt;br /&gt;0103 BB 0000 &lt;br /&gt;0106 B9 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0109 8B FO &lt;br /&gt;010B 8B F8 &lt;br /&gt;OlOD 8B E8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,O &lt;br /&gt;MOV BX,OOOOH &lt;br /&gt;~lOV CX,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV SI,AX &lt;br /&gt;MOV DI,AX &lt;br /&gt;MOV BP,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;choose single segment model &lt;br /&gt;;indicate start of code segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;indicate start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;p1ace OOOOH into AX &lt;br /&gt;;p1ace OOOOH into BX &lt;br /&gt;;p1ace OOOOH into CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;copy AX into SI &lt;br /&gt;;copy AX into DI &lt;br /&gt;;copy AX into BP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each statement in a program consists of four parts or fields, as illustrated in Example 3-3. &lt;br /&gt;The leftmost field is called the label; ilnd it is used to store a symbolic name for the memory lo-&lt;br /&gt;cation that it represents. All labels be3;n~le.t1er or one of the following special characters: &lt;br /&gt;@, $, _, or? A label may be of any length from 1 to 35 characters. The label appears in a pro-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5Code View is a registered trademark of Microsoft Corporation. &lt;br /&gt;6Programmer's WorkBench is a registered trademark of Microsoft Corporation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-2 Examples of &lt;br /&gt;immediate addressing using &lt;br /&gt;the MOV instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL,44 &lt;br /&gt;MOV AX,44H &lt;br /&gt;MOV SI,O &lt;br /&gt;MOV CH,100 &lt;br /&gt;MOV AL,'A' &lt;br /&gt;MOV AX,'AB' &lt;br /&gt;MOV CL, 1100111 DB &lt;br /&gt;MOV EBX,12340000H &lt;br /&gt;MOV ESI,12 &lt;br /&gt;MOV EAX,l OOY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bits &lt;br /&gt;16-bits &lt;br /&gt;16-bits &lt;br /&gt;8-bits &lt;br /&gt;8-bits &lt;br /&gt;16-bits &lt;br /&gt;8-bits &lt;br /&gt;32-bits &lt;br /&gt;32-bits &lt;br /&gt;32-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;75 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Copies a 44 decimal (2CH) into BL &lt;br /&gt;Copies a 0044H into AX &lt;br /&gt;Copies a OOOOH into SI &lt;br /&gt;Copies a 100 decimal (64H) into CH &lt;br /&gt;Copies an ASCII A into AL &lt;br /&gt;Copies an ASCII BA - into AX &lt;br /&gt;Copies a 11001110 binary into CL &lt;br /&gt;Copies a 12340000H into EBX &lt;br /&gt;Copies a 12 decimal into ESI &lt;br /&gt;Copies a 100 binary into EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-Note: This is not an error. The ASCII characters are stored as a BA, so care should be &lt;br /&gt;exercised when using a word-sized pair of ASCII characters. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;gram to identify the name of a memory location for storing data and for other purposes that are &lt;br /&gt;explained in the text as they appear. The next field is called the !!'p~ocle field; it is designed to &lt;br /&gt;hold the instruction or opcode. The MOV instruction is an example of an opcode. To the right of &lt;br /&gt;the opcode field is the operand field, which contains information used by the opcode. For ex-&lt;br /&gt;ample, the MOV AL,BL instruction has the opcode MOV and operands AL and BL. Note that &lt;br /&gt;some instructions contain between zero and three operands. The final field, the ,(:pmment field, &lt;br /&gt;contains a comment about an instruction or a group of instructions. A comment always begins &lt;br /&gt;with a semicolon (;). . &amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-3 &lt;br /&gt;LABEL OPCODE OPERAND COMMENT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATAl DB 23H ;define DATAl as a byte of 23H &lt;br /&gt;DATA2 DW 1000H ; define DATA2 as a word of 1000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;START: MOV AL,BL ;copy BL into AL &lt;br /&gt;MOV BH,AL ;copy AL into BH &lt;br /&gt;MOV CX,200 ;copy 200 decimal into ex &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ When the program is assembled and the list (.LST) file is viewed, it appears as the pro-&lt;br /&gt;gram listed in Example 3-2. The hexadecimal number at the far left is the offset address of the &lt;br /&gt;instruction or data. This number is generated by the assembler. The number or numbers to the &lt;br /&gt;right ofihe offset address are the macruIi.e-coded instructions or data that are also generated by &lt;br /&gt;the assembler. For example, if the MOV AX,O instruction appears il,l a file and it is assembled, it &lt;br /&gt;appears in memory location 0100 in Example 3-2. Its hexadecimal machine language form isB8 &lt;br /&gt;0000. When the program was written, only the MOV AX,O instruction was typed into the editor; &lt;br /&gt;th~'~ssembler generated the machine code and-address and stored the program in a file ending &lt;br /&gt;with the extension .LST. Not~-that all programs shown in this text are in the form generated by &lt;br /&gt;the assembler. - .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Direct Data Addressing &lt;br /&gt;Most instructions can use the direct data addressing mode. In fact, direct data addressing is ap-&lt;br /&gt;plied to many instructions in a typical program. There are two basic forms of direct data ad-&lt;br /&gt;dressing: (1) direct addressing, which applies to a MOV between a memory location and AL, &lt;br /&gt;AX, or EAX, and (2) displacement addressing, which applies to almost any instruction in the &lt;br /&gt;instruction set. In either case, the address is formed by adding the displacement to the default &lt;br /&gt;data segment address or an alternate segment address. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;76 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&amp;quot;&amp;quot;&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11235H &lt;br /&gt;AH AL 1&amp;lt; BAH BAH B A EAX 11234H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX 11233H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECX 11232H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;FIGURE 3-5 The operation of the MOV AL,[1234H] instruction when OS = 1000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Direct Addressing. Direct addressing, with a MOV instruction, transfers data between a mem-&lt;br /&gt;ory location, located within th.~~~nt, and the AL (8-bit), AX (16-bit), or EAX (32-bit) &lt;br /&gt;register. A MOV instruction using this type of addressing is usually a 3-byte long instruction. (In &lt;br /&gt;the 80386 and above, a register size prefix may appear before the instruction, causing it to ex-&lt;br /&gt;ceed three bytes in length.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The MOV AL,DATA instruction, as represented by most assemblers, loads AL from data &lt;br /&gt;segment memory location DATA (1234H). Memory location DATA is a symbolic memory lo-&lt;br /&gt;cation, while the 1234H is the actual hexadecimal location. With many assemblers, this instruc-&lt;br /&gt;tion is represented as a MOV AL,[1234H] instruction.7 The [1234H] is an absolute memory &lt;br /&gt;location that is not allowed by all assembler programs. Note that this may need to be formed as &lt;br /&gt;MOV AL,DS:[1234H] with some assemblers, to show that the address is in the data segment. &lt;br /&gt;Figure 3-5 shows how this instruction transfers a copy of the byt~-sized contents of memory lo-&lt;br /&gt;cation 11234H into AL. The effective address is formed by adding I 234H (the offset address) to &lt;br /&gt;10000H (the data segment address) in a system operating in the real mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 3-3 lists the three direct addressed instructions. These instructions often appear in &lt;br /&gt;programs, so Intel decided to make them special 3-byte long instructions to reduce the length of &lt;br /&gt;programs. All other instructions that move data from a memory location to a register, called dis-&lt;br /&gt;placement addressed instructions, require four or more bytes of memory for storage in a program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-3 Direct addressed instructions using EAX, AX and AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Size Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,NUMBER 8-bits Copies the byte contents of data segment memory &lt;br /&gt;location NUMBER into AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVAX,COW 16-bits Copies the word contents of data segment memory &lt;br /&gt;location COW into AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EAX,wATERo 32-bits Copies the doubleword contents of memory location &lt;br /&gt;WATER into EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVNEWS,AL 8-bits Copies AL into data segment memory location NEWS &lt;br /&gt;MOV THERE,AX 16-bits Copies AX into data segment memory location THERE &lt;br /&gt;MOV HOME,EAXÂ· 32-bits Copies EAX into data segment memory location HOME &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â·Note: The 80386-Pentium Pro microprocessors will some time::. use more than three bytes of memory for &lt;br /&gt;the 32-bit move between EAX and memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7This form may be used with MASM. but most often appears when a program is entered or listed by DEBUG. a debug-&lt;br /&gt;ging toll provided with DOS. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES 77 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement Addressing. Displacement addressing is almost identical with direct addressing, &lt;br /&gt;except that the instruction is four bytes wide instead of three. In the 80386 through the Pentium Pro, &lt;br /&gt;this instruction can be up to seven bytes wide if a 32-bit register and a 32-bit displacement is spec-&lt;br /&gt;ified. This type of direct data addressing is much more flexible because most instructions use it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the operation of the MOV CL,[1234H] instruction is compared to that of the MOV &lt;br /&gt;AL,[1234H] instruction in Figure 3-5, both basically perform the same operation except for the &lt;br /&gt;destination register (CL verses AL). Another difference only becomes apparent upon examining &lt;br /&gt;the assembled versions of these two instructions. The MOV AL,[ I 234H] instruction is three bytes &lt;br /&gt;long and the MOV CL,[1234H] instruction is four bytes long as illustrated in Example 3-4. This &lt;br /&gt;example shows how the assembler converts these two instructions into hexadecimal machine &lt;br /&gt;language. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-4 &lt;br /&gt;0000 AD 1234 R &lt;br /&gt;0003 SA OE 1234 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, [1234H] &lt;br /&gt;MOV CL, [1234H] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 3-4 lists some MOV instructions using the displacement form of direct addressing. &lt;br /&gt;Not all variations are listed because there ~re many MOV instructions of this type. Note that the &lt;br /&gt;segment registers can be stored or loaded from memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 3-5 shows a short program using models that address information in the data seg-&lt;br /&gt;ment. Note that the data segment begins w.i~t.(I ... DATA statement to infoI111 !he assembler where &lt;br /&gt;the .~~~'E.e!!.t.begins. The model size is adjusted from TINY, as in Example 3-3, ~SMALL &lt;br /&gt;so that a data segment can be included. The SMALL model allows one data segment and,one &lt;br /&gt;~cle segI11ent. The SMALL model is often used whenever ,~e!ll0ry d;i~'a;e required fs&amp;gt;r a pro-&lt;br /&gt;gram. A SMALL model program assembles as an execute (.EXE) program. Notice how this ex-&lt;br /&gt;ample allocates memory locations in the data segment using the DB and PW directives. Here the &lt;br /&gt;.ST ART!lfitatement not only indicates the start of the code, but it also loads the data segment &lt;br /&gt;~eg~ with the 'segment address of the data segment. If this progra~;;i's-assembled and executed &lt;br /&gt;with'CodeView, the instructions can be viewed as they execute and change registers and &lt;br /&gt;memory locations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ 0000 10 &lt;br /&gt;0001 00 &lt;br /&gt;0002 0000 &lt;br /&gt;0004 MAA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATAl &lt;br /&gt;DATA2 &lt;br /&gt;DATA3 &lt;br /&gt;DATA4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 AD 0000 R &lt;br /&gt;001A SA 26 0001 R &lt;br /&gt;OOIE A3 0002 R &lt;br /&gt;0021 SB 1E 0004 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 10H &lt;br /&gt;DB a &lt;br /&gt;DW a &lt;br /&gt;DW OAAAAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,DATA1 &lt;br /&gt;AH,DATA2 &lt;br /&gt;DATA3,AX &lt;br /&gt;BX,DATM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register Indirect Addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;indicate start of DATA segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;place 10H in DATAl &lt;br /&gt;;place a in DATA2 &lt;br /&gt;;place a in DATA3 &lt;br /&gt;;place AAAAH in DATA4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;indicate start of CODE segment &lt;br /&gt;;indicate start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;copy DATAl to AL &lt;br /&gt;;copy DATA2 to AH &lt;br /&gt;;save AX at DATA3 &lt;br /&gt;;load BX with DATA4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;; end file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register indirect addressing allows data to be addressed at any memory location through an offset &lt;br /&gt;address held in any of the following registers: BP, BX, DI, and SI. For example, if register BX &lt;br /&gt;contains a lOOOH and the MOV AX,[BX] instruction executes, the word contents of data segment &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;78 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-4 Examples of direct data addressing using a displacement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Size Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVCH,DOG 8-bits Copies the byte contents of data segment memory &lt;br /&gt;location DOG into CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CH,[1 OOOHf 8-bits Copies the byte contents of data segment offset address &lt;br /&gt;1000H into CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV ES,DATA6 16-bits Copies the word contents of data segment memory &lt;br /&gt;location DAT A6 into ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DATA7,BP 16-bits Copies BP into data segment memory location DATA7 &lt;br /&gt;MOV NUMBER,SP 16-bits Copies SP into data segment memory location NUMBER &lt;br /&gt;MOV DATA1,EAX 32-bits Copies EAX into data segment memory location DATA 1 &lt;br /&gt;MOV EDI,SUM1 32-bits Copies the doubleword contents of data segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory location SUM1 into EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;*Note: This form of addressing is seldom used with most assemblers because an actual numeric offset &lt;br /&gt;address is rarely accessed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;offset addr~~s.l QQ.Q!J is copied into register AX. If the microprocessor is operated in the real mode &lt;br /&gt;and DS = OlOOH, this instruction addresses a word stored at memory bytes 2000H and 200lH and &lt;br /&gt;transfers it into register AX (see Figure 3-6). Note that the contents of 2000H are moved into AL &lt;br /&gt;and the contents of 200lH are moved into&amp;quot;AH. The [ ] symbols denote indirect addressing in as-&lt;br /&gt;sembly language. In addition to using the BP, BX, DI, and SI registers to indirectly address &lt;br /&gt;memory, the 80386 and above allow register indirect addressing with any extended register ex-&lt;br /&gt;cept ESP. Some typical instructions using indirect addressing appear in Table 3-5. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The data segment is used by default with register indirect addressing or any other addressing &lt;br /&gt;mode that uses BX, DI, or SI to address memory. If register BP addresses memory, the stack seg-&lt;br /&gt;ment is used by default. These are considered the default settings for these four index and base reg-&lt;br /&gt;isters. For the 80386 and above, EBP addresses memory in the stack segment by default; EAX, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-r--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00002002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX AH AL ~ 3 4 3 4 1 2 00002001 &lt;br /&gt;EBX 1 0 0 0 1000 ,+,/ 2000 1 2 00002000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-::::: &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS 00001001 &lt;br /&gt;1000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS o 1 o 0 00001000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-- ~ &lt;br /&gt;FIGURE 3-6 The operation of the MOV AX,[BXj instruction when BX = 1000H and DS = &lt;br /&gt;0100H. Note that this instruction is shown after the contents of memory are transferred to AX. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES 79 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-5 Example of register indirect addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,[BXj 16-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [BPj,OL* 8-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [Olj,BH 8-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [Olj,[BXj &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,[EOXj 8-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV ECX,[EBXj 32-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Copies the weld contents of the data segment memory &lt;br /&gt;location address by BX into CX &lt;br /&gt;Copies OL into the stack segment memory location &lt;br /&gt;addressed by BP &lt;br /&gt;Copies BH into the data segment memory location &lt;br /&gt;addressed by 01 &lt;br /&gt;Memory-to-memory moves are not allowed except with &lt;br /&gt;string instructions &lt;br /&gt;Copies the byte contents of the data segment memory &lt;br /&gt;location addressed by EOX into AL &lt;br /&gt;Copies the doubleword contents of the data segment &lt;br /&gt;memory location addressed by EBX into ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;*Note: Data addressed by SP or ESP is by default located in the stack segment, while all other indirect &lt;br /&gt;addressing modes use the data segment by default. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX, ECX, EDX, EDI, and ESI address memory in the data segment by default. When using a &lt;br /&gt;32~bit register to address memory in the real mode, the contents of the 32-bit register must never &lt;br /&gt;;;xceed OOOOFFFFH.lfi the protected mode, any value can be used in';-32-b&amp;quot;it register used to indi-&lt;br /&gt;f&amp;quot;ectly address memory, aslong asitcloes Ilot access a location outside of the segment as dictated by &lt;br /&gt;the acces~.ng}iiSj;-yte. An exa~p'j~80386/80486IPentrumlPentium Pro instruction is MOV &lt;br /&gt;EAX,[EBXl. This instruction loads EAX with the doubleword-sized number stored at the data seg-&lt;br /&gt;ment offset address indexed by EBX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In some cases, indirect addressing requires specifyinK the size of the data ~ith the special &lt;br /&gt;assembler directive BYTE PTR, WORD PTR, or DWORD PTR. These directives indicate the &lt;br /&gt;size of the memory daia-itddressed by the memory pointer (PTR). For example, the MOV AL,(Dll &lt;br /&gt;in&amp;quot;Struciionis'cie~ly ~~~Â§i~l!s! ~ove instruction, but the MOV [Dll,IOR instruction~ am-&lt;br /&gt;biguous. Does the ~QY. [Pll,IOR instruction address ~_1:J.j'~e-, ~.2.r:d-, or dqugleword-sized &lt;br /&gt;memory location? The assemb}~Lc.an't determine the size of the .lOR. The MOV ~XIE PTR &lt;br /&gt;[QIl,IOR instruction clearlYciesignates the location addr~ssed by DI as a byte-sized memory lo-&lt;br /&gt;cation. Likewise, the MOV DWORD PTR [Dll,IOR instruction clearly identifies the memory lo-&lt;br /&gt;cation as doubleword-sized. The BYTE PTR, WORD PTR, and DWORD PTR directives are &lt;br /&gt;used only with instructions that ~~dress a memory location through a pointer or index register &lt;br /&gt;with imm~diate data and for a few other instructions, which are described in subsequent chapters. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Indirect addressing often allows a program to refer to tabular data located in the memory &lt;br /&gt;system. For example, suppose that you must create a tableof information that contains 50 sam-&lt;br /&gt;ples taken from memory location OOOO:046C. LocationOi[OO:046C contains l!.~&amp;lt;:ounter that is &lt;br /&gt;maintained by the personal computer's real-tim\\! clock. Figure 3-7 shows the table and the BX &lt;br /&gt;~egiSterused to ad~e~sl?ach location i~&amp;quot;&amp;quot;thetable sequentially. To accomplish thi~task, load the &lt;br /&gt;starting location of the ~able into the BX register with a MOV immediate instruction, After ini-&lt;br /&gt;&amp;quot;tializing the starting address of the table, use register indirect addressing to store ~he _~Q. samples &lt;br /&gt;sequentially.-- - . _.... --&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The sequence shown in Example 3-6 loads register BX with the starting address of the &lt;br /&gt;table and initializes the count, located in register CX, to 50. The OFFSET directive tells the as-&lt;br /&gt;sembler to ~~13_X with the offset address of memory 10cationT ABLE, not the contents of &lt;br /&gt;.TABLE. For example, the MOV BX,DATAS instruction copies the contents of memory location &lt;br /&gt;DATAS into BX, while the MOV BX,OFFSET DATAS instruction copies the offset address of &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;80 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-7 An array &lt;br /&gt;(TABLE) containing 50 bytes &lt;br /&gt;that are indirectly addressed &lt;br /&gt;through register BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0032 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B8 0000 &lt;br /&gt;001A 8E CO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table + 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table + 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX 000 0 TAB L E Table &lt;br /&gt;~--------~--------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DA T AS into BX. When the OFFSET directive is used with the MOV instruction, the assembler &lt;br /&gt;calculates the offset address and then uses a MOV immediate instruction to load the address into &lt;br /&gt;the specified 16-bit register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATAS DW 50 DUP (?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,O &lt;br /&gt;MOV ES,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;setup array of 50 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address segment 0000 with ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001C BB 0000 R MOV BX,OFFSET DATAS ;address DATAS array &lt;br /&gt;;load counter with 50 001F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0022 &lt;br /&gt;0022 &lt;br /&gt;0026 &lt;br /&gt;0028 &lt;br /&gt;0029 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B9 0032 MOV CX,50 &lt;br /&gt;AGAIN: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26:A1 046C MOV AX,ES: [046CH] ;get clock value &lt;br /&gt;89 07 &lt;br /&gt;43 &lt;br /&gt;E2 F7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;INC &lt;br /&gt;LOOP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;[BX] ,AX &lt;br /&gt;BX &lt;br /&gt;AGAIN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save clock value in DATAS &lt;br /&gt;;increment BX to next element &lt;br /&gt;;repeat 50 times &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once the counter and pointer are initialized, a repeat-until CX = 0 loop executes. Here data &lt;br /&gt;are read from extra segment ~~_~()_~~~~CH with the MOV AX,ES:[046CH] instruction, &lt;br /&gt;and stored in memory that is i~ir~~!!L~2dress~d by the offset ad~ located in register BX. &lt;br /&gt;Next, BX is incremented (one is added to BX) to the next table location. Finally, the LOOP in-&lt;br /&gt;struction repeats the LOOP 50 times. The LOOP instruction decrements (subtracts one from) the &lt;br /&gt;counter (CX); if CX is not zero, LOOP causes a jump to memory location AGAIN. If CX be-&lt;br /&gt;comes zero, no jump occurs and this sequence of instructions ends. This example copies the 50 &lt;br /&gt;most recent values from the clock into the memory array DAT AS. This program will often show &lt;br /&gt;the same data in each location because the contents of the clock are changed only 18.2 times Qer &lt;br /&gt;second. To view the program and its execution, use the Code View program. To use CodeView, &lt;br /&gt;type CV FILE.EXE or CV FILE.COM or access it as DEBUG from the Programmer's Work-&lt;br /&gt;Bench program under the RUN menu. Note that CodeView functions only with .EXE or .COM &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES 81 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;files. Some useful Code View switches are /50 for a 50-line display and /S for use of high-reso-&lt;br /&gt;lution video displays in an application. To debug the file TEST.COM with 50 lines, type CV /50 &lt;br /&gt;TEST.COM at the DOS prompt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base-Plus-Index Addressing &lt;br /&gt;Base-plus-index addressing is similar to indirect addressing because it indirectly addresses &lt;br /&gt;memory data. In the 8086 through the 80286, this type of addressing uses one base register (BP &lt;br /&gt;or BX) and one index register (DI or SI) to indirectly address memory. The base register often &lt;br /&gt;holds the beginning location of a memory array, while the index register holds the relative posi-&lt;br /&gt;tion of an element in the array. Remember that whenever~y addresses memory data, both the &lt;br /&gt;stacksegment register and BP generate the effective address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80386 and above, this type of addressing allows the combination of any two 32-bit &lt;br /&gt;extended registers except ESP. For example, the MOV DL,[EAX+EBX] instruction is an ex-&lt;br /&gt;ample using EAX (as the base) plus EBX (as the index). If the EBP register is used, the data are &lt;br /&gt;located in the stack segment instead of in the data segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Locating Data with Base-plus-index Addressing. Figure 3-8 shows how data are addressed by &lt;br /&gt;. the MOV DX,[BX+DI] instruction when the microprocessor operates in the real mode. In this &lt;br /&gt;example, BX = 1000H, DI = OOlOH, and DS = OlOOH, which translate into memory address &lt;br /&gt;020l0H. This instruction transfers a copy of the word from location 02010H into the DX reg-&lt;br /&gt;ister. Table 3-6 lists some instructions used for base-plus-index addressing. Note that the Intel &lt;br /&gt;assembler requires that this addressing mode appear as [BX] [DI] instead of [BX+DI]. The MOV &lt;br /&gt;DX,[BX+DI] instruction is MOV DX,[BX][DI] for a program written for the Intel ASM assem-&lt;br /&gt;bler. This text uses the first form in all example programs, but the second form can be used in &lt;br /&gt;many assemblers, iI1cluding MASM from Microsoft. &lt;br /&gt;Locating Array Data Using Base-plus-index Addressing. A major use of the base-plus-index ad-&lt;br /&gt;dressing mode is to address elements in a memory array. Suppose that the elements in an array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 0 o 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A S o 3 Vt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010H &lt;br /&gt;o 0 1 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;AS03 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2010H &lt;br /&gt;+ + 1010H t 1000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS x 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02015H &lt;br /&gt;02014H &lt;br /&gt;02013H &lt;br /&gt;02012H &lt;br /&gt;02011H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02010H -&lt;br /&gt;0200FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l=IGURE 3-8 An example showing how the base-plus-index addressing mode functions for the MOV OX,[BX+OI] &lt;br /&gt;instruction. Notice that memory address 02010H is accessed because OS = 0100H, BX = i00H, and 01 = 0010H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;82 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-6 Examples of base-plus-index addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Size Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,[BX+DI] 16-bits Copies the word contents of the data segment memory &lt;br /&gt;location address by BX plus DI into CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CH,[BP+SI] 8-bits Copies the byte contents of the stack segment memory &lt;br /&gt;location addressed by BP plus SI into CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [BX+SI],SP 16-bits Copies SP into the data segment memory location &lt;br /&gt;addresses by BX plus SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [BP+DI],AH 8-bits Copies AH into the stack segment memory location &lt;br /&gt;addressed by BP plus DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CL,[EDX+EDI] 8-bits Copies the byte contents of the data segment memory &lt;br /&gt;location addressed by EDX plus EDI into CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [EAX+EBX],ECX 32-bits Copies ECX into the data segment memory location &lt;br /&gt;addressed by EAX plus EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;located in tJ:te data segment at memory location ARRA Y must be accessed. To accomplish this, &lt;br /&gt;load the BX register (base) with the beginning address of the array and the DI register (index) &lt;br /&gt;with the element number to be accessed. Figure 3-9 shows the use of BX and DI to access an el-&lt;br /&gt;ement in an array of data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A short program listed in Example 3-7 moves array element lOR into array element 20R. &lt;br /&gt;Notice that the array element number, loaded into the DI register, addresses the array element. &lt;br /&gt;Also notice how the contents of the ARRA Y have been initialized so element lOR contains a 29R. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0010 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 29 &lt;br /&gt;0011 001E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 BB 0000 R &lt;br /&gt;001A BF 0010 &lt;br /&gt;001D SA 01 &lt;br /&gt;001F BF 0020 &lt;br /&gt;0022 88 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AERAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 16 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 29H &lt;br /&gt;DB 30 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BX,OFFSET ARRAY &lt;br /&gt;MOV DI,10H &lt;br /&gt;MOV AL, [BX+DIJ &lt;br /&gt;MOV DI,20H &lt;br /&gt;MOV [BX+DIJ ,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register Relative Addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;se1ect SMALL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; setup ARRAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;sample data at element &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address ARRAY &lt;br /&gt;;address element 10H &lt;br /&gt;;get element 10H &lt;br /&gt;;address element 20H &lt;br /&gt;;save in element 20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;; end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register relative addressing is similar to base-plus-index addressing and displacement ad-&lt;br /&gt;dressing. In register relative addressing. the data in a segment of memory are addressed by &lt;br /&gt;adding the displacement to the contents of a base or an index register (BP, BX, DI, or SI). &lt;br /&gt;Figure 3-10 shows the operation of the MOV AX,[BX+lOOOR] instruction. In this example, &lt;br /&gt;BX = OIOOR and DS = 0200H, so the address generated is the sum of DS x lOR, BX, and the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I 01 &lt;br /&gt;I Element BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I ARRAY I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_ ........ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY + 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY +4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY + 3 &lt;br /&gt;ARRAY + 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY + 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;83 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-9 An example of the base-plus-index addressing mode. Here an element (DI) of an &lt;br /&gt;ARRAY (8X) is addressed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;displacement of 1000H or 03100H. Remember that BX, DI, or SI address the data segment and &lt;br /&gt;BP addresses the stack segment. In the 80386 and above, the displacement can be a 32-bit &lt;br /&gt;number and the register can be any 32-bit register except the ESP register. Remember that the &lt;br /&gt;size of a real mode segment is 64K bytes long. Table 3-7 lists a few instructions that use reg-&lt;br /&gt;ister relative addressing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The displacement can be a number added to the register within the [ ], as in MOY &lt;br /&gt;AL,[DI+2], or it can be a displacement subtracted from the register, as in MOY AL,[SI-I]. A &lt;br /&gt;displacement also can be an offset address appended to' the front of the [ ], as in MOY &lt;br /&gt;AL,DATA[DI]. Both forms of displacements also can appear simultaneously, as in MOY &lt;br /&gt;AL,DATA[DI+3]. In all cases, both forms of the displacement add to the base or base and index &lt;br /&gt;register within the [ ]. In the 8086-80286 microprocessors, the value of the displacement is lim-&lt;br /&gt;ited to a 16-bit signed number with a value ranging between +32,767 (7FFFH) and -32,768 &lt;br /&gt;(8000H); in the 80386 and above, a 32-bit displacement is allowed with a value ranging between &lt;br /&gt;+2,147,483,647 (7FFFFFFFH) and-2,147,483,648 (80000000H). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-10 The &lt;br /&gt;operation of the MOV &lt;br /&gt;AX,[8X+ 1 OOOH] instruction, &lt;br /&gt;when 8X = 0100H and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS = 0200H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A076 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register array L------1AAcoli 03101 H EAX 2222 &lt;br /&gt;EBX 0000 7 6 03100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;os x 10H &lt;br /&gt;2000H 3100H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;84 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-7 Examples of register relative addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,[OI+ 1 OOH] 16-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV ARRAY[SI],BL a-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV LlST[SI+2],CL a-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV OI,SET _IT[BX) 16-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV 0I,[EAX+10H) 16-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV ARRAY[EBX),EAX 32-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Copies the word contents of the data segment memory location &lt;br /&gt;addressed by 01 plus 100H into AX &lt;br /&gt;Copies BL into the data segment memory location addressed by &lt;br /&gt;ARRAY plus SI &lt;br /&gt;Copies CL into the data segment memory location addressed by &lt;br /&gt;sum of LIST, SI, and 2 &lt;br /&gt;Copies the word contents of the data segment memory location &lt;br /&gt;addressed by the sum of SET_IT and BX into 01 &lt;br /&gt;Copies the word contents of the data segment memory location &lt;br /&gt;addressed by the sum of EAX and 10H into 01 &lt;br /&gt;Moves EAX into the data segment memory location addressed by the &lt;br /&gt;sum of ARRAY and EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addressing Array Data with Register Relative Addressing. It is possible to address array data with &lt;br /&gt;register relative addressing such as one does with base-plus-index addressing. In Figure 3-11, &lt;br /&gt;register relative addressing is illustrated with the same example as for base-plus-index ad-&lt;br /&gt;dressing. This shows how the displacement ARRAY adds to index register DJ to generate a ref-&lt;br /&gt;erence to an array element. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 3-8 shows how this new addressing mode can transfer the contents of array ele-&lt;br /&gt;ment lOR into array element 20R. Notice the similarity between this example and Example 3-7. &lt;br /&gt;The main difference is that, in Example 3-8, register BX is not used to address memory area &lt;br /&gt;ARRAY; instead, ARRAY is used as a displacement to accomplish the same task. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-8 &lt;br /&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0010 ARRAY DB 16 DUP (? ) &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 29 DB 29H &lt;br /&gt;0011 DOlE DB 30 DUP ( ?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 BF 0010 MOV DI,10H &lt;br /&gt;001A 8A 85 0000 R MOV AL,ARRAY[DI) &lt;br /&gt;DOlE BF 0020 MOV DI,20H &lt;br /&gt;0021 88 85 0000 R MOV ARRAY[DI) ,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base Relative-Plus-Index Addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;setup ARRAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;samp1e data at element 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address element 10H &lt;br /&gt;;get element 10H &lt;br /&gt;;address element 20H &lt;br /&gt;;save in element 20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;; end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The base relative-plus-index addressing mode is similar to the base-plus-index addressing mode, &lt;br /&gt;but adds a displacement besides using a base register and an index register to form the memory &lt;br /&gt;address. This type of addressing mode often addresses a two-dimensional array of memory data. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement I &lt;br /&gt;I ARRAY L I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;Element I &lt;br /&gt;t &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;-&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY + 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY +5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY + 4 &lt;br /&gt;ARRAY + 3 &lt;br /&gt;ARRAY + 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY + 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-11 Register relative addressing used to address an element of ARRAY. The dis-&lt;br /&gt;placement addresses the start of ARRAY, and DI accesses an element. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;85 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addressing Data with Base Relative-plus-index Addressing. Base relative-plus-index addressing &lt;br /&gt;is the least-used addressing mode. Figure 3-12 shows how data are referenced if the instruction &lt;br /&gt;executed by the microprocessor is a MOV AX,[BX+SI+lOOH]. The displacement of 100H adds &lt;br /&gt;to BX and SI to form the offset address within the data segment. Registers BX = 0020H, SI = &lt;br /&gt;OOlOH, and DS = 1000H, so the effective address for this instruction is 10130H-the sum of &lt;br /&gt;these registers plus a displacement of 100H. This addressing mode is too complex for frequent &lt;br /&gt;use in a program. Some typical instructions using base relative-plus-index addressing appear in &lt;br /&gt;Table 3-8. Note that with the 80386 and above, the effective address is generated by the sum of &lt;br /&gt;two 32-bit registers plus a 32-bit displacement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;ESX &lt;br /&gt;ECX &lt;br /&gt;EOX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP &lt;br /&gt;ESP &lt;br /&gt;ESI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A 3 1 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 2 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ &lt;br /&gt;0010H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;r---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A 3 10131H &lt;br /&gt;A3l6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 6 1 10130H-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0030H 0130H &lt;br /&gt;+ + &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000H 10130H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100H OS x 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-12 An example of base relative-plus-index addressing using a MOV AX,[BX+SI+100H] &lt;br /&gt;instruction. Note: DS = 1000H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;86 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-8 Example base relative-plus-index instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV OH,[BX+01+20H] a-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,FILE[BX+OI] 16-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV LlST[BP+OI],CL a-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV LlST[BP+SI+4],OH a-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EAX,FILE[EBX+ECX+2] 32-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Copies the byte contents of the data segment memory location &lt;br /&gt;addressed by the sum of BX, 01, and 20H into OH &lt;br /&gt;Copies the word contents of the data segment memory location &lt;br /&gt;addressed by the sum of FILE, BX, and 01 into AX &lt;br /&gt;Copies CL into the stack segment memory location addressed &lt;br /&gt;by the sum of LIST, BP, and 01 &lt;br /&gt;Copies OH into the stack segment memory location addressed &lt;br /&gt;by the sum of LIST, BP, SI, and 4 &lt;br /&gt;Copies the doubleword contents of the data segment memory &lt;br /&gt;location addressed by the sum of FILE, EBX, ECX, and 2 into EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addressing Arrays with Base Relative-plus-index Addresssing. Suppose that a file of many &lt;br /&gt;records exists in memory and each record contains many elements. This displacement addresses &lt;br /&gt;the file, the base register addresses a record, and the index register addresses an element of a &lt;br /&gt;record. Figure 3-13 illustrates this very complex form of addressing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 3-9 provides a program that copies element 0 of record A into element 2 of &lt;br /&gt;record C using the base relative-plus-index mode of addressing. This example FILE contains &lt;br /&gt;four records, and each record contains ten elements. Notice how the THIS BYTE statement is &lt;br /&gt;used to define the labels FILE and RECA as the same memory location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 = 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 OOOA [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA OOOA [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 OOOA [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOlE OOOA [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 BB 0000 R &lt;br /&gt;001A BF 0000 &lt;br /&gt;001D 8A 81 0000 R &lt;br /&gt;0021 BB 0014 R &lt;br /&gt;0024 BF 0002 &lt;br /&gt;0027 88 81 0000 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FILE EQU THIS BYTE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RECA DB 10 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RECB DB 10 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RECC DB 10 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RECD DB 10 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BX.OFFSET RECA &lt;br /&gt;MOV DI,O &lt;br /&gt;MOV AL,F:rLE[BX+DI] &lt;br /&gt;MOV BX,urFSET RECC &lt;br /&gt;MOV DI,2 &lt;br /&gt;MOV FILE [BX+DI] ,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;SMALL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;assign FILE to this byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reserve 10 bytes for RECA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reserve 10 bytes for RECB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reserve 10 bytes for RECC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reserve 10 bytes for RECD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address RECA &lt;br /&gt;;address element 0 &lt;br /&gt;;get data &lt;br /&gt;;address RECC &lt;br /&gt;;address element 2 &lt;br /&gt;;save data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-13 Base rela-&lt;br /&gt;tive-plus-index addressing &lt;br /&gt;used to access a FILE that &lt;br /&gt;contains multiple records &lt;br /&gt;(REG) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;Displacement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Scaled-Index Addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDI I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;87 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ I &lt;br /&gt;Element I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t REG G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REG B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REGG I &lt;br /&gt;REG A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-.....-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Scaled-index addressing is the last type of data-addressing mode discussed. This data-addressing &lt;br /&gt;mode is unique to the 80~86 through the Pentium Pro microprocessors. Scaled-index addressing &lt;br /&gt;uses two 32-bit registers (a base register and an index register) to access the memory. The second &lt;br /&gt;register (index) is multiplied by a scaling factor. The scaling factor can be IX, 2X, 4X, or 8X. A &lt;br /&gt;scaling factor of IX is implied and need not be included in the assembly language instruction &lt;br /&gt;(MaY AL,[EBX+ECX]). A scaling factor of2X is used to address word-sized memory arrays; a &lt;br /&gt;scaling factor of 4X is used with doubleword-sized memory arrays; and a scaling factor of 8X is &lt;br /&gt;used with quadword-sized memory arrays. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An example instruction is MaY AX,[EDI+2*ECXJ. This instruction uses a scaling factor &lt;br /&gt;of 2X, which multiplies the contents of ECX by 2 before adding it to the EDI register to form the &lt;br /&gt;memory address. If ECX contains a OOOOOOOOH, word-sized memory element 0 is addressed; if &lt;br /&gt;ECX contains a OOOOOOOIH, word-sized memory element I is addressed, and so forth. This &lt;br /&gt;scales the index (ECX) by a factor of 2 for a word-sized memory array. Refer to Table 3-9 for &lt;br /&gt;some examples of scaled-index addressing. As you can imagine, there are an extremely large &lt;br /&gt;number of scaled-index addressed register combinations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 3-10 shows a sequence of instructions that uses scaled-index addressing to access a &lt;br /&gt;word-sized array of data caIled LIST. Note that the offset address of LIST is loaded into register EBX &lt;br /&gt;with the MaY EBX,OFFSET LIST instruction. Once EBX addresses array LIST, the elements (lo-&lt;br /&gt;cated in ECX) of 2, 4, and 7 of this word-wide array are added using a scaling factorof2 to access the &lt;br /&gt;elements. This program stores the 2 at element 2 into elements 4 and 7. Also notice the .386 directive &lt;br /&gt;to select the 80386 microprocessor. This directive must follow the .MODEL statement for the assem-&lt;br /&gt;bler to process 80386 instructions for DOS. If the 80486 is in use, the .486 directive appears after the &lt;br /&gt;.MODEL statement; if the Pentium or Pentium Pro &amp;quot;is in use, the .586 directive appears after the &lt;br /&gt;.MODEL statement. If the microprocessor selection directive appears before the .MODEL statement, &lt;br /&gt;the microprocessor executes instructions in the 32-bit mode, which is not compatible with DOS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL S~l'\\LL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;use the 80386 &lt;br /&gt;;start of DATA segment &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;88 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-9 Examples of scaled-index addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Size Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EAX,[EBX+4*ECX] 32-bits Copies the doubleword contents of the data segment memory &lt;br /&gt;location addressed by the sum of 4 times ECX plus EBX into EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV [EAX+2*EDI+100H],CX 16-bits Copies CX into the data segment memory location addressed by &lt;br /&gt;the sum of EAX, 100H, and 2 times EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,[EBP+2*EDI-2] 8-bits Copies the byte contents of the stack segment memory location &lt;br /&gt;addressed by the sum of EBP, -2, and 2 times EDI into AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EAX,ARRAY[4*ECX] 32-bits Copies the doubleword contents of the data segment memory &lt;br /&gt;location addressed by the sum of ARRAY plus 4 times ECX into EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0057 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0020 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 0020 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0040 0010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0050 0002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0052 0005 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0000 0001 0002 LIST DW 0,1,2,3,4 ;define array list &lt;br /&gt;0003 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA 0005 0006 0007 DW 5,6,7,8,9 &lt;br /&gt;0008 0009 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE ;start of CODE segment &lt;br /&gt;. STARTUP ;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 661 BB 00000000 R MOV EBX, OFFSET LIST ;address array LIST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0016 661 B9 00000002 MOV ECX,2 ;get element 2 &lt;br /&gt;001C 67&amp;amp; 8B 04 4B MOV AX, [EBX+2*ECX] &lt;br /&gt;0020 661 B9 00000004 HOV ECX, 4 ;store in element 4 &lt;br /&gt;0026 67&amp;amp; 89 04 4B MOV [EBX+2*ECX] ,AX &lt;br /&gt;002A 661 B9 00000007 HOV ECX, 7 ;store in element 7 &lt;br /&gt;0030 67&amp;amp; 89 04 4B MOV [EBX+2*ECX] ,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT ;exit to DOS &lt;br /&gt;EllD ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Structures &lt;br /&gt;A data structure is used to specify how information is stored in a memory array; it can be quite &lt;br /&gt;useful with applications that use arrays. It is best to think of a data structure as a template for data. &lt;br /&gt;The start of a structure is identified with the STRUC assembly language directive and the end &lt;br /&gt;with the ENDS statement. A typical data structure is defined and used three times in Example &lt;br /&gt;3-11. Notice that the name of the structure appears with both the STRUC and ENDS statements. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Define INFO data structure &lt;br /&gt;INFO STRUC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NAMES DB 32 DUP (? ) ;32 bytes for name &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STREET DB 32 DUP ( ?) ;32 bytes for street &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CITY DB 16 DUP (? ) ;16 bytes for city &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STATE DB 2 DUP ( ?) ; 2 bytes for state &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ZIP DB 5 DUP (? ) ;5 bytes for zip-code &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-1 DATA-ADDRESSING MODES 89 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INFO ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 42 6F 62 20 53 6D NAME1 &lt;br /&gt;69 74 68 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INFO &amp;lt;'Bob Smith', '123 Main Street' ,'Wanda', 'OH', '44444'&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0057 53 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;] &lt;br /&gt;31 32 33 20 4D &lt;br /&gt;61 69 6E 20 53 74 &lt;br /&gt;72 65 65 74 &lt;br /&gt;0011 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;57 61 6E 64 61 &lt;br /&gt;OOOB [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4F 48 34 34 34 &lt;br /&gt;34 34 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74 65 76 65 20 NAME2 INFO &amp;lt;'Steve Doe', '222 Mouse Lane', 'Mi11er','PA', '18100'&amp;gt; &lt;br /&gt;44 6F 65 &lt;br /&gt;0017 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32 32 32 20 4D &lt;br /&gt;6F 75 73 65 20 4C &lt;br /&gt;61 6E 65 &lt;br /&gt;0012 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4D 69 6C 6C 65 &lt;br /&gt;72 &lt;br /&gt;OOOA [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50 41 31 38 31 &lt;br /&gt;30 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOAE 42 65 6E 20 44 6F NAME3 INFO &amp;lt;'Ben Dover', '303 Main Street','Orender', 'CA', '90000'&amp;gt; &lt;br /&gt;76 65 72 &lt;br /&gt;0017 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33 30 33 20 4D &lt;br /&gt;61 69 6E 20 53 74 &lt;br /&gt;72 65 65 74 &lt;br /&gt;0011 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4F 72 65 6E 64 &lt;br /&gt;65 72 &lt;br /&gt;0009 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;43 41 &lt;br /&gt;30 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;39 30 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The data structure in Example 3-11 defines five fields of information. The first is 32 bytes &lt;br /&gt;long and holds a name; the second is 32 bytes long and holds a street address; the third is 16 &lt;br /&gt;bytes long for the city; the fourth is 2 bytes long for the state; and the fifth is 5 bytes long for the &lt;br /&gt;ZIP Code. Once the structure is defined (INFO), it can be filled as illustrated with names and ad-&lt;br /&gt;dresses. Three examples of use for INFO are illustrated. Note that literals are surrounded with &lt;br /&gt;apostrophes and the entire field is surrounded with &amp;lt; &amp;gt; symbols when the data structure is used &lt;br /&gt;to define data. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;90 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When data are addressed in a structure, use the structure name and the field name to select &lt;br /&gt;a field from the structure. For example, to address the street field in NAME2, use the operand &lt;br /&gt;NAME2.STREET, where the name of the structure is first followed by a period and then by the &lt;br /&gt;name of the field. Likewise, use NAME3.CITY to refer to the city field in structure NAME3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A short sequence of instructions appears in Example 3-12 that clears the name field in &lt;br /&gt;structure NAMEI, the address field in structure NAME2, and the ZIP Code field in structure &lt;br /&gt;NAME3. The function and operation of the instructions in this program are defined in later chap-&lt;br /&gt;ters. You may wish to refer back to this example once these instructions are learned. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-12 &lt;br /&gt;;Clear names in array NAME1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B9 0020 MOV CX,32 &lt;br /&gt;0003 BO 00 MOV AL,O &lt;br /&gt;0005 BE 0000 R MOV S1,OFFSET NAME1.NAMES &lt;br /&gt;0008 F3/AA REP STOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Clear street in array NAME2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA B9 0020 MOV CX,32 &lt;br /&gt;DODD BO 00 MOV AL,O &lt;br /&gt;0010 BE 0077 R MOV S1,OFFSET NAME2.STREET &lt;br /&gt;0013 F3/AA REP STOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Clear zip-code in array NAME3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0015 B9 0005 MOV CX,5 &lt;br /&gt;0018 BO 00 MOV AL,O &lt;br /&gt;001A BE 0100 R MOV S1,OFFSET NAME3.ZIP &lt;br /&gt;001D F3/AA REP STOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROGRAM MEMORY-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Program memory-addressing modes, used with the JMP and CALL instructions, consist of three &lt;br /&gt;distinct forms: direct, relative, and indirect. This section introduces these three addressing forms, &lt;br /&gt;using the JMP instruction to illustrate their operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Direct Program Memory Addressing &lt;br /&gt;. Direct program memory addressing is what many early microprocessors used for all jumps and &lt;br /&gt;calls. Direct program memory addressing is also used in high-level languages, such as the &lt;br /&gt;BASIC language GOTO and GOSUB instructions. The microprocessor uses this form of ad-&lt;br /&gt;dressing, but not as often as relative and indirect program memory addressing are used. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The instructions for direct program memory addressing store the address with the opcode. &lt;br /&gt;For example, if a program jumps to memory location lOOOOH for the next instruction, the address &lt;br /&gt;(lOOOOH) is stored following the opcode in the memory. Figure 3-14 shows the direct interseg-&lt;br /&gt;ment JMP instruction and the four bytes required to store the address 10000H. This JMP instruc-&lt;br /&gt;tion loads CS with lOOOH and IP with OOOOH to jump to memory location lOOOOH for the next &lt;br /&gt;instruction. (An intersegmentjump is ajump to any memory location within L~e entire memory &lt;br /&gt;system.) The direct jump is often called ajar jump because it can jump to any memory location &lt;br /&gt;for the next instruction. In the real mode, a far jump accesses any location within the first 1 M byte &lt;br /&gt;of memory by changing both CS and IP. In protected mode operation, the far jump accesses a new &lt;br /&gt;code segment descriptor from the descriptor table, allowing it to jump to any memory location in &lt;br /&gt;the entire 4G byte address range in the 80386 through Pentium Pro microprocessors. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-2 PROGRAM MEMORY-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-14 The 5-byte &lt;br /&gt;machine language version of &lt;br /&gt;a JMP [10000H] instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode Offset (low) Offset (high) Segment (low) Segment (high) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L---E_A--II I 0 0 ] I 0 0 I I 0 0 I I 1 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;91 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The only other instruction that uses direct program addressing is the intc:E~Â£gment or far &lt;br /&gt;CALL instruction. Usually. the name of a memory address, called a label, refers to the location &lt;br /&gt;that is called or jumped to instead of the actual numeric address. When using a label with the &lt;br /&gt;CALL or JMP instruction, most assemblers select the best form of program addressing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Relative Program Memory Addressing &lt;br /&gt;Relative program memory addressing is not available in all early microprocessors, but it is &lt;br /&gt;available to the Intel family of microprocessors. The term relative means &amp;quot;relative to the in-&lt;br /&gt;struction pointer (IP).&amp;quot; For example, if a JMP instruction skips the next two bytes of memory, &lt;br /&gt;the address in relation to the instruction pointer is a.2 that adds to the instruction pointer. This &lt;br /&gt;develops the address of the next program instruction. An example of the relative JMP instruc-&lt;br /&gt;tion is shown in Figure 3-15. Notice that the JMP instruction is a one-byte instruction with a &lt;br /&gt;one-byte or a ~.,.&amp;quot;o-byte displacement that adds to the instruction pointer. A QI.:1c:~byte displace-&lt;br /&gt;me&amp;quot;il&amp;quot;t is used in -short jumps, and a two-byte .. displacement is used in ne.&amp;lt;lrjunws and calls. Both &lt;br /&gt;types are consiclered intrasegment jumps. (An intrasegment jump is a jump anywhere within &lt;br /&gt;the current code segment.) In the 80386 and above, the displacement can also be a 32-bit value, &lt;br /&gt;allowing these microprocessors tous&amp;quot;ereTative addressing to any location within their 40 byte &lt;br /&gt;code segments. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Relative JMP and CALL instructions contain either an.J.l=~it or a 1_6~bit signed displace-&lt;br /&gt;ment that allows a forward memory reference or a reverse memory reference. (The 80386 and &lt;br /&gt;above can have an 8-bit or a 32-bit displacement.) bll assemblers automatically calculate the dis-&lt;br /&gt;tance for the ~is.p.I.aceIl1ent and select tlJe proper one-, two- or, four-byte form. If the distance is &lt;br /&gt;t?_O far for a.two-byte displacement in the 80~_t?.throllgI:180286 microprocessors, some assem-&lt;br /&gt;blers use the direct jump. An 8-bit displacement (short) has a jump range of between .:+J27 and &lt;br /&gt;-128 bytes f~-ihe n~~Unstruction, while a Jii:!&amp;gt;itdisplacement (near) has a range of Â±32K &lt;br /&gt;bytes. In the 80386 and above, a}2-bit displacement allows a range of ~_20 bytes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Indirect Program Memory Addressing &lt;br /&gt;The microprocessor allow..Â§. several forms of indirect program memory addressing for the JMP &lt;br /&gt;and CALL instructions. Table 3-10 lists some acceptable indirect program jump instructions, &lt;br /&gt;which can use any 16-bit register (AX, BX, CX, DX, SP, BP, DI, or SI), any relative register &lt;br /&gt;([BP], [BX], [DI], or [SI]), and any relative register with a displacement. In the 80386 and above, &lt;br /&gt;an ~t:I!~ed register can also be used to hold the address or indirect address of a relative JMP or &lt;br /&gt;CALL. For example, the JMP EAX instruction jumps to the location address by register EAX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If a 16-bit register holds the address of a lMP instruction, the jump is near. For example, if &lt;br /&gt;the BX register contains a 1000H and a JMP BX instruction executes, the microprocessor jumps &lt;br /&gt;to offset address 1000H iIi_&amp;quot;tp(;!current code segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If a relative register holds the address, the jump is also considered an indirect jump. For ex-&lt;br /&gt;ample, a JMP [BX] instruction refe~s&amp;quot;to memory location withi&amp;quot;u the data segment at the off-&lt;br /&gt;set address contained in BX. At this offset address is a 16-bit number that is used as the offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-15 A JMP [2] &lt;br /&gt;instruction. This instruction &lt;br /&gt;skips over the two bytes of &lt;br /&gt;memory that follow the JMP &lt;br /&gt;instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 &lt;br /&gt;10001 &lt;br /&gt;10002 &lt;br /&gt;10003 &lt;br /&gt;10004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EB } o &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;92 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-10 Examples of indirect program memory addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMPAX &lt;br /&gt;JMPCX &lt;br /&gt;JMP NEAR PTR [BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Jumps to the current code segment location addressed by the contents of AX &lt;br /&gt;Jumps to the current code segment location addressed by the contents of CX &lt;br /&gt;Jumps to the current code segment location addressed by the contents of the data &lt;br /&gt;segment memory location addressed by BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP NEAR PTR[01+2] Jumps to the current code segment location addressed by the contents of the data &lt;br /&gt;segment memory location addressed by 01 plus 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP T ABLE[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Jumps to the current code segment location addressed by the contents of the data &lt;br /&gt;segment memory location addressed by TABLE plus BX &lt;br /&gt;Jumps to the current code segment location addressed by the contents of ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 3-16 A jump table TABLE OW LOCO &lt;br /&gt;that stores addresses of var- OW LOC1 &lt;br /&gt;ious programs. The exact ad- OW LOC2 &lt;br /&gt;dress chosen from the OW LOC3 &lt;br /&gt;TABLE is determined by an &lt;br /&gt;index stored with the jump &lt;br /&gt;instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;address in the intrasegment jump. This type of jump is sometimes called an indirect-indirect or &lt;br /&gt;double-indirect jump. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 3-16 shows ajump table that is stored beginning at memory location TABLE. This &lt;br /&gt;jump table is referenced by the short program of Example 3-13. In this example, the BX register &lt;br /&gt;is loaded with a 4 so, when it combines in the JMP T ABLE[BX] instruction with TABLE, the ef-&lt;br /&gt;fective address is the contents of the second entry in the jump table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--- ---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-13 &lt;br /&gt;;using indirect addressing for a jump &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BB 0004 MOV BX,4 &lt;br /&gt;0003 FF A7 23Al R JMP TABLE[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STACK MEMORY-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address LOC2 &lt;br /&gt;; jump to LOC2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The stack plays an important role in all microprocessors. It holds data temporarily and stores re-&lt;br /&gt;turn addresses for procedures. The stack memory is a LIFO (last-in, first-out) memory, which &lt;br /&gt;describes the way that data are stored and removed from the stack. Data are placed onto the stack &lt;br /&gt;with a PUSH instruction and removed with a POP instruction. The CALL instruction also uses &lt;br /&gt;the stack to hold the return address for procedures and a RET (return) instruction to remove the &lt;br /&gt;return address from the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The stack memory is maintained by two registers: the stack pointer (SP or ESP) and the &lt;br /&gt;stack segment register (SS). Whenever a word of data is pushed onto the stack [see Figure 3-17 &lt;br /&gt;(a)], the high-order 8-bits are placed in the location addressed by SP - 1. The low-order 8-bits are &lt;br /&gt;placed in the location addressed by SP - 2. The SP is then decremented by 2 so the next word of &lt;br /&gt;data is stored in the next available stack memory location. The SPIESP register always points to &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-3 STACK MEMORY-ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX &lt;br /&gt;ECX &lt;br /&gt;EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r.---. &lt;br /&gt;1 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP~ .~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX &lt;br /&gt;ECX &lt;br /&gt;EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SS x 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 4 A &lt;br /&gt;&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SS x 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;93 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;j.. &lt;br /&gt;1 2 3 4 1 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- 3 4 &lt;br /&gt;J' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;~&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 234 1 2 &lt;br /&gt;3 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;FIGURE 3-17 The PUSH and POP instructions. (a) PUSH BX places the contents of BX onto &lt;br /&gt;the stack, (b) POP ex remo~es data from the stack and places them into ex. Both instructions &lt;br /&gt;are shown after execution. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;an area of memory located within the stack segment. The SPIESP register adds to SS x lOH to &lt;br /&gt;form the stack memory address in the real mode. In protected mode operation, the SS register &lt;br /&gt;holds a selector that accesses a descriptor for the base address of the stack segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever data are popped from the stack [see Figure 3-17 (b)], the low-order 8-bits are &lt;br /&gt;removed from the location addressed by SP. The high-order 8-bits are removed from the location &lt;br /&gt;addressed by SP + 1. The SP register is then incremented by 2. Table 3-11 lists some of the &lt;br /&gt;PUSH and POP instructions available to the microprocessor. Note that PUSH and POP instruc-&lt;br /&gt;tions always store or retrieve words of data-nev~rbytes-in the 8086 through the 80286 mi-&lt;br /&gt;croproce~sors. The 80386 and above allow word;; or doublewords to be transf(!ITed to and from &lt;br /&gt;the stack. Data may be pushed onto the stack from any l~~bit register or segment register and, in &lt;br /&gt;the 80386 and above, any 32-bit extended register. Data may be popped off the stack into any &lt;br /&gt;16-bit register or any segment register except CS. The reason that data may not be popped from &lt;br /&gt;the stack into CS is that this changes only part of the address of the next instruction. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;94 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-11 Example PUSH and POP Instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPF &lt;br /&gt;POPFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHF &lt;br /&gt;PUSHFO &lt;br /&gt;PUSH AX &lt;br /&gt;POPBX &lt;br /&gt;PUSH OS &lt;br /&gt;PUSH 1234H &lt;br /&gt;POPCS &lt;br /&gt;PUSH WORO PTR [BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHAO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPAO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP EAX &lt;br /&gt;PUSH EOI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Removes a word from the stack and places it into the flags &lt;br /&gt;Removes a doubleword from the stack and places it into the &lt;br /&gt;EFLAG register &lt;br /&gt;Copies the flags onto the stack &lt;br /&gt;Copies the EFLAG register to the stack &lt;br /&gt;Copies AX to the stack &lt;br /&gt;Removes a word from the stack and places it into BX &lt;br /&gt;Copies OS to the stack &lt;br /&gt;Copies a 1234H to the stack &lt;br /&gt;Illegal instruction &lt;br /&gt;Copies a word from the data segment memory location addressed &lt;br /&gt;by BX onto the stack &lt;br /&gt;Copies the word contents of AX, CX, OX, BX, SP, BP, 01, and SI &lt;br /&gt;onto the stack &lt;br /&gt;Removes data from the stack and places it into SI, 01, BP, SP, &lt;br /&gt;BX, OX, CX, and AX &lt;br /&gt;Copies the doubleword contents of EAX, ECX, EOX, EBX, ESP, &lt;br /&gt;EBP, EOI, and ESI onto the stack &lt;br /&gt;Removes data from the stack and places it into ESI, EOI, EBP, &lt;br /&gt;ESP, EBX, EOX, ECX, and EAX &lt;br /&gt;Removes data from the stack and places it into EAX &lt;br /&gt;Copies EOI to the stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PUSHA and POPA instructions either push or pop all of the registers, except the seg-&lt;br /&gt;ment registers, on the stack. These instructions are not available on the early 8086/8088 micro-&lt;br /&gt;processors. The push immediate instruction is also new to the 80286 through the Pentium Pro &lt;br /&gt;microprocessors. Note the examples in Table 3-11 that show the order of the registers trans-&lt;br /&gt;ferred by the PUSHA and POP A instructions. The 80386 and above also allow extended regis-&lt;br /&gt;ters to be pushed or popped. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 3-14 lists a short program that pushes the contents of AX, BX, and ex onto the &lt;br /&gt;stack. The first POP retrieves the value that was pushed onto the stack from ex and places it into &lt;br /&gt;AX. The second POP places the original value of BX into ex. The last POP places the original &lt;br /&gt;value of AX into BX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-14 &lt;br /&gt;.MODEL TINY ;select TINY model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE ;start CODE segment &lt;br /&gt;. STARTUP ;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 B8 1000 110V AY.,lOOOH ;load test data &lt;br /&gt;0103 BB 2000 HOV BZ,2000H &lt;br /&gt;0106 B9 3000 110V CZ,3000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0109 50 PUSH AX ;lOOOH to stack &lt;br /&gt;OIOA 53 PUSH BX ;2000H to stack &lt;br /&gt;OIOB 51 PUSH CX ;3000H to stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OIOC 58 POP AY. ;3000H to AX &lt;br /&gt;OIOD 59 POP CX ;2000H to CX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3-4 SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Olnr: 58 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP Ei: &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;:'JOOH to 8X &lt;br /&gt;;'2xit to DOS &lt;br /&gt;;'2:-:d of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;95 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The data-addressing modes include register, immediate, direct, register indirect, base-plus-index, &lt;br /&gt;register relative, and base relative-plus-index addressing. An additional addressing mode, called &lt;br /&gt;scaled-index addressing, exists in the 80386 through the Pentium Pro microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The program memory-addressing modes include direct, relative, and indirect addressing. &lt;br /&gt;3. Table 3-12 lists all real mode data-addressing modes available to the 8086 through the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 microprocessprs. Note that the 80386 and above also use these modes, in addition to &lt;br /&gt;the many defined throughout this chapter. In the protected mode, the function of the segment &lt;br /&gt;register is to address a descriptor that contains the base address of the memory segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. The 80386, 80486, Pentium, and Pentium Pro microprocessors have additional addressing &lt;br /&gt;modes that allow the extended registers EAX, EBX, ECX, EDX, EBP, EDI, and ESI to ad-&lt;br /&gt;dress memory. These addressing modes are too numerous to list in tabular form, but in gen-&lt;br /&gt;eral any of these registers function in the same way as those listed in Table 3-12. For &lt;br /&gt;example, the MOV AL,TABLE[EBX+2*ECX+1OH] instruction is a valid addressing mode &lt;br /&gt;for the 80386/80486IPentium/Pentium Pro microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The MOV instruction copies the contents of the source operand into the destination operand. &lt;br /&gt;The source never changes for any instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Register addressing specifies any 8-bit register (AH, AL, BH, BL, CH, CL, DH, or DL) or &lt;br /&gt;any 16-bit register (AX, BX, CX, DX, SP, BP, SI, or DI). The segment registers (CS, DS, &lt;br /&gt;ES, or SS) are also addressable for moving data between a segment register and a 16-bit reg-&lt;br /&gt;ister/memory location or for PUSH and POP. In the 80386 through the Pentium Pro micro-&lt;br /&gt;processors, the extended registers also are used for register addressing and consist of EAX, &lt;br /&gt;EBX, ECX, EDX, ESP, EBP, EDI, and ESI. Also available to the 80386 and above are the &lt;br /&gt;FS and GS segment registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. The MOV immediate instruction transfers the byte or word immediately following the op-&lt;br /&gt;code into a register or a memory location. Immediate addressing manipulates constant data &lt;br /&gt;in a program. In the 80386 and above, a doubleword immediate data may also be loaded into &lt;br /&gt;a 32-bit register or memory location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S. The .MODEL statement is used with assembly language to identify the start of a file and the &lt;br /&gt;type of memory model used with the file. If the size is TINY, the program exists in one seg-&lt;br /&gt;ment, the code segment, and is assembled as a command (.COM) program. If the SMALL &lt;br /&gt;model is used, the program uses a code and data segment and assembles as an execute &lt;br /&gt;(.EXE) program. Other model sizes and their attributes are listed in Appendix A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. Direct addressing occurs in two forms in the microprocessor: (1) direct addressing and &lt;br /&gt;(2) displacement addressing. Both forms of addressing are identical except that direct ad-&lt;br /&gt;dressing is used to transfer data between EAX, AX, or AL and memory, while displacement &lt;br /&gt;addressing is used with any register-memory transfer. Direct addressing requires three bytes &lt;br /&gt;of memory, while displacement addressing requires four bytes. Note that some of these in-&lt;br /&gt;structions in the 80386 and above may require additional bytes in the form of prefixes for &lt;br /&gt;register and operand sizes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Register indirect addressing allows data to be addressed at the memory location pointed to &lt;br /&gt;by either a base (BP and BX) or index register (DI and SO. In the 80386 and above, extended &lt;br /&gt;registers EAX, EBX, ECX, EDX, EBP, EDI, and ESI are used to address memory data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. Base-plus-index addressing often addresses data in an array. The memory address for this &lt;br /&gt;mode is formed by adding a base register, index register, and the contents of a segment register &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;96 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 3-12 Example real &lt;br /&gt;mode data-addressing modes Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,BL &lt;br /&gt;MOVAX,BX &lt;br /&gt;MOV EAX,ECX &lt;br /&gt;MOV OS,CX &lt;br /&gt;MOV AL,LlST &lt;br /&gt;MOV CH,OATA1 &lt;br /&gt;MOV ES,OATA2 &lt;br /&gt;MOV AL,12 &lt;br /&gt;MOV AL,[BP] &lt;br /&gt;MOV AL,[BX] &lt;br /&gt;MOV AL,[OI] &lt;br /&gt;MOV AL,[SI] &lt;br /&gt;MOV AL,[BP+2] &lt;br /&gt;MOV AL,[BX-4] &lt;br /&gt;MOV AL,[OI+ 1 OOOH] &lt;br /&gt;MOV AL,[SI+300H] &lt;br /&gt;MOV AL,LlST[BP] &lt;br /&gt;MOV AL,LlST[BX] &lt;br /&gt;MOV AL,LlST[OI] &lt;br /&gt;MOV AL,LlST[SI] &lt;br /&gt;MOV AL,LlST[BP+2] &lt;br /&gt;MOV AL,LlST[BX-6] &lt;br /&gt;MOV AL, LlST[OI+ 1 OOH] &lt;br /&gt;MOV AL,LlST[SI+200H] &lt;br /&gt;MOV AL,[BP+OI] &lt;br /&gt;MOV AL,[BP+SI] &lt;br /&gt;MOV AL,[BX+OI] &lt;br /&gt;MOV AL,[BX+SI] &lt;br /&gt;MOV AL,[BP+01+4] &lt;br /&gt;MOV AL,[BP+SI-8] &lt;br /&gt;MOV AL,[BX+OI+ 1 OH] &lt;br /&gt;MOV AL,[BX+ SI-10H] &lt;br /&gt;MOV AL,LlST[BP+OI] &lt;br /&gt;MOV AL,LlST[BP+SI] &lt;br /&gt;MOV AL,LlST[BX+OI] &lt;br /&gt;MOV AL,LlST[BX+SI] &lt;br /&gt;MOV AL,LlST[BP+01+2] &lt;br /&gt;MOV AL,LlST[BP+SI-7] &lt;br /&gt;MOV AL,LlST[BX+01+3] &lt;br /&gt;MOV AL,LlST[BX+SI-2] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address Generation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bit register addressing &lt;br /&gt;16-bit register addressing &lt;br /&gt;32-bit register addressing &lt;br /&gt;Segment register addressing &lt;br /&gt;(OS x 10H) + LIST &lt;br /&gt;(OS x 10H) + OATA1 &lt;br /&gt;(OS x 10H) + OATA2 &lt;br /&gt;Immediate data of 12H &lt;br /&gt;(SS x 10H) + BP &lt;br /&gt;{OS x 10H) + BX &lt;br /&gt;(OS x 10H) + 01 &lt;br /&gt;(OS x 10H) + SI &lt;br /&gt;(SS x 10H) + BP + 2 &lt;br /&gt;(OS x 10H) + BX - 4 &lt;br /&gt;(OS x 10H) + 01 + 1000H &lt;br /&gt;(OS x 10H) + SI + 300H &lt;br /&gt;(SS x 10H) + LIST + BP &lt;br /&gt;(OS x 10H) + LIST + BX &lt;br /&gt;(OS x 10H) + LIST + 01 &lt;br /&gt;(OS x 10H) + LIST + SI &lt;br /&gt;(SS x 10H) + LIST + BP + 2 &lt;br /&gt;(OS x 1 OH) + LIST + BX - 6 &lt;br /&gt;(OS x 10H) + LIST + 01 + 100H &lt;br /&gt;(OS x 10H) + LIST + SI + 200H &lt;br /&gt;(SS x 1 OH) + BP + 01 &lt;br /&gt;(SS x 10H) + BP + SI &lt;br /&gt;(OS x 10H) + BX + 01 &lt;br /&gt;(OS x 10H) + BX + SI &lt;br /&gt;(SS x 10H) + BP + 01 +4 &lt;br /&gt;(SS x 10H) + BP + SI - 8 &lt;br /&gt;(OS x 1 OH) + BX + 01 + 10H &lt;br /&gt;(OS x 10H) + BX + SI - 10H &lt;br /&gt;(SS x 10H) + LIST + BP + 01 &lt;br /&gt;(SS x 10H) + LIST + BP + SI &lt;br /&gt;(OS x 10H) + LIST + BX + 01 &lt;br /&gt;(OS x 10H) + LIST + BX + SI &lt;br /&gt;(SS x 1 OH) + LIST + BP + 01 + 2 &lt;br /&gt;(SS x 10H) + LIST + BP + SI-7 &lt;br /&gt;(OS x 10H) + LIST + BX + 01 + 3 &lt;br /&gt;(OS x 10H) + LIST + BX + SI - 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;times IOH. In the 80386 and above, the base and index registers may be any 32-bit register ex-&lt;br /&gt;cept EIP and ESP. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. Register relative addressing uses either a base or index register plus a displacement to access &lt;br /&gt;memory data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. Base relative-plus-index addressing is useful for addressing a two-dimensional memory &lt;br /&gt;array. Th,' address is formed by adding a base register, an index register, displacement, and &lt;br /&gt;the contents of a segment register times lOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Scaled-index addressing is unique to the 80386 through the Pentium Pro. The second of two &lt;br /&gt;registers (index) is scaled by a factor of 2X, 4X, or 8X to access words, doublewords, or &lt;br /&gt;quadwords in memory arrays. The MOY AX,[EBX+2*ECX] and the MOY [4*ECX],EDX &lt;br /&gt;are examples of scaled-index instructions. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-4 SUMMARY 97 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. Data structures are templates for storing arrays of data and are addressed by array name and field. &lt;br /&gt;For example, array NUMBER and field TEN of array NUMBER is addressed as NUMBER.TEN. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. Direct program memory addressing is allowed with the JMP and CALL instructions to any &lt;br /&gt;location in the memory system. With this addressing mode, the offset address and segment &lt;br /&gt;address are stored with the instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. Relative program addressing allows a JMP or CALL instruction to branch forward or back-&lt;br /&gt;ward in the current code segment by Â±32K bytes. In the 80386 and above, the 32-bit dis-&lt;br /&gt;placement allows a branch to any location in the current code segment using a displacement &lt;br /&gt;value of Â±2G bytes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. Indirect program addressing allows the JMP or CALL instructions to address another por-&lt;br /&gt;tion of the program or subroutine indirectly through a register or memory location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. The PUSH and POP instructions transfer a word between the stack and a register or memory &lt;br /&gt;location. A PUSH immediate instruction is available to place immediate data on the stack. The &lt;br /&gt;PUSHA and POPA instructions transfer AX, CX, DX, BX, BP, SP, SI, and DI between the &lt;br /&gt;stack and these registers. In the 80386 and above, the extended register and extended flags can &lt;br /&gt;also be transferred between registers and the stack. A PUSHFD stores the EFLAGS, while a &lt;br /&gt;PUSHF stores the FLAGS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. Example 3-15 shows many of the addressing modes presented in the chapter. This example &lt;br /&gt;program fills the ARRA Yl from locations 0000:0000-0000:0009. It then fills ARRA Y2 with &lt;br /&gt;0-9. Finally, it exchanges the contents of ARRA Yl element 2 with ARRA Y2 element 3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 3-15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;. MODEL SM.l\\LL &lt;br /&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 OOOA ARRAYl DB 10 DUP (7) &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA OOOA ARRAY2 DB 10 DUP (7) &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 .CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B8 0000 MOV AX, a &lt;br /&gt;001A 8E CO MOV ES,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001C BF 0000 MOV 01,0 &lt;br /&gt;001F B9 OOOA MOV CX,10 &lt;br /&gt;0022 LABl: &lt;br /&gt;0022 26: 8A as MOV AL,ES: [01] &lt;br /&gt;0025 88 85 0000 R MOV ARRAYl [01] ,AL &lt;br /&gt;0029 47 INC 01 &lt;br /&gt;002A E2 F6 LOOP LAB1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002C BF 0000 MOV 01,0 &lt;br /&gt;002F B9 OOOA MOV CX,10 &lt;br /&gt;0032 BO 00 MOV AL,O &lt;br /&gt;0034 LAB2: &lt;br /&gt;0034 88 85 OOOA R MOV ARRAY2 [01] ,AL &lt;br /&gt;0038 FE CO INC AL &lt;br /&gt;003A 47 INC DI &lt;br /&gt;003B E2 F7 LOOP LAB2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0030 BF 0003 MOV 01,3 &lt;br /&gt;0040 8A 85 0000 R MOV AL,ARRAY1 [01] &lt;br /&gt;0044 8A AS OOOB R MOV AH,ARRAY2 [DI+l] &lt;br /&gt;0048 88 AS 0000 R MOV ARRAYl[DI],AH &lt;br /&gt;004C 88 85 OOOB R MOV ARRAY2[DI+1],AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;se1ect SMALL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reserve for ARRAY 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reserve for ARRAY2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;segment ES is OOOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address element 0 &lt;br /&gt;;count of 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;copy data &lt;br /&gt;;into ARRAYl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address element a &lt;br /&gt;;count of 10 &lt;br /&gt;;initial value &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; fill ARRAY2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exchange array data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;98 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. What do the following MOY instructions accomplish? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) MOY AX,BX &lt;br /&gt;(b) MOY BX,AX &lt;br /&gt;(c) MOY BL,CH &lt;br /&gt;(d) MOY ESP,EBP &lt;br /&gt;(e) MOY AX,CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. List the 8-bit registers used for register addressing. &lt;br /&gt;3. List the I6-bit registers used for register addressing. &lt;br /&gt;4. List the 32-bit registers used for register addressing in the 80386 through the Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessors. &lt;br /&gt;5. List the I6-bit segment registers used for register addressing by MOY, PUSH, and POP. &lt;br /&gt;6. What is wrong with the MOY BL,CX instruction? &lt;br /&gt;7. What is wrong with the MOY DS,SS instruction? &lt;br /&gt;8. Select an instruction for each of the following tasks: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) copy EBX into EDX &lt;br /&gt;(b) copy BL into CL &lt;br /&gt;(c) copy SI into BX &lt;br /&gt;(d) copy DS into AX &lt;br /&gt;(e) copy AL into AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. Select an instruction for each of the following tasks: &lt;br /&gt;(a) move a I2H into AL &lt;br /&gt;(b) move a I23AH into AX &lt;br /&gt;(c) move a OCDH into CL &lt;br /&gt;(d) move a 1000H into SI &lt;br /&gt;(e) move a I200A2H into EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. What special symbol is sometimes used to denote immediate data? &lt;br /&gt;11. What is the purpose of the .MODEL TINY statement? &lt;br /&gt;12. What assembly language directive indicates the start of the CODE segment? &lt;br /&gt;13. What is a label? &lt;br /&gt;14. The MOY instruction is placed in what field of a statement? &lt;br /&gt;15. A label may begin with what characters? &lt;br /&gt;16. What is the purpose of the .EXIT directive? &lt;br /&gt;17. Does the .MODEL TINY statement cause a program to assemble an execute program? &lt;br /&gt;18. What tasks does the .STARTUP directive accomplish in the small memory model? &lt;br /&gt;19. What is a displacement? How does it determine the memory address in a MOY [2000H],AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;instruction? &lt;br /&gt;20. What do the symbols [ ] indicate? &lt;br /&gt;21. Suppose that DS = 0200H, BX = 0300H, and DI = 400H. Determine the memory address ac-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cessed by each of the following instructions, assuming real mode operation: &lt;br /&gt;(a) MOY AL,[1234H] &lt;br /&gt;(b) MOY EAX,[BX] &lt;br /&gt;(c) MOY [DI],AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22. What is wrong with a MOY [BX],[DI] instruction? &lt;br /&gt;23. Choose an instruction th; t requires BYTE PTR. &lt;br /&gt;24. Choose an instruction that requires WORD PTR. &lt;br /&gt;25. Choose an instruction that requires DWORD PTR. &lt;br /&gt;26. Explain the difference between the MOY BX,DATA instruction and the MOY BX,OFFSET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DA T A instruction. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3-5 QUESTIONS AND PROBLEMS 99 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27. Suppose that DS = 1000H, SS = 2000H, BP = 1000H, and DI = OIOOH. Detennine the memory &lt;br /&gt;address accessed by each of the following, assuming real mode operation: &lt;br /&gt;(a) MOY AL,[BP+DI] &lt;br /&gt;(b) MOY CX,[DI] &lt;br /&gt;(c) MOY EDX,[BP] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28. What, if anything, is wrong with a MOY AL,[BX][SI] instruction'? &lt;br /&gt;29. Suppose thal DS = 1200H, BX = OIOOE, and SI = 0250H. Determine the address accessed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;by each of the following instructions assuming real mode operation: &lt;br /&gt;(a) MOY [IOOH],DL &lt;br /&gt;(b) MOY [SI+IOOH],EAX &lt;br /&gt;(c) MOY DL,[BX+IOOH] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30. Suppose that DS = lIOOH, BX = 0200H, LIST = 0250H, and SI = 0500H. Determine the ad-&lt;br /&gt;dress accessed by each of the following instructions assuming real mode operation: &lt;br /&gt;(a) MOY LIST[SI],EDX &lt;br /&gt;(b) MOY CL,LIST[BX+SI] &lt;br /&gt;(c) MOY CH,[BX+SI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31. Suppose that DS = 1300H, SS = l400H, BP = l500H, and SI = OIOOH. Determine the ad-&lt;br /&gt;dress accessed by each of the following instructions, assuming real mode operation: &lt;br /&gt;(a) MOY EAX,[BP+200H] &lt;br /&gt;(b) MOY AL,[BP+SI-200H] &lt;br /&gt;(c) MOY AL,[SI-OIOOH] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32. Which base register addresses data in the stack segment? &lt;br /&gt;33. Suppose that EAX = OOOOIOOOH, EBX = 00002000H, and DS = OOIOH. Determine the ad-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;dress accessed by the following instructions, assuming real mode operation: &lt;br /&gt;(a) MOY ECX,[EAX+EBX] &lt;br /&gt;(b) MOY [EAX+2*EBX],CL &lt;br /&gt;(c) MOY DH,[EBX+4*EAX+IOOOH] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. Develop a data structure that has five fields of one word each named Fl, F2, F3, F4, and F5 &lt;br /&gt;with a structure name of FIELDS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;35. Show how field F3 of the data structure constructed in question 34 is addressed in a program. &lt;br /&gt;36. List all three program memory-addressing modes. &lt;br /&gt;37. How many bytes of memory store a far direct jump instruction? What is stored in each of the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bytes? &lt;br /&gt;38. What is the difference between an intersegmentjump and an intrasegmentjump? &lt;br /&gt;39. If a near jump uses a signed l6-bit displacement, how can it jump to any memory location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;within the current code segment? &lt;br /&gt;40. The 80386 and above use a -bit displacement to jump to any location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;within the 4G byte code segment. &lt;br /&gt;41. What is a far jump? &lt;br /&gt;42. If a JMP instruction is stored at memory location lOOH within the current code segment, it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cannot be a jump if it is jumping to memory location 200H within the cur-&lt;br /&gt;rent code segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;43. Show which JMP instruction (short, near, or far) assembles if the lMP THERE instruction is &lt;br /&gt;stored at memory address 10000H and the address of THERE is: &lt;br /&gt;(a) 10020H &lt;br /&gt;(b) llOOOH &lt;br /&gt;(c) OFFFEH &lt;br /&gt;(d) 30000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;44. Form a JMP instruction that jumps to the address pointed to by the BX register. &lt;br /&gt;45. Select a JMP instruction that jumps to the location stored in memory at the location table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assume that it is a near jump. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;100 CHAPTER 3 ADDRESSING MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;46. How many bytes are stored on the stack by the PUSH instruction? &lt;br /&gt;47. Explain how the PUSH [Dll instruction functions. &lt;br /&gt;48. What registers are placed on the stack by the PUSHA instruction? In what order are they &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;placed? &lt;br /&gt;49. What does the PUSHAD instruction accomplish? &lt;br /&gt;50. Which instruction places the EFLAGS on the stack in the Pentium microprocessor? &lt;br /&gt;51. Use the Internet to write a report detailing the Intel 80196 embedded controller. &lt;br /&gt;52. Use the Internet to write a report detailing the Intel 8051 embedded controller. &lt;br /&gt;53. Use the Internet to write a report detailing the Motorola 6811 microprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CHAPTER 4 &lt;br /&gt;Data Movement Instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This chapter concentrates on the data movement instructions. The data movement instructions &lt;br /&gt;include MQV, Â¥OVSX, JylOVZX, Pg_SH, .PgP, BSW AP, :}(CHG, fCLAT, lN, gUT, LEA, &lt;br /&gt;LDS, -hÂ§S, ~FS, ~qs, ~~S, LAHF, SAHF, and the string instructions lY10~S, LODS, STOS, &lt;br /&gt;INS, and OUTS. The latest data transfer instruction implemented on the Pentium Pro is the &lt;br /&gt;cCM.9_V (c~~itional m~ fnsirtiction.The data movement instru~ti~~~ -~~~ presented first &lt;br /&gt;because they are more commonly used in programs and are easy to understand. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The microprocessor requires an assembler program, which generates machine language, &lt;br /&gt;because machine language instructions are too complex to generate efficiently by hand. This &lt;br /&gt;chapter describes the ~~~~blylanguage syntax and some o(1!~stirecti:ves. (This text assumes &lt;br /&gt;that the user is developing software on anJI!M perso!tal computer or clone. It is recommended &lt;br /&gt;that the Microsoft MACRO assembler (MASM) be used a~the dev&amp;lt;::l()proef\\t tool, but the Intel &lt;br /&gt;Assembler (ASM), Borland Turbo assembler (T ASM), or similar software functions equally as &lt;br /&gt;well. This text presents information that functions with the Microsoft MASM assembler, but &lt;br /&gt;most programs assemble withoutIIl0c:iificationwith other as;emblers. Appendix A explains the &lt;br /&gt;Microsoft assembler and provides details on the linker program and Programmer's WorkBench.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. Explain the operation of each data movement instruction with applicable addressing modes. &lt;br /&gt;2. Explain the purposes of the assembly language pseudo-operations and key words such as &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALIGN, ASSUME, DB, DD, DW, END, ENDS, ENDP, EQU, .MODEL, OFFSET, ORG, &lt;br /&gt;PROC, PTR, SEGMENT, USEl6, USE32, and USES. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Select the appropriate assembly language instruction to accomplish a specific data move-&lt;br /&gt;ment task. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. Determine the symbolic opcode, source, destination, and addressing mode for a hexadecimal &lt;br /&gt;machine language instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Use the assembler to set up a data segment, stack segment, and code segment. &lt;br /&gt;6. Show how to set up a procedure using PROC and ENDP. &lt;br /&gt;7. Explain the difference between memory models and full segment definitions for the MASM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;assembler. &lt;br /&gt;101 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;102 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode &lt;br /&gt;1-2 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV REVISITED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The MOV instruction, introduced in Chapter 3, explains the diversity of 8086-80486IPentium &lt;br /&gt;Pro addressing modes. In this chapter, the MOV instruction introduces the machine language in-&lt;br /&gt;structions available with various addressing modes and instructions. Machine code is introduced &lt;br /&gt;because it may occasionally be necessary to interpret machine language programs generated by &lt;br /&gt;an assembler. Interpretation of the machine's native language (machine language) allows de-&lt;br /&gt;bugging or modification at the machine language level. Occasionally, machine language patches &lt;br /&gt;are made using the DEBUG program available with DOS, which requires some knowledge of &lt;br /&gt;machine language. Conversion between machine and assembly language instructions is illus-&lt;br /&gt;trated in Appendix B. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Machine Language &lt;br /&gt;Machine language is the native binary code that the microprocessor understands and uses as its &lt;br /&gt;instructions to control its operation. Machine language instructions for the 8086 through the Pen-&lt;br /&gt;tium Pro vary in length from one to as many as thirteen bytes. Although machine language ap-&lt;br /&gt;pears to be complex, there is order to this microprocessor's machine language. There are well &lt;br /&gt;over 100,000 variations of machine language instructions, which means that no complete list of &lt;br /&gt;these variations exists. Because of this, some binary bits in a machine language instruction are &lt;br /&gt;given, and the remainder are determined for each variation of the instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instructions for the 8086 through the 80286 are 16-bit mode instructions that take the form &lt;br /&gt;found in Figure 4-1 (a). The 16-bit mode instructions are compatible with the 80386 and above &lt;br /&gt;if they are programmed to operate in the 16-bit instruction mode, but they may be prefixed as &lt;br /&gt;shown in Figure 4-1 (b). The 80386 and above assume that all instructions are 16-bit mode in-&lt;br /&gt;structions when the machine is operated in the real mode. In the protected mode, the upper byte &lt;br /&gt;of the descriptor contains the D-bit that selects either the 16- or 32-bit instruction mode. At pre-&lt;br /&gt;sent, only Windows NT, Windows 95, and OS/2 operate in the 32-bit instruction mode. The 32-&lt;br /&gt;bit mode instructions are in the form shown in Figure 4-1 (b). These instructions occur in the &lt;br /&gt;16-bit instruction mode by the use of prefixes, which are explained later in this chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first two bytes of the 32-bit instruction mode format are called override prefixes be-&lt;br /&gt;cause they are not always present. The first modifies the size of the operand address used by the &lt;br /&gt;instruction, and the second modifies the register size. If the 80386 through the Pentium Pro op-&lt;br /&gt;erate as 16-bit instruction mode machines (real or protected mode) and a 32-bit register is used, &lt;br /&gt;the register-size prefix (66H) is appended to the front of the instruction. If operated in the 32-bit &lt;br /&gt;instruction mode (protected mode only) and a 32-bit register is used, the register-size prefix is &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-bit instruction mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOO-REG-R/M &lt;br /&gt;0-1 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement &lt;br /&gt;0-1 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Immediate &lt;br /&gt;0-2 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32-bit instruction mode (80386, 80486, Pentium, or Pentium Pro only) &lt;br /&gt;-Add;~~~-~i;~ -~ ~ -O;;~;~~d- ~i~~-~ Opcode &lt;br /&gt;___ ~:-_1_ ~Y.'~_~ __ ! L __ ~:-_1_~Y.'~_~ __ ! ~_1-_2_b_yt_e_s--l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOO-REG-R/M Scaled-index &lt;br /&gt;0-1 bytes 0-1 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Immediate &lt;br /&gt;0-4 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-1 The formats of the BOB6-Pentium Pro instructions. (a) The 16-bit form and (b) the 32-bit form. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-1 MOV REVISITED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-2 Byte 1 of &lt;br /&gt;many machine language in-&lt;br /&gt;structions, showing the posi-&lt;br /&gt;tion of the 0- and W-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;103 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;absent. If a 16-bit register appears in an instruction in the 32-bit instruction mode, the register-&lt;br /&gt;size prefix is present to select a 16-bit register. The address-size prefix (67H) is used in a sim-&lt;br /&gt;ilar fashion, as explained later in this chapter. The prefixes toggle the size of the register and &lt;br /&gt;operand address from 16-bit to 32-bit or 32-bit to 16-bit for the prefixed instruction. Note that &lt;br /&gt;the 16-bit instruction mode uses 8- and 16-bit registers and addressing modes, while the 32-bit &lt;br /&gt;instruction mode uses 8- and 32-bit registers and addressing modes by default. The prefixes &lt;br /&gt;override these defaults so that a 32-bit register can be used in the 16-bit mode or a 16-bit register &lt;br /&gt;can be used in the 32-bit mode. The mode of operation (16- or 32-bits) should be selected to &lt;br /&gt;conform with the application at hand. If 8- and 32-bit data pervade the application, then the 32-&lt;br /&gt;bit mode should be selected; likewise, if 8- and 16-bit data pervade, then the 16-bit mode should &lt;br /&gt;be selected. Normally, mode selection is a function of the operating system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Opcode. The opcode selects the operation (addition, subtraction, move, etc.) performed by &lt;br /&gt;the microprocessor. The opcode is either one or two bytes long for most machine language in-&lt;br /&gt;structions. Figure 4-2 illustrates the general form of the first opcode byte of many, but /lot all, &lt;br /&gt;machine language instructions. Here, the first six bits of the first byte are the binary opcode. The &lt;br /&gt;remaining two bits indicate the direction (D)-not to be confused with the instruction mode bit &lt;br /&gt;(16/32) or direction flag bit (used with string instructions)-of the data flow and whether the &lt;br /&gt;data are a byte or a word (W). In the 80386 and above, words and doublewords are both speci-&lt;br /&gt;fied when W = 1. The instruction mode and register-size prefix (66H) determine whether W rep-&lt;br /&gt;resents a word or a doubleword. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the direction bit (D) = 1, data flow to the register (REG) field from the RlMJield located &lt;br /&gt;in the second byte of an instruction. If the D-bit = 0 in the opcode, data flow to the RIM field &lt;br /&gt;from the REG field. If the W -bit = 1, the data size is a word or doubleword; if the W -bit = 0, the &lt;br /&gt;data size is a byte. The W-bit appears in most instructions, while the D-bit appears mainly with &lt;br /&gt;the MOY and some other instructions. Refer to Figure 4-3 for the binary bit pattern of the &lt;br /&gt;second opcode byte (reg-mod-rlm) of many instructions. Figure 4-3 shows the location of the &lt;br /&gt;MOD (mode), REG (register), and RIM (register/memory) fields. &lt;br /&gt;MOD Field. The MOD field specifies the addressing mode (MOD) for the selected instruction. &lt;br /&gt;The MOD field selects the type of addressing and whether a displacement is present with the se-&lt;br /&gt;lected type. Table 4-1 lists the operand forms available to the MOD field for the 16-bit instruction &lt;br /&gt;mode, unless the operand address-size override prefix (67H) appears. If the MOD field contains a &lt;br /&gt;11, it selects the register-addressing mode. Register addressing uses the RIM field to specify a reg-&lt;br /&gt;ister instead of a memory location. If the MOD field contains a 00, 01, or 10, the RIM field selects &lt;br /&gt;one of the data memory-addressing modes. When MOD selects a data memory-addressing mode, &lt;br /&gt;it indicates that the addressing mode contains no displacement (00), an 8-bit sign-extended dis-&lt;br /&gt;placement (01), or a 16-bit displacement (10). The MOY AL,[DIJ instruction is an example &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-3 Byte 2 of &lt;br /&gt;many machine language in-&lt;br /&gt;structions, showing the posi-&lt;br /&gt;tion of the MOD, REG, and &lt;br /&gt;R/M fields &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOD REG RIM &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;104 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-1 MOD field for &lt;br /&gt;the 16-bit instruction mode MOD Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 No displacement &lt;br /&gt;01 8-bit sign-extended displacement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. 10 16-bit displacement &lt;br /&gt;11 RIM is a register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;showing no displacement; a MOV AL,[DI + 2] instruction uses an 8-bit displacement (+ 2); and a &lt;br /&gt;MOV AL,[DI + 1000H] instruction uses a 16-bit displacement (+ 1000H). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All 8-bit displacements are sign-extended into 16-bit displacements when the micro-&lt;br /&gt;processor executes the instruction. If the 8-bit displacement is 00H-7FH (positive), it is sign-&lt;br /&gt;extended to 0000H-007FH before adding to the offset address. If the 8-bit displacement is &lt;br /&gt;80H-FFH (negative), it is sign-extended to FF80H-FFFFH. To sign-extend a number, its sign-&lt;br /&gt;bit is copied to the next higher-order byte, which generates either a OOH or an FFH in the higher-&lt;br /&gt;order byte. Note that some assembler programs do not use the 8-bit displacements. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80386 through the Pentium Pro microprocessors, the MOD field may be the same as &lt;br /&gt;shown in Table 4-1; if the instruction mode is 32-bits, the MOD field is as appears in Table 4-2. &lt;br /&gt;The MOD field is interpreted as selected by the address-size override prefix or the operating mode &lt;br /&gt;of the microprocessor. This change in the interpretation of the MOD field and instruction supports &lt;br /&gt;many of the numerous additional addressing modes allowed in the 80386 through the Pentium &lt;br /&gt;Pro. The main difference is when the MOD field is a 10. This causes the 16-bit displacement to &lt;br /&gt;become a 32-bit displacement to allow any protected mode memory location (4G bytes) to be ac-&lt;br /&gt;cessed. The 80386 and above allow only an 8- or 32-bit displacement when operated in the 32-bit &lt;br /&gt;instruction mode, unless the address-size override prefix appears. Note that if an 8-bit displace-&lt;br /&gt;ment is selected, it is sign-extended into a 32-bit displacement by the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register Assignments. Table 4-3 lists the register assignments for the REG field and the RIM &lt;br /&gt;field (MOD = 11). This table contains three lists of register assignments: one is used when the &lt;br /&gt;W-bit = 0 (bytes), and the other two are used when the W-bit = 1 (words or doublewords). Note &lt;br /&gt;that doubleword registers are used only available to the 80386 through the Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a 2-byte instruction, 8BECH, appears in a machine language program. Be-&lt;br /&gt;cause neither a 67H (operand address-size override prefix) nor 66H (register-size override &lt;br /&gt;prefix) appears as the first byte, the first byte is the opcode. Assuming that the microprocessor is &lt;br /&gt;operated in the 16-bit instruction mode, this instruction is converted to binary and placed in the &lt;br /&gt;instruction format of bytes 1 and 2, as illustrated in Figure 4-4. The opcode is 100010. If you &lt;br /&gt;refer to Appendix B, which lists the machine language instructions, you will find that this is the &lt;br /&gt;opcode for a MOV instruction. Also notice that both the D- and W-bits are a logic 1, which &lt;br /&gt;means that a word moves into the destination register specified in the REG field. The REG field &lt;br /&gt;contains a 101, indicating register BP, so the MOV instruction moves data into register BP. Be-&lt;br /&gt;cause the MOD field contains a II, the RIM field also indicates a register. Here, RIM = 100 (SP); &lt;br /&gt;therefore, this instruction moves data from SP into BP and is written in symbolic form as a MOV &lt;br /&gt;BP,SP instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-2 MOD field for &lt;br /&gt;the 32-bit instruction mode &lt;br /&gt;(80386-Pentium Pro only) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;01 &lt;br /&gt;10 &lt;br /&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;No displacement &lt;br /&gt;8-bit sign-extended displacement &lt;br /&gt;32-bit displacement &lt;br /&gt;RIM is a register &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;TABLE 4-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-1 MOV REVISITED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0: 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode = MOV &lt;br /&gt;0= Transfer to register (REG) &lt;br /&gt;W=Word &lt;br /&gt;MOD = RIM is a register &lt;br /&gt;REG = BP &lt;br /&gt;RIM = SP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o W &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;105 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOD REG RIM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 : 1 o o 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-4 The 8BEC instruction placed into Byte 1 and 2 formats from Figure 4-2 and 4-3. &lt;br /&gt;This instruction is a MOV BP,SP. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a 668BE8H instruction appears in an 80386 or above operated in the l6-bit &lt;br /&gt;instruction mode. The first byte (66H) is the register-size override prefix that selects 32-bit reg-&lt;br /&gt;ister operands for the 16-bit instruction mode. The remainder of the instruction indicates that the &lt;br /&gt;opcode is a MOV with a source operand of EAX and a destination operand of EBP. This in-&lt;br /&gt;struction is a MOV EBP,EAX. The same instruction becomes a MOV BP,AX instruction in the &lt;br /&gt;80386 and above if it is operated in the 32-bit instruction mode because the register-size override &lt;br /&gt;prefix selects a 16-bit register. Luckily, the assembler program keeps track of the register- and &lt;br /&gt;address-size prefixes and the mode of operation. Recall that if the .386 switch is placed before &lt;br /&gt;the .MODEL statement, the 32-bit mode is selected; if it is placed after the .MODEL statement, &lt;br /&gt;the l6-bit mode is selected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RIM Memory Addressing. If the MOD field contains a 00,01, or 10, the RIM field takes on a &lt;br /&gt;new meaning. Table 4-4 lists the memory-addressing modes for the RIM field when MOD is a &lt;br /&gt;00,01, or 10 for the 16-bit instruction mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All of the 16-bit addressing modes presented in Chapter 3 appear in Table 4-4. The dis-&lt;br /&gt;placement, discussed in Chapter 3, is defined by the MOD field. If MOD = 00 and RIM = 101, &lt;br /&gt;the addressing mode is [DIl If MOD = 01 or 10, the addressing mode is [DI + 33H] or LIST [DI &lt;br /&gt;+ 22H] for the 16-bit instruction mode. This example uses LIST, 33H, and 22H as arbitrary &lt;br /&gt;values for the displacement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 4-5 illustrates the machine language version of the 16-bit instruction MOV DL,[DI] &lt;br /&gt;or instruction (8A15H). This instruction is two bytes long and has an opcode 100010, D = 1 (to &lt;br /&gt;REG from RIM), W = 0 (byte), MOD = 00 (no displacement), REG = 010 (DL), and RIM = 101 &lt;br /&gt;([DID. If the instruction changes to MOY DL,[DI + 1], the MOD field changes to 01 for an 8-bit &lt;br /&gt;displacement, but the first two bytes of the instruction otherwise remain the same. The instruction &lt;br /&gt;now becomes 8A5501H instead of 8A1SH. Notice that the 8-bit displacement appends to the first &lt;br /&gt;two bytes of the instruction to form a 3-byte instruction instead of two bytes. If the instruction is &lt;br /&gt;again changed to a MOV DL,[DI+1000H], the machine language form becomes a 8A750010H. &lt;br /&gt;Here the 16-bit displacement of 1000H (coded as 001OH) appends the opcode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REG and &lt;br /&gt;RIM (when MOO = 11) Code w=o (Byte) W=1 (Word) W=1 (Doubleword) &lt;br /&gt;aSSignments &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 AL AX EAX &lt;br /&gt;001 CL CX ECX &lt;br /&gt;010 OL OX EOX &lt;br /&gt;011 BL BX EBX &lt;br /&gt;100 AH SP ESP &lt;br /&gt;101 CH BP EBP &lt;br /&gt;110 OH SI ESI &lt;br /&gt;111 BH 01 EOI &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;106 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0: 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode = MOV &lt;br /&gt;o = Transfer to register (REG) &lt;br /&gt;W= Byte &lt;br /&gt;MOD = No displacement &lt;br /&gt;REG = OL &lt;br /&gt;RIM = OS:[OI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o w MOD REG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-5 A MOV DL,[DI] instruction converted to its machine language form &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RIM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Special Addressing Mode. There is a special addressing mode that does not appear in Tables &lt;br /&gt;4-2, 4-3, or 4-4 that occurs whenever memory data are referenced by only the displacement &lt;br /&gt;mode of addressing for 16-bit instructions. Examples are the MOV [lOOOH],DL and MOV &lt;br /&gt;NUMB,DL instructions. The first instruction moves the contents of register DL into data seg-&lt;br /&gt;ment memory location 1000R. The second instruction moves register DL into symbolic data seg-&lt;br /&gt;ment memory location NUMB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever an instruction has only a displacement, the MOD field is always a 00 and the &lt;br /&gt;RIM field is always a 110. As indicated in the tables, this combination shows that the instruction &lt;br /&gt;contains no displacement and uses addressing mode [BP]. You cannot actually use addressing &lt;br /&gt;mode [BP] without a displacement in machine language. The assembler takes care of this by using &lt;br /&gt;an 8-bit displacement (MOD = 01) of OOH whenever the [BP] addressing mode appears in an in-&lt;br /&gt;struction. This means that the [BP] addressing mode assembles as a [BP + 0] even though a [BP] &lt;br /&gt;is used in the instruction. The same special addressing mode is also available to the 32-bit mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 4-6 shows the binary bit pattern required to encode the MOV [lOOOH],DL instruc-&lt;br /&gt;tion in machine language. If the individual translating this symbolic instruction into machine lan-&lt;br /&gt;guage does not know about the special addressing mode, the instruction would incorrectly &lt;br /&gt;translate to a MOV [BP],DL. Figure 4-7 shows the actual form of the MOV [BP],DL instruction. &lt;br /&gt;Notice that this is a 3-byte instruction with a displacement of OOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32-bit Addressing Modes. The 32-bit addressing modes found in the 80386 and above are ob-&lt;br /&gt;tained by either running these machines in the 32-bit instruction mode or in the 16-bit instruction &lt;br /&gt;mode by using the address-size prefix 67H. Table 4-5 shows the coding for RIM used to specify &lt;br /&gt;the 32-bit addressing modes. Notice that when RIM = 100, an additional byte appears in the in-&lt;br /&gt;struction called a scaled-index byte. The scaled-index byte indicates the additional forms of &lt;br /&gt;scaled-index addressing that do not appear in Table 4-5. The scaled-index byte is mainly used &lt;br /&gt;when two registers are added to specify the memory address in an instruction. Because the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-4 16-bit RIM &lt;br /&gt;memory-addressing modes R/Meade &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 &lt;br /&gt;001 &lt;br /&gt;010 &lt;br /&gt;011 &lt;br /&gt;100 &lt;br /&gt;101 &lt;br /&gt;110 &lt;br /&gt;111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addressing Mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D8:[BX+81] &lt;br /&gt;08:[BX+DI] &lt;br /&gt;88:[BP+81] &lt;br /&gt;88:{BP+01] &lt;br /&gt;08:[81] &lt;br /&gt;08:[01] &lt;br /&gt;88:[BP]* &lt;br /&gt;D8:[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'Note: See text section, Special &lt;br /&gt;Addressing Mode. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-1 MOV REVISITED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode D W &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 0 I 0 I 0 &lt;br /&gt;Byte 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement-low &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 o 0: 0 000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode = MOV &lt;br /&gt;D = Transfer from register (REG) &lt;br /&gt;W = Byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOD = because RIM is [BP] (special addressing) &lt;br /&gt;REG = DL &lt;br /&gt;RIM = DS:[BP] &lt;br /&gt;Displacement = 1000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOD REG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement-high &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 1 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-6 The MOV [1000H],DL instruction uses the special addressing mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;107 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RIM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;scaled-index byte is added to the instruction, there are seven bits in the opcode to define and &lt;br /&gt;eight bits in the scaled-index byte. This means that a scaled-index instruction has 215 (32K) pos-&lt;br /&gt;sible combinations. There are over 32,000 different variation of the MOV instruction alone in &lt;br /&gt;the 80386 through the Pentium Pro microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 4-8 shows the format of the scaled-index byte as selected by a value of 100 in the &lt;br /&gt;RIM field of an instruction when the 80386 and above use a 32-bit address. The leftmost two bits &lt;br /&gt;select a scaling factor (multiplier) of IX, 2X, 4X, or 8X. Note that a scaling factor of IX is im-&lt;br /&gt;plicit if none is used in an instruction that contains two 32-bit indirect address registers. The index &lt;br /&gt;and base fields both contain register numbers, as indicated in Table 4-3 for 32-bit registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode D W &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 0 ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a-bit displacement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 o 0 ~ 0 000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode = MOV &lt;br /&gt;D = Transfer from register (REG) &lt;br /&gt;W = Byte &lt;br /&gt;MOD = because RIM is [BP] (special addressing) &lt;br /&gt;REG = DL &lt;br /&gt;RIM = DS:[BP] &lt;br /&gt;Displacement = OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOD REG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o o 1 : 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-7 The MOV [BP],DL instruction converted to binary machine language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RIM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;108 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-5 32-bit address-&lt;br /&gt;ing modes selected by RIM RIM Code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 &lt;br /&gt;001 &lt;br /&gt;010 &lt;br /&gt;011 &lt;br /&gt;100 &lt;br /&gt;101 &lt;br /&gt;110 &lt;br /&gt;111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS:[EAX] &lt;br /&gt;DS:[ECX[ &lt;br /&gt;DS:[EDX] &lt;br /&gt;DS:[EBX] &lt;br /&gt;Uses scaled-index byte &lt;br /&gt;SS:[EBP]* &lt;br /&gt;DS:[ESI] &lt;br /&gt;DS:[EDI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'Note: See text section, Special Addressing Mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The MOV EAX,[EBX+4*ECX] instruction is encoded as 67668B048BH. Notice that both &lt;br /&gt;the address size (67H) and register size (66H) override prefixes appear in the instruction. This &lt;br /&gt;coding (67668B048BH) is used when the 80386 and above are operated in the 16-bit instruction &lt;br /&gt;mode for this instruction. If the microprocessor operates in the 32-bit instruction mode, both pre-&lt;br /&gt;fixes disappear and the instruction becomes a 8B048BH instruction. The use of the prefixes de-&lt;br /&gt;pends on the mode of operation of the microprocessor. Scaled-index addressing can also use a &lt;br /&gt;single register multiplied by a scaling factor. An example is the MOV AL,[2*ECX] instruction. &lt;br /&gt;The contents of the data segment location addressed by two times ECX is copied into AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An Immediate Instruction. Suppose the MOV WORD PTR [BX+1000H],1234H instruction is &lt;br /&gt;chosen as an example of a 16-bit instruction using immediate addressing. This instruction moves a &lt;br /&gt;1234H into the word-sized memory location addressed by the sum of lOOOH, BX, and DS X IOH. &lt;br /&gt;This six-byte instruction uses two bytes for the opcode, W, MOD, and RIM fields. Two of the six-&lt;br /&gt;bytes are the data of 1234H. Two of the six bytes are the displacement of IOOOH. Figure 4-9 shows &lt;br /&gt;the binary bit pattern for each byte of this instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This instruction, in symbolic form, includes WORD PTR. The WORD PTR directive indi-&lt;br /&gt;cates to the assembler that the instruction uses a word-sized memory pointer. If the instruction &lt;br /&gt;moves a byte of immediate data, then BYTE PTR replaces WORD PTR in the instruction. Like-&lt;br /&gt;wise, if the instruction uses a doubleword of immediate data, the DWORD PTR directive re-&lt;br /&gt;places BYTE PTR. Most instructions that refer to memory through a pointer do not need the &lt;br /&gt;BYTE PTR, WORD PTR, or DWORD PTR directives. These are only necessary when it is not &lt;br /&gt;clear if the operation is a byte or a word. The MOV [BX],AL instruction is clearly a byte move, &lt;br /&gt;while the MOV [BX],l instruction is not exact and could therefore be a byte-, word-, or double-&lt;br /&gt;word-sized move. Here the instruction must be coded as MOV BYTE PTR [BX], 1, MOV &lt;br /&gt;WORD PTR [BX], 1, or MOV DWORD PTR [BX], 1. If not, the assembler flags it as an error be-&lt;br /&gt;cause it cannot determine the intent of this instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment MOV Instructions. If the contents of a segment register are moved by the MOV, &lt;br /&gt;PUSH, or POP instructions, a special set of register bits (REG field) selects the segment register &lt;br /&gt;(see Table 4-6). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-8 The MOV &lt;br /&gt;[BP],DL instr'~ction converted &lt;br /&gt;to binary machine language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s s &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ss &lt;br /&gt;00 = x 1 &lt;br /&gt;01 = x 2 &lt;br /&gt;10 = x4 &lt;br /&gt;11 = x 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Index Base &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-1 MOV REVISITED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode w &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 0 I I &lt;br /&gt;Byte 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement-low &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 o 0: 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data-low &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 1 : 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode = MOV (immediate) &lt;br /&gt;W = Word &lt;br /&gt;MOD = 16-bit displacement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REG = 000 (not used in immediate addressing) &lt;br /&gt;RIM = DS:[BX] &lt;br /&gt;Displacement = 1000H &lt;br /&gt;Data = 1234H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;109 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOD RIM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement-high &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 1 0 0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data-high &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 1 0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byte 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-9 A MOV WORD PTR [BX+1000H],1234H instruction converted to binary machine &lt;br /&gt;language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 4-10 shows a MOY BX,CS instruction converted to binary. The opcode for this &lt;br /&gt;type of MOY instruction is different for the prior MOY instructions. Segment registers can be &lt;br /&gt;moved between any 16-bit register or 16-bit memory location. For example, the MOY [DI],DS &lt;br /&gt;instruction stores the contents of DS into the memory location addressed by DI in the data seg-&lt;br /&gt;ment. An immediate segment register MOY is not available in the instruction set. To load a seg-&lt;br /&gt;ment register with immediate data, first load another register with the data and then move it to a &lt;br /&gt;segment register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Although this has not been a complete coverage of machine language coding, it should give &lt;br /&gt;you a good start in machine language programming. Remember that a program written in sym-&lt;br /&gt;bolic assembly language (assembly language) is rarely assembled by hand into binary machine &lt;br /&gt;language. An assembler program converts symbolic assembly language into machine language. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ope ode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o o 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opeode = MOV &lt;br /&gt;MOD = RIM is a register &lt;br /&gt;REG = CS &lt;br /&gt;RIM = BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOD REG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-10 A MOV BX,CS instruction converted to binary machine language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RIM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-6 Segment regis-&lt;br /&gt;ter selection Code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 &lt;br /&gt;001 &lt;br /&gt;010 &lt;br /&gt;011 &lt;br /&gt;100 &lt;br /&gt;101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES &lt;br /&gt;esÂ· &lt;br /&gt;ss &lt;br /&gt;DS &lt;br /&gt;FS &lt;br /&gt;GS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;*Note: MOV CS,RlM(16) and &lt;br /&gt;POP CS are not allowed by the &lt;br /&gt;microprocessor. The FS and GS &lt;br /&gt;segments are only available to &lt;br /&gt;the 8D386-Pentium Pro micro-&lt;br /&gt;processors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;With the microprocessor and its over 100,000 instruction variations, let us hope that an assem-&lt;br /&gt;bler is available for the conversion, because the process is very time-consuming, although not &lt;br /&gt;impossible. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH/POP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PUSH and POP instructions are important instructions that store and retrieve data from the &lt;br /&gt;LIFO (last-in, first-out) stack memory. The microprocessor has six forms of the PUSH and POP &lt;br /&gt;instructions: register, memory, immediate, segment register, flags, and all registers. The PUSH &lt;br /&gt;and POP immediate and the PUSHA and POPA (all registers) forms are not available in the ear-&lt;br /&gt;lier 8086/8088 microprocessors, but are available to the 80286 through the Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register addressing allows the contents of any 16-bit register to be transferred to or from &lt;br /&gt;the stack. In the 80386 and above, the 32-bit extended registers and flags (EFLAGS) can also be &lt;br /&gt;pushed or popped from the stack. Memory addressing PUSH and POP instructions store the con-&lt;br /&gt;tents of a 16-bit memory location (or 32-bits in the 80386 and above) on the stack or stack data &lt;br /&gt;into a memory location. Immediate addressing allows immediate data to be pushed onto the &lt;br /&gt;stack, but not popped off the stack. Segment register addressing allows the contents of any seg-&lt;br /&gt;ment register to be pushed onto the stack or removed from the stack (eS may be pushed, but data &lt;br /&gt;from the stack may never be popped into eS). The flags may be pushed or popped from that &lt;br /&gt;stack, and the contents of all the registers may be pushed or popped. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH &lt;br /&gt;The 8086-80286 PUSH instruction always transfers two bytes of data to the stack; the 80386 and &lt;br /&gt;above transfer two or four bytes, depending on the register or size of the memory location. The &lt;br /&gt;source of the data may be any internal 16-bit/32-bit register, immediate data, any segment reg-&lt;br /&gt;ister, or any two bytes of memory data. There is also a PUSHA instruction that copies the con-&lt;br /&gt;tents of the internal register set, except the segment registers, to the stack. The PUSHA (push &lt;br /&gt;all) instruction copies the registers to the stack in the following order: AX, ex, OX, BX. SP, BP, &lt;br /&gt;SI, and 01. The value of SP p,,:;hed to the stack is whatever it was before the PUSHA instruction &lt;br /&gt;executes. The PUSHF (push flags) instruction copies the contents of the flag register to the &lt;br /&gt;stack. The PUSHAO and POPAO instructions push and pop the contents of the 32-bit register set &lt;br /&gt;found in the 80386 through the Pentium Pro. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-2 PUSH/POP 111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack segment o 12FFF &lt;br /&gt;~03800 EAXb l 6 A B g 6 A B 3 ~ :: J::::: ~ v .. &lt;br /&gt;------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP o 7 F E I &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS 03000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS 07FE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SS o 3 0 0 &lt;br /&gt;-t\\-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-... &lt;br /&gt;3000 37FE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-11 The effect of the PUSH AX instruction on ESP and stack memory location &lt;br /&gt;37FFH and 37FEH. This instruction is shown at the point after execution. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever data are pushed onto the stack, the first (most-significant) data byte moves into &lt;br /&gt;the stack segment memory location addressed by SP - 1. The second (least-significant) data byte &lt;br /&gt;moves into the stack segment memory location addressed by SP - 2. After the data are stored by &lt;br /&gt;a PUSH, the contents of the SP register decrement by 2. The same is true for a doubleword push, &lt;br /&gt;except that four bytes are moved to the stack memory (most-significant byte first), often which &lt;br /&gt;the stack pointer decrements by 4. Figure 4-11 shows the operation of the PUSH AX instruction. &lt;br /&gt;This instruction copies the contents of AX onto the stack where address SS:[SP - 1] = AH, &lt;br /&gt;SS:[SP - 2] = AL, and afterwards SP = SP - 2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PUSHA instruction pushes all of the internal 16-bit registers onto the stack, as illus-&lt;br /&gt;trated in Figure 4-12. This instruction requires 16 bytes of stack memory space to store all eight &lt;br /&gt;16-bit registers. After all registers are pushed, the contents of the SP register are decremented by &lt;br /&gt;16. The PUSHA instruction is very useful when the entire register set (microprocessor environ-&lt;br /&gt;ment) of the 80286 and above must be saved during a task. Note that the PUSHAD instruction &lt;br /&gt;places the 32-bit register on the stack in the 80386 through the Pentium Pro. PUSHAD requires &lt;br /&gt;32 bytes of stack storage space. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PUSH immediate data instruction has two different opcodes, but in both cases a 16-bit &lt;br /&gt;immediate number moves onto the stack; if PUSHD is used, a 32-bit immediate datum is pushed. &lt;br /&gt;If the value of the immediate data is OOH-FFH, the opcode is a 6AH; if the value of the data is &lt;br /&gt;OIOOH-FFFFH, the opcode is 68H. The PUSH 8 instruction, which pushes an 0008H onto the &lt;br /&gt;stack, assembles as a 6A08H; the PUSH 1000H instruction assembles as a 68001OH. Another &lt;br /&gt;example of PUSH immediate is the PUSH 'A' instruction, which pushes a 0041H onto the stack. &lt;br /&gt;Here the 41 H is the ASCII code for the letter A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 4-7 lists the forms of the PUSH instruction that include PUSHA and PUSHF. Notice &lt;br /&gt;how the instruction set is used to specify different data sizes with the assembler. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;112 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-12 The opera-&lt;br /&gt;tion of the PUSHA instruction, &lt;br /&gt;showing the location and &lt;br /&gt;order of stack data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SP after PUSHA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--- 16-bits ___ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ex &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The POP instruction performs the inverse operation of a PUSH instruction. The POP instruction &lt;br /&gt;removes data from the stack and places it into the target 16-bit register, segment register, or a 16-&lt;br /&gt;bit memory location. In the 80386 and above, a POP can also remove 32-bit data from the stack &lt;br /&gt;and use a 32-bit address. The POP instruction is not available as an immediate POP. The POPF &lt;br /&gt;(pop flags) instruction removes a l6-bit number from the stack and places it into the flag reg-&lt;br /&gt;ister; the POPFO instruction removes a 32-bit number from the stack and places it into the ex-&lt;br /&gt;tended flag register. The POP A (pop all) instruction removes 16 bytes of data from the stack and &lt;br /&gt;places it into the following registers in the order shown: 01, SI, BP, SP, BX, OX, ex, and AX. &lt;br /&gt;This is the reverse order from the way they are placed on the stack by the PUSHA instruction, &lt;br /&gt;causing the same data to return to the same registers. In the 80386 and above, a POP AD instruc-&lt;br /&gt;tion reloads the 32-bit registers from the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a POP BX instruction executes. The first byte of data removed from the stack &lt;br /&gt;(the memory location addressed by SP in the stack segment) moves into register BL. The second &lt;br /&gt;byte is removed from stack segment memory location SP + 1 and is placed into register BH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-7 The PUSH &lt;br /&gt;instructions Symbolic Example Note &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH reg16 &lt;br /&gt;PUSH reg32 &lt;br /&gt;PUSH mem16 &lt;br /&gt;PUSH mem32 &lt;br /&gt;PUSH seg &lt;br /&gt;PUSH imm8 &lt;br /&gt;PUSHW imm16 &lt;br /&gt;PUSHD imm32 &lt;br /&gt;PUSHA &lt;br /&gt;PUSHAD &lt;br /&gt;PUSHF &lt;br /&gt;PUSHFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH BX &lt;br /&gt;PUSH EDX &lt;br /&gt;PUSH WORD PTR [BX] &lt;br /&gt;PUSH DWORD PTR [EBX] &lt;br /&gt;PUSH DS &lt;br /&gt;PUSH ',' &lt;br /&gt;PUSHW 1000H &lt;br /&gt;PUSHD 20 &lt;br /&gt;PUSHA &lt;br /&gt;PUSHAD &lt;br /&gt;PUSHF &lt;br /&gt;PUSHFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-bit register &lt;br /&gt;32-bit register &lt;br /&gt;16-bit pointer &lt;br /&gt;32-bit pointer &lt;br /&gt;Segment register &lt;br /&gt;8-bit immediate &lt;br /&gt;16-bit immediate &lt;br /&gt;32-bit immediate &lt;br /&gt;Save all 16-bit registers &lt;br /&gt;Save all 32-bit registers &lt;br /&gt;Save flags &lt;br /&gt;Save EFLAGs &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-2 PUSH/POP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;~ EBX 392F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP 1008 &lt;br /&gt;,..... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SS 0000 &lt;br /&gt;00000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;'--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack segment DOFFFF &lt;br /&gt;01008 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;___ --1-~--::g:-I 0100~ &lt;br /&gt;,j ( &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;392F 2 F 01006 &lt;br /&gt;-.... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1008 00000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.;-&lt;br /&gt;1008 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;113 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-13 The POP BX instruction, showing how data are removed from the stack. This &lt;br /&gt;instruction is shown after execution. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After both bytes are removed from the stack, the SP register increments by 2. Figure 4-13 shows &lt;br /&gt;how the POP BX instruction removes data from the stack and places them into register BX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The opcodes used for the POP instruction and all of its variations appear in Table 4-8. &lt;br /&gt;Note that a POP CS instruction is not a valid instruction in the instruction set. If a POP CS in-&lt;br /&gt;struction executes, only a portion of the address (CS) of the next instruction changes. This makes &lt;br /&gt;the POP CS instruction unpredictable and therefore not allowed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Initializing the Stack &lt;br /&gt;When the stack area is initialized, load both the stack segment register (SS) and the stack pointer &lt;br /&gt;(SP) register. It is normal to designate an area of memory as the stack segment by loading SS &lt;br /&gt;with the bottom location of the stack segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, if the stack segment is to reside in memory locations lOOOOH-IFFFFH, load &lt;br /&gt;SS with a lOOOH. (Recall that the rightmost end of the stack segment register is appended with a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-8 The POP &lt;br /&gt;instructions Symbolic &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP reg16 &lt;br /&gt;POP reg32 &lt;br /&gt;POP mem16 &lt;br /&gt;POP mem32 &lt;br /&gt;POP seg &lt;br /&gt;paPA &lt;br /&gt;POPAD &lt;br /&gt;POPF &lt;br /&gt;POPFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPCX &lt;br /&gt;POP EBP &lt;br /&gt;POP WORD PTR[8X+ 1] &lt;br /&gt;POP DATA3 &lt;br /&gt;POP FS &lt;br /&gt;paPA &lt;br /&gt;POPAD &lt;br /&gt;POPF &lt;br /&gt;POPFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-bit register &lt;br /&gt;32-bit register &lt;br /&gt;16-bit pointer &lt;br /&gt;32-bit memory address &lt;br /&gt;Segment register &lt;br /&gt;Pop all 16-bit registers &lt;br /&gt;Pop all 32-bit registers &lt;br /&gt;Pop flags &lt;br /&gt;Pop EFLAGs &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;114 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX Stack segment 1FFFF &lt;br /&gt;A037 A037 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;v' &lt;br /&gt;ECX 1FFFE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP I 0000 &lt;br /&gt;L - ...J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;- -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS 0000 r--------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ss 1000 + &lt;br /&gt;10000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 &lt;br /&gt;100001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-14 The PUSH ex instruction, showing the cyclical nature of the stack segment. &lt;br /&gt;This instruction is shown just before execution, to illustrate that the stack bottom is contiguous to &lt;br /&gt;the top. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OH for real mode addressing.) To start the stack at the top of this 64K byte stack segment, the stack &lt;br /&gt;pointer (SP) is loaded with a OOOOH. Likewise, to address the top of the stack at location lOFFFH, &lt;br /&gt;use a value of lOOOH in SP. Figure 4-14 shows how this value causes data to be pushed onto the &lt;br /&gt;top of the stack segment with a PUSH CX instruction. Remember that all segments are cyclical-&lt;br /&gt;that is, the top location of a segment is contiguous with the bottom location of the segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In assembly language, a stack segment is set up as illustrated in Example 4-1. The first &lt;br /&gt;statement identifies the start of the stack segment, and the last statement identifies the end of the &lt;br /&gt;stack segment. The assembler and linker programs place the correct stack segment address in SS &lt;br /&gt;and the length of the segment (top of the stack) into SP. There is no need to load these registers &lt;br /&gt;into your program unless you wish to change their initial values for some reason. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-1 &lt;br /&gt;0000 SEGMENT STACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0100[ DW 100H DUP (?) &lt;br /&gt;???? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0200 ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An alternative method for defining the stack segment is used with one of the memory &lt;br /&gt;models for the MASM assembler only (refer to Appendix A). Other assemblers do not use &lt;br /&gt;models or, if they do, they are not exactly the same as with MASM. Here t'l:! .STACK statement. &lt;br /&gt;followed by the number of bytes allocated to the stack, defines the stack area (see Example 4-2). &lt;br /&gt;The function is identical to Example 4-1. The .STACK statement also initializes both SS and SP. &lt;br /&gt;Note this text uses memory models designed to be used with the Microsoft MACRO assembler &lt;br /&gt;program MASM. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-3 LOAD-EFFECTIVE ADDRESS 115 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-2 &lt;br /&gt;. MODEL SMl,LL &lt;br /&gt;.STACK 200H ;set stack size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the stack is not specified using either method, a warning will appear when the program &lt;br /&gt;is linked. The warning may be ignored if the stack size is 128 bytes or less. The system automat-&lt;br /&gt;ically assigns (through DOS) at least 128 bytes of memory to the stack. This memory section is &lt;br /&gt;located in the program segment prefix (PSP), which is appended to the beginning of each pro-&lt;br /&gt;gram file. If you use more memory for the stack, you will erase information in the PSP that is &lt;br /&gt;critical to the operation of your program and the computer. This error often causes the computer &lt;br /&gt;program to crash. If the TINY memory model is used, the stack is automatically located at the &lt;br /&gt;very end of the segment, which allows for a larger stack area. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOAD-EFFECTIVE ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are several LEA (load-effective address) instructions in the microprocessor instruction &lt;br /&gt;set. The LEA instruction loads any 16-bit register with the address as determined by the ad-&lt;br /&gt;dressing mode selected for the instruction. The LDS and LES variations load any 16-bit register &lt;br /&gt;with the offset address retrieved from a memory location and then loads either DS or ES with a &lt;br /&gt;segment address retrieved from memory. In the 80386 and above, LFS, LOS, and LSS are added &lt;br /&gt;to the instruction set, and a 32-bit register can be selected to receive a 32-bit offset from memory. &lt;br /&gt;Table 4-9 lists the load-effective address instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEA &lt;br /&gt;The LEA instruction loads a 16- or 32-bit register with the offset address of the data specified by &lt;br /&gt;the operand. As the first example in Table 4-9 shows, the operand address NUMB is loaded into &lt;br /&gt;register AX, not the contents of address NUMB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;By comparing LEA with MOY, it is observed that LEA BX,[DI] loads the offset address &lt;br /&gt;specified by [DI] (contents of DI) into the BX register; MOY BX,[DI] loads the data stored at the &lt;br /&gt;memory location addressed by [DI] into register BX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Earlier in the text, several examples are presented using the OFFSET directive. The &lt;br /&gt;OFFSET directive performs the same function as an LEA instruction if the operand is a dis-&lt;br /&gt;placement. For example, the MOY BX,OFFSET LIST performs the same function as LEA &lt;br /&gt;BX,LIST. Both instructions load the offset address of memory location LIST into the BX reg-&lt;br /&gt;ister. Refer to Example 4-3 for a short program that loads SI with the address of DATAl and DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-9 Load-effective address instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEAAX,NUMB &lt;br /&gt;LEA EAX,NUMB &lt;br /&gt;LDS DI,LlST &lt;br /&gt;LDS EDI,LlST &lt;br /&gt;LES BX,CAT &lt;br /&gt;LFS DI,DATA1 &lt;br /&gt;LGS SI,DATA5 &lt;br /&gt;LSS SP,MEM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Loads AX with the address of NUMB &lt;br /&gt;Loads EAX with the address of NUMB &lt;br /&gt;Loads DS and DI with the 32-bit contents of data segment memory location LIST &lt;br /&gt;Loads DS and EDI with the 48-bit contents of data segment memory location LIST &lt;br /&gt;Loads ES and BX with the 32-bit contents of data segment memory location CAT &lt;br /&gt;Loads FS and DI with the 32-bit contents of data segment memory location DATA 1 &lt;br /&gt;Loads GS and SI with the 32-bit contents of data segment memory location DATA5 &lt;br /&gt;Loads SS and SP with the 32-bit contents of memory location MEM &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;116 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;with the address of DAT A2. It then exchanges the contents of these memory locations. Note that &lt;br /&gt;the LEA and MOV with OFFSET instructions are both the same length (three bytes). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 2000 DATAl &lt;br /&gt;0002 3000 DATA2 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 BE 0000 R &lt;br /&gt;OOlA BF 0002 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlD 8B lC &lt;br /&gt;OOlF 8B OD &lt;br /&gt;0021 89 OC &lt;br /&gt;0023 89 lD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;DW 2000H &lt;br /&gt;DW 3000H &lt;br /&gt;. CODE &lt;br /&gt;. STARTUP &lt;br /&gt;LEA SI,DATAl &lt;br /&gt;MOV DI,OFFSET DATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BX, lSI] &lt;br /&gt;MOV CX, [DI] &lt;br /&gt;MOV lSI] ,cx &lt;br /&gt;MOV [DI],BX &lt;br /&gt;. EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;; define DATAl &lt;br /&gt;;define DATA2 &lt;br /&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;;address DATAl with SI &lt;br /&gt;;address DATA2 with DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exchange DATAl with DATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;But why is the LEA instruction available if the OFFSET directive accomplishes the same &lt;br /&gt;task? First, OFFSET functions only with simple operands such as LIST. It may not be used for &lt;br /&gt;an operand such as [DI], LIST [SI], etc. The OFFSET directive is more efficient than the LEA &lt;br /&gt;instruction for simple operands. It takes the microprocessor longer to execute the LEA BX,LIST &lt;br /&gt;instruction than the MOV BX,OFFSET LIST instruction. The 80486 microprocessor, for ex-&lt;br /&gt;ample, requires two clocks to execute LEA BX,LIST and only one clock to execute MOV &lt;br /&gt;BX,OFFSET LIST. The reason that the MOV BX,OFFSET LIST instruction executes more &lt;br /&gt;quickly is that the assembler calculates the offset address of LIST, while the microprocessor cal-&lt;br /&gt;culates the LEA instruction. The MOV BX,OFFSET LIST instruction is actually assembled as a &lt;br /&gt;move immediate instruction and is therefore more efficient. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that the microprocessor executes an LEA BX,[DI] instruction and DI contains a &lt;br /&gt;1000H. Because DI contains the offset address, the microprocessor transfers a copy of DI into &lt;br /&gt;BX. A MOV BX,DI instruction performs this task in less time and is often preferred to the LEA &lt;br /&gt;BX,[DI] instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another example is LEA SI,[BX + DI]. This instruction adds BX to DI and stores the sum &lt;br /&gt;in the SI register. The sum generated by this instruction is a modulo-64K sum. If BX = 1000H &lt;br /&gt;and DI = 2000H, the offset address moved into SI is 3000H. If BX = l000H and DI = FFOOH, the &lt;br /&gt;offset address is OFOOH instead of lOFOOH. Notice that the second result is a modulo-64K sum &lt;br /&gt;of OFOOH. (A modulo-64K sum drops any carry out of the 16-bit result.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOS, LES, LFS, LGS, and LSS &lt;br /&gt;The LDS, LES, LFS, LGS, and LSS instructions load any 16-bit or 32-bit register with an offset &lt;br /&gt;address and load the DS, ES, FS, GS, or SS segment register with a segment address. These in-&lt;br /&gt;structions use any of the memory-addressing modes to access a 32- or 48-bit section of memory &lt;br /&gt;that contains both the segment and offset address. The 32-bit section of memory contains a 16-bit &lt;br /&gt;offset and segment address, while the 48-bit section contains a 32-bit offset and segment address. &lt;br /&gt;These instructions may not use the register-addressing mode (MOD = 11). Note that the LFS, &lt;br /&gt;LGS, and LSS instructions are available only on the 80386 and above, as are the 32-bit registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 4-15 illustrates an example LDS BX,[DI] instruction. This instruction transfers the &lt;br /&gt;32-bit number, addressed by DI in the data segment, into the BX and DS registers. The t OS, &lt;br /&gt;LES, LFS, LGS, and LSS instructions obtain a new far address from memory. The offset address &lt;br /&gt;appears first, followed by the segment address. This format is used for storing all 32-bit memory &lt;br /&gt;addresses. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-3 LOAD-EFFECTIVE ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D 1Fm EAX ESX 6 F 2 A &lt;br /&gt;3 0 11003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP o 0 11002 &lt;br /&gt;ESP 1 2 11001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESI 7 A 11000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDI 100 0 &lt;br /&gt;-----.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS 1 0 0 0 &lt;br /&gt;10000 '--___ --' 10000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-15 The LOS BX,[Oll instruction loads register BX from addresses 11000H and &lt;br /&gt;11001 H and register OS from locations 11 002H and 11 003H. This instruction is shown at the &lt;br /&gt;point just before OS changes to 3000H and BX changes to 127 AH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;117 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A far address can be stored in memory by the assembler. For example, the ADDR DD &lt;br /&gt;FAR PTR FROG instruction stores the offset and segment address (far address) of FROG in 32-&lt;br /&gt;bits of memory at location ADDR. The DD directive tells the assembler to store a doubleword &lt;br /&gt;(32-bit number) in memory address ADDR. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80386 and above, an LDS EBX,[DI] instruction loads EBX from the 4-byte section &lt;br /&gt;of memory. addressed by DI in the data segment. Following this 4-byte offset is a word that is &lt;br /&gt;loaded to the DS register. Notice that instead of addressing a 32-bit section of memory, the &lt;br /&gt;80386 and above address a 48-bit section of the memory whenever a 32-bit offset address is &lt;br /&gt;loaded to a 32-bit register. The first four bytes contain the offset value loaded to the 32-bit reg-&lt;br /&gt;ister, and the last two bytes contain the segment address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-4 &lt;br /&gt;. MODEL SMALL ;select SMALL model &lt;br /&gt;.386 ;select 80386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . DATA ;start of DATA segment &lt;br /&gt;0000 00000000 SADDR DD ? ;old stack address &lt;br /&gt;0004 1000 [ SAREA DW 1000H DUP ( ?) ;new stack area &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2004 = 2004 STOP EQU THIS WORD ;define to of new stack &lt;br /&gt;0000 . CODE ;start of CODE segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP ;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 FA CLI ;disable interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0011 8E C4 MOV AX,SP ; save old SP &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;118 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0013 A3 0000 R MOV WORD PTR SADDR,AX &lt;br /&gt;0016 Be DO 110V AX,S8 ;save old SS &lt;br /&gt;0018 A3 0002 R MOV WORD PTR SADDR+2,AZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlB 8e DB HOV AX,DS ;load new SS &lt;br /&gt;OOlD 8E DO MOV SS,AX &lt;br /&gt;OOlF B8 2004 R MOV AX,OFFSET STOP ;load new SP &lt;br /&gt;0022 8B EO MOV SP,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 FB STI ;enable interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0025 8B eo MOV AX,AX ;do dummy instructions &lt;br /&gt;0027 8B eo MOV AX,AX &lt;br /&gt;0029 OF B2 26 0000 R LSS SP,SADDR ;load old SS and SP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT ;exit to DOS &lt;br /&gt;END ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The most useful of the load instructions is the LSS instruction. Example 4-4 shows a short &lt;br /&gt;program that creates a new stack area after saving the address of the old stack area. After exe-&lt;br /&gt;cuting some dummy instructions, the old stack area is reactivated by loading both SS and SP &lt;br /&gt;with the LSS instruction. Note that the CLI (disable interrupts) and STI (enable interrupts) in-&lt;br /&gt;structions must be included to disable interrupts, a topic discussed near the end of this chapter. &lt;br /&gt;Because the LSS instruction functions in the 80386 or above, the .386 statement appears after the &lt;br /&gt;.MODEL statement to select the 80386 microprocessor. Also notice how the WORD PTR direc-&lt;br /&gt;tive is used to override the doubleword (DD) definition for the old stack address memory loca-&lt;br /&gt;tion. If an 80386 or newer microprocessor is in use, it is suggested that the .386 switch be used &lt;br /&gt;to develop software for the 8038~ microprocessor. This is true even if the microprocessor is a &lt;br /&gt;Pentium or Pentium Pro, because the 80486-Pentium Pro add only a few additional instructions &lt;br /&gt;to the 80386 instruction set, which are seldom used in software development. If the need arises &lt;br /&gt;to use any of the CMPXCHG, CMPXCHG8 (new to the Pentium), XADD, or BSW AP instruc-&lt;br /&gt;tions, then select either the .486 switch for the 80486 microprocessor or the .586 switch for the &lt;br /&gt;Pentium or Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING DATA TRANSFERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are five string data transfer instructions: LODS, STOS, MOVS, INS, and OUTS. Each &lt;br /&gt;string instruction allows data transfers that are either a single byte, word, or doubleword (or, if &lt;br /&gt;repeated, a block of bytes, words, or doublewords). Before the string instructions are presented, &lt;br /&gt;the operation of the D flag-bit (direction), DI, and SI must be understood as they apply to the &lt;br /&gt;string instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Direction Flag &lt;br /&gt;The direction flag (D) (located in the flag register) selects the auto-increment (D = 0) or the auto-&lt;br /&gt;decrement (D = 1) operation for the DI and SI registers during string operations. The direction &lt;br /&gt;flag is used only with the string instructions. The CLD instruction clears the D flag (D = 0), and &lt;br /&gt;the STD instruction sets it (D = 1). Therefore, the CLD instruction selects the auto-increment &lt;br /&gt;mode (D = 0), and STD selects the auto-decrement mode (D = 1). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever a string instruction transfers a byte, the contents of DI and/or SI increment or &lt;br /&gt;decrement by I. If a word is transferred, the contents of DI and/or SI increment or decrement by &lt;br /&gt;2. Doubleword transfers cause DI and/or SI to increment or decrement by 4. Only the actual reg-&lt;br /&gt;isters used by the string instruction increment or decrement. For example, the STOSB instruction &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-4 STRING DATA TRANSFERS 119 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;uses the DI register to address a memory location. When STOSB executes, only DI increments or &lt;br /&gt;decrements without effecting SL The same is true of the LODSB instruction, which uses the SI &lt;br /&gt;register to address memory data. LODSB only increments/decrements SI without effecting DL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 and SI &lt;br /&gt;During the execution of a string instruction, memory accesses occur through either or both of the &lt;br /&gt;Dr and SI registers. The Dr offset address accesses data in the extra segment for all string in-&lt;br /&gt;structions that use it. The SI offset address accesses data, by default, in the data segment. The &lt;br /&gt;segment assignment of SI may be changed with a segment override prefix, as described later in &lt;br /&gt;this chapter. The DI segment assignment is always in the extra segment when a string instruction &lt;br /&gt;executes. This assignment cannot be changed. The reason that one pointer addresses data in the &lt;br /&gt;extra segment and the other in the data segment is so the MOVS instruction can move 64K bytes &lt;br /&gt;of data from one segment of memory to another. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOS &lt;br /&gt;The LODS instruction loads AL, AX, or EAX with data stored at the data segment offset address &lt;br /&gt;indexed by the SI register. (Note that only the 80386 and above use EAX.) After loading AL &lt;br /&gt;with a byte, AX with a word, or EAX with a doubleword, the contents of SI increment (if D = 0) &lt;br /&gt;or decrement (if D = I). A I is added to or subtracted from SI for a byte-sized LODS; a 2 is &lt;br /&gt;added or subtracted for a word-sized LODS; and a 4 is added or subtracted for a doubleword-&lt;br /&gt;sized LODS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 4-10 lists the permissible forms of the LODS instruction. The LODSB (loads a &lt;br /&gt;byte) instruction causes a byte to be loaded into AL; the LODSW (loads a word) instruction &lt;br /&gt;causes a word to be loaded into AX; and the LODSD (loads a doubleword) instruction causes a &lt;br /&gt;doub1eword to be loaded into EAX. Although rare, as an alternative to LODSB, LODSW, and &lt;br /&gt;LODSD, the LODS instruction may be followed by a byte-, word-, or doubleword-sized operand &lt;br /&gt;to select a byte, word, or doubleword transfer. Operands are often defined as bytes with DB, as &lt;br /&gt;words with DW, and as doublewords with DD. The DB pseudo-operation defines byte(s); the &lt;br /&gt;DW pseudo-operation defines word(s); and the DD pseudo-operation defines doubleword(s). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 4-16 shows the effect of executing the LODSW instruction if the D flag = 0, SI = &lt;br /&gt;1000H, and DS = 1000H. Here a 16-bit number, stored at memory locations 1l000H and &lt;br /&gt;11001H, moves into AX. Because D = 0, and this is a word transfer, the contents of SI increment &lt;br /&gt;by 2 after AX loads with memory data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOS &lt;br /&gt;The STOS instruction stores AL, AX, or EAX at the extra segment memory location addressed by &lt;br /&gt;the DI register. (Note only the 80386-Pentium Pro use EAX and doublewords.) Table 4-11 lists &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-10 Forms of the &lt;br /&gt;LOD8 instruction Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOD8B &lt;br /&gt;LOD8W &lt;br /&gt;LOD8D &lt;br /&gt;LOD8 L18T &lt;br /&gt;LOD8 DATA1 &lt;br /&gt;LOD8 FROG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL = D8:[81]; 81 = 81 Â± 1 &lt;br /&gt;AX = D8:[81]; 81 = 81 Â± 2 &lt;br /&gt;EAX = D8:[81]; 81 = 81 Â± 4 &lt;br /&gt;AL = D8:[81]; 81 = 81 Â± 1 (if L18T is a byte) &lt;br /&gt;AX = D8:[8!], 81 = 81 Â± 2 (if DATA1 is a word) &lt;br /&gt;EAX = D8:[81]; 81 = 81 Â± 4 (if FROG is a doubleword) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: The segment can be overridden with' a segment override prefix as in LODS &lt;br /&gt;ES:DATA4. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;120 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data segment O'FFFF &lt;br /&gt;A 0 11001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I &lt;br /&gt;&amp;quot;4 3 2 11000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A 0 3 2 A 0 3 2 EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I...--..&amp;quot;, &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESI 1 0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDI 10000 &lt;br /&gt;....... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1000 &lt;br /&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 &lt;br /&gt;+'&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11000 &lt;br /&gt;DS 1 0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-16 The operation of the LODSW instruction if DS = 1000H, D = 0, 11000H = 32, &lt;br /&gt;and 11001 H = AO. This instruction is shown after AX is loaded from memory, but before SI in-&lt;br /&gt;crements by 2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;all forms of the STOS instruction. As with LODS, a STOS instruction Il1ay be appended with a B, &lt;br /&gt;W, or D for byte, word, or doubleword transfers. The STOSB (stores a byte) instruction stores &lt;br /&gt;the byte in AL at the extra segment memory location addressed by DI. The STOSW (stores a &lt;br /&gt;word) instruction stores AX in the extra segment memory location addressed by DI. A double-&lt;br /&gt;word is stored in the extra segment location addressed by DI with the STOSD (stores a double-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, word) instruction. After the byte (AL), word (AX), or doubleword (EAX) is stored, the contents &lt;br /&gt;of DI increments or decrements. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-11 Forms of the &lt;br /&gt;STOS Instruction Assembly Language Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOSS &lt;br /&gt;STOSW &lt;br /&gt;STOSD &lt;br /&gt;STO~ LIST &lt;br /&gt;STOS DATA3 &lt;br /&gt;STOS DATA4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES:[DI] = AL; DI = DI Â± 1 &lt;br /&gt;ES:[DI] = AX; DI = 01 Â± 2 &lt;br /&gt;ES:[OI] = EAX; 01 = 01 Â± 4 &lt;br /&gt;ES:[DI] = AL; 01 = 01 Â± 1 (if list is a byte) &lt;br /&gt;ES:[OI] = AX; 01 = DI Â± 2 (if DATA3 is a word) &lt;br /&gt;ES:[OI] = EAX; 01 = 01 Â± 4 (if DATA4 is a doubleword) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-4 STRING DATA TRANSFERS 121 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOS with a REP. The repeat prefix (REP) is added to any string data transfer instruction ex-&lt;br /&gt;cept the LODS instruction. It doesn't make any sense to perform a repeated LODS operation. &lt;br /&gt;The REP prefix causes CX to decrement by 1 each time the string instruction executes. After CX &lt;br /&gt;decrements, the string instruction repeats. If CX reaches a value of 0, the instruction terminates &lt;br /&gt;and the program continues with the next sequential instruction. Thus, if CX is loaded with a 100, &lt;br /&gt;and a REP STOSB instruction executes, the microprocessor automatically repeats the STOSB &lt;br /&gt;instruction 100 times. Since the DI register is automatically incremented or decremented after &lt;br /&gt;each datum is stored, this instruction stores the contents of AL in a block of memory instead of a &lt;br /&gt;single byte of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that the STOSW instruction is used to clear the video text display (see Example &lt;br /&gt;4-5). This is accomplished by addressing video text memory that begins at memory location &lt;br /&gt;B800:0000. Each character position on the 25-line-by-80-character per line display comprises &lt;br /&gt;two bytes. The first byte contains the ASCII-coded character and the second contains the color &lt;br /&gt;and attributes of the character. In this example, AL is the ASCII-coded space (20H) and AH is &lt;br /&gt;the color code for white text on a black background (07H). Notice how this program uses a count &lt;br /&gt;of 25 *80 and the REP STOSW instruction to clear the screen with ASCII spaces. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-5 &lt;br /&gt;.MODEL TINY ;select TINY model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE ;start of CODE segment &lt;br /&gt;. STARTUP ;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 FC CLD ;select increment mode &lt;br /&gt;0101 BB BBOO MOV AX,OBBOOH ;address segment BBOO &lt;br /&gt;0104 BE CO MOV ES,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 BF 0000 MOV DI,O ;address offset 0000 &lt;br /&gt;0109 B9 07DO MOV CX,25*BO ; load count &lt;br /&gt;010C BB 0720 MOV AX,0720H ;load data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010F F3/AB REP STOSW ;clear the screen &lt;br /&gt;.EXIT ;exit to DOS &lt;br /&gt;END ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The operands in a program can be modified by using arithmetic or logic operators such as &lt;br /&gt;multiplication (*). Other operators appear in Table 4-12. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The REP prefix precedes the STOSW instruction in both assembly language and hexadec-&lt;br /&gt;imal machine language. In machine language, the F3H is the REP prefix and ABH is the &lt;br /&gt;STOSW opcode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the value loaded to AX is changed to 0731H, the video display fills with white ones on &lt;br /&gt;a black background. If AX is changed to 0132H, the video display fills with blue twos on a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-12 Common operand operators &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operator &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ &lt;br /&gt;MOD &lt;br /&gt;AND &lt;br /&gt;OR &lt;br /&gt;NOT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVAL,6+3 &lt;br /&gt;MOVAL,8-2 &lt;br /&gt;MOV AL,4*3 &lt;br /&gt;MOV AX,1215 &lt;br /&gt;MOV AX, 12 MOD 7 &lt;br /&gt;MOV AX,12 AND 4 &lt;br /&gt;MOV AX,12 OR 1 &lt;br /&gt;MOV AL,NOT 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Copies 9 into AL &lt;br /&gt;Copies 6 into AL &lt;br /&gt;Copies 12 into AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Comment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Copies 2 into AX (remainder is lost) &lt;br /&gt;Copies 5 into AX (quotient is lost) &lt;br /&gt;Copies 4 into AX (1100 AND 0100 = 0100) &lt;br /&gt;Copies 13 into AX (1100 OR 0001 = 1101) &lt;br /&gt;Copies 254 into AL (0000 0001 NOT equals 1111 1110 or 254) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;122 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;black background. By changing the value loaded to AX, the display can be filled with any char-&lt;br /&gt;acter and any color combination. More information on accessing video displays appears in &lt;br /&gt;Chapter 7. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVS &lt;br /&gt;One of the more useful string data transfer instructions is MOYS, because it transfers data from &lt;br /&gt;one memory location to another. This is the only memory-to-memory transfer allowed in the &lt;br /&gt;8086-Pentium Pro microprocessors. The MOYS instruction transfers a byte, word, or double-&lt;br /&gt;word from the data segment location addressed by SI to the extra segment location addressed by &lt;br /&gt;DI. As with the other string instructions, the pointers then increment or decrement as dictated by &lt;br /&gt;the direction flag. Table 4-13 lists all of the permissible forms of the MOYS instruction. Note &lt;br /&gt;that only the source operand (SI), located in the data segment, may be overridden so that another &lt;br /&gt;segment may be used. The destination operand (DI) must always be located in the extra segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that the video display needs to be scrolled up one line. Because we now know the &lt;br /&gt;location of the video display, a repeated MOYSW instruction can be used to scroll the video dis-&lt;br /&gt;play up a line. Example 4-6 lists a short program that addresses the video text display beginning &lt;br /&gt;at location B800:0000 with the DS:SI register combination and location B800:00AO with the &lt;br /&gt;ES:DI register combination. Next, the REP MOYSW instruction is executed 24*80 times to &lt;br /&gt;scroll the display up a line. This is followed by a sequence that addresses the last line of the dis-&lt;br /&gt;play so that it can be cleared. The last line is cleared in this example by storing spaces on a black &lt;br /&gt;background. The last line could be cleared by changing only the ASCII code to a space without &lt;br /&gt;modifying the attribute by reading the code and attribute into a register. Once in a register, the &lt;br /&gt;code is modified, and both the code and attribute are stored in memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-6 &lt;br /&gt;.HODEL TINY ;select TINY model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 .CODE ;indicate start of CODE segment &lt;br /&gt;. STARTUP ; indicate start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 FC CLD ;select increment &lt;br /&gt;0101 B8 B800 MOV AX,OBBOOH ;load ES and DS with B800 &lt;br /&gt;0104 8E CO MOV ES,AX &lt;br /&gt;0106 BE D8 NOV DS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0108 BE OOAO NOV SI,160 ;address line 1 &lt;br /&gt;010B BF 0000 MOV DI,O ;address line 0 &lt;br /&gt;010E B9 07BO MOV CX,24*80 ;load count &lt;br /&gt;0111 F3/A5 REP MOVSW ;scroll screen &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0113 BF OFOO MOV DI,24*80*2 ;clear bottom line &lt;br /&gt;0116 B9 0050 MOV CX,80 &lt;br /&gt;0119 B8 0720 MOV AX,0720H &lt;br /&gt;011C F3/AB REP STOSW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT ;exit to DOS &lt;br /&gt;END ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INS &lt;br /&gt;The INS (input string) instruction (not available on the 8086/8088 microprocessors) transfers a &lt;br /&gt;byte, word, or double word of data from an I/O device into the extra segment memory location &lt;br /&gt;addressed by the DI register. The I/O address is contained in the DX register. This instruction is &lt;br /&gt;useful for inputting a block of data from 1n external I/O device directly into the memory. One &lt;br /&gt;application transfers data from a disk drive to memory. Disks drives are often considered and in-&lt;br /&gt;terfaced as I/O devices in a computer system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with the prior string instructions, there are two basic fonTIs of the INS. The INSB in-&lt;br /&gt;struction inputs data from an 8-bit I/O device and stores them in the byte-sized memory location &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-4 STRING DATA TRANSFERS 123 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-13 Forms of the MOVS instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVSB &lt;br /&gt;MOVSW &lt;br /&gt;MOVSD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVS BYTE1 ,BYTE2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVS WORD1 ,WORD2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVS DWORD1, DWORD2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES:[DI] = DS:[SI]; DI == DI Â± 1; SI == SI Â± 1 (byte transferred) &lt;br /&gt;ES:[DI] == DS:[SI]; DI == DI Â± 2; SI == SI Â± 2 (word ~ransferred) &lt;br /&gt;ES:[DI] = DS:[SI]; DI == DI Â± 4; SI = SI Â± 4 (doubleword &lt;br /&gt;transferred) &lt;br /&gt;ES:[DI] == DS:[SI]; DI == DI Â± 1; SI == SI Â± 1 (if BYTE1 and BYTE2 &lt;br /&gt;are bytes) &lt;br /&gt;ES:[DI] == DS:[SI]; DI == DI Â± 2, SI == SI Â± 2 (if WORD1 and &lt;br /&gt;WORD2 are words) &lt;br /&gt;ES:[DI] = DS:[SI]; DI == DI Â± 4; SI = SI Â± 4 (if DWORD1 and &lt;br /&gt;DWORD2 are doublewords) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;indexed by S1. The INSW instruction inputs 16-bit I/O data and stores them in a word-sized &lt;br /&gt;memory location. The INSD instruction inputs a doubleword. These instructions can be repeated &lt;br /&gt;using the REP prefix. This allows an entire block of input data to be stored in the memory from &lt;br /&gt;an I/O device. Table 4-14 lists the various forms of the INS instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 4-7 shows a sequence of instructions that in~ut_50_bÂ¥tes of data from an I/O de-&lt;br /&gt;vice whose address is 03ACH and stores the data in ext!'&amp;quot; segment memory array LISTS. This &lt;br /&gt;software assumes that data are available from the I/O device at all times. Otherwise, the software &lt;br /&gt;!TIust check to see if the I/O device is ready to transfer data precluding the use of a REP prefix. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BF 0000 R &lt;br /&gt;0003 BA 03AC &lt;br /&gt;0006 FC &lt;br /&gt;0007 B9 0032 &lt;br /&gt;OOOA F3/6C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;iUsing the REP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;CLD &lt;br /&gt;MOV &lt;br /&gt;REP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INSB to input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DI,OFFSST &lt;br /&gt;DX,3ACH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CX,50 &lt;br /&gt;INSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data to a memory array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LISTS ; address array &lt;br /&gt;;address I/O &lt;br /&gt;;auto-increment &lt;br /&gt;;load count &lt;br /&gt;; input data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The OUTS (output string) instruction (not available on the 8086/8088 microprocessors) trans-&lt;br /&gt;fers a byte, word, or doubleword of data from the data segment memory location address by SI &lt;br /&gt;to an I/O device. The I/O device is addressed by the DX register as it was with the INS instruc-&lt;br /&gt;tion. Table 4-15 shows the variations available for the OUTS instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-14 Forms of the &lt;br /&gt;INS instruction Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INSB &lt;br /&gt;INSW &lt;br /&gt;INSD &lt;br /&gt;INS LIST &lt;br /&gt;INS DATA4 &lt;br /&gt;INS DATA5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES:[DI] = [DX]; DI == DI Â± 1 (byte transferred) &lt;br /&gt;ES:[DI] = [DX]; DI == DI Â± 2 (word transferred) &lt;br /&gt;ES:[DI] = [DX]; DI = DI Â± 4 (doubleword transferred) &lt;br /&gt;ES:[DI] = [DX]; DI = DI Â± 1 (if LIST is a byte) &lt;br /&gt;ES:[DI] == [DX]; DI = DI Â± 2 (if DATA4 is a word) &lt;br /&gt;ES:[DI] = [DX]; DI = DI Â± 4 (if DATA5 is a doubleword) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: [OX] indicates that OX contains the I/O device address. These instructions are not &lt;br /&gt;available on the 8086/8088 microprocessors. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;124 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-15 Forms of the &lt;br /&gt;OUTS instruction Assembly Language Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTSB &lt;br /&gt;OUTSW &lt;br /&gt;OUTSO &lt;br /&gt;OUTS OATA7 &lt;br /&gt;OUTS OATA8 &lt;br /&gt;OUTS OATA9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;[OX] = OS:[SI]; 81 = 81 Â± 1 (byte transferred) &lt;br /&gt;[OX] = 08:[81]; 81 = 81 Â± 2 (word transferred) &lt;br /&gt;[OX] = 08:[81]; 81 = 81 Â± 4 (doubleword transferred) &lt;br /&gt;[OX] = 08:[81]; 81 = 81 Â± 1 (if OATA7 is a byte) &lt;br /&gt;[OX] = 08:[81]; 81 = 81 Â± 2 (if OATA8 is a word) &lt;br /&gt;[OX] = 08:[81]; 81 = 81 Â± 4 (if OATA9 is a doubleword) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: [DX] indicates that DX contains the I/O device address. These instructions are not &lt;br /&gt;available on the 8086/8088 microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 4-8 shows a short sequence of instructions that transfer data from a data segment &lt;br /&gt;memory array (ARRAY) to an I/O device at I/O address 3ACH. This software assumes that the &lt;br /&gt;I/O device is always ready for data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BE 0064 R &lt;br /&gt;0003 BA 03AC &lt;br /&gt;0006 FC &lt;br /&gt;0007 B9 0064 &lt;br /&gt;OOOA F3/6E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Using the REP OUTS to output data from a memory array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV SI,OFFSET ARRAY &lt;br /&gt;MOV DX,3ACH &lt;br /&gt;CLD &lt;br /&gt;MOV CX,lOO &lt;br /&gt;REP OUTSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address array &lt;br /&gt;;address I/O &lt;br /&gt;; auto-increment &lt;br /&gt;;load count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MISCELLANEOUS DATA TRANSFER INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Don't be fooled by the term miscellaneous; these instructions are used in programs. The data &lt;br /&gt;transfer instructions detailed in this section are XCHG, LAHF, SAHF, XLAT, IN, OUT, &lt;br /&gt;MOVSX, MOVZX, BSWAP, and CMOV. Because the miscellaneous instructions are not used &lt;br /&gt;as often as a MOV instruction, they have been grouped together and represented in this section. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG &lt;br /&gt;The XCHG (exchange) instruction exchanges the contents of a register with the contents of any &lt;br /&gt;other register or memory location. The XCHG instruction cannot exchange segment registers or &lt;br /&gt;memory-to-memory data. Exchanges are byte-, word-, or doubleword-sized (80386 and above) &lt;br /&gt;and use any addressing mode discussed in Chapter 3, except immediate addressing. Table 4-16 &lt;br /&gt;shows some examples of the XCHG instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The XCHG instruction, using the 16-bit AX register with another 16-bit register, is the &lt;br /&gt;most efficient exchange. This instruction occupies one byte of memory. Other XCHG instruc-&lt;br /&gt;tions require two or more bytes of memory, depending on the addressing mode selected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-16 Forms of the XCHG instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHGAL,CL &lt;br /&gt;XCHG CX,BP &lt;br /&gt;XCHG EOX,E81 &lt;br /&gt;XCHG AL,OATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exchanges the contents of AL with CL &lt;br /&gt;Exchanges the contents of CX with BP &lt;br /&gt;Exchanges the contents of EOX with E81 &lt;br /&gt;Exchanges the contents of AL with data segment memory location OATA2 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-5 MISCELLANEOUS DATA TRANSFER INSTRUCTIONS 125 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When using a memory addressing mode and the assembler, it doesn't matter which &lt;br /&gt;operand addresses memory. The XCHG AL,[DI] instruction is identical to the XCHG [DI],AL &lt;br /&gt;instruction as far as the assembler is concerned. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The XCHG instruction can exchange doubleword data in the 80386 through the Pentium &lt;br /&gt;Pro microprocessors. For example, the XCHG EAX,EBX instruction exchanges the contents If &lt;br /&gt;the EAX register with the EBX register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LAHF and SAHF &lt;br /&gt;The LAHF and SAHF instructions are seldom used because they were designed as bridge in-&lt;br /&gt;structions. These instructions allowed 8085 (an early 8-bit microprocessor) software to be trans-&lt;br /&gt;lated into 8086 software by a translation program. Because any software that required translation &lt;br /&gt;was probably completed many years ago, these instructions have little application today. The &lt;br /&gt;LAHF instruction transfers the rightmost 8-bits of the flag register into the AH register. The &lt;br /&gt;SAHF instruction transfers the AH register into the rightmost 8-bits of the flag register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;At times, the SAHF instruction may find some application with the numeric coprocessor. &lt;br /&gt;The numeric coprocessor contains a status register that is copied into the AX register with the &lt;br /&gt;FSTSW AX instruction. The SAHF instruction is then used to copy from AH into the flag reg-&lt;br /&gt;ister. The flags are then tested for some of the conditions of the numeric coprocessor. This is de-&lt;br /&gt;tailed in Chapter 8, which explains the operation and programming of the numeric coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XLAT &lt;br /&gt;The XLAT (translate) instruction converts the contents of the AL register into a number stored &lt;br /&gt;in a memory table. This instruction performs the direct table lookup technique, which is often &lt;br /&gt;used to convert one code to another. An XLAT instruction first adds the contents of AL to BX to &lt;br /&gt;form a memory address within the data segment. It then copies the contents of this address into &lt;br /&gt;AL. This is the only instruction that adds an 8-bit number to a 16-bit number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a 7-segment LED display lookup table is stored in memory at address &lt;br /&gt;TABLE. The XLAT instruction then translates the BCD number in AL to a 7-segment code in &lt;br /&gt;AL. Example 4-9 provides a short program that converts from a BCD code to 7 -segment code. &lt;br /&gt;Figure 4-17 shows the operation of this example program if TABLE = JOOOH, DS = 1000H, and &lt;br /&gt;the initial value of AL = 05H (a 5 BCD). After the translation, AL = 6DH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 0 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~05 11006 6 D 11005 &lt;br /&gt;1000 .... + 11004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11003 &lt;br /&gt;11002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1005 11001 &lt;br /&gt;11000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ 0,_ 10000 11005 &lt;br /&gt;FIGURE 4-17 The operation of the XLAT instruction at the point just before 6DH is loaded &lt;br /&gt;into AL &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;126 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 3F 06 5B 4F &lt;br /&gt;0004 66 6D 7D 27 &lt;br /&gt;0008 7F 6F &lt;br /&gt;OOOA 00 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 BO 04 &lt;br /&gt;0019 BB 0000 R &lt;br /&gt;OOlC D7 &lt;br /&gt;OOlD A2 OOOA R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN and OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;using an XLAT to convert from BCD to 7-segment code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. HODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;TABLE DB 3FH,6,5BH,4FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 66H, 6DH, 7DH, 27H &lt;br /&gt;DB 7FH,6FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CODE7 DB ? &lt;br /&gt;.CODE &lt;br /&gt;. STARTUP &lt;br /&gt;MOV AL,4 &lt;br /&gt;MOV BX,OFFSET TABLE &lt;br /&gt;XLAT &lt;br /&gt;MOV CODE7,AL &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;;7-segment lookup table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reserve for result &lt;br /&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;;load test data &lt;br /&gt;;address lookup table &lt;br /&gt;;convert to 7-segment &lt;br /&gt;;save 7-segment code &lt;br /&gt;;exit to DOS &lt;br /&gt;lend of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 4-17 lists the forms of the IN and OUT instructions, which perform I/O operations. Notice &lt;br /&gt;that the contents of AL, AX, or EAX are transferred only between the liD device and the micro-&lt;br /&gt;processor. An IN instruction transfers data from an external I/O device to AL, AX, or EAX; an &lt;br /&gt;OUT instruction transfers data from AL, AX, or EAX to an external liD device. (Note that only &lt;br /&gt;the 80386 and above contain EAX.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Two forms of liD device (port) addressing exist for IN and OUT: fixed-port and variable-port. &lt;br /&gt;Fixed-port addressing allows data transfer between AL, AX, or EAX using an 8-bit I/O port address. &lt;br /&gt;It is called fixed-port addressing because the port number follows the instruction's opcode. Instruc-&lt;br /&gt;tions are often stored in a ROM. A fixed port instruction stored in a ROM has its port number per-&lt;br /&gt;manently fixed because of the nature of read-only memory. A fixed-port address stored in a RAM &lt;br /&gt;can be modified, but such a modification does not conform to good programming practices. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The port address appears on the address bus during an I/O operation. For the 8-bit fixed-&lt;br /&gt;port liD instructions, the 8-bit port address is zero-extended into a 16-bit address. For example, &lt;br /&gt;if the IN AL,6AH instruction executes, data from I/O address 6AH is input to AL. The address &lt;br /&gt;appears as a 16-bit 006AH on pins AO-AIS of the address bus. Address bus bits Al6-AI9 &lt;br /&gt;(8086/8088), A16-A23 (80286/S0386SX), Al6-A24 (80386SLl80386SLC/80386EX), or &lt;br /&gt;Al6-A32 (80386-Pentium Pro) are undefined for an IN or OUT instruction. Note that Intel re-&lt;br /&gt;serves the last 16 I/O ports for use with some of its peripheral components. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-17 IN and OUT &lt;br /&gt;instructions Assembly Language Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,p8 &lt;br /&gt;IN AX,p8 &lt;br /&gt;IN EAX,p8 &lt;br /&gt;IN AL,OX &lt;br /&gt;IN AX,OX &lt;br /&gt;IN EAX,OX &lt;br /&gt;OUT p8,AL &lt;br /&gt;OUTp8,AX &lt;br /&gt;OUTp8,EAX &lt;br /&gt;OUT OX,AL &lt;br /&gt;OUT OX,AX &lt;br /&gt;OUT OX,EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bits are input to AL from I/O port p8 &lt;br /&gt;16-bits are input to AX from I/O port p8 &lt;br /&gt;32-bits are input to EAX from I/O port p8 &lt;br /&gt;8-bits are input to AL from I/O port OX &lt;br /&gt;16-bits are input to AX from I/O port OX &lt;br /&gt;32-bits are input to EAX from I/O port OX &lt;br /&gt;8-bits are output from AL to I/O port p8 &lt;br /&gt;16-bits are output from AX to I/O port p8 &lt;br /&gt;32-bits are output from EAX to I/O port p8 &lt;br /&gt;8-bits are output from AL to I/O port DX &lt;br /&gt;16-bits are output from AX to I/O port OX &lt;br /&gt;32-bits are output from EAX to I/O port OX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: p8 = an 8-bit I/O port number and OX = the l6-bit port address held in OX. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-5 MISCELLANEOUS DATA TRANSFER INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microprocessor-based system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Port data) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Contents of register AX Data bus (00-015) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Port address) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0019H Address bus (AO-A 15) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Port control) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 4-18 The signals found in the microprocessor-based system for an OUT 19H,AX &lt;br /&gt;instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;127 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Variable-port addressing allows data transfers between AL, AX, or EAX and a 16-bit port &lt;br /&gt;address. It is called variable-port addressing because the liD port number is stored in register &lt;br /&gt;DX, which can be changed (varied) during the execution of a program. The 16=-~itIl9 port ad-&lt;br /&gt;dress appears on the address bus pin connections AD-AIS. The IBM PC uses a 16-bit port ad-&lt;br /&gt;dress to access its liD space. The liD space for a PC is located at 110 port 0000H-03FFH. Note &lt;br /&gt;'that some plug-in adapter cards may use 110 addresses above 03FFH. ,~-' '&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 4-18 illustrates the execution of the OUT 19H,AX instruction, which transfers the &lt;br /&gt;contents of AX to 110 port 19H. Note that the 110 port number appears as a 0019H on the 16-bit &lt;br /&gt;address bus and that the data from AX appears on the data bus of the microprocessor. The system &lt;br /&gt;control signal, 10WC (110 write control), is a logic 0 to enable the 110 device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A short program that clicks the speaker in the personal computer appears in Example 4-10. &lt;br /&gt;The speaker is controlled by accessing 110 port 61 H. If the rightmost two bits of this port are set &lt;br /&gt;(11) and then cleared (00), a click is heard on the speaker. Note that this program uses a logical &lt;br /&gt;OR instruction to set these two bits and a logical AND instruction to clear them. These logic op-&lt;br /&gt;eration instructions are described in Chapter 5. The MOV CX,1000H instruction followed by the &lt;br /&gt;LOOP L1 instruction is used as a time delay. If the count is increased, the click will become &lt;br /&gt;longer; if shortened, the click will become shorter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-10 &lt;br /&gt;.MODEL TINY ;select TINY model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 .CODE ; indicate start of code segment &lt;br /&gt;. STARTUP ; indicate start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 E4 61 IN AL,61H ;read port 61H &lt;br /&gt;0102 OC 03 OR AL,3 ;set rightmost two bits &lt;br /&gt;0104 E6 61 OUT 61H,AL ; speaker is on &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 B9 1000 MOV CX,1000H ;delay count &lt;br /&gt;0109 L1: &lt;br /&gt;0109 E2 FE LOOP L1 ;time delay &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GlOB E4 61 IN AL,61H ;read port 61H &lt;br /&gt;0100 24 FC AND AL,OFCH ;clear rightmost two bits &lt;br /&gt;OlOF E6 61 OUT 61H,AL ; speaker is off &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT ;exi-: to DOS &lt;br /&gt;END ;enci of file &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;128 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVSX and MOVZX &lt;br /&gt;The MOVSX (move and sign-extend) and MOVZX (move and zero-extend) instructions are &lt;br /&gt;found in the 80386-Pentium Pro instruction sets. These instructions move data and at the same &lt;br /&gt;time either sign- or zero-extend it. Table 4-18 illustrates these instructions with several exam-&lt;br /&gt;ples of each. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When a number is zero-extended, the most significant part fills with zeros. For example, if &lt;br /&gt;an 8-bit 34H is zero-extended into a 16-bit number, it becomes 0034H. Zero-extension is often &lt;br /&gt;used to convert unsigned 8- or 16-bit numbers into unsigned 16- or 32-bit numbers using the &lt;br /&gt;MOVZX instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A number is sign-extended when its sign-bit is copied into the most-significant part. For &lt;br /&gt;example, if an 8-bit 84H is sign-extended into a 16-bit number, it becomes FF84H. The sign-bit &lt;br /&gt;of an 84H is a one, which is copied into the most-significant part of the sign-extended result. &lt;br /&gt;Sign-extension is most often used to convert 8- or 16-bit signed numbers into 16- or 32-bit &lt;br /&gt;signed numbers using the MOVSX instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSWAP &lt;br /&gt;The BSWAP (byte swap) instruction is available only in the 80486 and both versions of the Pen-&lt;br /&gt;tium microprocessors. This instruction takes the contents of any 32-bit register and swaps the &lt;br /&gt;first byte with the fourth and the second with the third. For example, the BSW AP EAX instruc-&lt;br /&gt;tion with EAX = 00112233H swaps bytes in EAX, resulting in EAX = 33221100H. Note that the &lt;br /&gt;order of all four bytes is reversed by this instruction. This instruction is used to convert data from &lt;br /&gt;big endian form to little endian form or vice versa. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMOV &lt;br /&gt;The CMOV (conditional move) class of instruction is new to the Pentium Pro microprocessor &lt;br /&gt;instruction set. Actually, there are many variations of the CMOV instruction. Table 4-19 lists &lt;br /&gt;these variations of CMOV. These instructions only move the data if the condition is true. For ex-&lt;br /&gt;ample, the CMOVZ instruction only moves data if the result from some prior instruction was a &lt;br /&gt;zero. The destination is limited to 16- or 32-bit registers, but the source can be a 16- or 32-bit &lt;br /&gt;register or memory location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because this is a new instruction, you cannot use it with the assembler until a .686 switch is &lt;br /&gt;provided. In the interim, the instruction can be coded in hexadecimal form using the DB directive. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-18 The MOVSX &lt;br /&gt;and MOVZX instructions Assembly Language Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVSXCX,BL &lt;br /&gt;MOVSX ECX,AX &lt;br /&gt;MOVSX BX,DATA1 &lt;br /&gt;MOVSX EAX,[EDI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVZX DX,AL &lt;br /&gt;MOVZX EBP,DI &lt;br /&gt;MOVZX DX,DATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVZX EAX,DATA3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sign-extendS BL into CX &lt;br /&gt;Sign-extends AX into ECX &lt;br /&gt;Sign-extends the byte at DATA 1 into BX &lt;br /&gt;Sign-extendS the word at the data segment memory &lt;br /&gt;location addressed by EDI into EAX &lt;br /&gt;Zero-extends AL into DX &lt;br /&gt;Zero-extends DI into EBP &lt;br /&gt;Zero-extends the byte at data segment memory &lt;br /&gt;location DAT A2 into DX &lt;br /&gt;Zero-extends the word at data segment memory &lt;br /&gt;location DAT A3 into EAX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-6 SEGMENT OVERRIDE PREFIX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-19 The conditional move instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMOVB &lt;br /&gt;CMOVAE &lt;br /&gt;CMOVBE &lt;br /&gt;CMOVA &lt;br /&gt;CMOVE or CMOVZ &lt;br /&gt;CMOVNE or CMOVNZ &lt;br /&gt;CMOVL &lt;br /&gt;CMOVLE &lt;br /&gt;CMOVG &lt;br /&gt;CMOVGE &lt;br /&gt;CMOVS &lt;br /&gt;CMOVNS &lt;br /&gt;CMOVC &lt;br /&gt;CMOVNC &lt;br /&gt;CMOVO &lt;br /&gt;CMOVNO &lt;br /&gt;CMOVP or CMOVPE &lt;br /&gt;CMOVNP or CMOVPO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Condition Tested &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C = 1 &lt;br /&gt;C=O &lt;br /&gt;Z = 1 or C = 1 &lt;br /&gt;Z = 0 and C = 0 &lt;br /&gt;Z=1 &lt;br /&gt;Z=O &lt;br /&gt;S&amp;lt;&amp;gt;O &lt;br /&gt;Z = 1 or S &amp;lt;&amp;gt; 0 &lt;br /&gt;Z= 0 and S = 0 &lt;br /&gt;S=O &lt;br /&gt;S=1 &lt;br /&gt;S=O &lt;br /&gt;C = 1 &lt;br /&gt;C=O &lt;br /&gt;0= 1 &lt;br /&gt;0=0 &lt;br /&gt;P=1 &lt;br /&gt;P=O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Move if below &lt;br /&gt;Move if above or equal &lt;br /&gt;Move if below or equal &lt;br /&gt;Move if above &lt;br /&gt;Move if equal or set if zero &lt;br /&gt;Move if not equal or set if not zero &lt;br /&gt;Move if less than &lt;br /&gt;Move if less than or equal &lt;br /&gt;Move if greater than &lt;br /&gt;Move if greater than or equal &lt;br /&gt;Move if sign (negative) &lt;br /&gt;Move if no sign (positive) &lt;br /&gt;Move if carry &lt;br /&gt;Move if no carry &lt;br /&gt;Move if overflow &lt;br /&gt;Move if no overflow &lt;br /&gt;Move if parity or set if parity even &lt;br /&gt;Move if no parity or set if parity odd &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;129 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The opcode for the CMOV instruction is an OF4XH where X is the condition code 0000-1111 &lt;br /&gt;(refer to Appendix B for the codes). This is followed by a mod-reg-r/m byte. Example 4-11 shows &lt;br /&gt;how the CMOVB instruction is coded into hexadecimal using the DB directive. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-11 &lt;br /&gt;0000 OF 42 C3 DB OFH,42H,OC3H ;same as CMOVB AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEGMENT OVERRIDE PREFIX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The segment override prefix, which may be added to almost any instruction in any memory-&lt;br /&gt;addressing mode, allows the programmer to deviate from the default segment. The segment &lt;br /&gt;override prefix is an additional byte that appends the front of an instruction to select an alternate &lt;br /&gt;segment register. About the o,Ely instructions that cannot be prefixed are the jump and call in-&lt;br /&gt;structions that must use the code~segment register for address generation. The segment override &lt;br /&gt;is also used to select the FS and GS segments in the 80386 through the Pentium Pro micro-&lt;br /&gt;processors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, the MOV AX,[DI] instruction accesses data within the data segment by de-&lt;br /&gt;fault. If required by a program, this can be changed by prefixing the instruction. Suppose that the &lt;br /&gt;data are in the extra segment instead of the data segment. This instruction addresses the extra &lt;br /&gt;segment if changed to MOV AX,ES:[DI]. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 4-20 shows some altered instructions that address different memory segments than &lt;br /&gt;normal. Each time an instruction is prefixed with a segment override prefix, the instruction be-&lt;br /&gt;comes one byte longer. Although this is not a serious change to the length of the instruction, it &lt;br /&gt;does add to the instruction's execution time. It is usually customary to limit the use of the seg-&lt;br /&gt;ment override prefix and remain in the default segments so that shorter and more efficient soft-&lt;br /&gt;ware can be written. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;130 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 4-20 Instructions &lt;br /&gt;that include segment override Assembly Language Segment Accessed Default Segment &lt;br /&gt;prefixes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,DS:[BP] Data Stack &lt;br /&gt;MOV AX,ES:[BP] Extra Stack &lt;br /&gt;MOV AX,SS:[DI] Stack Data &lt;br /&gt;MOV AX,CS:LlST Code Data &lt;br /&gt;MOV AX,ES:[SI] Extra Data &lt;br /&gt;LODS ES:DATA1 Data Extra &lt;br /&gt;MOV EAX,FS:DATA2 Data FS &lt;br /&gt;MOV BL,GS:[ECX] Data GS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASSEMBLER DETAIL &lt;br /&gt;The assembler! for the microprocessor can be used in two ways: (1) with models (used in most &lt;br /&gt;examples in this text) that are unique to a particular assembler and (2) with full segment defini-&lt;br /&gt;tions that allow complete control over the assembly process and are universal to all assemblers. &lt;br /&gt;This section of the text presents both methods and explains how to organize a program's memory &lt;br /&gt;space using the assembler. It also explains the purpose and use of some of the more important di-&lt;br /&gt;rectives used with this assembler. Appendix A provides additional details about the assembler. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Directives &lt;br /&gt;Before the format of an assembly language program is discussed, some details about the direc-&lt;br /&gt;tives (pseudo-operations) that control the assembly process must be mentioned. Some common &lt;br /&gt;assembly language directives appear in Table 4-21. Directives indicate how an operand or sec-&lt;br /&gt;tion of a program is to be processed by the assembler. Some directives generate and store infor-&lt;br /&gt;mation in the memory, while others do not. The DB (define byte) directive stores bytes of data &lt;br /&gt;in the memory, while the BYTE PTR directive never stores data. The BYTE PTR directive in-&lt;br /&gt;dicates the size of the data referenced by a pointer or index register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note that the assembler by default accepts only 8086/8088 instructions, unless a program &lt;br /&gt;is preceded by the .386 or .386P directive or one of the other microprocessor selection switches. &lt;br /&gt;The .386 directive tells the assembler to use the 80386 instruction set in the real mode, while the &lt;br /&gt;.386P directive tells the assembler to use the 80386 protected mode instruction set. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Storing Data in a Memory Segment. The DB (define byte), DW (define word), and DD (define &lt;br /&gt;doubleword) directives, first presented in Chapter I, are most often used with the micro-&lt;br /&gt;processor to define and store memory data. If a numeric coprocessor executes software in the &lt;br /&gt;system, the DQ (define quadword) and DT (define ten bytes) directives are also common. &lt;br /&gt;These directives label a memory location with a symbolic name and indicate its size. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 4-12 shows a memory segment that contains various forms of data definition di-&lt;br /&gt;rectives. It also shows the full segment definition with the first SEGMENT statement to indicate &lt;br /&gt;the start of the segment and its symbolic name. Alternately, as in previous examples, the &lt;br /&gt;SMALL model can be used with the .DAT A statement. The last statement in this example con-&lt;br /&gt;tains the ENDS directive that indicates the end of the segment. The name of the segment &lt;br /&gt;(LIST_SEG) can be anything that the programmer desires to call it. This allows a program to &lt;br /&gt;contain as many segments as required. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IThe assembler used throughout this text is the Microsoft MACRO assembler MASM, version 6.x &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;TABLE 4-21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Directive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.286 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.286P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.486 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.486P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.586 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.586P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.287 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.STARTUP &lt;br /&gt;ALIGN 2 &lt;br /&gt;ASSUME &lt;br /&gt;BYTE &lt;br /&gt;DB &lt;br /&gt;DD &lt;br /&gt;DO &lt;br /&gt;DT &lt;br /&gt;DUP &lt;br /&gt;DW &lt;br /&gt;DWORD &lt;br /&gt;END &lt;br /&gt;ENDM &lt;br /&gt;ENDP &lt;br /&gt;ENDS &lt;br /&gt;EOU &lt;br /&gt;FAR &lt;br /&gt;MACRO &lt;br /&gt;NEAR &lt;br /&gt;OFFSET &lt;br /&gt;ORG &lt;br /&gt;PROC &lt;br /&gt;PTR &lt;br /&gt;SEGMENT &lt;br /&gt;STACK &lt;br /&gt;STRUC &lt;br /&gt;USES &lt;br /&gt;USE16 &lt;br /&gt;USE32 &lt;br /&gt;WORD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-7 ASSEMBLER DETAIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Common assembler directives &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selects the 80286 instruction set &lt;br /&gt;Selects the 80286 protected mode instruction set &lt;br /&gt;Selects the 80386 instruction set &lt;br /&gt;Selects the 80386 protected mode instruction set &lt;br /&gt;Selects the 80486 instruction set &lt;br /&gt;Selects the 80486 protected mod instruction set &lt;br /&gt;Selects the Pentium instruction set &lt;br /&gt;Selects the Pentium protected mode instruction set &lt;br /&gt;Selects the 80287 math coprocessor &lt;br /&gt;Selects the 80387 math coprocessor &lt;br /&gt;Exits to DOS &lt;br /&gt;Selects the programming model &lt;br /&gt;Indicates the start of the program when using program models &lt;br /&gt;Starts data on a word boundary (4 starts data on a doubleword boundary) &lt;br /&gt;Informs the assembler of the name of each segment for full segment definitions &lt;br /&gt;Indicates byte-sized, as in BYTE PTR &lt;br /&gt;Defines byte(s) (8-bits) &lt;br /&gt;Defines doubleword(s) (32-bits) &lt;br /&gt;Defines quadword(s) (64-bits) &lt;br /&gt;Defines ten byte(s) (80-bits) &lt;br /&gt;Generates duplicates &lt;br /&gt;Defines word(s) (16-bits) &lt;br /&gt;Indicates doubleword-sized, as in DWORD PTR &lt;br /&gt;Ends a program file &lt;br /&gt;Ends a macro sequence &lt;br /&gt;Ends a procedure &lt;br /&gt;Ends a segment or data structure &lt;br /&gt;Equates data to a label &lt;br /&gt;Defines a far pOinter &lt;br /&gt;Designates the start of a macro sequence &lt;br /&gt;Defines a near pointer &lt;br /&gt;Specifies an offset address &lt;br /&gt;Sets the origin within a segment &lt;br /&gt;Starts a procedure &lt;br /&gt;Designates a pointer &lt;br /&gt;Starts a segment &lt;br /&gt;Starts a stack segment &lt;br /&gt;Defines the start of a data structure &lt;br /&gt;Automatically pushes and pops registers within a procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;131 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Directs the assembler to use 16-bit instruction mode and data sizes for the 80386-Pentium Pro &lt;br /&gt;Directs the assembler to use 32-bit instruction mode and data sizes for the 80386-Pentium Pro &lt;br /&gt;Indicates word-sized, as in WORD PTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 01 02 03 &lt;br /&gt;0003 45 &lt;br /&gt;0004 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Using the DB, DW, and DD directives &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D;&amp;gt;.TA1 DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEGMENT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1, 2,3 &lt;br /&gt;45H &lt;br /&gt;'A' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define bvtes &lt;br /&gt;; hexadecimal &lt;br /&gt;;ASCII &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;132 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0005 FO DB ll1J (JOOOB ;binary &lt;br /&gt;0006 oooe OOOD DATJ..2 DVI 12,13 ;define words &lt;br /&gt;OOOA 0200 DV: LISTI ; symbolic &lt;br /&gt;oooe 2345 DVi 2345H ; hexadecimal &lt;br /&gt;OOOE OOOQ0300 DATA3 D;) 300H ; hexadecimal &lt;br /&gt;0012 4007DF3B DD 2.123 ;real &lt;br /&gt;0016 544269El DD 3.34E+12 ;real &lt;br /&gt;001A 00 LISTA DB ? ; reserve 1 byte &lt;br /&gt;001B OOOA[ LISTB DB 10 DUP (? ) ; reserve 10 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;?? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0025 00 ALIGN 2 ;set word boundary &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0026 0100[ LISTC DW 100H DUP (0 ) ;word array &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;0226 0016[ LIST_ 9 DD 22 DUP (? ) ;doubleword array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;???????? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;027E 0064[ SIXES DB 100 DUP (6 ) ;byte array &lt;br /&gt;06 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02E2 LIST_SEG ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 4-12 shows various forms of data storage for bytes at DATAL More than one &lt;br /&gt;byte can be defined on a line in binary, hexadecimal, decimal, or ASCII code. The DATA21abei &lt;br /&gt;shows how to store various forms of word data. Doublewords are stored at DAT A3, including &lt;br /&gt;floating-point, single-precision real numbers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory is reserved for use in the future by using a ? as an operand for a DB, DW, or DD &lt;br /&gt;directive. When a ? is used in place of a numeric or ASCII value, the assembler sets aside a lo-&lt;br /&gt;cation and does not initialize it to any specific value. (Actually, the assembler usually stores a &lt;br /&gt;zero into locations specified with a ?). The DUP (duplicate) directive creates an array as shown &lt;br /&gt;in several ways in Example 4-12. A 10 DUP (?) directive reserves 10 locations of memory, but &lt;br /&gt;stores no specific value in any of the 10 locations. If a number appears within the ( ) part of the &lt;br /&gt;DUP statement, the assembler initializes the reserved section of memory with the data indicated. &lt;br /&gt;For example, the DATAl DB 10 DUP (2) instruction reserves 10 bytes of memory for array &lt;br /&gt;DATAl and initializes each location with a 02H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ALIGN directive, used in this example, makes sure that the memory arrays are stored &lt;br /&gt;on word boundaries. An ALIGN 2 places data on word boundaries, and an ALIGN 4 places data &lt;br /&gt;on doubleword boundaries. In the Pentium and Pentium Pro, quadword data for double-preci-&lt;br /&gt;sion floating-point numbers should use ALIGN 8. It is important that word-sized data be placed &lt;br /&gt;at word boundaries and doubleword-sized data at doubleword boundaries. If not, the micro-&lt;br /&gt;processor spends additional time accessing these data types. A word stored at an odd-numbered &lt;br /&gt;memory location takec; twice as long to access as a word stored at an even-numbered memory lo-&lt;br /&gt;cation. Note that the ALIGN directive cannot be used with memory models, because the size of &lt;br /&gt;the model determines the data alignment. If all doubleword data are defined first, followed by &lt;br /&gt;word and then byte-sized data, the ALIGN statement is not necessary to align data correctly. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASSUME, EQU, and ORG. The equate directive (EQU) equates a numeric, ASCII, or label to an-&lt;br /&gt;other label. Equates make a program clearer and simplify debugging. Example 4-13 shows sev-&lt;br /&gt;eral equate statements and a few instructions that show how they function in a program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-13 &lt;br /&gt;;Using equace directive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA TE;J EQU 10 &lt;br /&gt;0009 NINE EQU 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BO OA MOV AL,TEN &lt;br /&gt;0002 04 09 ADD AL, !;:;:NE &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-7 ASSEMBLER DETAIL 133 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The THIS directive always appears as THIS BYTE, THIS WORD, or THIS DWORD. In &lt;br /&gt;certain cases, data must be referred to as both a byte and a word. The assembler can only assign &lt;br /&gt;either a byte or a word address to a label. To assign a byte label to a word, use the software listed &lt;br /&gt;in Example 4-14. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 0100 &lt;br /&gt;0100 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0102 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0004 &lt;br /&gt;0007 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SA 1E 0100 R &lt;br /&gt;A1 0100 R &lt;br /&gt;SA 3E 0101 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;using the THIS and ORG directives &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA_SEG SEGMENT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORG 100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATAl EQU THIS BYTE &lt;br /&gt;DATA2 DW ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA_SEG ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CODE_SEG SEGMENT 'CODE' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASSUME CS:CODE_SEG,DS:DATA_SEG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL,DATA1 &lt;br /&gt;MOV AX,DATA2 &lt;br /&gt;MOV BH,DATA1+1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This example also illustrates how the ORO (origin) statement changes the starting offset &lt;br /&gt;address of the data in the data segment to location lOOH. At times, the origin of data or the code &lt;br /&gt;must be assigned to an absolute offset address with the ORO statement. The ASSUME state-&lt;br /&gt;ment tells the assembler what names have been chosen for the code, data, extra, and stack seg-&lt;br /&gt;ments. Without the ASSUME statement, the assembler assumes nothing and automatically uses &lt;br /&gt;a segment override prefix on all instructions that address memory data. The ASSUME statement &lt;br /&gt;is only used with full-segment definitions, as described later in this section of the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC and ENDP. The PROC and ENDP directives indicate the start and end of a pro-&lt;br /&gt;cedure (subroutine). These directives force structure because the procedure is clearly defined. &lt;br /&gt;Note that if structure is to be violated for any reason, the CALLF, CALLN, RETF, and RETN in-&lt;br /&gt;structions should be used. Both the PROC and ENDP directives require a label to indicate the &lt;br /&gt;name of the procedure. The PROC directive, which indicates the start of a procedure, must also &lt;br /&gt;be followed with a NEAR ~r FAR. A NEAR procedure is one that resides in the same code seg-&lt;br /&gt;ment as the program. A FAR procedure may reside at any location in the memory system. Often, &lt;br /&gt;the call NEAR procedure is considered local, and the call FAR procedure is considered global. &lt;br /&gt;The term global denotes a procedure that can be used by any program, while local defines a pro-&lt;br /&gt;cedure that is used only by the current program. Any labels that are defined within the procedure &lt;br /&gt;block are also defined as either local (NEAR) or global (FAR). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 4-15 shows a procedure that adds BX, CX, and DX and stores the sum in register &lt;br /&gt;AX. Although this procedure is short, and may not be particularly useful, it does illustrate how to &lt;br /&gt;use the PROC and ENDP directives to delineate the procedure. Note that information about the &lt;br /&gt;operation of the procedure should appear as a grouping of comments that show the registers &lt;br /&gt;changed by the procedure and the result of the procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 03 D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that adds BX, CX, and DX with the sum &lt;br /&gt;;stored in AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDEM PROC FAR ;start procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD BX,CX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;134 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 03 DA &lt;br /&gt;0004 8B C3 &lt;br /&gt;0006 CB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD &lt;br /&gt;MOV &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDEM ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX,DX &lt;br /&gt;AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If version 6.x of the Microsoft MASM assembler program is available, the PROC direc-&lt;br /&gt;tive specifies and automatically saves any registers used within the procedure. The USES state-&lt;br /&gt;ment indicates which registers are used by the procedure so that the assembler can automatically &lt;br /&gt;save them before your procedure begins and restore them before the procedure ends with the &lt;br /&gt;RET instruction. For example, the ADDS PROC USES AX BX CX statement automatically &lt;br /&gt;pushes AX, BX, and CX on the stack before the procedure begins, and pops them from the stack &lt;br /&gt;before the RET instruction executes at the end of the procedure~ Example 4-16 illustrates a pro-&lt;br /&gt;cedure written using MASM 6.x that shows the USES statement. Note that the registers in the &lt;br /&gt;list are not separated by commas, but by spaces, and the PUSH and POP instructions are dis-&lt;br /&gt;played in the procedure listing because the procedure was assembled with the .LIST ALL direc-&lt;br /&gt;tive. The instructions prefaced with an asterisk (*) are inserted by the assembler and were not &lt;br /&gt;typed in the source file. Further information about the USES statement appears, in Chapter 7, so &lt;br /&gt;ifMASM version 5.10 is being used, the code will need to be modified. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-16 &lt;br /&gt;;A procedure that includes the USES directive to save &lt;br /&gt;;BX, CX, and DX on the stack and restore them before &lt;br /&gt;;the RET instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 ADDS PROC NEAR USES BX CX DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 53 * push bx &lt;br /&gt;0001 51 * push cx &lt;br /&gt;0002 52 * push dx &lt;br /&gt;0003 03 D8 ADD BX,AX &lt;br /&gt;0005 03 CB ADD CX,BX &lt;br /&gt;0007 03 D1 ADD DX,CX &lt;br /&gt;0009 8B C2 MOV AX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;OOOB 5A * pop dx &lt;br /&gt;OOOC 59 * pop cx &lt;br /&gt;OOOD 5B * pop bx &lt;br /&gt;OOOE C3 * ret OOOOOh &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOF ADDS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Organization &lt;br /&gt;The assembler uses two basic formats for qeveloping software. One method uses models and the &lt;br /&gt;other uses full-segment definitions. Memory models, as presented in this section and also in &lt;br /&gt;Chapters 2 and 3, are unique to the MASM assembler program. The T ASM assembler also uses &lt;br /&gt;memory models, but they differ somewhat from the MASM models. The full-segment defini-&lt;br /&gt;tions are common to most assemblers, including the Intel assembler, and are often used for soft-&lt;br /&gt;ware development. The models are easier to use for simple tasks. The full-segment definitions &lt;br /&gt;offer better control over the assembly language task and are recommended for complex pro-&lt;br /&gt;grams. The model was used in early chapters because it is easier to understand for the beginning &lt;br /&gt;programmer. Models 41(; also used with assembly language procedures that are used by high-&lt;br /&gt;level languages such as C/C++. This text fully develops and uses the memory model definitions &lt;br /&gt;for its programming examples, but realize that full-segment definitions offer some advantages &lt;br /&gt;over memory models, as discussed later in this section. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-7 ASSEMBLER DETAIL 135 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Models. There are many models available to the MASM assembler, from tiny to huge. Ap-&lt;br /&gt;pendix A contains a table listing all of the models available for use with the assembler. To des-&lt;br /&gt;ignate a model, use the .MODEL statement followed by the size of the memory system. The &lt;br /&gt;TINY model requires that all software and data fit into one 64K byte memory segment, and is &lt;br /&gt;useful for many small programs. The SMALL model requires that only one data segment be &lt;br /&gt;used with one code segment, for a total of l28K bytes of memory. Other models are available up &lt;br /&gt;to the HUGE model. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 4-17 illustrates how the .MODEL statement defines the parameters of a short &lt;br /&gt;program that copies the contents of a lOO-byte block of memory (LISTi\\) into a second lOO-byte &lt;br /&gt;block of memory (LISTB). It also shows how to define the stack, data, and code segments. The &lt;br /&gt;.EXIT 0 directive returns to DOS with an error code of 0 (no error). If no parameter is added to &lt;br /&gt;.EXIT, it still returns to DOS, but the error code is not defined. Also note that special directives &lt;br /&gt;such as @DATA (see Appendix A) are used to identify various segments. If the .STARTUP di-&lt;br /&gt;rective is used (MASM version 6.X), the MOV AX,@DATA followed by MOV DS,AX state-&lt;br /&gt;ments can be eliminated. The .STARTUP directive also eliminates the need to store the starting &lt;br /&gt;address next to the END label. Models are important with both Microsoft C/C++ and Borland &lt;br /&gt;C/C++ development systems if assembly language is included with C/C++ programs. Both de-&lt;br /&gt;vdopment systems use in-line assembly programming for adding assembly language instruc-&lt;br /&gt;tions and require an understanding of programming models. Refer to the respective C/C++ &lt;br /&gt;language reference for each system to determine the model protocols. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0064[ LISTA &lt;br /&gt;?? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0064 0064[ LISTB &lt;br /&gt;?? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B8 ---- R HERE: &lt;br /&gt;0003 8E CO &lt;br /&gt;0005 8E D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 FC &lt;br /&gt;0008 BE 0000 R &lt;br /&gt;OOOB BF 0064 R &lt;br /&gt;OOOE B9 0064 &lt;br /&gt;0011 F3/A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0013 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;REP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SMALL &lt;br /&gt;100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX,@DATA &lt;br /&gt;ES,AX &lt;br /&gt;DS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI,OFFSET LISTA &lt;br /&gt;DI,OFFSET LISTB &lt;br /&gt;CX,lOO &lt;br /&gt;MOVSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT a &lt;br /&gt;END HERE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define stack &lt;br /&gt;;define data segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define code segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; load ES, DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;move data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Full Segment Definitions. Exampie 4-18 illustrates the same program using full-segment defini-&lt;br /&gt;tions. Full-segment definitions are also used with the Borland and Microsoft C/C++ environments &lt;br /&gt;for procedures developed in assembly language. The program in Example 4-18 appears longer &lt;br /&gt;than the one shown in Figure 4-17, but more structured than the model method of setting up a pro-&lt;br /&gt;gram. The first segment defined is the ST ACK_SEG, which is clearly delineated with the SEG-&lt;br /&gt;MENT and ENDS directives. Within these directives, a DW 100 DUP (?) sets aside lOOH words &lt;br /&gt;for the stack segment. Because the :-vord STACK appears next to SEGMENT, the assembler and &lt;br /&gt;linker automatically load both the stack segment register (SS) and stack pointer (SP). &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;136 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-18 &lt;br /&gt;0000 STACK_SEG SEGMENT STACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 OlOO[ DW 100H DUP (? ) &lt;br /&gt;???? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0200 STACK_SEG ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 DATA_SEG SEGMENT 'DATA' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0064[ LISTA DB 100 DUP (?) &lt;br /&gt;?? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0064 0064[ LISTB DB 100 DUP ( ?) &lt;br /&gt;?? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C8 DATA_SEG ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 CODE_SEG SEGMENT 'CODE' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASSUME CS:CODE_SEG,DS:DATA_SEG &lt;br /&gt;ASSUME SS:STACK_SEG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 MAIN PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B8 ---- R MOV AX,DATA_SEG ;load DS and ES &lt;br /&gt;0003 8E CO MOV ES,AX &lt;br /&gt;0005 8E D8 MOV DS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 FC CLD ;move data &lt;br /&gt;0008 BE 0000 R MOV SI,OFFSET LISTA &lt;br /&gt;OOOB BF 0064 R MOV DI,OFFSET LISTB &lt;br /&gt;OOOE B9 0064 MOV CX,lOO &lt;br /&gt;0011 F3/M REP MOVSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0013 B4 4C MOV AH,4CH ;exit to DOS &lt;br /&gt;0015 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 MAIN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 CODE_SEG ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END MAIN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Next, the data are defined in the DATA_SEG. Here two arrays of data appear as LISTA &lt;br /&gt;and LISTB. Each array contains 100 bytes of space for the progr;lm. The names of the segments &lt;br /&gt;in this program can be changed to any name. Always include the group name 'DATA' so the Mi-&lt;br /&gt;crosoft program Code View can be effectively used to symbolically debug this software. Code-&lt;br /&gt;View is a part of the MASM package used to debug software .. To access CodeView, type CV &lt;br /&gt;followed by the file name at the DOS command line; if operating from Programmer's W ork-&lt;br /&gt;Bench, select Debug under the Run menu. If the group name is not placed in a program, Code-&lt;br /&gt;View can still be used to debug a program, but the program will not be debugged in symbolic &lt;br /&gt;form. Other group names such as 'STACK', 'CODE', and so forth are listed in Appendix A. You &lt;br /&gt;must at least place the word 'CODE' next to the code segment SEGMENT statement if you want &lt;br /&gt;to view the program symbolically in CodeView. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CODE_SEG is organized as a far procedure because most software is procedure ori-&lt;br /&gt;ented. Before the program begins, the code segment contains the ASSUME statement. The AS-&lt;br /&gt;SUME statement tells the assembler and linker that the name used for the code segment (CS) is &lt;br /&gt;CODE_SEG; it also tells the assembler and linker that the data segment is DAT A_SEG and the &lt;br /&gt;stack segment is ST ACK_SEG. Also notice that the group name 'CODE' is used for the code &lt;br /&gt;segment for use by CodeView. Other group names appear in Appendix A with the models. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-7 ASSEMBLER DETAIL 137 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After the program loads both the extra segment register and data segment register with the &lt;br /&gt;location of the data segment, it transfers 100 bytes from LIST A to LISTB. Following this is a se-&lt;br /&gt;quence of two instructions that return control back to DOS (the disk operating system). Note that &lt;br /&gt;the program loader does not automatically initialize DS and ES. These registers must be loaded &lt;br /&gt;with the desired segment addresses in the program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The last statement in the program is END MAIN. The END statement indicates the end of &lt;br /&gt;the program and the location of the first instruction executed_ Here we want the machine to exe-&lt;br /&gt;cute the main procedure, so a label follows the END directive. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80386 through the Pentium Pro microprocessors, an additional directive is found at-&lt;br /&gt;tached to the code segment. The USE16 or USE32 directive tells the assembler to use either the &lt;br /&gt;16- or 32-bit instruction modes for the microprocessor. Software developed for the DOS envi-&lt;br /&gt;ronment must use the USE16 directive for the 80386 through the Pentium programs to function &lt;br /&gt;correctly, because MASM assumes that all segments are 32-bits and all instruction modes are &lt;br /&gt;32-bits by default. In fact, any program designed to execute in the real mode must include the &lt;br /&gt;USE16 directive to deviate from the default 8086/8088. Example 4--19 shows how the same soft-&lt;br /&gt;ware listed in Example 4--18 is formed for the 80386 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0100[ &lt;br /&gt;???? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0200 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0064[ &lt;br /&gt;?? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0064 0064[ &lt;br /&gt;?? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B8 ---- R &lt;br /&gt;0003 8E CO &lt;br /&gt;0005 8E D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 FC &lt;br /&gt;0008 BE 0000 R &lt;br /&gt;OOOB BF 0064 R &lt;br /&gt;OOOE B9 0064 &lt;br /&gt;0011 F3/A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0013 B4 4C &lt;br /&gt;0015 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 ;select the 80386 &lt;br /&gt;STACK_SEG SEGMENT STACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DW 100H DUP (?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STACK_SEG ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA_SEG SEGMENT 'DATA' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LISTA DB 100 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LISTB DB 100 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CODE_SEG SEGMENT USE16 'CODE' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASSUME CS:CODE_SEG,DS:DATA_SEG &lt;br /&gt;ASSUME SS:STACK_SEG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,DATA_SEG ;load DS and ES &lt;br /&gt;MOV ES,AX &lt;br /&gt;MOV DS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD ;move data &lt;br /&gt;MOV SI,OFFSET LISTA &lt;br /&gt;MOV DI,OFFSET LISTB &lt;br /&gt;MOV CX,100 &lt;br /&gt;REP MOVSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,4CH ;exit to DOS &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CODE_SEG ENDS &lt;br /&gt;END Ko,IN &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;138 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A Sample Program &lt;br /&gt;Example 4-20 provides a sample program, using full-segment definitions. that reads a character &lt;br /&gt;from the keyboard and displays it on the CRT screen. Although this program is trivial, it does il-&lt;br /&gt;lustrate a complete workable program that functions on any personal computer using DOS, from &lt;br /&gt;the earliest 8088-based system to the latest Pentium-based system. This program also illustrates &lt;br /&gt;the use of a few DOS function calls. Appendix A lists the DOS function calls with their parame-&lt;br /&gt;ters. The BIOS function calls allow the use of the keyboard, printer, disk drives, and everything &lt;br /&gt;else that is available in your computer system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This example program uses only a code segment because there is no data. A stack segment &lt;br /&gt;should appear, but has been left out because DOS automatically allocates a 128-byte stack for all &lt;br /&gt;programs. The only time that the stack is used in this example is for the INT 21H instruction that &lt;br /&gt;calls a procedure in DOS. Note that when this program is linked, the linker signals that no stack &lt;br /&gt;segment is present. This warning may be ignored in this example because the stack is less than &lt;br /&gt;128 bytes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that the entire program is placed into a far procedure called MAIN. It is good pro-&lt;br /&gt;gramming practice to write all software in procedural form. This allows the program to be used &lt;br /&gt;as a procedure if necessary at some future time. It is also fairly important to document register &lt;br /&gt;use and any parameters required for the program in the program header. The program header is a &lt;br /&gt;section of comments that appear at the start of the program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The program uses DOS functions 06H and 4CH. The function number is placed in AH be-&lt;br /&gt;fore the INT 2lH instruction executes. The 06H function reads the keyboard if DL = OFFH or &lt;br /&gt;displays the ASCII contents of DL if it is not OFFH. Upon close examination, the first section of &lt;br /&gt;the program moves a 06H into AH and a OFFH into DL so that a key is read from the keyboard. &lt;br /&gt;The INT 2lH instruction tests the keyboard; if no key is typed, it returns equal. The JE instruc-&lt;br /&gt;tion tests the equal condition and jumps to MAIN if no key is typed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When a key is typed, the program continues to the next step. This step compares the con-&lt;br /&gt;tents of AL with an @ symbol. Upon return from the INT 21H instruction, the ASCII character &lt;br /&gt;of the typed key is found in AL. In this program, if an @ symbol is typed, the program ends. If &lt;br /&gt;the @ symbol is not typed, the program continues by displaying the character typed on the key-&lt;br /&gt;board with the next INT 2lH instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The second INT 21 H instruction moves the ASCII character into DL so it can be displayed &lt;br /&gt;on the CRT screen. After displaying the character, a JMP executes. This causes the program to &lt;br /&gt;continue at MAIN, where it repeats reading a key. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the @ symbol is typed, the program continues at MAINl, where it executes the DOS &lt;br /&gt;function code number 4CH. This causes the program to return to the DOS prompt (AÂ» so that &lt;br /&gt;the computer can be used for other tasks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;More information about the assembler and its application appears in Appendix A and in &lt;br /&gt;the next several chapters. Appendix A provides a complete overview of the assembler, linker, &lt;br /&gt;and DOS functions. It also provides a list of the BIOS (basic I/O system) functions. The infor-&lt;br /&gt;mation provided in the following chapters clarifies how to use the assembler for certain tasks at &lt;br /&gt;different levels of the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 4-20 &lt;br /&gt;;An example program that reads a key and displays i~. &lt;br /&gt;;Note that an @ key ends the program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 CODE_SEG SEGMENT 'CODE' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASSUME CS:CODE_SEG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 MAIN PRO':: FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B4 06 ~lO\\' AH,6 ;read key &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-8 SUMMARY 139 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 82 FF MOV DL,OFFH &lt;br /&gt;0004 CD 21 INT 21H &lt;br /&gt;0006 74 F8 JE MAIN ; if no key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 3C 40 CMP AL, '@' ;test for @ &lt;br /&gt;00 Of.. 74 02 JE ~L'\\.IN1 ; if @ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC B4 06 MOV AH,6 ;display key &lt;br /&gt;OOOE SA DO MOV DL,AL &lt;br /&gt;0010 CD n INT nH &lt;br /&gt;0012 EB EC JMP MAIN ; repeat &lt;br /&gt;0014 MAIN1: &lt;br /&gt;0014 B4 4C NOV AH,4CH ;exit to DOS &lt;br /&gt;0016 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0018 MAIN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0018 CODE_SEG ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END MAIN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Data movement instructions transfer data between registers, a register and memory, a reg-&lt;br /&gt;ister and the stack, memory and the stack, the accumulator and I/O, and the flags and the &lt;br /&gt;stack. Memory-to-memory transfers are only allowed with the MOYS instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Data movement instructions include MOY, PUSH, POP, XCHG, XLAT, IN, OUT, LEA, &lt;br /&gt;LDS, LES, LSS, LGS, LFS, LAHF, SAHF, and the string instructions: LODS, STOS, &lt;br /&gt;MOYS, INS, and OUTS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The first byte of an instruction contains the opcode. The opcode specifies the operation per-&lt;br /&gt;formed by the microprocessor. The opcode may be preceded by one or more override pre-&lt;br /&gt;fixes in some forms of instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. The D-bit, located in many instructions, selects the direction of data flow. If D = 0, the data &lt;br /&gt;flow from the REG field to the RIM field of the instruction. If D = 1, the data flow from the &lt;br /&gt;RIM field to the REG field. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The W-bit, found in most instructions, selects the size of the data transfer. IfW = 0, the data &lt;br /&gt;are byte-sized; if W = 1, the data are word sized. In the 80386 and above, W = 1 specifies ei-&lt;br /&gt;ther a word or doubleword register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. MOD selects the addressing mode of operation for a machine language instruction's RIM field. &lt;br /&gt;If MOD = 00, there is no displacement; if MOD-OI, an 8-bit sign-extended displacement ap-&lt;br /&gt;pears; if MOD-lO, a I6-bit displacement occurs; and if a MOD-ll, a register is used instead of &lt;br /&gt;a memory location. In the 80386 and above, the MOD bits also specify a 32-bit displacement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. A 3-bit binary register code specifies the REG and RIM fields when the MOD = 11. The 8-&lt;br /&gt;bit registers are AH, AL, BH, BL, CH, CL, DH, and DL. The 16-bit registers are AX, BX, &lt;br /&gt;CX, DX, SP, BP, DI, and SI. The 32-bit registers are EAX, EBX, ECX, EDX, ESP, EBP, &lt;br /&gt;EDI, and ESI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. When the RIM field depicts a memory mode, a 3-bit code selects one of the following &lt;br /&gt;modes: [BX+DI], [BX+SI], [BP+DI], [BP+SI], [BX], [BP], [DI], or [SI] for 16-bit instruc-&lt;br /&gt;tions. In the 80386 and above, the RIM field specifies EAX, EBX, ECX, EDX, EBP, EDI, &lt;br /&gt;and ESI or one of the scaled-index modes of addressing memory data. If the scaled-index &lt;br /&gt;mode is selected (RIM = 100), an additional byte (scaled-index byte) is added to the instruc-&lt;br /&gt;tion to specify the base register, index register, and the scaling factor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. All memory-addressing modes, by default, address data in the data segment unless BP or &lt;br /&gt;EBP addresses memory. The BP or EBP register addresses data in the stack segment. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;140 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The segment registers are addressed only by the MOV, PUSH, or POP instructions. The &lt;br /&gt;MOV instruction may transfer a segment register to a 16-bit register or vice versa. MOV &lt;br /&gt;CS,reg or POP CS instructions are not allowed because they change only part of the address. &lt;br /&gt;The 80386 through the Pentium Pro include two additional segment registers, FS and GS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. Data are transferred between a register or a memory location and the stack by the PUSH and &lt;br /&gt;POP instructions. Variations of these instructions allow immediate data to be pushed onto &lt;br /&gt;the stack, the flags to be transferred between the stack, and all the 16-bit registers to be &lt;br /&gt;transferred between the stack and the registers. When data are transferred to the stack, two &lt;br /&gt;bytes (8086-80286) always move; the most-significant byte is placed at the location ad-&lt;br /&gt;dressed by SP - 1. and the least-significant byte is placed at the location addressed by SP - 2. &lt;br /&gt;After placing the data on the stack, SP decrements by 2. In the 80386/80486IPentium/Pen-&lt;br /&gt;tium Pro, four bytes of data from a memory location or register may also be transferred to &lt;br /&gt;the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. Opcodes that transfer data between the stack and the flags are PUSHF and POPF. Opcodes &lt;br /&gt;that transfer all of the 16-bit registers between the stack and the registers are PUSHA and &lt;br /&gt;papA. In the 80386 and above, PUSHFD and POPFD transfer the contents of the EFLAGS &lt;br /&gt;between the microprocessor and the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. LEA, LDS, and LES instructions load a register or registers with an effective address. The &lt;br /&gt;LEA instruction loads any 16-bit register with an effective address, while LDS and LES &lt;br /&gt;load any 16-bit register and either DS or ES with the effective address. In the 8038-6 and &lt;br /&gt;above, additional instructions include LFS, LGS, and LSS, which load a 16-bit register and &lt;br /&gt;FS, GS, or SS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. String data transfer instructions use either or both DI and SI to address memory. The DI &lt;br /&gt;offset address is located in the extra segment, and the SI offset address is located in the data &lt;br /&gt;segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. The direction flag (D) chooses the auto-increment or auto-decrement mode of operation for &lt;br /&gt;DI and SI for string instructions. To clear D to 0, use the CLD instruction to select the auto-&lt;br /&gt;increment mode; to set D to 1, use the STD instruction to select the auto-decrement mode. &lt;br /&gt;Either or both DI and SI increment/decrement by 1 for a byte operation, by 2 for a word op-&lt;br /&gt;eration, and by 4 for a doubleword operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. LaDS loads AL, AX, or EAX with data from the memory location addressed by SI; STOS &lt;br /&gt;stores AL, AX, or EAX in the memory location addressed by DI; and MOVS transfers a &lt;br /&gt;byte or a word from the memory location addressed by SI into the location addressed by DI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. INS inputs data from an I/O device addressed by DX and stores it in the memory location &lt;br /&gt;addressed by DI. OUTS outputs the contents of the memory location addressed by SI and &lt;br /&gt;sends it to the I/O device addressed by DX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. The REP prefix may be attached to any string instruction to repeat it. The REP prefix repeats &lt;br /&gt;the string instruction the number of times found in register CX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. Arithmetic and logic operators can be used in assembly language. An example is MOV &lt;br /&gt;AX,34*3, which loads AX with 102. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. Translate (XLAT) converts the data in AL into a number stored at the memory location ad-&lt;br /&gt;dress by BX plus AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21. IN and OUT transfer data between AL, AX, or EAX and an external 1/0 device. The address &lt;br /&gt;of the I/O device is either stored with the instruction (fixed port) or in register DX (variable &lt;br /&gt;port). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22. The Pentium Pro contains a new instruction called CMOV or conditional move. This in-&lt;br /&gt;struction only performs the move if the condition is true. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;23. The segment override prefix selects a different segment register for a memory location than &lt;br /&gt;the default segment. For example, the MOV AX,[BX] instruction uses the data segment, but &lt;br /&gt;the MOV AX,ES:[BX] instruction uses the extra segment because of the ES: prefix. The &lt;br /&gt;segment override prefix is the only way that the FS and GS segments are addressed in the &lt;br /&gt;80386 through the Pentium Pro. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-9 QUESTIONS AND PROBLEMS 141 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24. The MOVZX (move and zero-extend) and MOVSX (move and sign-extend) instructions &lt;br /&gt;found in the 80386 and above increase the size of a byte to a word or a word to a double-&lt;br /&gt;word. The zero-extend version increases the size of the number by inserting leading zeros. &lt;br /&gt;The sign-extend version increases the size of the number by copying the sign-bit into the &lt;br /&gt;more-significant bits of the number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;25. Assembler directives DB, (define byte), DW (define word), DD (define doubleword), and &lt;br /&gt;DUP (duplicate) store data in the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26. The EQU (equate) directive allows data or labels to be equated to labels. &lt;br /&gt;27. The SEGMENT directive identifies the start of a memory segment and ENDS identifies the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;end of a segment when full-segment definitions are in use. &lt;br /&gt;28. The ASSUME directive tells the assembler what segment names you have assigned to CS, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS, ES, and SS when full-segment definitions are in effect. In the 80386 and above, AS-&lt;br /&gt;SUME also indicates the segment name for FS and GS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;29. The PROC and ENDP directives indicate the start and end of a procedure. The USES direc-&lt;br /&gt;tive (MASM version 6.X) automatically saves and restores any number of registers on the &lt;br /&gt;stack if they appear with the PROC directive. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30. The assembler assumes that software is being developed for the 8086/8088 microprocessors &lt;br /&gt;unless the .286, .386, .486, or .586 directive is used to select one of these other micro-&lt;br /&gt;processors. This directive follows the .MODEL statement to use the 16-bit instruction mode, &lt;br /&gt;and precedes it for the 32-bit instruction mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31. Memory models can be used to shorten the program slightly, but they can cause problems &lt;br /&gt;for larger programs. Also be aware that memory models are not compatible with all assem-&lt;br /&gt;bler programs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;I. The first byte of an instruction is the unless it contains one of the override &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;prefixes. &lt;br /&gt;2. Describe the purpose of the D- and W -bits found in some machine language instructions. &lt;br /&gt;3. In a machine language instruction, what information is specified by the MOD field? &lt;br /&gt;4. If the register field (REG) of an instruction contains a 010 and W = 0, what register is se-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lected, assuming that the instruction is a 16-bit mode instruction? &lt;br /&gt;5. How are the 32-bit registers selected for the 80486 microprocessor? &lt;br /&gt;6. What memory-addressing mode is specified by RIM = 001 with MOD = 00 for a 16-bit in-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;struction? &lt;br /&gt;7. Identify the default segment register assigned to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) SP &lt;br /&gt;(b) EBX &lt;br /&gt;(c) DI &lt;br /&gt;(d) EBP &lt;br /&gt;(e) SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Convert an 8B07H from machine language to assembly language. &lt;br /&gt;9. Convert an 8BIE004CH from machine language to assembly language. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. If a MOV SI,[BX+2] instruction appears in a program, what is its machine language equiv-&lt;br /&gt;alent? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II. If a MOV ESI,[EAX] instruction appears in a program for the Pentium microprocessor op-&lt;br /&gt;erated in the 16-bit instruction mode, what is its machine language equivalent? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. What is wrong with a MOV CS,AX instruction? &lt;br /&gt;13. Form a short sequence of instructions that load the data segment register with a 1000H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;142 CHAPTER 4 DATA MOVEMENT INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The PUSH and POP instructions always transfer a __ -bit number between the stack and a &lt;br /&gt;register or memory location in the 8086-80286 microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. What segment register may not be popped from the stack? &lt;br /&gt;16. Which registers move onto the stack with the PUSHA instruction? &lt;br /&gt;17. Which registers move onto the stack with a PUS HAD instruction? &lt;br /&gt;18. Describe the operation of each of the following instructions: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) PUSHAX &lt;br /&gt;(b) POP ESI &lt;br /&gt;(c) PUSH [BX] &lt;br /&gt;(d) PUSHFD &lt;br /&gt;(e) POPDS &lt;br /&gt;(f) PUSHD4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. Explain what happens when the PUSH BX instruction executes. Make sure to show where &lt;br /&gt;BH and BL are stored. (Assume that SP = OlOOH and SS = 0200H.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. Repeat question 19 for the PUSH EAX instruction. &lt;br /&gt;21. The 16-bit POP instruction (except for POPA) increments SP by _____ _ &lt;br /&gt;22. What values appear in SP and SS if the stack is addressed at memory location 02200H? &lt;br /&gt;23. Compare the operation of a MOV DI,NUMB instruction with an LEA DI,NUMB instruction. &lt;br /&gt;24. What is the difference between an LEA SI,NUMB instruction and a MOV SI,OFFSET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NUMB instruction? &lt;br /&gt;25. Which is more efficient, a MOV with an OFFSET or an LEA instruction? &lt;br /&gt;26. Describe how the LDS BX,NUMB instruction operates. &lt;br /&gt;27. What is the difference between the LDS and LSS instructions? &lt;br /&gt;28. Develop a sequence of instructions that move the contents of data segment memory loca-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tions NUMB and NUMB+ 1 into BX, DX, and SI. &lt;br /&gt;29. What is the purpose of the direction flag? &lt;br /&gt;30. Which instructions set and clear the direction flag? &lt;br /&gt;31. The string instructions use DI and SI to address memory data in which memory segments? &lt;br /&gt;32. Explain the operation of the LODSB instruction. &lt;br /&gt;33. Explain the operation of the STOSW instruction. &lt;br /&gt;34. Explain the operation of the OUTSB instruction. &lt;br /&gt;35. What does the REP prefix accomplish and with what type of instruction is it used? &lt;br /&gt;36. Develop a sequence of instructions that copy 12 bytes of data from an area of memory ad-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;dressed by SOURCE into an area of memory addressed by DEST. &lt;br /&gt;37. Where is the I/O address (port number) stored for an INSB instruction? &lt;br /&gt;38. Select an assembly language instruction that exchanges the contents of the EBX register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;with the ESI register. &lt;br /&gt;39. Would the LAHF and SAHF instructions nOlmally appear in software? &lt;br /&gt;40. Explain how the XLA T instruction transforms the contents of the AL register. &lt;br /&gt;41. Write a short program that uses the XLAT instruction to convert the BCD numbers 0-9 into &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCII-coded numbers 30H-39H. Store the ASCII-coded data in a TABLE located within &lt;br /&gt;the data segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;42. Explain what the IN AL,12H instruction accomplishes. &lt;br /&gt;43. Explain how the OUT DX,AX instruction operates. &lt;br /&gt;44. What is a segment override prefix? &lt;br /&gt;45. Select an instruction that moves a byte of data from the memory location addressed by the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX register, in the extra segment, into the AH register. &lt;br /&gt;46. Develop a sequencc of instructions that exchange the contents of AX with BX, ECX with &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDX, and SI with DI. &lt;br /&gt;47. What is accomplished by the CMOVNE CX,DX instruction in the Pentium Pro micro-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;processor? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4-9 QUESTIONS AND PROBLEMS 143 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48. How is a CMOVNS ECX,EBX instruction encoded and stored in a program if the assembler &lt;br /&gt;does not recognize this new Pentium Pro instruction&amp;quot;? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;49. What is an asscmbly language directive? &lt;br /&gt;50. Describe the purpose of the following assembly language directives: DB, OW, and DO. &lt;br /&gt;51. Select al. assembly language directive that reserves 30 bytes of memory for array LIST I. &lt;br /&gt;52. Dcscribe thc purpose of the EQU directive. &lt;br /&gt;53. What is the purpose of the .386 directive? &lt;br /&gt;54. What is the purpose of the .MODEL directive? &lt;br /&gt;55. If the start of a segment is identified with .DAT A, what type of memory organization is in &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;effect? &lt;br /&gt;56. If the SEGMENT directive identifies the start of a segment, what type of memory organiza-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tion is in effect? &lt;br /&gt;57. What does the INT 21 H instruction accomplish if AH contains a 4CH? &lt;br /&gt;58. What directives indicate the start and end of a procedure? &lt;br /&gt;59. Explain the purpose of the USES statement as it applies to a procedure with version 6.X of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MASM. &lt;br /&gt;60. How is the 80486 microprocessor instructed to use the 16-bit instruction mode? &lt;br /&gt;61. Develop a near procedure that stores AL in four consecutive memory locations, within the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data segment, as addressed by the 01 register. &lt;br /&gt;62. Develop a far procedure that copies contents of the word-sized memory location CS:DATAI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;into AX, BX, CX, OX, and SI. &lt;br /&gt;63. Use the Internet to access the Borland web page and detail the information provided for &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TASM. &lt;br /&gt;64. Use the Internet to access the Zilog web page and list the microprocessor products. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;144 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 5 &lt;br /&gt;Arithmetic and Logic Instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this chapter, arithmetic and logic instructions are examined. Arithmetic instructions include &lt;br /&gt;addition, subtraction, multiplication, division, comparison, negation, increment, and decrement. &lt;br /&gt;Logic instructions include AND, OR, Exclusive-OR, NOT, shifts, rotates, and the logical com-&lt;br /&gt;pare (TEST). Also presented are the 80386 through the Pentium Pro instructions XADD, &lt;br /&gt;SHRD, SHLD, bit tests, and bit scans. The chapter concludes with a discussion of string &lt;br /&gt;comparison instructions, which are used for scanning tabular data and for comparing sections &lt;br /&gt;of memory data. Both tasks perform efficiently with the string scan (SCAS) and string compare &lt;br /&gt;(CMPS) instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If you are familiar with an 8-bit microprocessor, you will recognize that the 8086 through &lt;br /&gt;the Pentium Pro instruction set is superior to most 8-bit microprocessors because most of the in-&lt;br /&gt;structions have two operands instead of one. Even if this is your first microprocessor, you will &lt;br /&gt;quickly learn that it possesses a powerful and easy-to-use set of arithmetic and logic instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Use arithmetic and logic instructions to accomplish simple binary, BCD, and ASCII &lt;br /&gt;arithmetic. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Use AND, OR, and Exclusive-OR to accomplish binary bit manipulation. &lt;br /&gt;3. Use the shift and rotate instructions. &lt;br /&gt;4. Explain the operation of the 80386 through the Pentium Pro exchange and add, compare &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and exchange, double precision shift, bit test, and bit scan instructions. &lt;br /&gt;5. Check the contents of a table for a match with the string instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDITIO~~, SUBTRACTION, AND COMPARISON &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bulk of the arithmetic instructions found in any microprocessor include addition, subtrac-&lt;br /&gt;lion, and comparison. In this seclion addition, subtraction, and comparison instructions are illus-&lt;br /&gt;trated. Also shown are their use in manipulating register and memory data. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-1 ADDITION, SUBTRACTION, AND COMPARISON 145 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addition &lt;br /&gt;Addition (ADD) appears in many forms in the microprocessor. This section details the use of &lt;br /&gt;the ADD instruction for 8-, 16-, and 32-bit binary addition. Another form of addition, called add-&lt;br /&gt;with-carry, is introduced with the ADC instruction. Finally, the increment instruction (INC) is &lt;br /&gt;presented. Increment is a speciai type of addition that adds a one to a number. In Section 5-3, &lt;br /&gt;other fonns of addition are examined, such as BCD and ASCII. Also described is the XADD in-&lt;br /&gt;struction found in the 80486 through the Pentium Pro processors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 5-1 illustrates the addressing modes available to the ADD instruction. (These ad-&lt;br /&gt;dressing modes include almost all those mentioned in Chapter 3.) However, since there are over &lt;br /&gt;32,000 variations of the ADD instruction in the instruction set, it is impossible to list them all in &lt;br /&gt;this table. The only types of addition not allowed are memory-to-memory and segment register. &lt;br /&gt;The segment registers can only be moved, pushed, or popped. Note that as with all other instruc-&lt;br /&gt;tions, the 32-bit registers are only available with the 80386 through the Pentium Pro processors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register Addition. Example 5-1 shows a simple procedure that uses register addition to add the &lt;br /&gt;contents of several registers. In this example, the contents of AX, BX, CX, and DX are added to &lt;br /&gt;fonn a 16-bit result stored in the AX register. Here a procedure is used, because assembly lan-&lt;br /&gt;guage is procedure-oriented, as are most languages. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 03 c3 &lt;br /&gt;0002 03 Cl &lt;br /&gt;0004 03 C2 &lt;br /&gt;0006 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that sums AX, BX, CD, and DX; &lt;br /&gt;;the result is returned in AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AX,BX &lt;br /&gt;ADD AX,CX &lt;br /&gt;ADD AX,DX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever arithmetic and logic instructions execute, the contents of the flag register &lt;br /&gt;change. Note that the contents of the interrupt, trap, and other flags do not change due to arith-&lt;br /&gt;metic and logic instructions. Only the flags located in the rightmost 8 bits of the flag register and &lt;br /&gt;the overflow flag change. These rightmost flags denote the result of the arithmetic or logic oper-&lt;br /&gt;ation. Any ADD instruction modifies the contents of the sign, zero, carry, auxiliary carry, parity, &lt;br /&gt;and overflow flags. The flag bits never change for most of the data transfer instructions pre-&lt;br /&gt;sented in Chapter 4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Immediate Addition. Immediate addition is employed whenever constant or known data are &lt;br /&gt;added. An 8-bit immediate addition appears in Example 5-2. In this example, load DL is first &lt;br /&gt;loaded with a 12H by using an immediate move instruction. Next, a 33H is added to the 12H in &lt;br /&gt;DL using an immediate addition instruction. After the addition, the sum (45H) moves into reg-&lt;br /&gt;ister DL and the flags change as follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Z = 0 (result not zero) &lt;br /&gt;C = 0 (no carry) &lt;br /&gt;A = 0 (no half-carry) &lt;br /&gt;S = 0 (result positive) &lt;br /&gt;P = 0 (odd parity) &lt;br /&gt;0= 0 (no overflow) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;146 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-1 Addition instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDAL,BL &lt;br /&gt;ADDCX,DI &lt;br /&gt;ADD EBP,EAX &lt;br /&gt;ADD CL,44H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL = AL + BL &lt;br /&gt;CX= CX+ 01 &lt;br /&gt;EBP = EBP + EAX &lt;br /&gt;CL = CL+44H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD BX,245FH &lt;br /&gt;ADD EDX,12345H &lt;br /&gt;ADD [BX],AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX = BX + 245FH &lt;br /&gt;EDX = EDX + 00012345H &lt;br /&gt;AL adds to the contents of the data segment memory location address by BX with the &lt;br /&gt;sum stored in the same memory location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD CL,[BP] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,[EBX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD BX,[SI + 2] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDCL,TEMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The byte contents of the stack segment memory location addressed by BP add to CL &lt;br /&gt;with the sum stored in CL &lt;br /&gt;The byte contents of the data segment memory location address by EBX add to AL &lt;br /&gt;with the sum stored in AL &lt;br /&gt;The word contents of the data segment memory location addressed by the sum of SI &lt;br /&gt;plus 2 add to BX with the sum stored in BX &lt;br /&gt;The byte contents of the data segment memory location TEMP add to CL with the &lt;br /&gt;sum stored in CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD BX,TEMP[DI] The word contents of the data segment memory location addressed by TEMP plus 01 &lt;br /&gt;add to BX with the sum stored in BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD [BX + DI],DL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD BYTE PTR [01],3 &lt;br /&gt;ADD BX,[EAX + 2*ECX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DL adds to the contents of the data segment memory location addressed by BX plus &lt;br /&gt;01 with the sum stored in the same memory location &lt;br /&gt;A 3 adds to the byte contents of the data segment memory location addressed by 01 &lt;br /&gt;The word contents of the data segment memory location addressed by the sum of &lt;br /&gt;2 times ECX plus EAX add to BX with the sum stored in BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-2 &lt;br /&gt;0006 B2 12 MOV DL,12H &lt;br /&gt;0008 80 C2 33 ADD DL,33H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory-fo-register Addition. Suppose an application requires that memory data add to the AL &lt;br /&gt;register. Example 5-3 shows an example that adds two consecutive bytes of data, stored at the &lt;br /&gt;data segment offset locations NUMB and NUMB+ 1, to the AL register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BF 0000 R &lt;br /&gt;0003 BO 00 &lt;br /&gt;0005 02 05 &lt;br /&gt;0007 02 45 01 &lt;br /&gt;OOOA C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that sums data in locations NUMB and NUMB+l; &lt;br /&gt;;the result is returned in AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;ADD &lt;br /&gt;.p,.DD &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dr,OFFSET NUMB &lt;br /&gt;AL,O &lt;br /&gt;AL, [Dr] &lt;br /&gt;AL, [DI+1] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address NUMB &lt;br /&gt;;clear sum &lt;br /&gt;;add NUMB &lt;br /&gt;;add NUMB+l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Procedure SUMS first loads the destinalion index register CD I) with offset address NUMB. &lt;br /&gt;The DI register, used in this example, addresses data in the data segment beginning at memory &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-1 ADDITION, SUBTRACTION, AND COMPARISON 147 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;location NUMB. In most cases, loading the address inside of a procedure is poor programming &lt;br /&gt;practice. It is usually better to load the address outside of the procedure and then CALL the pro-&lt;br /&gt;cedure with the address in place. Next, the ADD AL,[DI] instruction adds the contents of &lt;br /&gt;memory location NUMB to AL. Note that AL is initialized to zero. This occurs because DI ad-&lt;br /&gt;dresses memory location NUMB, and the instructi,.,,, adds its contents to AL. Finally, the ADD &lt;br /&gt;AL,[DI+ I] instruction adds the contents of memory location NUMB plus one byte to the AL reg-&lt;br /&gt;ister. After both ADD instructions execute, the result appears in the AL register as the sum of the &lt;br /&gt;contents of NUMB plus the contents of NUMB+ 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Array Addition. Memory arrays are sequential lists of data. Suppose that an array of data &lt;br /&gt;(ARRAY) contains 10 bytes numbered from element 0 through element 9. Example 5-4 shows &lt;br /&gt;a procedure that adds the contents of array elements 3, 5, and 7. (The procedure and the array &lt;br /&gt;elements it adds are chosen to demonstrate the use of some of the addressing modes for the &lt;br /&gt;microprocessor.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This example first clears AL to zero so it can be used to accumulate the sum. Next, register &lt;br /&gt;SI is loaded with a 3 to initially address array element 3. The ADD AL,ARRA Y[SI] instruction &lt;br /&gt;adds the contents of array element 3 to the sum in AL. The instructions that follow add array el-&lt;br /&gt;ements 5 and 7 to the sum in AL using a 3 in SI plus a displacement of 2 to address element 5, &lt;br /&gt;and a displacement of 4 to address element 7. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BO 00 &lt;br /&gt;0002 BE 0003 &lt;br /&gt;0005 02 84 0002 R &lt;br /&gt;0009 02 84 0004 R &lt;br /&gt;OOOD 02 84 0006 R &lt;br /&gt;0011 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0012 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that sums ARRAY elements 3, 5, and 7Â· &lt;br /&gt;;the result is returned in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Note this procedure destroys the concents of S1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUM PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,O ;clear sum &lt;br /&gt;MOV S1,3 ; address element &lt;br /&gt;ADD AL,ARRAY[S1] ;add element 3 &lt;br /&gt;ADD AL,ARRAY[S1+2] ; add element &lt;br /&gt;ADD AL,ARRAY[S1+4] ;add element 7 &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUM ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that an array of data contains 16-bit numbers used to form a 16-bit sum in register &lt;br /&gt;AX. Example 5-5 shows a procedure written for the 80386 and above showing the scaled-index &lt;br /&gt;form of addressing to add elements 3, 5, and 7 of an area of memory called ARRAY. In this ex-&lt;br /&gt;ample, EBX is loaded with the address ARRAY, and ECX holds the array element number. Note &lt;br /&gt;how the scaling factor is used to multiply the contents of the ECX register by 2 to address words &lt;br /&gt;of data. Recall that words are two bytes long. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 661 BB &lt;br /&gt;0006 661 B9 &lt;br /&gt;OOOC 67&amp;amp; 8B &lt;br /&gt;0010 661 B9 &lt;br /&gt;0016 67&amp;amp; 03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that sums ARRAY elements 3, 5 and 7; &lt;br /&gt;;the result is returned in AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Note that the contents of registers EBX and ECX are &lt;br /&gt;;destroyed. &lt;br /&gt;SUM PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 R MOV EBX,OFFSET ARRAY ;address ARRAY &lt;br /&gt;00000003 MOV ECX,3 ;address element &lt;br /&gt;04 4B MOV AX, [EBX+2*ECX] ;get element 3 &lt;br /&gt;00000005 MOV ECX,5 ;address element &lt;br /&gt;04 4B ADD AX, [EBX+2*ECX] ;add element 5 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;148 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlA &lt;br /&gt;0020 &lt;br /&gt;0024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;66/ B9 00000007 &lt;br /&gt;67&amp;amp; 03 04 4B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;ADD &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECX,7 &lt;br /&gt;AX, [EBX+2*ECX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address element 7 &lt;br /&gt;;add element 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0025 SUM ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Increment Addition. Increment addition (INC) adds 1 to a register or a memory location. The &lt;br /&gt;INC instruction can add 1 to any register or memory location except a segment register. Table 5-2 &lt;br /&gt;illustrates some of the possible forms of the increment instruction available to the 8086-80486 &lt;br /&gt;and PentiumlPentium Pro processors. As with other instructions presented thus far, it is impos-&lt;br /&gt;sible to show all variations of the INC instruction because of the large number available. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;With indirect memory increments, the size of the data must be described using the BYTE &lt;br /&gt;PTR, WORD PTR, or DWORD PTR directives. The reason is that the assembler program cannot &lt;br /&gt;determine if, for example, the INC [01] instruction is a byte-, word-, or doubleword-sized incre-&lt;br /&gt;ment. The INC BYTE PTR [01] instruction clearly indicates byte-sized memory data; the INC &lt;br /&gt;WORD PTR [01] instruction unquestionably indicates word-sized memory data; and the INC &lt;br /&gt;DWORD PTR [DJ] instruction indicates doubleword-sized data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-6 shows how the procedure of Example 5-3 is modified to use the increment &lt;br /&gt;instruction for addressing NUMB and NUMB+ 1. Here, an INC DJ instruction changes the con-&lt;br /&gt;tents of register DJ from offset address NUMB to offset address NUMB+ 1. Both procedures &lt;br /&gt;shown in Examples 5-3 and 5-6 add the contents of NUMB and NUMB+ 1. The difference be-&lt;br /&gt;tween these programs is the way that this data's address is formed through the contents of the DJ &lt;br /&gt;register using the increment instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BF 0000 R &lt;br /&gt;0003 BO 00 &lt;br /&gt;0005 02 05 &lt;br /&gt;0007 47 &lt;br /&gt;0008 02 05 &lt;br /&gt;OOOA C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that sums NUMB and NUMB+l; &lt;br /&gt;;the result is returned in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Note that the contents of DI are destroyed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;ADD &lt;br /&gt;INC &lt;br /&gt;ADD &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DI,OFFSET NUMB &lt;br /&gt;AL,O &lt;br /&gt;AL, [DI] &lt;br /&gt;Dr &lt;br /&gt;AL, [Dr] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address NUMB &lt;br /&gt;;clear sum &lt;br /&gt;;add NUMB &lt;br /&gt;;address NUMB+l &lt;br /&gt;;add NUMB+l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-2 Increment instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INCBl &lt;br /&gt;INCSP &lt;br /&gt;INC EAX &lt;br /&gt;INC BYTE PTR [BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC WORD PTR [SI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC DWORD PTR [ECX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC DATA1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bl = Bl + 1 &lt;br /&gt;SP = SP + 1 &lt;br /&gt;EAX=EAX+1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Adds 1 to the byte contents of the data segment memory location &lt;br /&gt;addressed by BX &lt;br /&gt;Adds 1 to the word contents of the data segment memory location &lt;br /&gt;addressed by SI &lt;br /&gt;Adds 1 to the doubleword contents of the data segment memory &lt;br /&gt;location addressed by ECX &lt;br /&gt;Increments the contents of data segment memory location DAAT1 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-1 ADDITION, SUBTRACTION, AND COMPARISON 149 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-3 Add-with-carry instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC AL,AH &lt;br /&gt;ADC CX,BX &lt;br /&gt;ADC EBX,EDX &lt;br /&gt;ADCDH,[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC BX,[BP + 2] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC ECX,[EBXl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL = AL + AH + carry &lt;br /&gt;CX = CX + BX + carry &lt;br /&gt;EBX = EBX + EDX + carry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The byte contents of the data segment memory location addressed by &lt;br /&gt;BX add to DH with carry with the sum stored in DH &lt;br /&gt;The word contents of the stack segment memory location address by &lt;br /&gt;BP plus 2 add to BX with carry with the sum stored in BX &lt;br /&gt;The doubleword contents of the data segment memory location &lt;br /&gt;addressed by EBX add to ECX with carry with the sum stored in ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Increment instructions affect the flag bits, as do most other arithmetic and logic opera-&lt;br /&gt;tions. The difference is that increment instructions do not affect the carry flag bit. Carry doesn't &lt;br /&gt;change because we often use increments in programs that depend upon the contents of the carry &lt;br /&gt;flag. Note that increment is used to point to the next memory element in a byte-sized array &lt;br /&gt;of data only. If word-sized data are addressed, it is better to use an ADD DI,2 instruction &lt;br /&gt;to modify the DI pointer in place of two INC DI instructions. For doubleword arrays, use the &lt;br /&gt;ADD DI,4 instruction to modify the DI pointer. In some cases, the carry flag must be preserved, &lt;br /&gt;which may mean that two or four INC instructions might appear in a program to modify a &lt;br /&gt;pointer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addition-with-Carry. An addition-with-carry instruction (ADC) adds the bit in the carry flag (C) &lt;br /&gt;to the operand data. This instruction mainly appears in software that adds numbers that are wider &lt;br /&gt;than l6-bits in the 8086-80286 or wider than 32-bits in the 80386 through the Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 5-3 lists several add-with-carry instructions with comments that explain their oper-&lt;br /&gt;ations. Like the ADD instruction, ADC affects the flags after the addition. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose a program is written for the 8086-80286 to add the 32-bit number in BX and AX &lt;br /&gt;to the 32-bit number in DX and CX. Figure 5-1 illustrates this addition so the placement and &lt;br /&gt;function of carry flag can be understood. This addition cannot be easily performed without &lt;br /&gt;adding the carry flag bit because the 8086-80286 only adds 8- or l6-bit numbers. Example 5-7 &lt;br /&gt;shows how the addition occurs with a procedure. Here the contents of registers AX and CX add &lt;br /&gt;to form the least-significant l6-bits of the sum. This addition mayor may not generate a carry. &lt;br /&gt;A carry appears in the carry flag if the sum is greater than FFFFH. Because it is impossible to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-1 Additional-&lt;br /&gt;with-carry showing how the &lt;br /&gt;carry flag (C) links the two &lt;br /&gt;16-bit additions into one &lt;br /&gt;32-bit addition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(ADC) r &lt;br /&gt;BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ox &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(ADD) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I AX &lt;br /&gt;CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;150 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;predict a carry, the most-significant 16-bits of this addition are added with the carry flag using &lt;br /&gt;the ADC instruction. The ADC instruction adds the one or the zero in the carry flag to the most-&lt;br /&gt;significant 16-bits of the result. This program adds BX-AX to DX-CX with the sum appearing &lt;br /&gt;in BX-AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0002 &lt;br /&gt;0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0005 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03 Cl &lt;br /&gt;13 DA &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that sums BX-AX and DX-CX; &lt;br /&gt;;the result is returned in BX-AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUM32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUM32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD &lt;br /&gt;ADC &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX,CX &lt;br /&gt;BX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose the same procedure is rewritten for the 80386 through the Pentium Pro, but mod-&lt;br /&gt;ified to add two 64-bit numbers. The changes required for this operation are the use of the ex-&lt;br /&gt;tended registers to hold the data and modifications of the instructions for the 80386/804861 &lt;br /&gt;PentiumlPentium Pro microprocessors. These changes are shown in Example 5-8, which adds &lt;br /&gt;two 64-bit numbers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 661 03 C1 &lt;br /&gt;0003 661 13 DA &lt;br /&gt;0006 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that sums EBX-EAX and EDX-ECX; &lt;br /&gt;;the result is returned in EBX-EAX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUM64 PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD &lt;br /&gt;ADC &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUM64 ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX,ECX &lt;br /&gt;EBX,EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exchange and Add for the 80486-Pentium Pro Processors. A new type of addition called ex-&lt;br /&gt;challge and add (XADD) appears in the 80486 instruction set and continues through the Pentium &lt;br /&gt;Pro processor. The XADD instruction adds the source to the destination and stores the sum in the &lt;br /&gt;destination, as with any addition. The difference is that after the addition takes place, the original &lt;br /&gt;value of the destination is copied into the source operand. This is one of the few instructions that &lt;br /&gt;change the source. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, if BL = 12H and DL = 02H, and the XADD BL,DL instruction executes, the &lt;br /&gt;BL register contains the sum of 14H and DL becomes 12H. The sum of 14H is generated, and the &lt;br /&gt;original destination of l2H replaces the source. This instruction functions with any register size &lt;br /&gt;and any memory operand, just as with the ADD instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Subtraction &lt;br /&gt;Many forms of subtraction (SUB) appear in the instruction set. These forms use any addressing &lt;br /&gt;mode with 8-, 16-, or 32-bit data. A special form of subtraction (decrement or DEC) subtracts a &lt;br /&gt;I from any register or memory location. Section 5-3 shows how BCD and f.SCII data subtract. &lt;br /&gt;As with addition, numbers that are wider than 16-bits or 32-bits must occasionally be sub-&lt;br /&gt;tracted. The subtract-with-borrow instruction (SBB) performs this type of subtraction. In the &lt;br /&gt;80486 through the Pentium Pro processors, the instruction set also includes a compare and ex-&lt;br /&gt;change instruction. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-1 ADDITION, SUBTRACTION, AND COMPARISON 151 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-4 Subtraction instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB CL,BL &lt;br /&gt;SUB AX,SP &lt;br /&gt;SUB ECX,EBP &lt;br /&gt;SUB OH,6FH &lt;br /&gt;SUB AX,OCCCCH &lt;br /&gt;SUB ESI,2000300H &lt;br /&gt;SUB [OI],CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB CH,[BP] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AH,TEMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB OI,TEMP[ESI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB ECX,OATA1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CL = CL- BL &lt;br /&gt;AX=AX-SP &lt;br /&gt;ECX = ECX - EBP &lt;br /&gt;OH = OH - 6FH &lt;br /&gt;AX = AX - CCCCH &lt;br /&gt;ESI = ESI - 2000300H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Subtracts the contents of CH from the contents of the data segment &lt;br /&gt;memory location addressed by 01 &lt;br /&gt;Subtracts the byte contents of the stack segment memory location &lt;br /&gt;address by BP from CH &lt;br /&gt;Subtracts the byte contents of the data segment memory location &lt;br /&gt;TEMP from AH &lt;br /&gt;Subtracts the word contents of the data segment memory location &lt;br /&gt;addressed by TEMP plus ESI from 01 &lt;br /&gt;Subtracts the doubleword contents of the data segment memory &lt;br /&gt;location addressed by OATA1 from ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 5-4 lists some of the many addressing modes allowed with the subtraction instruc-&lt;br /&gt;tion. There are well over 1,000 possible subtraction instructions, far too many to list here. About &lt;br /&gt;the only types of subtraction not allowed are memory-to-memory and segment register subtrac-&lt;br /&gt;tions. Like other arithmetic instructions, the subtraction instruction affects the flag bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register Subtraction. Example 5-9 shows a sequence of instructions that perform register sub-&lt;br /&gt;traction. This example subtracts the 16-bit contents of registers CX and DX from the contents of &lt;br /&gt;register BX. After each subtraction, the microprocessor modifies the contents of the flag register. &lt;br /&gt;The flags change for most arithmetic and logic operations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-9 &lt;br /&gt;0000 2B D9 &lt;br /&gt;0002 2B DA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB BX,ex &lt;br /&gt;SUB BX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Immediate Subtraction. As with addition, the microprocessor also allows immediate operands &lt;br /&gt;for the subtraction of constant data. Example 5-10 presents a short sequence of instructions that &lt;br /&gt;subtract a 44H from a 22H. Here, we first load the 22H into CH using an immediate move in-&lt;br /&gt;struction. Next, the SUB instruction, using immediate data 44H, subtracts a 44H from the 22H. &lt;br /&gt;After the subtraction, the difference (DEH) moves into the CH register. The flags change as fol-&lt;br /&gt;lows for this subtraction: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Z = 0 (result not zero) &lt;br /&gt;C = 1 (borrow) &lt;br /&gt;A = 1 (half-borrow) &lt;br /&gt;S = I (result negative) &lt;br /&gt;P = 1 (even parity) &lt;br /&gt;o = 0 (no overflow) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;152 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-10 &lt;br /&gt;0000 B5-') &lt;br /&gt;0002 80 ED 44 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CH,22H &lt;br /&gt;SUB CH,44H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Both carry flags (C and A) hold borrows after a subtraction rather than carries, as after an &lt;br /&gt;addition. Notice in this example that there is no overflow. This example subtracted a 44H (+68) &lt;br /&gt;from a 22H (+34), resulting in a DEH (-34). Because the correct 8-bit signed result is a -34, &lt;br /&gt;there is no overflow in this example. An 8-bit overflow only occurs if the signed result is greater &lt;br /&gt;than +127 or less than -128. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Decrement Subtraction. Decrement subtraction (DEC) subtracts a 1 from a register or the con-&lt;br /&gt;tents of a memory location. Table 5-5 lists some decrement instructions that illustrate register &lt;br /&gt;and memory decrements. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The decrement indirect memory data instructions require BYTE PTR. WORD PTR, or &lt;br /&gt;DWORD PTR because the assembler cannot distinguish a byte from a word when an index reg-&lt;br /&gt;ister addresses memory. For example, DEC [SI] is vague, because the assembler cannot deter-&lt;br /&gt;mine if the location addressed by SI is a byte, word, or doubleword. Using DEC BYTE PTR &lt;br /&gt;[SI], DEC WORD PTR [DI), or DEC DWORD PTR [SI] reveals t~e size of the data to the &lt;br /&gt;assembler. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Subtract-with-Borrow. A subtraction-with-borrow (SBB) instruction functions as a regular sub-&lt;br /&gt;traction, except that the carry flag (C), which holds the borrow, also subtracts from the differ-&lt;br /&gt;ence. The most common use for this instruction is for subtractions that are wider than 16-bits in &lt;br /&gt;the 8086-80286 or wider than 32-bits in the 80386 through the PentiumPro. Wide subtractions &lt;br /&gt;require that borrows propagate through the subtraction just as wide additions propagate the &lt;br /&gt;carry. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 5-6 lists many SBB instructions with comments that define their operations. Like &lt;br /&gt;the SUB instruction, SBB affects the flags. Notice that the subtract from memory immediate in-&lt;br /&gt;struction in this table requires a BYTE PTR, WORD PTR, or DWORD PTR directive. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When the 32-bit number held in BX and AX is subtracted from the 32-bit number held in &lt;br /&gt;SI and DI, the carry flag propagates the borrow between the two 16-bit subtractions required to &lt;br /&gt;perform this operation in the microprocessor. Figure 5-2 shows how the borrow propagates &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-5 Decrement instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DECBH &lt;br /&gt;DECCX &lt;br /&gt;DEC EDX &lt;br /&gt;DEC BYTE PTR [DI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC WORD PTR[BP] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC DWORD PTR[EBX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC NUMB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BH = BH-1 &lt;br /&gt;CX= CX-1 &lt;br /&gt;EDX= EDX-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Subtracts 1 from the byte contents of the data segment memory &lt;br /&gt;location addressed by DI &lt;br /&gt;Subtracts 1 from the word contents of the stack segment memory &lt;br /&gt;location addressed by BP &lt;br /&gt;Subtracts 1 from the doubleword contents of the data segment &lt;br /&gt;memory location addressed by EBX &lt;br /&gt;Subtracts 1 from the contents of the data segment memory &lt;br /&gt;location NUMB &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-1 ADDITION, SUBTRACTION, AND COMPARISON 153 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-6 Subtract-with-borrow instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBBAH,Al &lt;br /&gt;SBB AX,BX &lt;br /&gt;SBB EAX,ECX &lt;br /&gt;SBB Cl,2 &lt;br /&gt;SBB BYTE PTR[01],3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB [OI],Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB OI,[BP + 2] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB Al,[EBX + ECX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH = AH - Al- carry &lt;br /&gt;AX = AX - BX - carry &lt;br /&gt;EAX = EAX - ECX - carry &lt;br /&gt;Cl = Cl- 2 - carry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Both a 3 and carry subtract from the contents of the data segment &lt;br /&gt;memory location addressed by 01 &lt;br /&gt;Both Al and carry subtract from the data segment memory location &lt;br /&gt;addressed by 01 &lt;br /&gt;Both carry and the word contents of the stack segment memory &lt;br /&gt;location addressed by the sum of BP and 2 subtract from DI &lt;br /&gt;Both carry and the byte contents of the data segment memory &lt;br /&gt;location addressed by the sum of EBX and ECX subtract from Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;through the carry flag (e) for this task. Example 5-11 shows how this subtraction is performed &lt;br /&gt;by a program. With wide subtraction, the least-significant 16- or 32-bit data are subtracted with &lt;br /&gt;the SUB instruction. All subsequent and more-significant data are subtracted using the SBB &lt;br /&gt;instruction. Examples 5-11 uses the SUB instruction to subtract DI from AX, then uses SBB to &lt;br /&gt;subtract-with-borrow SI from BX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-11 &lt;br /&gt;0004 2B C7 &lt;br /&gt;0006 lB DE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Comparison &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AX,D1 &lt;br /&gt;SBB BX,S1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The comparison instruction (eMP) is a subtraction that changes only the flag bits. A comparison &lt;br /&gt;is useful for checking the entire contents of a register or a memory location against another &lt;br /&gt;value. A eMP is normally followed by a conditional jump instruction, which tests the condition &lt;br /&gt;of the flag bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-2 Subtraction-&lt;br /&gt;with-borrow showing how the &lt;br /&gt;carry flag (C) propagates the &lt;br /&gt;borrow (SBB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 (SUB) &lt;br /&gt;I AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;154 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-7 Comparison instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP Cl,Bl &lt;br /&gt;CMPAX,SP &lt;br /&gt;CMP EBP,ESI &lt;br /&gt;CMP AX,2000H &lt;br /&gt;CMP [DI],CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP Cl,[BP] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPAH,TEMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP DI,TEMP[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP Al,[EDI + ESI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cl-Bl &lt;br /&gt;AX-SP &lt;br /&gt;EBP- ESI &lt;br /&gt;AX-2000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CH subtracts from the contents of the data segment memory location &lt;br /&gt;addressed by DI &lt;br /&gt;The byte contents of the stack segment memory location addressed &lt;br /&gt;by BP subtract from Cl &lt;br /&gt;The byte contents of the data segment memory location TEMP &lt;br /&gt;subtract from AH &lt;br /&gt;The word contents of the data segment memory location addressed &lt;br /&gt;by the sum of TEMP plus BX subtract from DI &lt;br /&gt;The byte contents of the data segment memory location addressed &lt;br /&gt;by the sum of EDI plus ESI subtract from Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 5-7 lists a variety of comparison instructions that use the same addressing modes as &lt;br /&gt;the addition and subtraction instructions already presented. Similarly, the only disallowed forms &lt;br /&gt;of comparison are memory-to-memory and segment register compares. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-12 shows a comparison followed by a conditional jump instruction. In this ex-&lt;br /&gt;ample, the contents of AL are compared with a 1OH. Conditional jump instructions that often &lt;br /&gt;follow the comparison are JA (jump above) or JB (jump below). If the JA follows the compar-&lt;br /&gt;ison, the jump occurs if the value in AL is above 10H. If the JB follows the comparison, the jump &lt;br /&gt;occurs if the value in AL is below lOH. In this example, the JAE instruction follows the com-&lt;br /&gt;parison. This instruction causes the program to continue at memory location SUBER if the value &lt;br /&gt;in AL is 10H or above. There is also a JBE (jump below or equal) instruction that could follow &lt;br /&gt;the comparison to jump if the outcome is below or equal to lOH. Chapter 6 provides more detail &lt;br /&gt;on the comparison and conditional jump instructions. &lt;br /&gt;EXAMPLE 5-12 &lt;br /&gt;0000 3C 10 &lt;br /&gt;0002 73 1C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP AL.10H &lt;br /&gt;JAE SUBER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;compare with 10H &lt;br /&gt;;if 10H or above &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Compare and Exchange (804861PentiumiPentium Pro Processors Only). The compare and ex-&lt;br /&gt;change instruction (CMPXCHG) found only in the 80486 through the Pentium Pro instruction &lt;br /&gt;sets compares the destination operand with the accumulator. If they are equal, the source &lt;br /&gt;operand is copied into the destination. If they are not equal, the destination operand is copied into &lt;br /&gt;the accumulator. This instruction functions with 8-, 16-, or 32-bit data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CMPXCHG CX,DX instruction is an example of the compare and exchange instruc-&lt;br /&gt;tion. This instruction first compares the contents of CX with AX. If CX equals AX, DX is copied &lt;br /&gt;into AX. If CX is not equal to AX, CX is copied into AX. This instruction also compares AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. with 8-bit data and EAX with 32-bit data if the operands are either 8- or 32-bit. &lt;br /&gt;In the Pentium and Pentium Pro processors, a CMPXCHG8B instruction is available that &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;compares two quadwords. In fact this is the only new data manipulation instruction provided to &lt;br /&gt;the Pentium/Pentium Pro when compared with prior versions of the microprocessor. The com-&lt;br /&gt;pare-and-exchange-8-bytes instruction compares the 64-bit value located in EDX:EAX with a &lt;br /&gt;64-bit number located in memory. An example is CMPXCHG8B TEMP. If TEMP equals &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-2 MULTIPLICATION AND DIVISION 155 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDX:EAX, TEMP is replaced with the value found in ECX:EBX. If TEMP does not equal &lt;br /&gt;EDX:EAX, then the number found in TEMP is loaded into EDX:EAX. The zero flag bit indi-&lt;br /&gt;cates that the values are equal after the comparison. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MULTIPLICATION AND DIViSION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Only modem microprocessors contain multiplication and division instructions. Earlier 8-bit mi-&lt;br /&gt;croprocessors could not multiply or divide without the use of a program that multiplied or di-&lt;br /&gt;vided by using a series of shifts and additions or subtractions. Because microprocessor &lt;br /&gt;manufacturers were aware of this inadequacy, they incorporated multiplication and division in-&lt;br /&gt;structions into the instruction sets of the newer microprocessors. In fact, the Pentium and Pen-&lt;br /&gt;tium Pro processors contain special circuitry that performs a multiplication in as little as one &lt;br /&gt;clocking period, whereas it takes over 40 clocking periods to perform the same multiplication in &lt;br /&gt;earlier Intel microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Multiplication &lt;br /&gt;Multiplication is performed on bytes, words, or doublewords and can be signed integer (IMUL) or &lt;br /&gt;unsigned (MUL). Note that only the 80386 through the Pentium Pro processors multiply 32-bit &lt;br /&gt;doublewords. The product after a mUltiplication is always a double-width product. If two 8-bit &lt;br /&gt;numbers are multiplied, they generate a 16-bit product; if two 16-bit numbers are multiplied, they &lt;br /&gt;generate a 32-bit product; and if two 32-bit numbers are multiplied, a 64-bit product is generated. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Some flag bits (0 and C) change when the multiplication instruction executes and produce &lt;br /&gt;predictable outcomes. The other flags also change, but their results are unpredictable and there-&lt;br /&gt;fore are unused. In an 8-bit multiplication, if the most-significant 8-bits of the result are 0, both &lt;br /&gt;the C and 0 flag bits equal O. These flag bits show that the result is 8-bits wide (C = 0) or 16-bits &lt;br /&gt;wide (C = 1). In a 16-bit multiplication, if the most-significant 16-bits of the product are 0, both &lt;br /&gt;C and 0 clear to O. In a 32-bit multiplication, both C and 0 indicate that the most-significant 32-&lt;br /&gt;bits of the product are zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bit Multiplication. With 8-bit multiplication, whether signed or unsigned, the multiplicand is &lt;br /&gt;always in the AL register. The multiplier can be any 8-bit register or any memory location. Imme-&lt;br /&gt;diate multiplication is not allowed unless the special signed immediate multiplication instruction, &lt;br /&gt;discussed later in this section, appears in a program. The multiplication instruction contains one &lt;br /&gt;operand because it always multiplies the operand times the contents of register AL. An example &lt;br /&gt;is the MUL BL instruction, which multiplies the unsigned contents of AL by the unsigned con-&lt;br /&gt;tents of BL. After the multiplication, the unsigned product is placed in AX-a double-width &lt;br /&gt;product. Table 5-8 illustrates some 8-bit multiplication instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-8 8-bit multiplication instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MULCL &lt;br /&gt;IMUL DH &lt;br /&gt;IMUL BYTE PTR[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MULTEMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL is multiplied by CL; the unsigned product is in AX &lt;br /&gt;AL is multiplied by DH; the signed product is in AX &lt;br /&gt;AL is multiplied by the byte contents of the data segment memory &lt;br /&gt;location addressed by BX; the signed product is in AX &lt;br /&gt;AL is multiplied by the byte contents of the data segment memory &lt;br /&gt;location addressed by TEMP; the unsigned product is in AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;156 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that BL and CL each contain two 8-bit unsigned numbers, and these numbers &lt;br /&gt;must be mUltiplied to form a 16-bit product stored in DX. This procedure cannot be accom-&lt;br /&gt;plished by a single instruction, because we can only multiply a number times the AL register for &lt;br /&gt;an 8-bit multiplication. Example 5-13 shows a short program that generates DX = BL x CL. This &lt;br /&gt;example loads register BL and CL with example data 5 and 10. The product, a 50, mqves into &lt;br /&gt;DX from AX after the multiplication by using the MOV DX,AX instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-13 &lt;br /&gt;0000 B3 05 MOV BL,5 ;load data &lt;br /&gt;0002 Bl OA MOV CL,lO &lt;br /&gt;0604 8A Cl MOV AL,CL ;position data &lt;br /&gt;0006 F6 E3 MUL BL ;multiply &lt;br /&gt;0008 8B DO MOV DX,AX ;position product &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For signed multiplication, the product is in true binary form, if positive, and in two's com-&lt;br /&gt;plement form, if negative. These are the same forms used to store all positive and negative &lt;br /&gt;signed numbers used by the microprocessor. If the program of Example 5-13 multiplies two &lt;br /&gt;signed numbers, only the MUL instruction is changed to IMUL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-bit Multiplication. Word multiplication is very similar to byte multiplication. The difference &lt;br /&gt;is that AX contains the multiplicand instead of AL and the product appears in DX-AX instead of &lt;br /&gt;AX. The DX register always contains the most-significant 16-bits of the product, and AX the &lt;br /&gt;least-significant 16-bits. As with 8-bit multiplication, the choice of the multiplier is up to the pro-&lt;br /&gt;grammer. Table 5-9 shows several different 16-bit multiplication instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A Special Immediate 16-bit Multiplication. The 8086/8088 microprocessors could not perform &lt;br /&gt;immediate multiplication, but the 80186 through the Pentium Pro processors can by using a spe-&lt;br /&gt;cial version of the multiplication instruction. Immediate multiplication must be signed multipli-&lt;br /&gt;cation, and the instruction format is different because it contains three operands. The first &lt;br /&gt;operand is the 16-bit destination register; the second operand is a register or memory location &lt;br /&gt;that contains the 16-bit multiplicand; and the third operand is either an 8-bit or 16-bit immediate &lt;br /&gt;data used as the multiplier. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The IMUL CX,DX,12H instruction multiplies 12H times DX and leaves a 16-bit signed &lt;br /&gt;product in CX. If the immediate data are 8-bits, they sign-extend into a 16-bit number before the &lt;br /&gt;multiplication occurs. Another example is IMUL BX,NUMBER,IOOOH, which mUltiplies &lt;br /&gt;NUMBER times 1000H and leaves the product in BX. Both the destination and multiplicand must &lt;br /&gt;be 16-bit numbers. Although this is immediate multiplication, the restrictions placed upon it limit &lt;br /&gt;its utility, especially the fact that it is a signed multiplication and the product is l6-bits wide. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32-bit Multiplication. In the 80386 and above, 32-bit multiplication is allowed because these mi-&lt;br /&gt;croprocessors contain 32-bit registers. As with 8- and 16-bit multiplication, 32-bit multiplication &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-9 16-bit multiplication instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MULCX &lt;br /&gt;IMULOI &lt;br /&gt;MUL WORD PTR[81] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX is multiplied by CX; the unsigned product is in OX-AX &lt;br /&gt;AX is multiplied by 01; the signed product is in OX-AX &lt;br /&gt;AX is multiplied by the word contents of the data segment memory &lt;br /&gt;location addressed by 81; the unsigned product is in OX-AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-2 MULTIPLICATION AND DIVISION 157 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-10 32-bit multiplication instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MULECX &lt;br /&gt;IMUL EDI &lt;br /&gt;MUL DWORD PTR[ECX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX is multiplied by ECX; the unsigned product is in EDX-EAX &lt;br /&gt;EAX is multiplied by EDI; the signed product is in EDX-EAX &lt;br /&gt;EAX is multiplied by the doubleword contents of the data &lt;br /&gt;segment memory location addressed by ECX; the unsigned &lt;br /&gt;product is in EDX-EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;can be signed or unsigned by using the IMUL and MUL instructions. With 32-bit multiplication, &lt;br /&gt;the contents of EAX are multiplied by the operand specified with the instruction. The product &lt;br /&gt;(64-bits wide) is found in EDX-EAX where EAX contains the least-significant 32-bits of the &lt;br /&gt;product. Table 5-10 lists some of the 32-bit multiplication instructions found in the 80386 and &lt;br /&gt;above instruction set. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Division &lt;br /&gt;As with mUltiplication, division occurs on 8- or 16-bit numbers and also 32-bit numbers in the &lt;br /&gt;80386 through the Pentium Pro. These numbers are signed (IDIV) or unsigned (DlV) integers. &lt;br /&gt;The dividend is always a double-width dividend that is divided by the operand. This means that &lt;br /&gt;an 8-bit division divides a 16-bit number by an 8-bit number; a 16-bit division divides a 32-bit &lt;br /&gt;number by a 16-bit number; and a 32-bit division divides a 64-bit number by a 32-bit number. &lt;br /&gt;There is no immediate division instruction available to any microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;None of the flag bits change predictably for a division. A division can result in two dif-&lt;br /&gt;ferent types of errors. One of these is an attempt to divide by zero; the other is a divide over-&lt;br /&gt;flow. A divide overflow occurs when a small number divides into a large number. For &lt;br /&gt;example, suppose that AX = 3,000 and that it is divided by 2. Because the quotient for an &lt;br /&gt;8-bit division appears in AL, the result of 1,500 causes a divide overflow because the 1,500 &lt;br /&gt;does not fit into AL. In both cases, the microprocessor generates an interrupt if a divide error &lt;br /&gt;occurs. In most cases, a divide-error-interrupt displays an error message on the video screen. &lt;br /&gt;The divide-error-interrupt and all other interrupts for the microprocessor are explained in &lt;br /&gt;Chapter 6. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bit Division. An 8-bit division uses the AX register to store the dividend that is divided by &lt;br /&gt;the contents of any 8-bit register or memory location. The quotient moves into AL after the divi-&lt;br /&gt;sion with AH containing a whole number remainder. For a signed division, the quotient is posi-&lt;br /&gt;tive or negative; the remainder always assumes the sign of the dividend and is always an integer. &lt;br /&gt;For example, if AX = 0010H (+16) and BL = FDH (-3) and the IDIV BL instruction executes, &lt;br /&gt;AX = 0IFBH. This represents a quotient of -5 (AL) with a remainder of 1 (AH). If, on the other &lt;br /&gt;hand, a -16 is divided by a +3, the result will be a quotient of -5 (AL) with a remainder of-l &lt;br /&gt;(AH). Table 5-11 lists some 8-bit division instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;With 8-bit division, the numbers are usually 8-bits wide. This means that one of them, the &lt;br /&gt;dividend, must be converted to a 16-bit wide number in AX. This is accomplished differently for &lt;br /&gt;signed and unsigned numbers. For unsigned numbers, the most-significant 8-bits must be cleared &lt;br /&gt;to zero (zero-extended). The MOVZX instruction described in Chapter 4 can be used to zero-&lt;br /&gt;extend a number in the 80386 through the Pentium Pro. For signed numbers, the least-significant &lt;br /&gt;8-bits are sign-extended into the most significant 8-bits. A special instruction sign-extends &lt;br /&gt;AL into AH, or converts an 8-bit signed number in AL into a 16-bit signed number in AX. The &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;158 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-11 a-bit division instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OIVCL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IOIVBL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OIV BYTE PTR[BP] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX is divided by CL; the unsigned quotient is in AL and the remainder &lt;br /&gt;is in AH &lt;br /&gt;AX is divided by BL; the signed quotient is in AL and the remainder is &lt;br /&gt;inAH &lt;br /&gt;AX is divided by the byte contents of the stack segment memor &lt;br /&gt;location addressed by BP; the unsigned quotient is in AL and the &lt;br /&gt;remainder is in AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CBW (convert byte to word) instruction performs this conversion. In the 80386 through the &lt;br /&gt;Pentium Pro, a MOVSX instruction (see Chapter 4) sign-extends a number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-14 illustrates a short program that divides the unsigned byte contents of &lt;br /&gt;memory location NUMB by the unsigned contents of memory location NUMB I. Here the quo-&lt;br /&gt;tient is stored in location ANSQ and the remainder in location ANSR. Notice how the contents &lt;br /&gt;of location NUMB are retrieved from memory and then zero-extended to form a 16-bit unsigned &lt;br /&gt;number for the dividend. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-14 &lt;br /&gt;0000 AD 0000 R MOV AL,NUMB ;get NUMB &lt;br /&gt;0003 B4 00 MOV AH,O ; zero-extend &lt;br /&gt;0005 F6 36 0002 R DIV NUMBl ;divide by NUMBl &lt;br /&gt;0009 A2 0003 R MOV ANSQ,AL ;save quotient &lt;br /&gt;OOOC 88 26 0004 R MOV ANSR,AH ;save remainder &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-15 shows the same basic program, except that the numbers are signed num-&lt;br /&gt;bers. This means that instead of zero-extending AL into AH, it is sign-extended with the CBW &lt;br /&gt;instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-15 &lt;br /&gt;0000 AD 0000 R MOV AL,NUMB ;get NUMB &lt;br /&gt;0003 98 CBW ; sign-extend &lt;br /&gt;0004 F6 3E 0002 R IDIV NUMB 1 ;divide by NUMBl &lt;br /&gt;0008 A2 0003 R MOV ANSQ,AL ;save quotient &lt;br /&gt;OOOB 88 26 0004 R MOV ANSR,AH ;save remainder &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-bit Division. Sixteen-bit division is similar to 8-bit division except that instead of dividing &lt;br /&gt;into AX, the 16-bit number is divided into DX-AX, a 32-bit dividend. The quotient appears in AX &lt;br /&gt;and the remainder in DX after a 16-bit division. Table 5-12 lists some 16-bit division instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-12 16-bit division instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OIVCX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IOIV 81 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OIV NUMB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OX-AX is divided by CX; the unsigned quotient is in AX and the &lt;br /&gt;rem, &amp;quot;nder is in OX &lt;br /&gt;OX-AX is divided by 81; the signed quotient is in AX and the remainder &lt;br /&gt;is in OX &lt;br /&gt;AX is divided by the contents of the data segment memory location &lt;br /&gt;NUMB; the unsigned quotient is in AX and the reminder is in OX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-2 MULTIPLICATION AND DIVISION 159 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with 8-bit division, numbers must often be converted to the proper form for the divi-&lt;br /&gt;dend. If a 16-bit unsigned number is placed in AX, then DX must be cleared to O. In the 80386 &lt;br /&gt;and above, the number is zero-extended using the MOVZX instruction. If AX is a 16-bit signed &lt;br /&gt;number, the CWO (convert word to doubleword) instruction sign-extends it into a signed 32-&lt;br /&gt;bit number. If the 80386 and above is av,,;lable. the MOVSX instruction can also be used to sign-&lt;br /&gt;extend a number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-16 shows the division of two 16-bit signed numbers. Here a -100 in AX is di-&lt;br /&gt;vided by a +9 in CX. The CWO instruction converts the -100 in AX to a -100 in OX-AX before &lt;br /&gt;the division. After the division, the results appear in OX-AX as a quotient of -II in AX and a re-&lt;br /&gt;mainder of -1 in OX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-16 &lt;br /&gt;0000 B8 FF9C MOV AX,-lOG ;load -100 &lt;br /&gt;0003 B9 0009 MOV CX,9 ;load +9 &lt;br /&gt;0006 99 CWO ; sign-extend &lt;br /&gt;0007 F7 F9 IDIV CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32-bit Division. The 80386 through the Pentium Pro processors perform 32-bit division on &lt;br /&gt;signed or unsigned numbers. The 64-bit contents of EOX-EAX are divided by the operand spec-&lt;br /&gt;ified by the instruction, leaving a 32-bit quotient in EAX and a 32-bit remainder in EOX. Other &lt;br /&gt;than the size of the registers, this instruction functions in the same manner as the 8- and 16-bit di-&lt;br /&gt;visions. Table 5-13 shows some 32-bit division instructions. The COQ (convert doubleword to &lt;br /&gt;quadword) instruction is used before a signed division to convert the 32-bit contents of EAX &lt;br /&gt;into a 64-bit signed number in EOX-EAX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Remainder. What is done with the remainder after a division? There are a few possible &lt;br /&gt;choices. The remainder could be used to round the result or dropped to truncate the result. If the di-&lt;br /&gt;vision is unsigned, rounding requires that the remainder be compared with half the divisor to decide &lt;br /&gt;whether to round up the quotient. The remainder could also be converted to a fractional remainder. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-17 shows a sequence of instructions that divide AX by BL and round the re-&lt;br /&gt;sult. This program doubles the remainder before comparing it with BL to decide whether or not &lt;br /&gt;to round the quotient. Here, an INC instruction rounds the contents of AL after the comparison. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-17 &lt;br /&gt;0000 F6 F3 DIV &lt;br /&gt;0002 02 E4 ADD &lt;br /&gt;0004 3A E3 CMP &lt;br /&gt;0006 72 02 JB &lt;br /&gt;0008 FE CO INC &lt;br /&gt;OOOA NEXT: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BL &lt;br /&gt;AH,AH &lt;br /&gt;AH,BL &lt;br /&gt;NEXT &lt;br /&gt;AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;divide &lt;br /&gt;;double remainder &lt;br /&gt;;test for rounding &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; round &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-13 32-bit division instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIV ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIV DATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IDIV DWORD PTR[EDI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDX-EAX is divided by ECX; the unsigned quotient is in EAX and &lt;br /&gt;the remainder is in EDX &lt;br /&gt;EDX-EAX is divided by the doublewor j contents of data segment &lt;br /&gt;memory location DATA2; the unsigned quotient is in EAX and the &lt;br /&gt;remainder is in EDX &lt;br /&gt;EDX-EAX is divided by the doubleword contents of the data &lt;br /&gt;segment memory location addressed by EDI, the signed quotient &lt;br /&gt;is in EAX and the remainder is in EAX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;160 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a fractional remainder is required instead of an integer remainder. A fractional &lt;br /&gt;remainder is obtained by saving the quotient. Next, the AL register is cleared to zero. The number &lt;br /&gt;remaining in AX is now divided by the original operand to generate a fractional remainder. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-18 shows how a 13 is divided by a 2. The 8-bit quotient is saved in memory lo-&lt;br /&gt;cation ANSQ and then AL is cleared. Next, the contents of AX are again divided by 2 to generate &lt;br /&gt;a fractional remainder. After the division, the AL register equals an 80H. This is a 10000000,. If &lt;br /&gt;the binary point (radix) is placed before the leftmost bit of AL, the fractional remainder in Ai.. is &lt;br /&gt;0.100000002 or 0.5 decimal. The remainder is saved in memory location ANSR in this example. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-18 &lt;br /&gt;0000 B8 DODD MOV AX, 13 ;load 13 &lt;br /&gt;0003 B3 02 MOV BL,2 ;load 2 &lt;br /&gt;0005 F6 F3 DIV BL ; 13/2 &lt;br /&gt;0007 A2 0003 R MOV l'_&amp;quot;lSQ, AL ;save quotient &lt;br /&gt;OOOA BO 00 MOV AL,O ;clear AL &lt;br /&gt;oooe F6 F3 DIV BL ;generate remainder &lt;br /&gt;OOOE A2 0004 R MOV ANSR,AL ;save remainder &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BCD AND ASCII ARITHMETIC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The microprocessor allows arithmetic manipulation of both binary-coded decimal (BCD) and &lt;br /&gt;American Standard Code for Information Interchange (ASCII) data. This is accomplished by in-&lt;br /&gt;structions that adjust the numbers for BCD and ASCII arithmetic. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The BCD operations occur in systems such as point-of-sales terminals (e.g., cash registers) &lt;br /&gt;and others that seldom require arithmetic. The ASCII operations are performed on ASCII data &lt;br /&gt;used by many programs. In many cases, BCD or ASCII arithmetic is rarely used today. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BCD Arithmetic &lt;br /&gt;Two arithmetic techniques operate with BCD data: addition and subtraction. The instruction set &lt;br /&gt;provides two instructions that correct the result of a BCD addition and a BCD subtraction. The &lt;br /&gt;DAA (decimal adjust after addition) instruction follows BCD addition, and the DAS (decimal &lt;br /&gt;adjust after subtraction) instruction follows BCD subtraction. Both instructions correct the re-&lt;br /&gt;sult of the addition or subtraction so it is a BCD number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For BCD data, the numbers always appear in the packed BCD form and are stored as two &lt;br /&gt;BCD digits per byte. The adjust instructions only function with the AL register after BCD addi-&lt;br /&gt;tion and subtraction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAA Instruction. The DAA instruction follows the ADD or ADC instruction to adjust the result &lt;br /&gt;into a BCD result. Suppose that DX and BX each contain 4-digit packed BCD numbers. Ex-&lt;br /&gt;ample 5-19 provides a short sample program that adds the BCD numbers in DX and BX and &lt;br /&gt;stores the result in CX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-19 &lt;br /&gt;0000 BA 1234 MOV DX,1234H ;load 1,234 &lt;br /&gt;0003 BB 3099 MOV BX,3099H ;load 3,099 &lt;br /&gt;0006 8A e3 NOV AL,BL ;sum BL with DL &lt;br /&gt;0008 02 C2 ADD AL,DL &lt;br /&gt;OOOA 27 DAA ;adjust &lt;br /&gt;OOOE SA C8 NOV CL,AL ;answer to CL &lt;br /&gt;DODD 8A e7 MOV AL,BH ;sum BH, DH, and carr-I &lt;br /&gt;OOOF 12 e6 ADC AL,DH &lt;br /&gt;0011 27 DAA ;adjust &lt;br /&gt;0012 8A E8 MOV CH,AL ;answer to CH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-3 BCD AND ASCII ARITHMETIC 161 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the DAA instruction only functions with the AL register, this addition must occur &lt;br /&gt;8-bits at a time. After adding the BL and DL registers, the result is adjusted with a DAA instruc-&lt;br /&gt;tion before being stored in CL. Next, add BH and DH registers with carry and the result again is &lt;br /&gt;adjusted with DAA before being stored in CH. In this example, a 1,234 adds to a 3,099 to generate &lt;br /&gt;a sum of 4,333 that moves into CX after the additil)ll. Note that 1234 BCD is the same as 1234H. &lt;br /&gt;DAS Instruction. The DAS instruction functions as does the DAA instruction, except that it fol-&lt;br /&gt;lows a subtraction instead of an addition. Example 5-20 is basically the same as Example 5-19, &lt;br /&gt;except that it subtracts instead of adds DX and BX. The main difference in these programs is that &lt;br /&gt;the DAA instructions change to DAS and the ADD and ADC instructions change to SUB and &lt;br /&gt;SBB instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-20 &lt;br /&gt;0000 BA 1234 MOV OX,1234E ;load 1,234 &lt;br /&gt;0003 BB 3099 NOV BX,309% ;load 3,099 &lt;br /&gt;0006 8A C3 MOV AL,BL ;subtract OL from BL &lt;br /&gt;0008 2A C2 SUB AL,DL &lt;br /&gt;OOOA 2F OAS ;adjust &lt;br /&gt;OOOB 8A C8 MOV CL,AL ;answer to CL &lt;br /&gt;0000 8A C7 NOV AL,BH ;subtract OH &lt;br /&gt;OOOF 1A C6 SBB AL,OH &lt;br /&gt;0011 2F OAS ;adjust &lt;br /&gt;0012 8A E8 NOV CH,AL ; answer to CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCII Arithmetic &lt;br /&gt;The ASCII arithmetic instructions function with ASCII-coded numbers. These numbers range in &lt;br /&gt;value from 30H to 39H for the numbers 0-9. There are four instructions used with ASCII arith-&lt;br /&gt;metic operations: AAA (ASCII adjust after addition), AAD (ASCII adjust before division), &lt;br /&gt;AAM (ASCII adjust after multiplication), and AAS (ASCII adjust after subtraction). These &lt;br /&gt;instructions use register AX as the source and as the destination. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAA Instruction. The addition of two I-digit ASCII -coded numbers will not result in any useful &lt;br /&gt;data. For example, if 3lH and 39H are added, the result is 6AH. This ASCII addition (I + 9) &lt;br /&gt;should produce a 2-digit ASCII result equivalent to a 10 decimal, which is a 3lH and a 30H in &lt;br /&gt;ASCII code. If the AAA instruction is executed after this addition, the AX register will contain a &lt;br /&gt;0100H. Although this is not ASCII code, it can be converted to ASCII code by adding 3030H, &lt;br /&gt;which generates 3l30H. The AAA instruction clears AH if the result is less than 10, and adds a &lt;br /&gt;1 to AH if the result is greater than 10. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-21 shows how ASCII addition functions in the microprocessor. Please note &lt;br /&gt;that AH is cleared before the addition by using the MOV AX,31H instruction. The operand of &lt;br /&gt;0031H places a OOH in AH and a 31H into AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-21 &lt;br /&gt;0000 B8 0031 MOV AX,31H ; load ASCII 1 &lt;br /&gt;0003 04 39 ADD AL,39H ;add ASCII 9 &lt;br /&gt;0005 37 AAA ;adjust &lt;br /&gt;0006 05 3030 ADD AX,3030H ;answer to ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAD Instruction. Unlike all the other adjust instructions, the AAD instruction appears before a &lt;br /&gt;division. The AAD instruction requires that the AX register contain a 2-digit unpacked BCD &lt;br /&gt;number (not ASCII) before executing. After adjusting the AX register with AAD, it is divided by &lt;br /&gt;an unpacked BCD number to generate a single-digit result in AL with any remainder in AH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-22 illustrates how a 72 in unpacked BCD is divided by 9 to produce a quotient &lt;br /&gt;of 8. The 0702H loaded into the AX register is adjusted by the AAD instruction to 0048H. Notice &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;162 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;that this converts a 2-digit unpacked BCD number into a binary number so it can be divided with &lt;br /&gt;the binary division instruction (DIY). The AAD instruction converts the.unpacked BCD num-&lt;br /&gt;bers between 00 and 99 into binary. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-22 &lt;br /&gt;0000 B3 09 MOV BL,9 ; load di '.&amp;quot;isor &lt;br /&gt;0002 B8 0702 MOV AX,0702H ;load dividend &lt;br /&gt;0005 D5 OA AAD ;adjust &lt;br /&gt;0007 F6 F3 DIV BL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAM Instruction. The AAM instruction follows the multiplication instruction after mUltiplying &lt;br /&gt;two I-digit unpacked BCD numbers. Example 5-23 shows a short program that multiplies 5 &lt;br /&gt;times 5. The result after the mUltiplication is OOI9H in the AX register. After adjusting the result &lt;br /&gt;with the AAM instruction, AX contains a 0205H. This is an unpacked BCD result of 25. If &lt;br /&gt;3030H adds to 0205H, this becomes an ASCII result of 3235H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-23 &lt;br /&gt;0000 BO 05 MOV AL,5 ;load multiplicand &lt;br /&gt;0002 Bl 05 MOV CL,5 ;load multiplier &lt;br /&gt;0004 F6 El MUL CL &lt;br /&gt;0006 D4 OA AAM ;adjust &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The AAM instruction accomplishes this conversion by dividing AX by 10. The remainder &lt;br /&gt;is found in AL and the quotient is in AH. It has been noted that the second byte of the instruction &lt;br /&gt;contains a OAH. If the OAH is changed to another value, AAM divides by the new value. For ex-&lt;br /&gt;ample, if the second byte is changed to a OBH, the AAM instruction divides by an 11. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;One side benefit of the AAM instruction is that AAM converts from binary to unpacked &lt;br /&gt;BCD. If a binary number between OOOOH and 0063H appears in the AX register, the AAM in-&lt;br /&gt;struction converts it to BCD. For example, if AX contains a 0060H before AAM, it will contain &lt;br /&gt;a 0906H after AAM executes. This is the unpacked BCD equivalent of 96 decimal. If 3030H is &lt;br /&gt;added to 0906H, the result changes to ASCII code. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-24 shows how the 16-bit binary contents of AX are converted to a 4-digit &lt;br /&gt;ASCII character string by using division and the AAM instruction. Note that this works for num-&lt;br /&gt;bers between 0 and 9,999. First, DX is cleared and then DX-AX is divided by 100. For example, &lt;br /&gt;if AX = 24510 after the division, then AX = 2 and DX = 45. These separate halves are converted &lt;br /&gt;to BCD using AAM and then a 3030H is added to convert to ASCII code. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-24 &lt;br /&gt;0000 33 D2 XOR DX,DX ;clear DX register &lt;br /&gt;0002 B9 0064 ~IOV CX,lOO ;divide DX-AX by 100 &lt;br /&gt;0005 F7 Fl DIV CX &lt;br /&gt;0007 D4 OA AAM ;convert quotient to BCD &lt;br /&gt;0009 05 3030 ADD AX,3030H ;convert to ASCII &lt;br /&gt;OOOC 92 XCHG AX,DX ;repeat for remainder &lt;br /&gt;DODD D4 OA A.l\\M &lt;br /&gt;OOOF 05 3030 ADD AX,3030H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-25 uses the DOS 21 H function AH = 02H to display a sample number in dec-&lt;br /&gt;imal on the video display using the AAM instruction. Notice how AAM is used to convert AL &lt;br /&gt;into BCD. Next ADD AX,3030H converts thc BCD code in AX into ASCII for display with &lt;br /&gt;DOS INT 21H. Once the data are converted to ASCII code they are displayed by loading DL &lt;br /&gt;with the most significant digit from AH. Next, the least-significant digit is displayed from AL. &lt;br /&gt;Note that the DOS INT 21 H function calls change AL. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-4 BASIC LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 BO 48 &lt;br /&gt;0102 B4 00 &lt;br /&gt;0104 D4 OA &lt;br /&gt;0106 05 3030 &lt;br /&gt;0109 8A D4 &lt;br /&gt;010B B4 02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that displays the number loaded into AL, &lt;br /&gt;;with the first instruction (48H), as a decimal number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.~lODEL TUJY jselect TINY model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE ;start c,Â£ CODE segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP ;indicate start of program &lt;br /&gt;HOV AL,48H ;load AL with test data &lt;br /&gt;NOV AH,O ; cleaL- AH &lt;br /&gt;AAJ:o! ; convert to BCD &lt;br /&gt;ADD AX,3030H; ; convert to ASCII &lt;br /&gt;NOV DL,AH ;display most-significant &lt;br /&gt;NOV AH,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;163 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;digit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OlOD 50 PUSH AX isave least-significant digit &lt;br /&gt;010E CD 21 INT 21H &lt;br /&gt;0110 58 POP AX jrestore AL &lt;br /&gt;0111 8l1. DO NOV DL,AL ;display least-significant digit &lt;br /&gt;0113 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT ;exit to DOS &lt;br /&gt;END ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAS Instruction. Like other ASCII adjust instructions, AAS adjusts the AX register after an &lt;br /&gt;ASCII subtraction. For example, suppose that a 35H subtracts from a 39H. The result will be a &lt;br /&gt;04H, which requires no correction. Here AAS will modify neither AH or AL. On the other hand, &lt;br /&gt;if 38H subtracts from 37H, then AL will equal 09H and the number in AH will decrement by l. &lt;br /&gt;This decrement allows multiple-digit ASCII numbers to be subtracted from each other. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BASIC LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The basic logic instructions include AND, OR, Exclusive-OR, and NOT. Another logic instruc-&lt;br /&gt;tion is TEST, which is explained in this section of the text because the operation of the TEST in-&lt;br /&gt;struction is a special form of the AND instruction. Also explained is the NEG instruction, which &lt;br /&gt;is similar to the NOT instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Logic operations provide binary bit control in low-level software. The logic instructions &lt;br /&gt;allow bits to be set, cleared, or complemented. Low-level software appears in machine language &lt;br /&gt;or assembly language form and often controls a system's I/O devices. All logic instructions af-&lt;br /&gt;fect the flag bits. Logic operations always clear the carry and overflow flags, while the other &lt;br /&gt;flags change to reflect the condition of the result. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When binary data are manipulated in a register or a memory location, the rightmost bit po-&lt;br /&gt;sition is always numbered bit O. Bit position numbers increase from bit 0 toward the left to bit 7 &lt;br /&gt;for a byte and to bit 15 for a word. A doubleword (32-bits) uses bit position 31 as its leftmost bit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND &lt;br /&gt;The AND operation performs logical multiplication, as illustrated by the truth table in Figure 5-3. &lt;br /&gt;Here two bits, A and B, are ANDed to produce the result X. As indicated by the truth table, X is &lt;br /&gt;a logic 1 only when both A and B are logic l's. For all other input combination of A and B, X &lt;br /&gt;is a logic O. It is important to remember that 0 AND anything is always 0, and 1 AND 1 is &lt;br /&gt;always l. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The AND instruction can replace discrete AND gates if the speed required is not too great, &lt;br /&gt;although this is normally reserved for embedded control applications. (Note that Intel has re-&lt;br /&gt;leased the 80386EX embedded controller. which embodies the basic structure of thc personal &lt;br /&gt;computer system.) With the 8086 microprocessor, the AND instruction often executes in about a &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;164 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-3 (a) The truth &lt;br /&gt;table for the AND operation &lt;br /&gt;and (b) the logic symbol of an &lt;br /&gt;AND gate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 :~'----)- T &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microsecond. With newer versions, the execution speed is greatly increased. If the circuit that the &lt;br /&gt;AND instruction replaces operates at a much slower speed than the microprocessor, the AND in-&lt;br /&gt;struction is a logical replacement. This replacement can save a considerable amount of money. A &lt;br /&gt;single AND gate integrated circuit (7408) costs approximately 40Â¢, while it costs less than &lt;br /&gt;11100Â¢ to store the AND instruction in a read-only memory. Note that logic circuit replacement &lt;br /&gt;such as this only appears in control systems based on microprocessors, and does not generally &lt;br /&gt;find application in the personal computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The AND operation also clears bits of a binary number. The task of clearing a bit in a bi-&lt;br /&gt;nary number is called masking. Figure 5-4 illustrates the process of masking. Notice that the &lt;br /&gt;left most four bits clear to 0, because 0 AND anything is O. The bit positions that AND with l' s &lt;br /&gt;do not change. This occurs because if a 1 ANDs with a 1, a 1 results; if a 1 ANDs with a 0, a 0 &lt;br /&gt;results. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The AND instruction uses any addressing mode except memory-to-memory and segment &lt;br /&gt;register addressing. Refer to Table 5-14 for a list of some AND instructions and their operations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An ASCII-coded number can be converted to BCD by using the AND instruction to mask off &lt;br /&gt;the leftmost four binary bit positions. This converts the ASCII 30H to 39H to 0-9. Example 5-26 &lt;br /&gt;shows a short program that converts the ASCII contents ofBX into BCD. The AND instruction in &lt;br /&gt;this example converts two digits from ASCII to BCD simultaneously. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-26 &lt;br /&gt;0000 BE 3135 &lt;br /&gt;0003 81 E3 OF OF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EX,3135H &lt;br /&gt;AND EX,OFOFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; load ASCII &lt;br /&gt;;mask EX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The OR operation performs logical addition and is often called the Inclusive-OR function. The &lt;br /&gt;OR function generates a logic 1 output if any inputs are 1. A 0 appears at the output only when &lt;br /&gt;all inputs are O. The truth table for the OR function appears in Figure 5-5. Here, the inputs A and &lt;br /&gt;B OR together to produce the X output. It is important to remember that 1 ORed with anything &lt;br /&gt;yields a 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In embedded controller applications, the OR instruction can also replace discrete OR &lt;br /&gt;gates. This results in a considerable savings, because a quad, 2-input OR gate (7432) costs about &lt;br /&gt;40Â¢, while the OR instruction costs less than 111 OOÂ¢ to store in a read-only memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-4 The operation &lt;br /&gt;of the AND function showing &lt;br /&gt;how bits of a number are &lt;br /&gt;cleared to zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;x x x x x x x x Unknown number &lt;br /&gt;â¢ 0 0 0 0 1 1 1 1 Mask &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o 0 0 0 x x x x Result &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-4 BASIC LOGIC INSTRUCTIONS 165 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-14 AND instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND AL,BL &lt;br /&gt;AND CX,DX &lt;br /&gt;AND ECX,EDI &lt;br /&gt;AND CL,33H &lt;br /&gt;AND DI,4FFFH &lt;br /&gt;AND ESI,34H &lt;br /&gt;AND AX,[DI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND ARRA Y[SIJ,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND [EAX],CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL= ALAND BL &lt;br /&gt;CX= CXAND DX &lt;br /&gt;ECX = ECX AND EDI &lt;br /&gt;CL = CL AND 33H &lt;br /&gt;DI = DI AND 4FFFH &lt;br /&gt;ESI = ESI AND 00000034H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX is ANDed with the word contents of the data segment memory &lt;br /&gt;location addressed by DI &lt;br /&gt;The byte contents of the data segment memory location addressed &lt;br /&gt;by the sum of ARRAY plus SI is ANDed with AL; the result moves &lt;br /&gt;to memory &lt;br /&gt;CL is ANDed with the byte contents of the data segment memory &lt;br /&gt;location addressed by EAX; the result moves to memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 5-6 shows how the OR gate sets (1) any bit of a binary number. Here, an unknown &lt;br /&gt;number (XXXX XXXX) ORs with a 0000 1111 to produce a result of XXXX 1111. The right-&lt;br /&gt;most four bits set, while the leftmost four bits remain unchanged. The OR operation sets any bit, &lt;br /&gt;and the AND operation clears any bit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The OR instruction uses any of the addressing modes allowed to any other instruction ex-&lt;br /&gt;cept segment register addressing. Table 5-15 lists several OR instructions and their operations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that two BCD numbers are multiplied and adjusted with the AAM instruction. &lt;br /&gt;The result appears in AX as a 2-digit unpacked BCD number. Example 5-27 illustrates this mul-&lt;br /&gt;tiplication and shows how to change the result into a 2-digit ASCII-coded number using the OR &lt;br /&gt;instruction. Here, OR AX,3030H converts the 0305H found in AX to 3335H. The OR operation &lt;br /&gt;can be replaced with an ADD AX,3030H to obtain the same results. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-27 &lt;br /&gt;0000 BO 05 &lt;br /&gt;0002 B3 07 &lt;br /&gt;0004 F6 E3 &lt;br /&gt;0006 D4 OA &lt;br /&gt;0008 OD 3030 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-5 (a) The truth &lt;br /&gt;table for the OR operation &lt;br /&gt;and (b) the logic symbol of an &lt;br /&gt;OR gate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A B T &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 0 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,5 ;load data &lt;br /&gt;MOV BL,7 &lt;br /&gt;MUL BL &lt;br /&gt;AAM ;adjust &lt;br /&gt;OR AX,3030H ; to ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;166 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-6 The operation &lt;br /&gt;of the OR function showing &lt;br /&gt;how bits of a number are set &lt;br /&gt;to one &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;x x x x x x x x Unknown number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ 0 0 0 0 1 1 1 1 Mask &lt;br /&gt;x x x x 1 1 1 1 Result &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-15 OR instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORAH,BL &lt;br /&gt;OR SI,OX &lt;br /&gt;OR EAX,EBX &lt;br /&gt;OR OH,OA3H &lt;br /&gt;OR SP,9900H &lt;br /&gt;OR EBP,10 &lt;br /&gt;OR OX,[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR OATES[01+2],AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exclusive-OR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH=AH OR BL &lt;br /&gt;SI = SI OR OX &lt;br /&gt;EAX = EAX OR EBX &lt;br /&gt;OH = OH ORA3H &lt;br /&gt;SP = SP OR 9900H &lt;br /&gt;EBP = EBP OR OOOOOOOAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OX is ORed with the word contents of the data segment memory &lt;br /&gt;location addressed by BX &lt;br /&gt;The byte contents of the data segment memory location addressed &lt;br /&gt;by the sum of DATES, 01, and 2 are ORed with AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Exclusive-OR instruction (XOR) differs from Inclusive-OR (OR). The difference is that a &lt;br /&gt;1,1 condition of the OR function produces a 1, while the 1,1 condition of the Exclusive-OR op-&lt;br /&gt;eration produces a O. The Exclusive-OR operation excludes this condition, while the Inclusive-&lt;br /&gt;OR includes it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 5-7 shows the truth table ofthe Exclusive-OR function. (Compare this with Figure 5-5 &lt;br /&gt;to appreciate the difference between these two OR functions.) If the inputs of the Exclusive-OR &lt;br /&gt;function are both 0 or both 1, the output is O. If the inputs are different, the output is 1. Because of &lt;br /&gt;this, the Exclusive-OR function is sometimes calIed a comparator. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The XOR instruction uses any addressing mode except segment register addressing. &lt;br /&gt;Table 5-16 lists several Exclusive-OR instructions and their operations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with the AND and OR functions, Exclusive-OR can replace discrete logic circuitry in &lt;br /&gt;embedded applications. The 7486 quad, 2-input Exclusive-OR gate is replaced by one XOR in-&lt;br /&gt;struction. The 7486 costs about 40Â¢, while the instruction costs less than l/lOOÂ¢ to store in the &lt;br /&gt;memory. Replacing the circuitry on the 7486 saves a considerable amount of money, especially &lt;br /&gt;if many systems are built. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-7 (a) The truth &lt;br /&gt;table for the Exclusive-OR op-&lt;br /&gt;eration and (b) the logic &lt;br /&gt;symbol of an Exclusive-OR &lt;br /&gt;gate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B T &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 0 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) (b) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-4 BASIC LOGIC INSTRUCTIONS 167 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-16 Exclusive-OR instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR CH,DL &lt;br /&gt;XOR SI,BX &lt;br /&gt;XOR EBX,EDI &lt;br /&gt;XORAH,OEEH &lt;br /&gt;XOR DI,ODDH &lt;br /&gt;XOR ESI,100 &lt;br /&gt;XOR DX,[SI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR DATES[DI+2],AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CH = CH XOR DL &lt;br /&gt;SI = SI XOR BX &lt;br /&gt;EBX = EBX XOR EDI &lt;br /&gt;AH = AH XOR EEH &lt;br /&gt;DI = DI XOR OODDH &lt;br /&gt;ESI = ESI XOR 00000064H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX is Exciusive-ORed with the word contents of the data segment &lt;br /&gt;memory location addressed by SI &lt;br /&gt;AL is Exclusive-ORed with the byte contents of the data segment &lt;br /&gt;memory location addressed by the sum of DATES, DI, and 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Exclusive-OR instruction is useful if some bits of a register or memory location must &lt;br /&gt;be inverted. This instruction allows part of a number to be inverted or complemented. Figure 5-8 &lt;br /&gt;shows how just part of an unknown quantity can be inverted by XOR. Notice that when a 1 &lt;br /&gt;Exclusive-ORs with X, the result is X. If a 0 Exclusive-ORs with X, the result is X. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that the leftmost lO-bits of the BX register must be inverted without changing the &lt;br /&gt;rightmost 6-bits. The XOR BX,OFFCOH instruction accomplishes this task. The AND instruction &lt;br /&gt;clears (0) bits, the OR instruction sets (1) bits, and now the Exclusive-OR instruction inverts bits. &lt;br /&gt;These three instructions allow a program to gain complete control over any bit, stored in any reg-&lt;br /&gt;ister or memory location. This is ideal for control system applications where equipment must be &lt;br /&gt;turned on (1), turned off (0) and toggled from on to off or off to on. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A fairly common use for the Exclusive-OR instruction is to clear a register to zero. For ex-&lt;br /&gt;ample, the XOR CH,CH instruction clears register CH to OOH and requires two bytes of memory &lt;br /&gt;to store the instruction. Likewise, the MOY CH,OOH instruction also clears CH to OOH, but re-&lt;br /&gt;quires three bytes of memory. Because of this savings, the XOR instruction is used to clear a reg-&lt;br /&gt;ister in place of a move immediate. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-28 shows a short sequence of instructions that clear bits 0 and 1 of CX, set bits &lt;br /&gt;9 and 10 of CX, and invert bit 12 of CX. The OR instruction is used to set bits, the AND instruc-&lt;br /&gt;tion is used to clear bits, and the XOR instruction inverts bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-28 &lt;br /&gt;0000 81 C9 0600 &lt;br /&gt;0004 83 E1 FC &lt;br /&gt;0007 81 Fl 1000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR CX,0600H &lt;br /&gt;AND CX,OFFFCH &lt;br /&gt;XOR CX,1000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set bits 9 and 10 &lt;br /&gt;;c1ear bits 0 and 1 &lt;br /&gt;;invert bit 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Test and Bit Test Instructions &lt;br /&gt;The TEST instruction performs the AND operation. The difference is that the AND instruction &lt;br /&gt;changes the destination operand, while the TEST instruction does not. A TEST affects only the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-8 The operation &lt;br /&gt;of the Exclusive-OR function &lt;br /&gt;showing how bits of a number &lt;br /&gt;are inverted &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;x x x x x x x x Unknown number &lt;br /&gt;EeO 000 1 1 1 1 Mask &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;x x x x x x x x Result &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;168 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-17 TEST &lt;br /&gt;instructions Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST OL,OH &lt;br /&gt;TESTCX,BX &lt;br /&gt;TEST EOX,ECX &lt;br /&gt;TEST AH,4 &lt;br /&gt;TEST EAX,256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OL is ANOed with OH &lt;br /&gt;CX is ANOed with BX &lt;br /&gt;EOX is ANOed with ECX &lt;br /&gt;AH is AN Oed with 4 &lt;br /&gt;EAX is ANOed with 256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;condition of the flag register, which indicates the result of the test. The TEST instruction uses the &lt;br /&gt;same addressing modes as the AND instruction. Table 5-17 lists some TEST instructions and &lt;br /&gt;their operations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The TEST instruction functions in the same manner as a CMP instruction. The difference &lt;br /&gt;is that the TEST instruction normally tests a single bit (or occasionally mUltiple bits), while the &lt;br /&gt;CMP instruction tests the entire byte or word. The zero flag (Z) is a logic 1 (indicating a zero re-&lt;br /&gt;sult) if the bit under test is a zero, and Z = 0 (indicating a non-zero result) if the bit under test is &lt;br /&gt;not zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Usually the TEST instruction is followed by either the JZ (jump if zero) or JNZ (jump if &lt;br /&gt;not zero) instruction. The destination operand is normally tested against immediate data. The &lt;br /&gt;value of immediate data is 1 to test the rightmost bit position, 2 to test the next bit, 4 for the &lt;br /&gt;next, etc. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-29 lists a short program that tests the rightmost and leftmost bit positions of the &lt;br /&gt;AL register. Here, 1 selects the rightmost bit and 128 selects the leftmost bit. (Note: A 128 is an &lt;br /&gt;80H.) The JNZ instruction follows each test to jump to different memory locations depending on &lt;br /&gt;the outcome of the tests. The JNZ instruction jumps to the operand address (RIGHT or LEFT in &lt;br /&gt;the example) if the bit under test is not zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-29 &lt;br /&gt;0000 A8 01 TEST AL,l ;test right bit &lt;br /&gt;0002 75 Ie JNZ RIGHT ;if set &lt;br /&gt;0004 A8 80 TEST AL,128 ;test left bit &lt;br /&gt;0006 75 38 JNZ LEFT ;if set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80386 through the Pentium Pro processors contain additional test instructions that test &lt;br /&gt;single bit positions. Table 5-18 lists the four different bit test instructions available to these mi-&lt;br /&gt;croprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All four forms of the bit test instruction test the bit position in the destination operand se-&lt;br /&gt;lected by the source operand. For example, the BT AX,4 instruction tests bit position 4 in AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-18 Bit test instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BT &lt;br /&gt;BTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tests a bit in the destination operand specified by the source operand &lt;br /&gt;Tests and complements a bit in the destination operand spec;f;ed by &lt;br /&gt;the source operand &lt;br /&gt;Tests and resets a bit in the destination operand specified by the &lt;br /&gt;source operand &lt;br /&gt;Tests and sets a bit in the destination operand specified by the &lt;br /&gt;source operand &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-5 SHIFT AND ROTATE 169 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-19 NOT and NEG instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOTCH &lt;br /&gt;NEGCH &lt;br /&gt;NEG AX &lt;br /&gt;NOT EBX &lt;br /&gt;NEG ECX &lt;br /&gt;NOT TEMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOT BYTE PTR[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CH is one's complemented &lt;br /&gt;CH is two's complemented &lt;br /&gt;AX is two's complemented &lt;br /&gt;EBX is one's complemented &lt;br /&gt;ECX is two's complemented &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The contents of the data segment memory location TEMP is one's &lt;br /&gt;complemented &lt;br /&gt;The byte contents of the data segment memory location addressed &lt;br /&gt;by BX is one's complemented &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The result of the test is located in the carry flag bit. If bit position 4 is a 1, carry is set; if bit po-&lt;br /&gt;sition 4 is a 0, carry is cleared. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The remaining three bit test instructions also place the bit under test into the carry flag, and &lt;br /&gt;afterwards change the bit under test. The BTC AX,4 instruction complements bit position 4 after &lt;br /&gt;testing it; the BTR AX,4 instruction clears it (0) after the test, and the BTS AX,4 instruction sets &lt;br /&gt;it (1) after the test. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-30 repeats the sequence of instructions listed in Example 5-28. Here the BTR &lt;br /&gt;instruction clears bits in CX, BTS sets bits in CX, and BTC inverts bits in CX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-30 &lt;br /&gt;0000 OF BA E9 09 BTS CX,9 ;set bit 9 &lt;br /&gt;0004 OF BA E9 OA BTS CX,10 ;set bit 10 &lt;br /&gt;0008 OF BA F1 00 BTR CX,O ;clear bit 0 &lt;br /&gt;OOOC OF BA F1 01 BTR CX,l ;clear bit 1 &lt;br /&gt;0010 OF BA F9 OC BTC CX,12 ;invert bit 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOT and NEG &lt;br /&gt;Logical inversion or the one's complement (NOT) and arithmetic sign inversion or the two's com-&lt;br /&gt;plement (NEG) are the last two logic functions presented (except for shift and rotate in the next &lt;br /&gt;section of the text). These are two of a few instructions that contain only one operand. Table 5-19 &lt;br /&gt;lists some variations of the NOT and NEG instructions. As with most other instructions, NOT &lt;br /&gt;and NEG can use any addressing mode except segment register addressing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The NOT instruction inverts all bits of a byte, word, or doubleword. The NEG instruction &lt;br /&gt;two's complements a number, which means that the arithmetic sign of a signed number changes &lt;br /&gt;from positive to negative or negative to positive. The NOT function is considered logical, and &lt;br /&gt;the NEG function is considered an arithmetic operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHIFT AND ROTATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shift and rotate instructions manipulate binary numbers at the binary bit level, as did the AND, &lt;br /&gt;OR, Exclusive-OR, and NOT instructions. Shifts and rotates find their most common application &lt;br /&gt;in low-level software used to control VO devices. The microprocessor contains a complete set of &lt;br /&gt;shift and rotate instructions used to shift or rotate any memory data or register. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;170 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shifts &lt;br /&gt;Shift instructions position or move numbers to the left or right within a register or memory lo-&lt;br /&gt;cation. They also perform simple arithmetic such as multiplication by powers of 2+0 (left sh{ft) &lt;br /&gt;and division by powers of 2-0 (right shift). The microprocessor's instruction set contains four &lt;br /&gt;different shift instructions: two are logical shifts and two are arithmetic shifts. All four shift op-&lt;br /&gt;erations appear in Figure 5-9. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice in Figure 5-9 that there are two right shifts and two left shifts. The logical shifts &lt;br /&gt;move a 0 into the rightmost bit position for a logical left shift and a 0 into the leftmost bit posi-&lt;br /&gt;tion for a logic right shift. There are also two arithmetic shifts. The arithmetic and logical left &lt;br /&gt;shifts are identical. The arithmetic and logical right shifts are different because the arithmetic &lt;br /&gt;right shift copies the sign-bit through the number, while the logical right shift copies a 0 through &lt;br /&gt;the number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Logical shift operations function with unsigned numbers, and arithmetic shifts function &lt;br /&gt;with signed numbers. Logical shifts multiply or divide unsigned data, and arithmetic shifts mul-&lt;br /&gt;tiply or divide signed data. A shift left always multiplies by 2 for each bit position shifted, and a &lt;br /&gt;shift right always divides by 2 for each bit position shifted. Shifting a number 2 places mUltiplies &lt;br /&gt;or divides by 4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 5-20 illustrates some addressing modes allowed for the various shift instructions. &lt;br /&gt;There are two different forms of shifts that allow any register (except the segment register) or &lt;br /&gt;memory location to be shifted. One mode uses an immediate shift count, and the other uses reg-&lt;br /&gt;ister CL to hold the shift count. Note that CL must hold the shift count. When CL is the shift &lt;br /&gt;count, it does not change when the shift instruction executes. Note that the shift count is a &lt;br /&gt;modul0-32 count. This means that a shift count of 33 will shift the data one place (33 / 32 = &lt;br /&gt;remainder of 1). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-31 shows how to shift the DX register left 14 places in two different ways. The &lt;br /&gt;first method uses an immediate shift count of 14. The second method loads a 14 into CL and then &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-9 The shift in-&lt;br /&gt;structions showing the opera-&lt;br /&gt;tion and direction of the shift &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Target register or memory &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHL o---1'--_____ ---J1- 0 &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAL 0---1'--_____ ---J1- 0 &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHR 0-1 I..---------I~O &lt;br /&gt;SAR C[i C L...-L--__ ----I~O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;Sign &lt;br /&gt;bit &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-5 SHIFT AND ROTATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-20 Shift instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHL AX,1 &lt;br /&gt;SHR BX,12 &lt;br /&gt;SHR ECX,10 &lt;br /&gt;SAL DATA1,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAR SI,2 &lt;br /&gt;SAR EDX,14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX is logically shifted left 1 place &lt;br /&gt;BX is logically shifted right 12 places &lt;br /&gt;ECX is logically shifted right 10 places &lt;br /&gt;The contents of the data segment memory location DATA1 is &lt;br /&gt;arithmetically shifted left the number of places specified by CL &lt;br /&gt;SI is arithmetically shifted right 2 places &lt;br /&gt;EDX is arithmetically shifted right 14 places &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;171 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;uses CL as the shift count. Both instructions shift the contents of the DX register logically to the &lt;br /&gt;left 14 binary bit positions or places. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-31 &lt;br /&gt;0000 C1 E2 OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003 B1 OE &lt;br /&gt;0005 D3 E2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHL DX,14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CL,14 &lt;br /&gt;SHL DX,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that the contents of AX must be multiplied by 10, as in Example 5-32. This can &lt;br /&gt;be done in two ways: by the MUL instruction or by shifts and additions. A number is doubled &lt;br /&gt;when it shifts left one binary place. When a number is doubled, then added to the number times &lt;br /&gt;8, the result is 10 times the number. The number 10 decimal is 1010 in binary. A logic 1 appears &lt;br /&gt;in both the 2's and 8's positions. If 2 times the number is added to 8 times the number, the result &lt;br /&gt;is 10 times the number. Using this technique, a program can be written to multiply by any con-&lt;br /&gt;stant. This technique often executes faster than the multiply instruction in earlier versions of the &lt;br /&gt;Intel microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 D1 EO &lt;br /&gt;0002 8B D8 &lt;br /&gt;0004 C1 EO 02 &lt;br /&gt;0007 03 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 D1 EO &lt;br /&gt;OOOB 8B D8 &lt;br /&gt;OOOD C1 EO 03 &lt;br /&gt;0010 03 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0012 8B D8 &lt;br /&gt;0014 Dl EO &lt;br /&gt;0016 D1 EO &lt;br /&gt;0018 03 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Multiply AX by 10 (1010 ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHL AX,l &lt;br /&gt;MOV BX,AX &lt;br /&gt;SHL AX,2 &lt;br /&gt;ADD AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Multiply AX by 18 (10010) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHL AX,l &lt;br /&gt;MOV BX,AX &lt;br /&gt;SHL AX,3 &lt;br /&gt;ADD AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Multiply AX by 5 (l01) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BX,AX &lt;br /&gt;SHL AX,l &lt;br /&gt;SHL AX,l &lt;br /&gt;ADD AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;AX times 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;AX times 8 &lt;br /&gt;;10 times AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;AX times 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;AX times 16 &lt;br /&gt;;18 times AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;AX times 2 &lt;br /&gt;;AX times 4 &lt;br /&gt;;5 times AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;172 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 5-10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Double-precision Shifts (80386-Pentium Pro Only). The 80386 and above contain two double-&lt;br /&gt;precision shifts SHLD (shUt left) and SHRD (shift right). Each instruction contains three &lt;br /&gt;operands instead of the two found with the other shift instructions. Both instructions function &lt;br /&gt;with two 16- or 32-bit registers or with one 16- or 32-bit memory location and a register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The SHRD AX,BX,12 instruction is an example of the double-precision shift right instruc-&lt;br /&gt;tion. This instruction logically shifts AX right by 12-bit positions. The rightmost 12-bits of BX &lt;br /&gt;shift into the leftmost 12-bits of AX. The contents of BX remain unchanged by this instruction. &lt;br /&gt;The shift count can be an immediate count, as in this example, or can be found in register CL, as &lt;br /&gt;with other shift instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The SHLD EBX,ECX,16 instruction shifts EBX left. The leftmost 16-bits ofECX fill the &lt;br /&gt;rightmost 16-bits of EBX after the shift. As before, the contents of ECX, the second operand, re-&lt;br /&gt;main unchanged. This instruction as well as SHRD affect the flag bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Rotate &lt;br /&gt;Rotate instructions position binary data by rotating the information in a register or memory lo-&lt;br /&gt;cation either from one end to another or through the carry flag. They are often used to shift or po-&lt;br /&gt;sition numbers that are wider than 16-bits in the 8086-80286 microprocessors or wider than &lt;br /&gt;32-bits in the 80386 through the Pentium Pro. The four available rotate instructions appear in &lt;br /&gt;Figure 5-10. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Numbers rotate through a register or a memory location and the C-flag (carry) or through &lt;br /&gt;a register or memory location only. With either type of rotate instruction, the programmer can se-&lt;br /&gt;lect either a left or a right rotate. Addressing modes used with rotate are the same as used with &lt;br /&gt;the shifts. A rotate count can be immediate or located in register CL. Table 5-21 lists some of the &lt;br /&gt;possible rotate instructions. If CL is used for a rotate count, it does not change. As with shifts, the &lt;br /&gt;count in CL is a modulo-32 count. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Rotate instructions are often used to shift wide numbers to the left or right. The program &lt;br /&gt;listed in Example 5-33 shifts the 48-bit number in registers DX, BX, and AX left one binary &lt;br /&gt;place. Notice that the least-significant 16-bits (AX) are shifted left first. This moves the leftmost &lt;br /&gt;bit of AX into the carry flag bit. Next, the rotate BX instruction rotates carry into BX and its left-&lt;br /&gt;most bit moves into calTy. The last instruction rotates carry into DX, completing the shift. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The rotate Target register or memory &lt;br /&gt;instructions showing the di- C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rU-1 Il rection and operation of each RCL rotate &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL D-r IJ &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCR [I f-Q] &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROR rl 1-D &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-6 STRING COMPARISONS 173 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 5-21 Rotate instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL 81,14 &lt;br /&gt;RCL BL,6 &lt;br /&gt;ROL ECX,18 &lt;br /&gt;RCRAH,CL &lt;br /&gt;ROR WORD PTR[BPj,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-33 &lt;br /&gt;0000 Dl EO &lt;br /&gt;0002 Dl D3 &lt;br /&gt;0004 Dl D2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Scan Instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;81 rotates left 14 places &lt;br /&gt;BL rotates left through carry 6 places &lt;br /&gt;ECX rotates left 18 places &lt;br /&gt;AH rotates right through carry the number of places specified by CL &lt;br /&gt;The word contents of the stack segment memory location addressed &lt;br /&gt;by BP rotate right 2 places &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHL AX,l &lt;br /&gt;RCL BX,l &lt;br /&gt;RCL DX,l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Although the bit scan instructions don't shift or rotate numbers, they do scan through a number &lt;br /&gt;searching for a I bit. Because this is accomplished within the microprocessor by shifting the &lt;br /&gt;number, bit scan instructions are included in this section of the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bit scan instructions BSF (bit scan forward) and BSR (bit scan reverse) are avail-&lt;br /&gt;able only in the 80386-Pentium Pro processors. Both forms scan through a number searching for &lt;br /&gt;the first I-bit encountered. The BSF instruction scans the number from the rightmost bit toward &lt;br /&gt;the left, and BSR scans the number from the leftmost bit toward the right. If a I-bit is encoun-&lt;br /&gt;tered by either bit scan instruction, the zero flag is set and the bit position of the I-bit is placed &lt;br /&gt;into the destination operand. If no I-bit is encountered (i.e., the number contains all zeros), the &lt;br /&gt;zero flag is cleared. This means that the result is not -zero if no I-bit is encountered. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, if EAX = 60000000H and the BSF EBX,EAX instruction executes, the &lt;br /&gt;number is scanned from the rightmost bit toward the left. The first I-bit encountered is at bit po-&lt;br /&gt;sition 29, which is placed into EBX, and the zero flag bit is set. If the same value for EAX is used &lt;br /&gt;for the BSR instruction, the EBX register is loaded with a 30 and the zero flag bit is set. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING COMPARISONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As illustrated in Chapter 4, the string instructions are very powerful because they allow the pro-&lt;br /&gt;grammer to manipulate large blocks of data with relative ease. Block data manipulation occurs &lt;br /&gt;with the string instructions MOYS, LODS, STOS, INS, and OUTS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this section, additional string instructions are discussed that allow a section of memory &lt;br /&gt;to be tested against a constant or against another section of memory. To accomplish these tasks, &lt;br /&gt;use the SCAS (string scan) or CMPS (string compare) instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCAS &lt;br /&gt;The string scan instruction (SCAS) compares the AL register with a byte block of memory, the &lt;br /&gt;AX register with a word block of memory, or the EAX register (80386-Pentium Pro) with a dou-&lt;br /&gt;bleword block of memory. The SCAS instruction subtracts memory from AL, AX, or EAX &lt;br /&gt;without affecting either the register or the memory location. The opcode used for byte comparison &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;174 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;is SCASB: the opcode used for the word comparison is SCASW; and the opcode used for a dou-&lt;br /&gt;bleword comparison is SCASD. In all cases, the contents of the extra segment memory location &lt;br /&gt;addressed by DI is compared with AL, AX, or EAX. Recall that this default segment (ES) cannot &lt;br /&gt;be changed with a segment override prefix. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Like the other string instructions, SCAS instructions use the direction flag (D) to select ei-&lt;br /&gt;ther auto-increment or auto-decrement operation for DI. They also repeat if prefixed by a condi-&lt;br /&gt;tional repeat prefix. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a section of memory is 100 bytes long and begins at location BLOCK. This &lt;br /&gt;section of memory must be tested to see if any location contains a OOH. The program in Example &lt;br /&gt;5-34 shows how to search this part of memory for a OOH using the SCASB instruction. In this &lt;br /&gt;example, the SCASB instruction is prefixed with an REPNE (repeat while not equal) prefix. &lt;br /&gt;The REPNE prefix causes the SCASB instruction to repeat until either the CX register reaches 0, &lt;br /&gt;or until an equal condition exists as the outcome of the SCASB instruction's comparison. An-&lt;br /&gt;other conditional repeat prefix is REPE (repeat while equal). With either repeat prefix, the con-&lt;br /&gt;tents of CX decrements without affecting the flag bits. The SCASB instruction and the &lt;br /&gt;comparison it makes change the flags. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-34 &lt;br /&gt;0000 BF 0011 R MOV DI,OFFSET BLOCK ;address data &lt;br /&gt;0003 FC CLD ; auto-increment &lt;br /&gt;0004 B9 0064 MOV CX,100 ;load counter &lt;br /&gt;0007 32 co XOR AL,AL ;clear AL &lt;br /&gt;0009 F2/AE REPNE SCASB ;search &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose you must develop a program that skips ASCII-coded spaces in a memory alTay. &lt;br /&gt;This task appears in the procedure listed in Example 5-35. This procedure assumes that the DI &lt;br /&gt;register already addresses the ASCII-coded character string, and that the length of the string is &lt;br /&gt;256 bytes or less. Because this program is to skip spaces (20H), the REPE (repeat while equal) &lt;br /&gt;prefix is used with a SCASB instruction. The SCASB instruction repeats the comparison. &lt;br /&gt;searching for a 20H, as long as an equal condition exists. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-35 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 FC &lt;br /&gt;0001 B9 0100 &lt;br /&gt;0004 BO 20 &lt;br /&gt;0006 F3/AE &lt;br /&gt;0008 CB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SKIP PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD &lt;br /&gt;MOV CX,256 &lt;br /&gt;MOV AL,20H &lt;br /&gt;REPE SCASB &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SKIP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; auto-increment &lt;br /&gt;;counter &lt;br /&gt;;get space &lt;br /&gt;; search &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The compare strings instruction (CMPS) always compares two sections of memory data as bytes &lt;br /&gt;(CMPSB), words (CMPSW), or doublewords (CMPSD). Note that only the 80386/80486IPen-&lt;br /&gt;tium/Pentium Pro can use doublewords. The contents of the data segment memory location ad-&lt;br /&gt;dressed by SI is compared with the contents of the extra segment memory location addressed by &lt;br /&gt;DL The CMPS instruction increments or decrements both SI and DI. The CMPS instruction is &lt;br /&gt;normally u~cd with either the REPE or REPl\\E prefix. Alternates to these prefixes are REPZ (re-&lt;br /&gt;peat while zero) and REPNZ (repeat while not zero), but usually the REPE or REPNE prefixes &lt;br /&gt;are used in programming. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 5-36 illustrates a short procedure that compares two sections of memory &lt;br /&gt;searching for a match. The CMPSB instruction is prefixed with a REPE. This causes the search &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-7 SUMMARY 175 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to continue as long as an equal condition exists. When the CX register hecomes 0, or an unequal &lt;br /&gt;condition exists, the CMPSB instruction stops execution. After the CMPSB instruction ends. the &lt;br /&gt;CX register is zero or the flags indicate an equal condition when the two strings match. If CX is &lt;br /&gt;not zero or the nags indicate a not-equal condition, the strings do not match. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-36 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BE 0075 R &lt;br /&gt;0003 BF 007F R &lt;br /&gt;0006 FC &lt;br /&gt;0007 B9 OOOA &lt;br /&gt;OOOA F3/A6 &lt;br /&gt;OOOC CB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NriTCH PROC FAR. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV SI,OFFS~I LINE &lt;br /&gt;NOV DI.OFFS~: TABLE &lt;br /&gt;CLD &lt;br /&gt;NOV CX,lO &lt;br /&gt;REPE CNPSB &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MATCH EtlDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address LINE &lt;br /&gt;;address TABLE &lt;br /&gt;;auto-increment &lt;br /&gt;;counter &lt;br /&gt;isearch &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Addition (ADD) can be 8-, 16-, or 32-bit. The ADD instruction allows any addressing mode &lt;br /&gt;except segment register addressing. Most flags (c. A, S, Z, P, and 0) change when the ADD &lt;br /&gt;instruction executes. A different type of addition. add-with-carry (ADC), adds two operands &lt;br /&gt;and the contents of the carry flag bit (C). The 80..+86 through the Pentium Pro processors &lt;br /&gt;have an additional instruction (XADD) that combines an addition with an exchange. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The increment instruction (INC) adds 1 to a byte, word, or doubleword contents of a register &lt;br /&gt;or memory location. The INC instruction affects the same flag bits as ADD, except the carry &lt;br /&gt;flag. The BYTE PTR, WORD PTR, and DWORD PTR directives appear with the INC in-&lt;br /&gt;struction when the contents of a memory location are addressed by a pointer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Subtraction (SUB) is a byte, word, or doubleword and is performed on a register or a &lt;br /&gt;memory location. The only form of addressing not allowed by the SUB instruction is seg-&lt;br /&gt;ment register addressing. The subtraction instruction affects the same flags as ADD, and &lt;br /&gt;subtracts carry if the SBB form is used. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. The decrement (DEC) instruction subtracts 1 from the contents of a register or memory lo-&lt;br /&gt;cation. The only addressing modes not allowed with DEC are immediate or segment register &lt;br /&gt;addressing. The DEC instruction does not affect the carry flag and is often used with BYTE &lt;br /&gt;PTR, WORD PTR, or DWORD PTR. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The comparison (CMP) instruction is a special form of subtraction that does not store the &lt;br /&gt;difference; instead, the flags change to reflect the difference. Comparison is used to compare &lt;br /&gt;an entire byte or word located in any register (except segment) or memory location. An ad-&lt;br /&gt;ditional comparison instruction (CMPXCHG), which is a combination of compare and ex-&lt;br /&gt;change instructions is found in the 80486-Pentium Pro processors. In the Pentium and &lt;br /&gt;Pentium Pro processors, the CMPXCHG8B instruction compares and exchanges quadword &lt;br /&gt;data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Multiplication is byte, word, or double word and can be signed (IMUL) or unsigned (MUL). &lt;br /&gt;The 8-bit multiplication always multiplies register AL by an operand with the product found &lt;br /&gt;in AX. The 16-bit multiplication always multiplies register AX by an operand with the &lt;br /&gt;product found in DX-AX. The 32-bit multiplication always multiplies register EAX by an &lt;br /&gt;operand with the product found in EDX-EAX. A special IMUL immediate instruction exists &lt;br /&gt;on the 80 186-Pentium Pro processors that contains three operands. For example, the IMUL &lt;br /&gt;BX,CX,3 instruction multiplies CX by 3 and leayes the product in BX. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;176 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 5-37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DODO &lt;br /&gt;0000 42 55 47 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B8 B800 &lt;br /&gt;DOll'. 8E CO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Division is byte, word, or doubleword and can be signed (IDlY) or unsigned (DIY). For an &lt;br /&gt;S-bit division, the AX register divides by the operand, after which the quotient appears in &lt;br /&gt;AL and the remainder in AH. In the 16-bit division, the DX-AX register divides by the &lt;br /&gt;operand, after which the AX register contains the quotient and DX the remainder. In the 32-&lt;br /&gt;bit division, the EDX-EAX register is divided by the operand, after which the EAX register &lt;br /&gt;contains the quotient and the EDX register the remainder. Note that the remainder after a &lt;br /&gt;signed division always assumes the sign of the dividend. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S. BCD data add or subtract in packed form by adjusting the result of the addition with DAA or &lt;br /&gt;the subtraction with DAS. ASCII data are added, subtracted, multiplied, or divided when the &lt;br /&gt;operations are adjusted with AAA, AAS, AAM, and AAD. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The AAM instruction has an interesting added feature that allows it to convert a binary &lt;br /&gt;number into unpacked BCD. This instruction converts a binary number between 00H-63H &lt;br /&gt;into unpacked BCD in AX. The AAM instruction divides AX by 10, and leaves the re-&lt;br /&gt;mainder in AL and the quotient in AH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The AND, OR, and Exclusive-OR instructions perform logic functions on a byte, word, or &lt;br /&gt;doubleword stored in a register or memory location. All flags change with these instructions, &lt;br /&gt;with carry (C) and overflow (0) cleared. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. The TEST instruction performs the AND operation, but the logical product is lost. This in-&lt;br /&gt;struction changes the flag bits to indicate the outcome of the test. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The NOT and NEG instructions perform logical inversion and arithmetic inversion. The &lt;br /&gt;NOT instruction one's complements an operand, and the NEG instruction two's comple-&lt;br /&gt;ments an operand. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. There are eight different shift and rotate instructions. Each of these instructions shifts or ro-&lt;br /&gt;tates a byte, word, or doubleword register or memory data. These instructions have two &lt;br /&gt;operands: the first is the location of the data shifted or rotated, and the second is an imme-&lt;br /&gt;diate shift or rotate count or CL. If the second operand is CL, the CL register holds the shift &lt;br /&gt;or rotate count. In the S0386 through the Pentium Pro processors two additional double-pre-&lt;br /&gt;cision shifts (SHRD and SHLD) exist. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The scan string (SCAS) instruction compares AL, AX, or EAX with the contents of the extra &lt;br /&gt;segment memory location addressed by DI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. The string compare (CMPS) instruction compares the byte, word, or doubleword contents of &lt;br /&gt;two sections of memory. One section in addressed by DI, in the extra segment, and the other &lt;br /&gt;by SI, in the data segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. The SCAS and CMPS instructions repeat with the REPE or REPNE prefixes. The REPE &lt;br /&gt;prefix repeats the string instruction while an equal condition exists, and the REPNE prefix &lt;br /&gt;repeats the string instruction while a not-equal condition exists. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. Example 5-37 illustrates a program that uses some of the instructions in this chapter to &lt;br /&gt;search the video display (beginning at address B800:000) to find if it contains the word &lt;br /&gt;BUG. If the word BUG is found, the program displays a Y. If BUG is not found, it displays &lt;br /&gt;an N. Notice how the CMPSB instruction is used to search for BUG. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program that tests the video display for the word BUG &lt;br /&gt;;if BUG appears anywhere on the display, a Y is &lt;br /&gt;;displayed &lt;br /&gt;;if BUG does not appear, the program displays N &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SWÂ·.LL ;select SMALL model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA ; start of DP'. I, segment &lt;br /&gt;DATAl DB 'BUG' ;define BUG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE ;start of CODE segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP ;start of program &lt;br /&gt;MOV AX,OB800H ;address segment B800 with ES &lt;br /&gt;MOV ES,AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;001C B9 07DO &lt;br /&gt;001F FC &lt;br /&gt;0020 BF 0000 &lt;br /&gt;0023 &lt;br /&gt;0023 BE 0000 R &lt;br /&gt;0026 57 &lt;br /&gt;0027 A6 &lt;br /&gt;0028 75 OA &lt;br /&gt;002A 47 &lt;br /&gt;002B .~.6 &lt;br /&gt;002C 75 06 &lt;br /&gt;002E 47 &lt;br /&gt;002F A6 &lt;br /&gt;0030 B2 59 &lt;br /&gt;0032 74 09 &lt;br /&gt;0034 &lt;br /&gt;0034 5F &lt;br /&gt;0035 83 C7 02 &lt;br /&gt;0038 E2 E9 &lt;br /&gt;003A 57 &lt;br /&gt;003B B2 4E &lt;br /&gt;003D &lt;br /&gt;003D 5F &lt;br /&gt;003E B4 02 &lt;br /&gt;0040 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5-8 QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,25*80 &lt;br /&gt;CLD &lt;br /&gt;MOV DI,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ll: &lt;br /&gt;MOV SI,OFFSET DATAl &lt;br /&gt;PUSH DI &lt;br /&gt;CMPSB &lt;br /&gt;JNE L2 &lt;br /&gt;INC DI &lt;br /&gt;CMPSB &lt;br /&gt;JNE L2 &lt;br /&gt;INC DI &lt;br /&gt;CMPSB &lt;br /&gt;MOV DL, 'y' &lt;br /&gt;JE L3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L2: &lt;br /&gt;POP DI &lt;br /&gt;ADD DI,2 &lt;br /&gt;LOOP L1 &lt;br /&gt;PUSH DI &lt;br /&gt;MOV DL, 'N' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L3: &lt;br /&gt;POP DI &lt;br /&gt;MOV AH,2 &lt;br /&gt;INT 21H &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. Select an ADD instruction that will: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) add BX to AX &lt;br /&gt;(b) add 12H to AL &lt;br /&gt;(c) add EDI and EBP &lt;br /&gt;(d) add 22H to CX &lt;br /&gt;(e) add the data addressed by SI to AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set count &lt;br /&gt;;select increment &lt;br /&gt;;address display &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address BUG &lt;br /&gt;;save display address &lt;br /&gt;;test fo: i:l &lt;br /&gt;;i.f display is not B &lt;br /&gt;;address next position &lt;br /&gt;;test for U &lt;br /&gt;; if display is not U &lt;br /&gt;;address next position &lt;br /&gt;;test for G &lt;br /&gt;;load Y for possible BUG &lt;br /&gt;;if BUG is found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;restore display address &lt;br /&gt;;point to next position &lt;br /&gt;;repeat for whole screen &lt;br /&gt;;save display address &lt;br /&gt;; indicate N if no BUG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear stack &lt;br /&gt;;display DL function &lt;br /&gt;;display ASCII from DL &lt;br /&gt;;exit to DOS &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(f) add CX to the data stored at memory location FROG &lt;br /&gt;2. What is wrong with the ADD ECX,AX instruction? &lt;br /&gt;3. Is it possible to add CX to DS with the ADD instruction? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;177 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. If AX = lOOIH and DX = 20FFH, list the sum and the contents of each flag register bit (C, &lt;br /&gt;A, S, Z, and 0) after the ADD AX,DX instruction executes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Develop a short sequence of instructions that add AL, BL, CL, DL, and AH. Save the sum in &lt;br /&gt;the DH register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Develop a short sequence of instructions that add AX, BX, CX, DX, and SP. Save the sum &lt;br /&gt;in the DI register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Develop a short sequence of instructions that add ECX, EDX, and ESL Save the sum in the &lt;br /&gt;EDI register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Select an instruction that adds BX to DX and that also adds the contents of the carry flag (C) &lt;br /&gt;to the result. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. Choose an instruction that adds a 1 to the contents of the SP register. &lt;br /&gt;10. What is wrong with the INC [BX] instruction? &lt;br /&gt;11. Select a SUB instruction that will: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) subtract BX from ex &lt;br /&gt;(b) subtract OEEH from DH &lt;br /&gt;(c) subtract DI from SI &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;178 CHAPTER 5 ARITHMETIC AND LOGIC INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(d) subtract 3322H from EBP &lt;br /&gt;(e) subtract the data address by SI from CH &lt;br /&gt;(f) subtract the data stored 10 words after the location addressed by SI from OX &lt;br /&gt;(g) subtract AL from memory location FROG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. If DL = OF3H and BH = 72H, list the difference after BH subtracts from DL and show the &lt;br /&gt;contents of the flag register bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. Write a short sequence of instructions that subtract the numbers in 01, SI, and BP ftom the &lt;br /&gt;AX register. Store the difference in register BX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Choose an instruction that subtracts 1 from register EBX. &lt;br /&gt;15. Explain what the SBB [DI - 4J,DX instruction accomplishes. &lt;br /&gt;16. Explain the difference between the SUB and CMP instructions. &lt;br /&gt;17. When two 8-bit numbers are multiplied, where is the product found? &lt;br /&gt;18. When two 16-bit numbers are multiplied, what two registers hold the product? Show which &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;register contains the most- and least-significant portions of the product. &lt;br /&gt;19. When two numbers multiply, what happens to the 0 and C flag bits? &lt;br /&gt;20. Where is the product stored for the MUL EDI instruction? &lt;br /&gt;21. What is the difference between the IMUL !lnd MUL instructions? &lt;br /&gt;22. Write a sequence of instructions that cube the 8-bit number found in DL. Load DL with a 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;initially and make sure that your result is a 16-bit number. &lt;br /&gt;23. Describe the operation of the IMUL BX,DX,I OOH instruction. &lt;br /&gt;24. When 8-bit numbers are divided, in which register is the dividend found? &lt;br /&gt;25. When 16-bit numbers are divided, in which register is the quotient found? &lt;br /&gt;26. What type of errors are detected during a division? &lt;br /&gt;27. Explain the difference between the IDIV and DlV instructions. &lt;br /&gt;28. Where is the remainder found after an 8-bit division? &lt;br /&gt;29. Write a short sequence of instructions that divide the number in BL by the number in CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and then multiply the result by 2. The final answer must be a 16-bit number stored in the &lt;br /&gt;DX register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30. Which instructions are used with BCD arithmetic operations? &lt;br /&gt;31. Which instructions are used with ASCII arithmetic operations? &lt;br /&gt;32. Explain how the AAM instruction converts from binary to BCD. &lt;br /&gt;33. Develop a sequence of instructions that convert the unsigned number in AX (values of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0-65535) into a 5-digit BCD number stored in memory beginning at the location addressed &lt;br /&gt;by the BX register in the data segment. Note that the most-significant character is stored first &lt;br /&gt;and no attempt is made to blank leading zeros. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. Develop a sequence of instructions that adds the 8-digit BCD number in AX and BX to the &lt;br /&gt;8-digit BCD number in CX and DX. (AX and CX are the most-significant registers. The re-&lt;br /&gt;sult must be found in CX and OX after the addition.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;35. Select an AND instruction that will: &lt;br /&gt;(a) AND BX with DX and save the result in BX &lt;br /&gt;(b) AND OEAH with DH &lt;br /&gt;(c) AND DI with BP and save the result in DI &lt;br /&gt;(d) AND 1122H with EAX &lt;br /&gt;(e) AND the data addressed by BP with CX and save the result in memory &lt;br /&gt;(f) AND the data stored in four words before the location addressed by SI with OX and save &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the result in DX &lt;br /&gt;(g) AND AL with memory location WHAT and save the result at location WÂ·-IAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36. Develop a short sequence of instructions that clear (0) the three leftmost bits of DH without &lt;br /&gt;changing the remainder DH and store the result in BH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37. Select an OR instruction that will: &lt;br /&gt;(a) OR BL with AH and save the result in AH &lt;br /&gt;(b) OR 88H with ECX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5-8 QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(c) OR DX with SI and save the result in SI &lt;br /&gt;(d) OR 1122H with BP &lt;br /&gt;(e) OR the data addressed by BX with CX and save the result in memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;179 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(f) OR the data stored 40 bytes after the location addressed by BP with AL and save the &lt;br /&gt;result in AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(g) OR AH with memory location WHEN and save the result in WHEN &lt;br /&gt;38. Develop a short sequence of instructions that set (I) the rightmost 5-bits of DI without &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;changing the remaining bits of Dr. Save the result in SI. &lt;br /&gt;39. Select the XOR instruction that will: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) XOR BH with AH and save the result in AH &lt;br /&gt;(b) XOR 99H with CL &lt;br /&gt;(c) XOR DX with DI and save the result in DX &lt;br /&gt;(d) XOR lA23H with ESP &lt;br /&gt;(e) XOR the data addressed by EBX with DX and save the result in memory &lt;br /&gt;(f) XOR the data stored 30 words after the location addressed by BP with DI and save the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;result in DI &lt;br /&gt;(g) XOR DI with memory location WELL and save the result in DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40. Develop a sequence of instructions that set (1) the rightmost four bits of AX, clear (0) the &lt;br /&gt;leftmost three bits of AX, and invert bits 7, 8, and 9 of AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41. Describe the difference between the AND and TEST instructions. &lt;br /&gt;42. Select an instruction that tests bit position 2 of register CH. &lt;br /&gt;43. What is the difference between the NOT and NEG instructions? &lt;br /&gt;44. Select the correct instruction to perform each of the following tasks: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) shift DI right three places with zeros moved into the leftmost bit &lt;br /&gt;(b) move all bits in AL left one place, making sure that a 0 moves into the rightmost bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;position &lt;br /&gt;(c) rotate all the bits of AL left three places &lt;br /&gt;(d) rotate carry right one place through EDX &lt;br /&gt;(e) move the DH register right one place, making sure that the sign of the result is the same &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;as the sign of the original number &lt;br /&gt;45. What does the SCASB instruction accomplish? &lt;br /&gt;46. For string instructions, DI always addresses data in the segment. &lt;br /&gt;47. What is the purpose of the D flag bit? &lt;br /&gt;48. Explain what the REPE prefix does when coupled with the SCASB instruction. &lt;br /&gt;49. What condition or conditions will terminate the repeated string instruction REPNE SCASB? &lt;br /&gt;50. Describe what the CMPSB instruction accomplishes. &lt;br /&gt;51. Develop a sequence of instructions that scan through a 300H byte section of memory called &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LIST located in the data segment searching for a 66H. &lt;br /&gt;52. What happens if AH = 02H and DL = 43H when the INT 21H instruction is executed? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;180 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 6 &lt;br /&gt;Program Control Instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The program control instructions direct the flow of a program and allow the flow to change. &lt;br /&gt;A change in flow often occurs after a decision, made with the CMP or TEST instruction, is &lt;br /&gt;followed by a conditional jump instruction. This chapter explains the program control instruc-&lt;br /&gt;tions including the jumps, calls, returns, interrupts, and machine control instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also presented in this chapter are the relational assembly language statements (.IF, &lt;br /&gt;.ELSE â¢. ELSEIF â¢. ENDIF, .WHILE â¢ .ENDW â¢. REPEAT. and .UNTIL) that are available in &lt;br /&gt;version 6.0 and above of MASM. These relational assembly language commands allow the &lt;br /&gt;programmer to develop control flow portions of the program with C/C++ language efficiency. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Use both conditional and unconditional jump instructions to control the flow of a program. &lt;br /&gt;2. Use the relational assembly language statements .IF â¢. REPEAT, .WHILE. and so forth in &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;programs. &lt;br /&gt;3. Use the call and return instructions to include procedures in the program structure. &lt;br /&gt;4. Explain the operation of the interrupts and interrupt control instructions. &lt;br /&gt;5. Use machine control instructions to modify the flag bits. &lt;br /&gt;6. Use ENTER and LEAVE to enter and leave programming structures. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE JUMP GROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The main program control instruction. jump (JMP). allows the programmer to skip sections of a &lt;br /&gt;program and branch to any part of the memory for the next instruction. A conditional jump in-&lt;br /&gt;struction allows the programmer to make decisions based upon numerical tests. The results of &lt;br /&gt;these numerical tests are held in the flag bits. which are then tested by conditional jump instruc-&lt;br /&gt;tions. Another instruction similar to the conditional jump. the conditional set. is explained with &lt;br /&gt;the conditional jump instructions in this section. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-1 THE JUMP GROUP 181 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this section of the text, all jump instructions are illustrated with their uses in sample pro-&lt;br /&gt;grams. Also revisited are the LOOP and conditional LOOP instructions, first presented in &lt;br /&gt;Chapter 3, because they are also forms of the jump instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unconditional Jump (JMP) &lt;br /&gt;Three types of unconditional jump instructions (refer to Figure 6-1) are available to the micro-&lt;br /&gt;processor: short jump, near jump, and far jump. The short jump is a 2-byte instruction that allows &lt;br /&gt;jumps or branches to memory locations within + 127 and -128 bytes from the address following &lt;br /&gt;the jump. The 3-byte near jump allows a branch or jump within Â±32K bytes (or anywhere in the &lt;br /&gt;current code segment) from the instruction in the current code segment. Remember, the seg-&lt;br /&gt;ments are cyclical, which means that one location above offset address FFFFH is offset address &lt;br /&gt;OOOOH. For this reason, if you jump two bytes ahead in memory and the instruction pointer ad-&lt;br /&gt;dresses offset address FFFFH, the flow continues at offset address OOOIH. Thus, a displacement &lt;br /&gt;of Â±32K bytes allows a jump to any location within the current code segment. Finally, the 5-byte &lt;br /&gt;far jump allows a jump to any memory location within the entire real memory system. The short &lt;br /&gt;and near jumps are often called intrasegment jumps, and the far jumps are often called interseg-&lt;br /&gt;ment jumps. , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80386 through the Pentium Pro processors, the near jump is within Â±2G if the ma-&lt;br /&gt;chine is operated in the protected mode with a code segment of 40 bytes in length, and Â±32K &lt;br /&gt;bytes if operated in the real mode. In the protected mode, the 80386 and above use a 32-bit dis-&lt;br /&gt;placement that is not shown in Figure 6-1. The 80386 through the Pentium Pro allow a far jump &lt;br /&gt;to any location within the 40 byte address range of these microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Short Jump. Short jumps are called relative jumps because they can be moved, along with their &lt;br /&gt;related software, to any location in current code segment without a change. This is because the &lt;br /&gt;jump address is not stored with the opcode. Instead of a jump address, a distance or displace-&lt;br /&gt;ment follows the opcode. The short jump displacement is a distance represented by a I-byte &lt;br /&gt;signed number whose value ranges between +127 and -128. The short jump instruction appears &lt;br /&gt;in Figure 6-2. When the microprocessor executes a short jump, the displacement is sign-&lt;br /&gt;extended and added to the instruction pointer (IPJEIP) to generate the jump address within the &lt;br /&gt;current code segment. The short jump instruction branches to this new address for the next in-&lt;br /&gt;struction in the program; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-1 shows how short jump instructions pass control from one part of the program &lt;br /&gt;to another. It also illustrates the use of a label (symbolic name for a memory address) with the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-1 The three &lt;br /&gt;main forms of the JMP in-&lt;br /&gt;struction. Note that Disp is &lt;br /&gt;either an 8- or 16-bit signed &lt;br /&gt;displacement or distance. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(c) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Disp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Disp &lt;br /&gt;Low &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IP &lt;br /&gt;Low &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Disp &lt;br /&gt;High &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IP &lt;br /&gt;High &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;Low &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;High &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;182 CHAPTER 6 PROGRAM CONTROL I~JSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-2 A short jump &lt;br /&gt;to four memory locations &lt;br /&gt;beyond the address of the &lt;br /&gt;next instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1000A &lt;br /&gt;10009 &lt;br /&gt;10008 &lt;br /&gt;10007 &lt;br /&gt;10006 &lt;br /&gt;10005 &lt;br /&gt;10004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10003 &lt;br /&gt;10002 &lt;br /&gt;10001 &lt;br /&gt;10000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Jump to here) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04 &lt;br /&gt;JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS = 1000H &lt;br /&gt;IP = 0002H &lt;br /&gt;New IP =.IP 4- 4 &lt;br /&gt;New IP = 0006H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;jump instruction. Notice how one jump (JMP SHORT NEXT) uses the SHORT directive to &lt;br /&gt;force a short jump, while the other does not. Most assembler programs choose the best form of &lt;br /&gt;the jump instruction, so the second jump instruction (JMP START) also assembles as a short &lt;br /&gt;jump. If the address of the next instruction (0009H) is added to the sign-extended displacement &lt;br /&gt;(00 17H) of the first jump, the address of NEXT is at location 00 17H + 0009H or 0020H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-1 &lt;br /&gt;0000 33 DB XOR BX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 B8 0001 START: HOV AX,l &lt;br /&gt;0005 03 C3 ;:'.DD AX,BX &lt;br /&gt;0007 EB 17 JMP SHORT NEXT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 8B D8 NEXT: 110V BX,AX &lt;br /&gt;0022 EB DE JMP START &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever ajump instruction references an address, a label normally identifies the address. &lt;br /&gt;The JMP NEXT instruction is an example; it jumps to label NEXT for the next instruction. It is &lt;br /&gt;very rare ever to use an actual hexadecimal address with any jump instruction, but the assembler &lt;br /&gt;supports addressing in relation to the instruction pointer by using the $ + a displacement. For ex-&lt;br /&gt;ample, a JMP $+2 jumps over the next two memory locations following the JMP instruction. The &lt;br /&gt;label NEXT must be followed by a cololl (NEXT:) to alI ow an instruction to reference it for a &lt;br /&gt;jump. If a colon does not folIow a label, you cannot jump to it. Note that the only time a colon is &lt;br /&gt;used after a label is when the label is used with a jump or call instruction. &lt;br /&gt;Near Jump. The near jump is similar to the short jump except that the distance is farther. A &lt;br /&gt;Ilear jump passes control to an instruction in the current code segment located within Â±32K &lt;br /&gt;bytes from the near jump instruction or Â±2G in the 80386 and above operated in protected mode. &lt;br /&gt;The near jump is a 3-byte instruction that contains an ope ode folIowed by a signed 16--bit dis-&lt;br /&gt;placemc 1t. In the 80386 through the Pentium Pro processors, the displacement is 32-bits and the &lt;br /&gt;near jump is 5 bytes long. The signed displacement adds to the instruction pointer (lp) to gen-&lt;br /&gt;erate the jump address. Because the signed displacement is in the range of Â±32K, a near jump &lt;br /&gt;can jump to any memory location within the current real mode code segment. The protected &lt;br /&gt;mode code segment in the 80386 and above can be 4G bytes in length, so the 32-bit displacement &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-1 THE JUMP GROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-3 A near jump &lt;br /&gt;that adds the displacement &lt;br /&gt;(0002H) to the contents of IP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1000A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10009 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10008 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10007 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10006 &lt;br /&gt;10005 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Jump to here) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS = 1000H &lt;br /&gt;IP = 0002H &lt;br /&gt;New IP = 0006H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;} N&amp;quot;&amp;quot;i&amp;quot;mp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;183 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;allows a near jump to any location within Â±2G bytes. Figure 6-3 illustrates the operation of the &lt;br /&gt;real mode near jump instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The near jump is relocatable (as was the short jump) because it is also a relative jump. If &lt;br /&gt;the code segment moves to a new location in the memory, the distance between the jump in-&lt;br /&gt;struction and the operand address remains the same. This allows a code segment to be relocated &lt;br /&gt;simply by moving it. This feature, along with the relocatable data segments, makes the Intel &lt;br /&gt;family of microprocessors ideal for use in a general-purpose computer system. Software can be &lt;br /&gt;written and loaded anywhere in the memory and function without modification because of the &lt;br /&gt;relative jumps and relocatable data segments. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-2 shows the same basic program that appeared in Example 6-1, except that &lt;br /&gt;the jump distance is greater. The first jump (JMP NEXT) passes control to the instruction at &lt;br /&gt;offset memory location 0200H within the code segment. Notice that the instruction assembles &lt;br /&gt;as an E9 0200 R. The letter R denotes a relocatable jump address of 0200H. The relocatable ad-&lt;br /&gt;dress of 0200H is for the assembler program's internal use only. The actual machine language &lt;br /&gt;instruction assembles as an E9 F6 01, which does not appear in the assembler listing. The actual &lt;br /&gt;displacement is a 01 F6H for this jump instruction. The assembler lists the jump address as 0200 &lt;br /&gt;R, so the address is easier to interpret as software is developed. If the linked execution file &lt;br /&gt;(.EXE) or command file (.COM) is displayed in hexadecimal code, the jump instruction ap-&lt;br /&gt;pears as an E9 F6 01. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-2 &lt;br /&gt;0000 33 DB XOR BX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 B8 0001 START: MOV AX,l &lt;br /&gt;0005 03 C3 ADD AX,BX &lt;br /&gt;0007 E9 0200 R JMP NEXT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0200 88 D8 NEXT: NOV BX,AX &lt;br /&gt;0202 E9 0002 R JMP START &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Far Jump. A far jump instruction (see Figure 6-4) obtains a new segment and offset address to &lt;br /&gt;accomplish the jump. Bytes 2 and 3 of this 5-byte instruction contain the new offset address, &lt;br /&gt;and bytes 4 and 5 contain the new segment address. If the microprocessor (80286 through the &lt;br /&gt;Pentium Pro) is operated in the protected mode, the segment address accesses a descriptor that &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;184 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-4 A far jump &lt;br /&gt;instruction replaces the &lt;br /&gt;contents of both CS and IP &lt;br /&gt;with four bytes following the &lt;br /&gt;opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3129 &lt;br /&gt;A3128 &lt;br /&gt;A3127 &lt;br /&gt;A3126 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Jump to here) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10004 &lt;br /&gt;10003 &lt;br /&gt;10002 &lt;br /&gt;10001 &lt;br /&gt;10000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 &lt;br /&gt;00 &lt;br /&gt;01 &lt;br /&gt;27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Far jump &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;contains the base address of the far jump segment. The offset address, which is either 16- or 32-&lt;br /&gt;bits, contains the offset location within the new code segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-3 lists a short program that uses a far jump instruction. The far jump instruc-&lt;br /&gt;tion sometimes appears with the FAR PTR directive, as illustrated. Another way to obtain a far &lt;br /&gt;jump is to define a label as afar label. A label is far only if it is external to the current code seg-&lt;br /&gt;ment or procedure. The JMP UP instruction in the Example 6-3 references a far label. The label &lt;br /&gt;UP is defined as a far label by the EXTRN UP:FAR directive. External labels appear in pro-&lt;br /&gt;grams that contain more than one program file. Another way of defining a label as global is to &lt;br /&gt;use a double colon (LABEL::) following the label in place of the single colon. This is required &lt;br /&gt;inside procedure blocks that are defined as near if the label is accessed from outside the proce-&lt;br /&gt;dure block. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-3 &lt;br /&gt;EXTRN UP:FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 33 DB XOR BX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 B8 0001 START: MOV AX,1 &lt;br /&gt;0005 03 C3 ADD AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, 0007 E9 0200 R JMP NEXT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0200 8B D8 NEXT: MOV BX,AX &lt;br /&gt;0202 EA 0002 ---- R JMP FAR PTR START &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0207 EA 0000 ---- E JMP UP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When the program files are joined, the linker inserts the address for the UP label into the &lt;br /&gt;JMP UP instruction. It also inserts the segment address in the JMP START instruction. The seg-&lt;br /&gt;ment address in JMP FAR PTR START is listed as - - - - R for relocatable; the segment address &lt;br /&gt;in JMP UP is listed as - - - - E for external. In both cases, the - - - - is filled in by the linker &lt;br /&gt;when it links or joins the program files. &lt;br /&gt;Jumps with Register Operands. The jump instruction can also use a 16- or 32-bit register as an &lt;br /&gt;operand. This automatically sets up the instruction as an indirect jump. The address of the jump &lt;br /&gt;is in the register specified by the jump instruction. Unlike the displacement associated with the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-1 THE JUMP GROUP 185 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;near jump, the contents of the register are transferred directly into the instruction pointer. An in-&lt;br /&gt;direct jump does not add to the instruction pointer, as with short and near jumps. The JMP AX &lt;br /&gt;instruction, for example, copies the contents of the AX register into the IP when the jump occurs. &lt;br /&gt;This allows a jump to any location within the current code segment. In the 80386 and above, a &lt;br /&gt;JMP EA X instruction also jumps to any location within the current code segment; the difference &lt;br /&gt;is that in protected mode the code segment can be 40 bytes long so a 32-bit offset address is &lt;br /&gt;needed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-4 shows how the JMP AX instruction accesses a jump table in the code seg-&lt;br /&gt;ment. This program reads a key from the keyboard and then modifies the ASCII code to a OOH in &lt;br /&gt;AL for a '1', a OIH for a '1', and a 02H for a '3'. If a 'i', '2', or '3' is typed, AH is cleared to &lt;br /&gt;OOH. Because the jump table contains 16-bit offset addresses, the contents of AX are doubled to &lt;br /&gt;0,2, or 4, so a 16-bit entry in the table can be accessed. Next, the offset address of the start of the &lt;br /&gt;jump table is loaded to SI, and AX is added to form the reference to the jump address. The MOV &lt;br /&gt;AX,[SI] instruction then fetches an address from the jump table, so the JMP AX instruction &lt;br /&gt;jumps to the addresses (ONE, TWO, or THREE) stored in the jump table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 0030 R &lt;br /&gt;0002 0034 R &lt;br /&gt;0004 0038 R &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;0017 &lt;br /&gt;0019 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001B &lt;br /&gt;001D &lt;br /&gt;001F &lt;br /&gt;0021 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0023 &lt;br /&gt;0025 &lt;br /&gt;0027 &lt;br /&gt;002A &lt;br /&gt;002C &lt;br /&gt;002E &lt;br /&gt;0030 &lt;br /&gt;0030 &lt;br /&gt;0032 &lt;br /&gt;0034 &lt;br /&gt;0034 &lt;br /&gt;0036 &lt;br /&gt;0038 &lt;br /&gt;0038 &lt;br /&gt;003A &lt;br /&gt;003A &lt;br /&gt;003C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B4 01 &lt;br /&gt;CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2C 31 &lt;br /&gt;72 F8 &lt;br /&gt;3C 02 &lt;br /&gt;77 F4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B4 00 &lt;br /&gt;03 CO &lt;br /&gt;BE 0000 R &lt;br /&gt;03 FO &lt;br /&gt;8B 04 &lt;br /&gt;FF EO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B2 31 &lt;br /&gt;EB 06 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B2 32 &lt;br /&gt;EB 02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B2 33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B4 02 &lt;br /&gt;CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that reads 1, 2, or 3 from the keyboard &lt;br /&gt;;if a 1, 2, or 3 is typed, a 1, 2, or 3 is displayed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;TABLE DW ONE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TOP: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ONE: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TWO: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THREE: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOT: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DW TWO &lt;br /&gt;DW THREE &lt;br /&gt;. CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;INT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB &lt;br /&gt;JB &lt;br /&gt;CMP &lt;br /&gt;JA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;ADD &lt;br /&gt;MOV &lt;br /&gt;ADD &lt;br /&gt;MOV &lt;br /&gt;JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;INT &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,l &lt;br /&gt;21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,31H &lt;br /&gt;TOP &lt;br /&gt;AL,2 &lt;br /&gt;TOP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,O &lt;br /&gt;AX,AX &lt;br /&gt;SI,OFFSET TABLE &lt;br /&gt;SI,AX &lt;br /&gt;AX, [51] &lt;br /&gt;AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DL, '1' &lt;br /&gt;BOT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DL, '2' &lt;br /&gt;BOT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DL, '3' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,2 &lt;br /&gt;21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;;define lookup table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key into AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;convert to binary &lt;br /&gt;;if below '1' typed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if above '3' typed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;double to 0, 2, or 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address lookup table &lt;br /&gt;;form lookup address &lt;br /&gt;;get ONE, TWO, or THREE &lt;br /&gt;;jump address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load '1' for display &lt;br /&gt;;go display '1' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load '2' for display &lt;br /&gt;;go display '2' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load '3' for display &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to 005 &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Indirect Jumps Using an Index. The jump instruction may also use the [ ] form of addressing to &lt;br /&gt;directly access the jump table. The jump table can contain offset addresses for near indirect &lt;br /&gt;jumps or segment and offset addresses for far indirect jumps. (This type of jump is also known &lt;br /&gt;as a double-indirect jump if the register jump is called an indirect jump.) The assembler assumes &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;186 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;that the jump is near unless the FAR PTR directive indicates a far jump instruction. Here, Ex-&lt;br /&gt;ample 6-5 repeats Example 6-4 by using the JMP TABLE [SI] instead of JMP AX. This reduces &lt;br /&gt;the length of the program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-5 &lt;br /&gt;MODEL SMALL ;select SMALL model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . DATA ;start of DATA segment &lt;br /&gt;0000 002D R TABLE DW ONE ;lookup table &lt;br /&gt;0002 0031 R DW TWO &lt;br /&gt;0004 0035 R DW THREE &lt;br /&gt;0000 .CODE ;start of CODE segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP ;start of program &lt;br /&gt;0017 TOP: &lt;br /&gt;0017 B4 01 MOV AH,l ; read key to AL &lt;br /&gt;0019 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001B 2C 31 SUB AL,31H ;test for below '1 ' &lt;br /&gt;001D 72 F8 JB TOP ;if below '1' &lt;br /&gt;001F 3C 02 CMP AL,2 &lt;br /&gt;0021 77 F4 JA TOP ;if above '3 ' &lt;br /&gt;0023 B4 00 MOV AH,O ;calculate table address &lt;br /&gt;0025 03 CO ADD AX,AX &lt;br /&gt;0027 03 FO ADD SI,AX &lt;br /&gt;0029 FF A4 0000 R JMP TABLE lSI] ;jump to ONE, TWO, or THREE &lt;br /&gt;002D ONE: &lt;br /&gt;002D B2 31 MOV DL,' l' ; load DL with '1 ' &lt;br /&gt;002F EB 06 JMP BOT &lt;br /&gt;0031 TWO: &lt;br /&gt;0031 B2 32 MOV DL, '2' ;load DL with '2 ' &lt;br /&gt;0033 EB 02 JMP BOT &lt;br /&gt;0035 THREE: &lt;br /&gt;0035 B2 33 MOV DL,' 3' ;load DL with '3 ' &lt;br /&gt;0037 BOT: &lt;br /&gt;0037 B4 02 MOV AH,2 ;display ONE, TWO, or THREE &lt;br /&gt;0039 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT ;exit to DOS &lt;br /&gt;END ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The mechanism used to access the jump table is identical with a nonnal memory reference. &lt;br /&gt;The JMP TABLE [SI] instruction points to ajump address stored at the code segment offset lo-&lt;br /&gt;cation addressed by SI. It jumps to the address stored in the memory at this location. Both the &lt;br /&gt;register and indirect indexed jump instructions usually address a 16-bit offset. This means that &lt;br /&gt;both types of jumps are near jumps. If a JMP FAR PTR [SI] or JMP TABLE [SI], with TABLE &lt;br /&gt;data defined with the DD directive, appear in a program, the microprocessor assumes that the &lt;br /&gt;jump table contains doubleword, 32-bit addresses (IP and CS). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conditional Jumps and Conditional Sets &lt;br /&gt;Conditional jump instructions are always short jumps in the 8086 through the 80286 micro-&lt;br /&gt;processors. This limits the range of the jump to within + 127 bytes and -128 bytes from the loca-&lt;br /&gt;tion following the conditional jump. In the 80386 and above, conditional jumps are either short &lt;br /&gt;or near jumps. This allows these microprocessors to use a conditional jump to any location &lt;br /&gt;within the current code segment. Table 6--1 lists all the conditional jump instructions with their &lt;br /&gt;test conditions. Note that the Microsoft MASM version 6.X assembler automatically adjusts &lt;br /&gt;conditional jumps if the distance is too great. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The conditional jump instructions test the following flag bits: sign (S), zero (Z), carry (C), &lt;br /&gt;parity (P), and overflow (0). If the condition under test is true, a branch to the label associated &lt;br /&gt;with the jump instruction occurs. If the condition is false, the next sequential step in the program &lt;br /&gt;executes. For example, a JC will jump if the carry bit is set. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-1 THE JUMP GROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 6-1 Conditional jump instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JA &lt;br /&gt;JAE &lt;br /&gt;JB &lt;br /&gt;JBE &lt;br /&gt;JC &lt;br /&gt;JE or JZ &lt;br /&gt;JG &lt;br /&gt;JGE &lt;br /&gt;JL &lt;br /&gt;JLE &lt;br /&gt;JNC &lt;br /&gt;JNE or JNZ &lt;br /&gt;JNO &lt;br /&gt;JN8 &lt;br /&gt;JNP orJPO &lt;br /&gt;JO &lt;br /&gt;JP or JPE &lt;br /&gt;J8 &lt;br /&gt;JCXZ &lt;br /&gt;JECXZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Condition Tested &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Z = 0 and C = 0 &lt;br /&gt;'::=0 &lt;br /&gt;C = 1 &lt;br /&gt;Z = 1 or C = 1 &lt;br /&gt;C = 1 &lt;br /&gt;Z=1 &lt;br /&gt;Z = 0 and 8 = 0 &lt;br /&gt;8=0 &lt;br /&gt;8&amp;lt;&amp;gt;0 &lt;br /&gt;Z = 1 or 8 &amp;lt;&amp;gt; 0 &lt;br /&gt;C=O &lt;br /&gt;Z=O &lt;br /&gt;0=0 &lt;br /&gt;8=0 &lt;br /&gt;p=o &lt;br /&gt;0=1 &lt;br /&gt;P=1 &lt;br /&gt;8=1 &lt;br /&gt;CX=O &lt;br /&gt;ECX=O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Jump if above &lt;br /&gt;Jump if above or equal &lt;br /&gt;Jump if below &lt;br /&gt;Jump if below or equal &lt;br /&gt;Jump if carry set &lt;br /&gt;Jump if equal or jump if zero &lt;br /&gt;Jump if greater than &lt;br /&gt;Jump if greater than or equal &lt;br /&gt;Jump if less than &lt;br /&gt;Jump if less than or equal &lt;br /&gt;Jump if no carry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;187 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Jump if not equal or jump if not zero &lt;br /&gt;Jump if no overflow &lt;br /&gt;Jump if no sign &lt;br /&gt;Jump if no parity or jump if parity odd &lt;br /&gt;Jump if overflow set &lt;br /&gt;Jump if parity set or jump if parity even &lt;br /&gt;Jump if sign is set &lt;br /&gt;Jump if CX is zero &lt;br /&gt;Jump if ECX is zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The operation of most conditional jump instructions is straightforward because they often &lt;br /&gt;test just one flag bit, although some test more than one. Relative magnitude comparisons require &lt;br /&gt;more complicated conditional jump instructions that test more than one flag bit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because both signed and unsigned numbers are used in programming, and because the &lt;br /&gt;order of these numbers is different, there are two sets of conditional jump instructions for mag-&lt;br /&gt;nitude comparisons. Figure 6-5 shows the order of both signed and unsigned 8-bit numbers. The &lt;br /&gt;16- and 32-bit numbers follow the same order as the 8-bit numbers except that they are larger. &lt;br /&gt;Notice that an FFH (255) is above the DOH in the set of unsigned numbers, but an FFH (-1) is &lt;br /&gt;less than DOH for signed numbers. Therefore, an unsigned FFH is above DOH, but a signed FFH &lt;br /&gt;is less than DOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-5 8igned and &lt;br /&gt;unsigned numbers follow &lt;br /&gt;different orders. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unsigned numbers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;254 FEH 5500 &lt;br /&gt;132 &lt;br /&gt;131 &lt;br /&gt;130 &lt;br /&gt;129 &lt;br /&gt;128 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;3 &lt;br /&gt;2 &lt;br /&gt;1 &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;....--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-84H &lt;br /&gt;83H &lt;br /&gt;82H &lt;br /&gt;81H &lt;br /&gt;80H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H &lt;br /&gt;03H &lt;br /&gt;02H &lt;br /&gt;01H &lt;br /&gt;OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Signed numbers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+126 7EH l27QLJ &lt;br /&gt;+2 &lt;br /&gt;+1 &lt;br /&gt;+0 &lt;br /&gt;-1 &lt;br /&gt;-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-124 &lt;br /&gt;-125 &lt;br /&gt;-126 &lt;br /&gt;-127 &lt;br /&gt;-128 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-02H &lt;br /&gt;01H &lt;br /&gt;OOH &lt;br /&gt;FFH &lt;br /&gt;FEH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;84H &lt;br /&gt;83H &lt;br /&gt;82H &lt;br /&gt;81H &lt;br /&gt;80H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;188 CHAPTER 6 PROGRAM CONTROL INSTRUCTiONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When signed numbers are compared, use the JG, JL, JGE, JLE, JE, and JNE instructions. &lt;br /&gt;The terms greater thall and less than refer to signed numbers. When unsigned numbers are com-&lt;br /&gt;pared, use the JA, JB, JAE, JBE, JE, and JNE instructions. The terms above and below refer to &lt;br /&gt;unsigned numbers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The remaining conditional jumps test individual flag bits such as overflow and parity. No-&lt;br /&gt;tice that JE has an alternative opcode JZ. All instructions have alternates, but many aren't used in &lt;br /&gt;programming because they don't usually fit the condition under test. (The alternates appear in &lt;br /&gt;Appendix B with the instruction set listing.) For example, the JA (jump if above) instruction has &lt;br /&gt;the alternative JNBE (jump if not below or equal). A JA functions exactly as a JNBE, but JNBE &lt;br /&gt;is awkward in many cases when compared to JA. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The conditional jump instructions all test flag bits, except for JCXZ (jump if CX = 0) and &lt;br /&gt;JECXZ (jump if ECX = 0). Instead of testing flag bits, JCXZ directly tests the contents of the CX &lt;br /&gt;register without affecting the flag bits, and JECXZ tests the contents of the ECX register. For the &lt;br /&gt;JCXZ instruction, if CX = 0, a jump occurs; if CX &amp;lt;&amp;gt; 0, no jump occurs. Likewise for the &lt;br /&gt;JECXZ instruction, if ECX = 0, ajump occurs; if CX &amp;lt;&amp;gt; 0, no jump occ~rs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A program that uses JCXZ appears in Example 6-6. Here the SCASB instruction searches &lt;br /&gt;a table for a OAH. Following the search, a JCXZ instruction tests CX to see if the count has &lt;br /&gt;reached zero. If the count is zero, the OAH is not found in the table. The carry flag is used in this &lt;br /&gt;example to pass the not found condition back to the calling program. Another method used to &lt;br /&gt;test to see if the data are found is the JNE instruction. If JNE replaces JCXZ, it performs the &lt;br /&gt;same function. After the SCASB instruction executes, the flags indicate a not-equal condition if &lt;br /&gt;the data were not found in the table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B9 0064 &lt;br /&gt;001A BO OA &lt;br /&gt;001C FC &lt;br /&gt;OOlD F2/AE &lt;br /&gt;001F F9 &lt;br /&gt;0020 E3 01 &lt;br /&gt;0022 F8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0023 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0023 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that searches a table of 100 bytes for OAH &lt;br /&gt;;The address, TABLE, is transferred to the procedure &lt;br /&gt;;through the S1 register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCAN PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,100 ;load count of 100 &lt;br /&gt;MOV AL,OAH ;load AL with OAH &lt;br /&gt;CLD ;se1ect increment &lt;br /&gt;REPNE SCASB ;test 100 bytes for OAH &lt;br /&gt;STC ;set carry for not found &lt;br /&gt;JCXZ NOT_FOUND ;if not found &lt;br /&gt;CLC ;clear carry if found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOT_FOUND: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET ;return from procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCAN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Conditional Set Instructions. In addition to the conditional jump instructions, the 80386 &lt;br /&gt;through the Pentium Pro processors also contain conditional set instructions. The conditions &lt;br /&gt;tested by conditional jumps are put to work with the conditional set instructions. The conditional &lt;br /&gt;set instructions set a byte to either a OIH or clear a byte to OOH, depending on the outcome of the &lt;br /&gt;condition under test. Table 6-2 lists the available forms of the conditional set instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;These instructions are useful where a condition must be tested at a point much later in the &lt;br /&gt;program. For example, a byte can be set to indicate that the carry is c;zared at some point in the &lt;br /&gt;program by using the SETNC MEM instruction. This instruction places a OIH into memory lo-&lt;br /&gt;cation MEM if carry is cleared, and a OOH into MEM if carry is set. The contents of MEM can be &lt;br /&gt;tested at a later point in the program to determine if carry is cleared at the point where the &lt;br /&gt;SETNC MEM instruction executed. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-1 THE JUMP GROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 6-2 The conditional set instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SETS &lt;br /&gt;SETAE &lt;br /&gt;SETSE &lt;br /&gt;SETA &lt;br /&gt;SETE or SETZ &lt;br /&gt;SETNE or SETNZ &lt;br /&gt;SETL &lt;br /&gt;S!=TLE &lt;br /&gt;SETG &lt;br /&gt;SETGEÂ· &lt;br /&gt;SETS &lt;br /&gt;SETNS &lt;br /&gt;SETC &lt;br /&gt;SETNC &lt;br /&gt;SETO &lt;br /&gt;SETNO &lt;br /&gt;SETP or SETPE &lt;br /&gt;SETNP or SETPO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Condition Tested &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C = 1 &lt;br /&gt;C=O &lt;br /&gt;Z = 1 or C = 1 &lt;br /&gt;Z = 0 and C = 0 &lt;br /&gt;Z=1 &lt;br /&gt;Z=O &lt;br /&gt;S&amp;lt;&amp;gt;O &lt;br /&gt;Z = 1 or S &amp;lt;&amp;gt; 0 &lt;br /&gt;Z = 0 and S = 0 &lt;br /&gt;S=O &lt;br /&gt;S = 1 &lt;br /&gt;S=O &lt;br /&gt;C = 1 &lt;br /&gt;C=O &lt;br /&gt;0= 1 &lt;br /&gt;0=0 &lt;br /&gt;P=1 &lt;br /&gt;P=O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Set if below &lt;br /&gt;Set if above or equal &lt;br /&gt;Set if below or equal &lt;br /&gt;Set if above &lt;br /&gt;Set if equal or set if zero &lt;br /&gt;Set if not equal or set if not zero &lt;br /&gt;Set if less than &lt;br /&gt;Set if less than or equal &lt;br /&gt;Set if greater than &lt;br /&gt;Set if greater than or equal &lt;br /&gt;Set if sign (negative) &lt;br /&gt;Set if no sign (positive) &lt;br /&gt;Set if carry &lt;br /&gt;Set if no carry &lt;br /&gt;Set if overflow &lt;br /&gt;Set if no overflow &lt;br /&gt;Set if parity or set if parity even &lt;br /&gt;Set if no parity or set if parity odd &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;189 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The LOOP instruction is a combination of a decrement CX and the JNZ conditional jump. In the &lt;br /&gt;8086 through the 80286, LOOP decrements CX and if CX &amp;lt;&amp;gt; 0, it jumps to the address indicated &lt;br /&gt;by the labeL IfCX becomes a 0, the next sequential instruction executes. In the 80386 and above, &lt;br /&gt;LOOP decrements either CX or ECX, depending upon the instruction mode. If the 80386 and &lt;br /&gt;above operate in the l6-bit instruction mode, LOOP uses CX; if operated in the 32-bit instruction &lt;br /&gt;mode, LOOP uses ECX. This default is changed by the LOOPW (using CX) and LOOPD (using &lt;br /&gt;ECX) instructions in the 80386 through the Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-7 shows how data in one block of memory (BLOCKl) add to data in a second &lt;br /&gt;block of memory (BLOCK2) using LOOP to control how many numbers add. The LODSW and &lt;br /&gt;STOSW instructions access the data in BLOCKl and BLOCK2. The ADD AX,ES:[DI] instruc-&lt;br /&gt;tion accesses the data in BLOCK2 located in the extra segment The only reason that BLOCK2 &lt;br /&gt;is in the extra segment is that DI addresses extra segment data for the STOSW instruction. The &lt;br /&gt;.STARTUP directive only loads DS with the address of the data segment In this example, &lt;br /&gt;the extra segment also addresses data in the data segment, so the contents of DS are copied to &lt;br /&gt;ES through the accumulator. Unfortunately, there is no direct move from segment-register-to-&lt;br /&gt;segment-register instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 0064 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCS 0064 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that sums the contents of BLOCK1 and BLOCK2 &lt;br /&gt;;and stores the results over top of the data in BLOCK2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL ;se1ect SMALL model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA ;start of DATA segment &lt;br /&gt;BLOCK1 DW 100 DUP (? ) ;100 bytes for BLOCK1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;BLOCK2 DW 100 DUP (? ) ;100 bytes for BLOCK2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;190 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 6 PROGRAM CON1ROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;() 1...1 L' C .:-::';E ;start of CODE segment &lt;br /&gt;~-- - ---- ;start of program ...... ---- - ... -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.; &amp;quot;)1 &amp;quot;7 8C DS EC-.- .'.X,DS ; overlap DS and ES &lt;br /&gt;0019 8E ~, r1C-.- O:S,.'.X '-\\, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OO:B FC C-, ;select increment &lt;br /&gt;OOlC B9 0064 110\\' CX,IOO ;load count of 100 &lt;br /&gt;OOIF BE 0000 R 110\\- SI,OFFSET BLOCKl ;address BLOCKl &lt;br /&gt;0022 BF OOCS R HO\\' D:L,OFFSET BLOCK2 ; address BLOCK2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0025 Ll: &lt;br /&gt;0025 AD LODS\\&amp;gt;i ;load AX with BLOCKl &lt;br /&gt;0026 26:03 05 ADD AX, ES: [DI] ;add BLOCK2 data to AX &lt;br /&gt;0029 AB STOSW ;store sum in BLOCK2 &lt;br /&gt;002A E2 F9 LOOP Ll ; repeat 100 times &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT ;exit to DOS &lt;br /&gt;END ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conditional LOOPs. As with REP, the LOOP instruction also has conditional fonns: LOOPE &lt;br /&gt;and LOOPNE. The LOOPE (loop while equal) instruction jumps ifCX &amp;lt;&amp;gt; 0 while an equal con-&lt;br /&gt;dition exists. It will exit the loop if the condition is not equal or if the CX register decrements to &lt;br /&gt;O. The LOOPNE (loop while not equal) instruction jumps if CX &amp;lt;&amp;gt; 0 while a not-equal condi-&lt;br /&gt;tion exists. It will exit the loop if the condition is equal or if the CX register decrements to O. In &lt;br /&gt;the 80386 through the Pentium Pro processors the conditional LOOP instruction can use either &lt;br /&gt;CX or ECX as the counter. The LOOPEWILOOPED or LOOPNEWILOOPNED instructions &lt;br /&gt;override the instruction mode if needed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with the conditional repeat instructions, alternates exist for LOOPE and LOOPNE. The &lt;br /&gt;LOOPE instruction is the same as LOOPZ, and the LOOPNE is the same as LOOPNZ. In most &lt;br /&gt;programs, only the LOOPE and LOOPNE apply. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTROLLING THE FLOW OF AN ASSEMBLY LANGUAGE PROGRAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It is much easier to use the assembly language statements .IF, .ELSE, .ELSEIF, and .ENDIF to &lt;br /&gt;control the flow of the program than it is to use the correct conditional jump statement. These &lt;br /&gt;statements always indicate a special assembly language command to MASM. Note that the con-&lt;br /&gt;trol flow assembly language statements beginning with a period are available only to MASM &lt;br /&gt;version 6.x and not to earlier versions of the assembler. Other statements developed in this &lt;br /&gt;chapter include the DO-WHILE and REPEAT-UNTIL loops. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-8 shows how these statements are used to control the flow of a program by &lt;br /&gt;testing the system for the version of DOS. Notice that in this example DOS INT 21H, function &lt;br /&gt;number 30H is used to read the DOS version. The version is tested to detennine if it is above or &lt;br /&gt;below version 3.3. If it is below version 3.3, the program terminates, using DOS INT 21H func-&lt;br /&gt;tion number 4CH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-8 (a) shows the source program sequence as it was typed; Example 6-8 &lt;br /&gt;(b) shows the fully expanded assembled output generated by the assembler program. Notice &lt;br /&gt;that assembler-generated and -inserted statements begin with an asterisk (*) in the listing. The &lt;br /&gt;.IF AL&amp;lt;3 &amp;amp;&amp;amp; AH&amp;lt;30 statement tests for DOS version 3.30. If the major version number (AL) &lt;br /&gt;is less than 3 AND the minor version number (AH) is less than 30, the MOY AH,O and INT &lt;br /&gt;21 H instructions execute. Notice how the &amp;amp;&amp;amp; symbol represents the word AND in the iF state-&lt;br /&gt;ment. Refer to Table 6-3 for a complete list of relation operators used with the .IF statement. &lt;br /&gt;Note that many of these conditions (such as &amp;amp;&amp;amp;) are also used by many high-level languages &lt;br /&gt;such as C/C++. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-2 CONTROLLING THE FLOW OF AN ASSEMBLY LANGUAGE PROGRAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-8 (a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-8 (b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 84 30 &lt;br /&gt;0002 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 3C 03 &lt;br /&gt;0006 73 09 &lt;br /&gt;0008 80 FC 1E &lt;br /&gt;0008 73 04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOD 84 4C &lt;br /&gt;OOOF CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;SOUlce program sequence &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Nm- ,c.H,30H &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF ~~&amp;lt;3 &amp;amp;&amp;amp; AH&amp;lt;30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV .~.H,4CH &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get DOS version &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;terminate program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;assembled listing file of Example 6-8 (a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV AH,30H &lt;br /&gt;INT 21H ;get DOS version &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF ALd &amp;amp;&amp;amp; AH&amp;lt;30 &lt;br /&gt;cmp al,003h &lt;br /&gt;jae @COO01 &lt;br /&gt;cmp ah,OlEh &lt;br /&gt;jae @COO01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV riH,4CH ;terminate program &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;* @COO01: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;191 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-9 shows another example of the conditional .IF directive that converts all &lt;br /&gt;ASCII-coded letters to uppercase. First, the keyboard is read without echo using the DOS INT &lt;br /&gt;21H function 06H, and then the .IF statement converts the character into uppercase if needed. &lt;br /&gt;In this example, the logical AND function (&amp;amp;&amp;amp;) is used to determine if the character is lower-&lt;br /&gt;case. This program reads a key from the keyboard and converts it to uppercase before dis-&lt;br /&gt;playing it. Notice also how the program terminates when the control C key (ASCII = 03H) is &lt;br /&gt;typed. The .LISTALL directive causes all assembler-generated statements to be listed, in-&lt;br /&gt;cluding the label @Startup generated by the .STARTUP directive. The .EXIT directive also is &lt;br /&gt;expanded by .LISTALL to show the use of the DOS INT 21H function 4CH, which returns &lt;br /&gt;control to DOS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 6-3 Relational &lt;br /&gt;operators used with the .IF &lt;br /&gt;statement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operator &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;!= &lt;br /&gt;&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;gt;= &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;lt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;lt;= &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;amp; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;amp;&amp;amp; &lt;br /&gt;II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Equal or the same as &lt;br /&gt;Not equal &lt;br /&gt;Greater than &lt;br /&gt;Greater than or equal &lt;br /&gt;Less than &lt;br /&gt;Less than or equal &lt;br /&gt;Bit test &lt;br /&gt;Logical inversion &lt;br /&gt;Logical AND &lt;br /&gt;Logical OR &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;192 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 &lt;br /&gt;0100 &lt;br /&gt;0100 &lt;br /&gt;0102 &lt;br /&gt;0104 &lt;br /&gt;0106 &lt;br /&gt;0108 &lt;br /&gt;010A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B4 06 &lt;br /&gt;B2 FF &lt;br /&gt;CD 21 &lt;br /&gt;74 F8 &lt;br /&gt;3C 03 &lt;br /&gt;74 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010C 3C 61 &lt;br /&gt;010E 72 06 &lt;br /&gt;0110 3C 7A &lt;br /&gt;0112 77 02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0114 2C 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0116 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0116 8A DO &lt;br /&gt;0118 CD 21 &lt;br /&gt;011A EB E4 &lt;br /&gt;011C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;011C B4 4C &lt;br /&gt;011E CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;a program that reads th(Â· 'Â·:eyboard and converts all &lt;br /&gt;;lowercase data to upperCd&amp;quot;,e before displaying it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;this program uses a control C for termination &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.LISTALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;* @Startup: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN1: &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;INT &lt;br /&gt;JE &lt;br /&gt;CMP &lt;br /&gt;JE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,6 &lt;br /&gt;DL,OFFH &lt;br /&gt;21H &lt;br /&gt;MAIN1 &lt;br /&gt;AL,3 &lt;br /&gt;MAIN2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select TINY model &lt;br /&gt;;list all statements &lt;br /&gt;;start CODE segment &lt;br /&gt;;start program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key without echo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if no key typed &lt;br /&gt;;test for control C key &lt;br /&gt;;if control C key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF AL&amp;gt;='a' &amp;amp;&amp;amp; AL&amp;lt;='z' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cmp &lt;br /&gt;jb &lt;br /&gt;cmp &lt;br /&gt;ja &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;aI, 'a' &lt;br /&gt;@COOOI &lt;br /&gt;aI, , z' &lt;br /&gt;@COOOI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;* @C0001: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,AL &lt;br /&gt;INT 21H &lt;br /&gt;JIYIP MAIN1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mov &lt;br /&gt;int &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ah, 04Ch &lt;br /&gt;021h &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;echo character to display &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; repeat &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS on control C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this program, a lowercase letter is converted to uppercase by the use of the .IF AL &amp;gt;= 'a' &lt;br /&gt;&amp;amp;&amp;amp; AL &amp;lt;= 'z' statement. If AL contains a value that is greater than or equal to a lowercase a and &lt;br /&gt;less than or equal to a lowercase z (a value of a-z), then the statement between the .IF and &lt;br /&gt;.ENDIF executes. This statement (SUB AL,20H) subtracts 20H from the lowercase letter to &lt;br /&gt;change it to an uppercase letter. Notice how the assembler program implements the .IF statement &lt;br /&gt;(see lines that begin with a *). The label @COOOI is an assembler-generated label used by the &lt;br /&gt;conditional jump statements placed in the program by the .IF statement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another example using the conditional .IF statement appears in Example 6-10. This pro-&lt;br /&gt;gram reads a key from the keyboard and then converts it to hexadecimal code. This program is &lt;br /&gt;not listed in expanded form. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this example, the.IF AL &amp;gt;='a' &amp;amp;&amp;amp; AL&amp;lt;= 'f' statement causes the next instruction (SUB &lt;br /&gt;AL,57H) to execute if AL contains letters a through f, converting them to hexadecimal. If it is &lt;br /&gt;not between letters a through f, the next .ELSEIF statement tests it for the letters A through F. If &lt;br /&gt;it is letters A through F, a 37H is subtracted from AL. If neither of these are true, a 30H is sub-&lt;br /&gt;tracted from AL before AL is stored at data segment memory location TEMP. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-10 &lt;br /&gt;;A program that reads a key and stores its hexadecimal &lt;br /&gt;;va1ue in memory location TEMP. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;EXAMPLE 6-11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 OD OA &lt;br /&gt;0002 0100 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 BC DB &lt;br /&gt;0019 8E CO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001B FC &lt;br /&gt;001C BF 0002 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001F EB 05 &lt;br /&gt;0021 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 B4 01 &lt;br /&gt;0023 CD 21 &lt;br /&gt;0025 M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6-2 CONTROLLING THE FLOW OF AN ASSEMBLY LANGUAGE PROGRAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;0000 . DATA &lt;br /&gt;0000 00 TEMP DB ? &lt;br /&gt;0000 .CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0017 B4 01 MOV AH,1 &lt;br /&gt;0019 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF AL&amp;gt;='a' &amp;amp;&amp;amp; AL&amp;lt;='f' &lt;br /&gt;0023 2C 57 SUB AL,5'7H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ELSEIF AL&amp;gt;='A' &amp;amp;&amp;amp; AL&amp;lt;='F' &lt;br /&gt;002F 2C 37 SUB AL,37H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ELSE &lt;br /&gt;0033 2C 30 SUB AL,30H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0035 A2 0000 R MOV TEMP,AL &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO-WHILE Loops &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start DATA segment &lt;br /&gt;;define TEMP &lt;br /&gt;;start CODE segment &lt;br /&gt;;start program &lt;br /&gt;;read key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if lowercase &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if uppercase &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; otherwise &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;193 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with most higher level languages, the assembler also provides the DO-WHILE loop con-&lt;br /&gt;struct, available to MASM version 6X. The .WHILE statement is used with a condition to begin &lt;br /&gt;the loop, and the .ENDW statement ends the loop. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-11 shows how the .WHILE statement is used to read data from the keyboard &lt;br /&gt;and store it into an array called BUF until the enter key (ODH) is typed. This program assumes &lt;br /&gt;that BUF is stored in the extra segment because the STOSB instruction is used to store the key-&lt;br /&gt;board data in memory. Note that the .WHILE loop portion of the program is shown in expanded &lt;br /&gt;form so that the statements inserted by the assembler (beginning with a *) can be studied. After &lt;br /&gt;the enter key (ODH) is typed, the string is appended with a $ so it can be displayed with DOS &lt;br /&gt;INT 21H function number 9. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that reads a character string from the &lt;br /&gt;;keyboard and, after enter is typed, displays it again. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;MES DB 13,10 &lt;br /&gt;BUF DB 256 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MOV AX,DS &lt;br /&gt;MOV ES,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD &lt;br /&gt;MOV DI,OFFSET BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE AL != ODH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;jmp @COO01 &lt;br /&gt;* @COO02: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,1 &lt;br /&gt;INT 21H &lt;br /&gt;STOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select small model &lt;br /&gt;;indicate DATA segment &lt;br /&gt;;return &amp;amp; line feed &lt;br /&gt;;character string buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;;make ES overlap DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select increment &lt;br /&gt;;address buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;loop while AL not enter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key with echo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;store key code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;eC&amp;quot;ld while loop &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;194 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0026 &lt;br /&gt;[;026 3C OD &lt;br /&gt;0028 75 F7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G02A C6 45 FF &lt;br /&gt;002E BA 0000 &lt;br /&gt;0031 B4 09 &lt;br /&gt;0033 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* @COC'Ol: &lt;br /&gt;cmp al. CiClDh &lt;br /&gt;jne @C:02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24 MOV BY:-=: PTR [DI-1),'$' ;make it $ string &lt;br /&gt;R MOV DX,O?FSET MES ;address MES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,9 ;display MES &lt;br /&gt;INT 21H &lt;br /&gt;.EXIT ;exit to DOS &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The program in Example 6-11 functions perfectly as long as we arrive at the .WHILE &lt;br /&gt;statement with AL containing some other value except DDH. This can be corrected by adding a &lt;br /&gt;MOV AL,DDH instruction before the .WHILE statement in Example 6-11. A better way of han-&lt;br /&gt;dling this problem is illustrated in Example 6-12. In this example, the .BREAK statement is used &lt;br /&gt;to break out of the .WHILE loop. A .WHILE 1 creates an infinite loop, and the .BREAK state-&lt;br /&gt;ment tests for a value of ODH (enter) in AL. If AL = ODH, the program breaks out of the infinite &lt;br /&gt;loop, correcting the problem exhibited in Example 6-11. Note that the .BREAK statement &lt;br /&gt;causes the break to occur at the point where it appears in the program. This is important, because &lt;br /&gt;it allows the point of the break to be selected by the programmer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Not illustrated in this example is the .CONTINUE statement, which can be used to allow &lt;br /&gt;the DO-WHILE loop to continue if a certain condition is met. For example, a .CONTINUE .IF &lt;br /&gt;AL == 15 allows the loop to continue if AL equals 15. Note that the .BREAK and .CONTINUE &lt;br /&gt;commands function in the same manner in a C-Ianguage program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 OD OA MES &lt;br /&gt;0002 0100 [ BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 8C D8 &lt;br /&gt;0019 8E cO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001B FC &lt;br /&gt;001C BF 0002 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001F * @COO01: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001F B4 01 &lt;br /&gt;0021 CD 21 &lt;br /&gt;0023 AA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 3C OD * &lt;br /&gt;0026 74 02 * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0028 EB F5 &lt;br /&gt;002A * @C0002: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002A C6 t &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FF 24 &lt;br /&gt;nn::E BA 001)0 R &lt;br /&gt;0031 B4 09 &lt;br /&gt;0033 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;DB 13,10 &lt;br /&gt;DB 256 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MOV AX,DS &lt;br /&gt;MOV ES,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD &lt;br /&gt;MOV DI,OFFSET BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 21H &lt;br /&gt;STOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.BREAK .IF AL ODH &lt;br /&gt;cmp al,OODh &lt;br /&gt;je @COO02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;jmp @C0001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define string &lt;br /&gt;;memory for string &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;make ES overlap DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select increment &lt;br /&gt;;address BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;create an infinite loop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;store key code in BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;breaks loop for a ODH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BYTE PTR [DI-1), '$' ;make it a $ string &lt;br /&gt;MOV DX,OFFSET MES ;display string &lt;br /&gt;MOV AH,9 &lt;br /&gt;INT 21H &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-2 CONTROLLING THE FLOW OF AN ASSEMBLY LANGUAGE PROGRAM 195 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-13 lists a practical example using the DO-WHILE construct to display the con-&lt;br /&gt;tents of EAX in decimal on the video display. Note that the EAX register is initialized with a &lt;br /&gt;number (123455) to test this program. Two infinite loops are used to convert EAX to decimal. &lt;br /&gt;The first divides EAX by 10 until the quotient is zero. After each division, the remainder is saved &lt;br /&gt;on the stack as a significant digit in the result. Also located within the first infinite loop is a &lt;br /&gt;comma counter stored in CL. Each time that the quotient is not zero, the comma counter incre-&lt;br /&gt;ments. If the comma counter reaches a 3, a comma is pushed onto the stack for later display, and &lt;br /&gt;the comma count is reset to zero. The final infinite loop displays the result. After each POP DX &lt;br /&gt;instruction, the break statement checks DX to find if it contains a 10. The 10 was pushed on to &lt;br /&gt;the stack to indicate the end of the number. If it does contain a 10, the loop breaks; if it doesn't, &lt;br /&gt;a decimal digit or a comma is displayed. This procedure can be added to any program where a &lt;br /&gt;decimal number of up to four billion must be displayed with commas at the correct places. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-13 &lt;br /&gt;;A program that displays the contents of EAX in decimal. &lt;br /&gt;;This program inserts commas between thousands, &lt;br /&gt;;millions, and billions . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 661 B8 0001E23F &lt;br /&gt;0106 E8 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EAX,123455 &lt;br /&gt;CALL DISPE &lt;br /&gt;. EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select 80386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load test data &lt;br /&gt;;display EAX in decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;the DISPE procedure displays EAX in decimal format. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010D DISPE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010D 661 BB OOOOOOOA &lt;br /&gt;0113 53 &lt;br /&gt;0114 B1 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0116 661 BA 00000000 &lt;br /&gt;011C 661 F7 F3 &lt;br /&gt;OllF 80 C2 30 &lt;br /&gt;0122 52 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0128 FE C1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012F 6A 2C &lt;br /&gt;0131 B1 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0135 5A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;013B B4 02 &lt;br /&gt;013D CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EBX,10 &lt;br /&gt;PUSH BX &lt;br /&gt;MOV CL,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EDX,O &lt;br /&gt;DIV EBX &lt;br /&gt;ADD DL,30H &lt;br /&gt;PUSH DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. BREAK .IF EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF CL == 3 &lt;br /&gt;PUSH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CL,O &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP DX &lt;br /&gt;. BREAK . IF DL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load 10 for decimal &lt;br /&gt;;save end of number &lt;br /&gt;;load comma counter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;first infinite loop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear EDX &lt;br /&gt;;divide EDX:EAX by 10 &lt;br /&gt;;convert to ASCII &lt;br /&gt;;save remainder &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;break if quotient zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;increment comma counter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if comma count is 3 &lt;br /&gt;;save comma &lt;br /&gt;;clear comma counter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end first loop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;second infinite loop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get remainder &lt;br /&gt;;break if remainder is 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display decimal digit &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;'196 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0141 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0142 DISPE ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPEAT-UNTIL Loops &lt;br /&gt;Also available to the assembler is the REPEAT-UNTIL construct. A series of instructions is re-&lt;br /&gt;peated until some condition occurs. The .REPEAT statement defines the start of the loop; the end &lt;br /&gt;is defined with the .UNTIL statement that contains a condition. Note that .REPEAT and .UNTIL &lt;br /&gt;are available to version 6.x of MASM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If Example 6-11 is once again reworked using the REPEAT-UNTIL construct, this ap-&lt;br /&gt;pears to be the best solution. Refer to Example 6-14 for the program that reads keys from the &lt;br /&gt;keyboard and stores keyboard data into extra segment array BUF until the enter key is typed. &lt;br /&gt;This program also fills the buffer with keyboard data until the enter key (ODH) is typed. Once the &lt;br /&gt;enter key is typed, the program displays the character string using DOS INT 21H function &lt;br /&gt;number 9, after appending the buffer data with the required dollar sign. Notice how the .UNTIL &lt;br /&gt;AL == ODH statement generates code (statements beginning with a *) to test for the enter key. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 OD OA &lt;br /&gt;0002 0100 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 BC DB &lt;br /&gt;0019 BE CO &lt;br /&gt;001B FC &lt;br /&gt;001C BF 0002 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001F B4 01 &lt;br /&gt;0021 CD 21 &lt;br /&gt;0023 AA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 3C OD &lt;br /&gt;0026 75 F7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002B C6 45 FF 24 &lt;br /&gt;002C B4 09 &lt;br /&gt;002E BA 0000 R &lt;br /&gt;0031 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MES &lt;br /&gt;BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;DB 13,10 &lt;br /&gt;DB 256 DUP (?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MOV AX,DS &lt;br /&gt;MOV ES,AX &lt;br /&gt;CLD &lt;br /&gt;MOV DI,OFFSET BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;* @C0001: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 21H &lt;br /&gt;STOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL AL == ODH &lt;br /&gt;cmp aI, OODh &lt;br /&gt;jne @C0001 &lt;br /&gt;MOV BYTE PTR [DI-1],'$' &lt;br /&gt;MOV AH,9 &lt;br /&gt;MOV DX,OFFSET MES &lt;br /&gt;INT 21H &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define MES &lt;br /&gt;;reserve memory for BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;overlap DS and ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select increment &lt;br /&gt;;address BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key with echo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save key code in BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;make $ string &lt;br /&gt;;display MES and BUF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There is also an .UNTILCXZ instruction available that uses the LOOP instruction to check &lt;br /&gt;for the until condition. The .UNTILCXZ can P1ave a condition or may just use the CX register as &lt;br /&gt;a connter to repeat a loop a fixed number of times. Example 6-15 shows a sequence of instruc-&lt;br /&gt;tions that use the .UNTILC;&amp;quot;'Z instruction used to add the contents of byte-sized array ONE to &lt;br /&gt;byte sized array TWO. The sums are stored in array THREE. Note that each array contains 100 &lt;br /&gt;bytes of data, so the loop is repeated 100 times. This example assumes that array THREE is in &lt;br /&gt;the extra segment and that arrays ONE and TWO are in the data segment. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6-3 PROCEDURES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-15 &lt;br /&gt;Ol2C B9 0064 &lt;br /&gt;Ol2F BF 00C8 R &lt;br /&gt;0132 BE 0000 R &lt;br /&gt;0135 BB 0064 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0138 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0138 AC &lt;br /&gt;0139 02 07 &lt;br /&gt;013B AA &lt;br /&gt;013C 43 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0130 E2 F9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROCEDURES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* @C0001: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,lOO &lt;br /&gt;MOV DI,OFFSET THREE &lt;br /&gt;MOV SI,OFFSET ONE &lt;br /&gt;MOV BX,OFFSET TWO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LODSB &lt;br /&gt;ADD AL, [BX] &lt;br /&gt;STOSB &lt;br /&gt;INC BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;loop @COOOl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set count &lt;br /&gt;;address arrays &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;197 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure or subroutine is an important part of any computer system's architecture. A proce-&lt;br /&gt;dure is a group of instructions that usually performs one task. A procedure is a reusable section of &lt;br /&gt;the software that is stored in memory once, but used as often as necessary. This saves memory &lt;br /&gt;space and makes it easier to develop software. The only disadvantage of a procedure is that it takes &lt;br /&gt;the computer a small amount of time to link to the procedure and return from it. The CALL in-&lt;br /&gt;struction links to the procedure and the RET (return) instruction returns from the procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The stack stores the return address whenever a procedure is called during the execution of a &lt;br /&gt;program. The CALL instruction pushes the address of the instruction following the CALL (return &lt;br /&gt;address) on the stack. The RET instruction removes an address from the stack so the program re-&lt;br /&gt;turns to the instruction following the CALL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;With the assembler, there are specific rules for the storage of procedures. A procedure begins &lt;br /&gt;with the PROC directive and ends with the ENDP directive. Each directive appears with the name of &lt;br /&gt;the procedure. This programming structure makes it easy to locate the procedure in a program listing. &lt;br /&gt;The PROC directive is followed by the type of procedure: NEAR or FAR. Example 6-16 shows how &lt;br /&gt;the assembler uses the definition of both a near (intrasegment) and far (intersegment) procedure. In &lt;br /&gt;MASM version 6X, the NEAR or FAR type can be followed by the USES statement. The USES &lt;br /&gt;statement allows any number of registers to be automatically pushed to the stack and popped from the &lt;br /&gt;stack within the procedure. The USES statement is also illustrated in Example 6-16. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-16 &lt;br /&gt;0000 SUMS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 03 C3 ADD AX,BX &lt;br /&gt;0002 03 Cl ADD AX,CX &lt;br /&gt;0004 03 C2 ADD AX,DX &lt;br /&gt;0006 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 SUMS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 SUMSl PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 03 C3 ADD AX,BX &lt;br /&gt;0009 03 Cl ADD AX,CX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;198 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB 03 C2 J.~DD AX,DX &lt;br /&gt;OOOD eB ?ET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE SUHSl E!JDF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE SUMS2 PROe t.:E.;R USES EX ex DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0011 03 e3 .z..DD AX,EX &lt;br /&gt;0013 03 e1 ?DD AX,ex &lt;br /&gt;0015 03 e2 110V AX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001B SUMS2 ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When these two procedures are compared, the only difference is the opcode of the return &lt;br /&gt;instruction. The near return instruction uses opcode C3H, and the far return uses opcode CBH. A &lt;br /&gt;near return instruction removes a 16-bit number from the stack and places it into the instruction &lt;br /&gt;pointer to return from the procedure in the current code segment. A far return removes a 32-bit &lt;br /&gt;number from the stack and places it into both IP and CS to return from the procedure to any &lt;br /&gt;memory location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Procedures that are to be used by all software (global) should be written as far procedures. &lt;br /&gt;Procedures that are used by a given task (local) are normally defined as near procedures. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL &lt;br /&gt;The CALL instruction transfers the flow of the program to the procedure. The CALL instruction &lt;br /&gt;differs from the jump instruction because a CALL saves a return address on the stack. The return &lt;br /&gt;address returns control to the instruction that immediately follows the CALL in a program when &lt;br /&gt;a RET instruction executes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Near CALL. The near CALL instruction is three bytes long, with the tirst byte containing the op-&lt;br /&gt;code and the second and third bytes containing the displacement or distance of Â±32K in the 8086 &lt;br /&gt;through the 80286. This is identical to the form of the near jump instruction. The 80386 and above &lt;br /&gt;use a 32-bit displacement when operated in the protected mode to allow a distance of Â±2G bytes. &lt;br /&gt;When the near CALL executes, it first pushes the offset address of the next instruction on the stack. &lt;br /&gt;The offset address of the next instruction appears in the instruction pointer (lP or EIP). After saving &lt;br /&gt;this return address, it then adds the displacement from bytes 2 and 3 to the IP to transfer control to &lt;br /&gt;the procedure. There is no short CALL instruction. A variation on the opcode exists as CALLN, &lt;br /&gt;but this should be avoided in favo~:of using the PROC statement to define the CALL as near. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Why save the IP or EIP on the stack? The instruction pointer l!L).\\Iays points to the next in-&lt;br /&gt;struction in the program. For the CALL instruction, the contents o~IP are pushed onto the &lt;br /&gt;stack, so program control passes to the instruction following the CALL after a procedure ends. &lt;br /&gt;Figure 6-6 shows the return address (IP) stored on the stack, and the call to the procedure. &lt;br /&gt;Far CALL. The far CALL instruction is like a far jump because it can call a procedure stored in &lt;br /&gt;any memory location in the system. The far CALL is a 5-byte instruction that contains an opcode &lt;br /&gt;followed by the next value for the IP and CS registers. Bytes 2 and 3 contain the new contents of &lt;br /&gt;the IP, and bytes 4 and 5 contain the new contents for CS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The far CALL instruction places the contents of both IP and CS on the stack before &lt;br /&gt;jumping to the address indicated by bytes 2-5 of the instruction. This allows the far CALL to call &lt;br /&gt;a grocedure located anywhere in the memory and return from that procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- Figure 6-7 shows how the far CALL instruction calls a far procedure. Here the contents of &lt;br /&gt;IP and CS are pushed onto the stack. Next, the program branches to the procedure. A variant of &lt;br /&gt;the far CALL exists as CALLF, but this should be avoided in favor of defining the type.{&amp;gt;f call &lt;br /&gt;instruction with the PROC statement. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-3 PROCEDURES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-6 The effect of a &lt;br /&gt;near CALL on the stack and &lt;br /&gt;the instruction pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-7 The effect of a &lt;br /&gt;far CALL instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AFFFE &lt;br /&gt;SP -AFFFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001 &lt;br /&gt;11000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10002 &lt;br /&gt;10001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AFFFE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AFFFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AFFFC &lt;br /&gt;SP ---+- AFFFB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001 &lt;br /&gt;11000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10002 &lt;br /&gt;10001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Procedure) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;05 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Procedure) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;199 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SP before CALL = FFFF &lt;br /&gt;SS before CALL = AOOO &lt;br /&gt;IP before CALL = 0003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;}N'~CALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SP before CALL = FFFF &lt;br /&gt;SS before CALL = AOOO &lt;br /&gt;IP before CALL = 0005 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;200 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALLs with Register Operands. Like jump instructions, call instructions also may contain a reg-&lt;br /&gt;ister operand. An example is the CALL BX instruction. This instruction pushes the contents of &lt;br /&gt;IP onto the stack. It then jumps to the offset address, located in register BX, in the current code &lt;br /&gt;segment. This type of CALL always uses a 16-bit offset address stored in any 16-bit register, ex-&lt;br /&gt;cept the segment registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-17 illustrates the use of the CALL register instruction to call a procedure that &lt;br /&gt;begins at offset address DISP. (This call could also directly call the procedure by using the &lt;br /&gt;CALL DISP instruction). The OFFSET address DISP is placed into the BX register, and then the &lt;br /&gt;CALL BX instruction calls the procedure beginning at address DISP. This program displays an &lt;br /&gt;&amp;quot;OK&amp;quot; on the monitor screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 BB 0110 R &lt;br /&gt;0103 B2 4F &lt;br /&gt;0105 FF D3 &lt;br /&gt;0107 B2 4B &lt;br /&gt;0109 FF D3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0110 B4 02 &lt;br /&gt;0112 CD 21 &lt;br /&gt;0114 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0115 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that displays OK on the monitor screen &lt;br /&gt;;using procedure DISP. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;CALL &lt;br /&gt;MOV &lt;br /&gt;CALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX,OFFSET &lt;br /&gt;DL, '0' &lt;br /&gt;BX &lt;br /&gt;DL, 'K' &lt;br /&gt;BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select TINY model &lt;br /&gt;;start of CODE segment &lt;br /&gt;;start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address DISP with BX &lt;br /&gt;;display '0' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display 'K' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT ;exit to DOS &lt;br /&gt;;a procedure that displays the ASCII contents of DL on &lt;br /&gt;;the monitor screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:JISP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;INT 21H &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select function 02H &lt;br /&gt;;execute DOS function &lt;br /&gt;;return from procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALLs with Indirect Memory Addresses. A CALL with an indirect memory address is particu-&lt;br /&gt;larly useful whenever different subroutines need to be chosen in a program. This selection &lt;br /&gt;process is often keyed with a number that addresses a CALL address in a lookup table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-18 shows three separate subroutines referenced by the numbers 1,2, and 3 as &lt;br /&gt;read from the keyboard on the personal computer. The calling sequence adjusts the value of AL &lt;br /&gt;and extends it to a 16-bit number before adding it to the location of the lookup table. This refer-&lt;br /&gt;ences one of the three subroutines using the CALL TABLE [BX] instruction. When this program &lt;br /&gt;executes, the letter A is displayed when a 1 is typed, the letter B is displayed when a 2 is typed, &lt;br /&gt;and the letter C is displayed when a 3 is typed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 0000 R &lt;br /&gt;0002 0007 R &lt;br /&gt;0004 OOOE R &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that uses a CALL lookup table to access one of &lt;br /&gt;;three different procedures: ONE, TWO, or THREE . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;DW ONE &lt;br /&gt;DW TWO &lt;br /&gt;DW THREE &lt;br /&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SH.,\\LL model &lt;br /&gt;;start of DATA segment &lt;br /&gt;;define lookup table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of CODE segment &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-3 PROCEDURES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 ONE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B4 02 &lt;br /&gt;0002 B2 41 &lt;br /&gt;0004 CD 21 &lt;br /&gt;0006 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 ONE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 TWO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 B4 02 &lt;br /&gt;0009 B2 42 &lt;br /&gt;OOOB CD 21 &lt;br /&gt;OOOD C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE TWO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE THREE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE B4 02 &lt;br /&gt;0010 B2 43 &lt;br /&gt;0012 CD 21 &lt;br /&gt;0014 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0015 THREE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002C TOP: &lt;br /&gt;002C B4 01 &lt;br /&gt;002E CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0030 2C 31 &lt;br /&gt;0032 72 F8 &lt;br /&gt;0034 3C 02 &lt;br /&gt;0036 77 F4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 B4 00 &lt;br /&gt;003A 8B D8 &lt;br /&gt;003C 03 DB &lt;br /&gt;003E FF 97 0000 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL, 'A' &lt;br /&gt;INT 21H &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL, 'B' &lt;br /&gt;INT 21H &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL, 'C' &lt;br /&gt;INT 21H &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AL,31H &lt;br /&gt;JB TOP &lt;br /&gt;CMP AL,2 &lt;br /&gt;JA TOP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,O &lt;br /&gt;MOV BX,AX &lt;br /&gt;ADD BX,BX &lt;br /&gt;CALL TABLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;[BX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display a letter A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display letter B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display letter C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;indicate start of program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key into AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;convert to binary &lt;br /&gt;;if below 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if above 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;form lookup address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;call procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;201 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CALL instruction also can reference far pointers if the instruction appears as a CALL &lt;br /&gt;FAR PfR [SI] or as a CALL TABLE [SI], if the data in the table are defined as doubleword data &lt;br /&gt;with the DD directive. These instructions retrieve a 32-bit address from the data segment &lt;br /&gt;memory location addressed by SI and use it as the address of a far procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;The return instruction (RET) removes either a 16-bit number (near return) from the stack and &lt;br /&gt;places it into IP or a 32-bit number (far return) and places it into IP and CS. The near and far re-&lt;br /&gt;turn instructions are both defined in the procedure's PROC directive. This automatically selects &lt;br /&gt;the proper return instruction. With the 80386 through the Pentium Pro processors operated in the &lt;br /&gt;protected mode, the far return removes six bytes from the stack. The first four bytes contain the &lt;br /&gt;new value for EIP, and the last two contain the new value for CS. In the 80386 and above, a pro-&lt;br /&gt;tected mode near return removes four bytes from the stack and places them into EIP. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When IPIEIP or IPIEIP and CS are changed, the address of the next instruction is at a new &lt;br /&gt;memory location. This new location is the address of the instruction that immediately follows the &lt;br /&gt;most recent CALL to a procedure. Figure 6-8 shows how the CALL instruction links to a proce-&lt;br /&gt;dure and how the RET instruction returns in the 8086-80286. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;202 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-8 The effect of a &lt;br /&gt;near return instruction on the &lt;br /&gt;stack and instruction pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SP -AFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AFFFE &lt;br /&gt;AFFFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001 &lt;br /&gt;11000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- ==--&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Return here) &lt;br /&gt;OF &lt;br /&gt;FF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Near RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SP before CALL = FFFD &lt;br /&gt;SS before CALL = AOOO &lt;br /&gt;IP before CALL = 1004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There is one other fonn of the return instruction. This form adds a number to the contents &lt;br /&gt;of the stack pointer (SP) after the return address is removed from the stack. A return that uses an &lt;br /&gt;immediate operand is ideal for use in a system that uses the C or PASCAL calling conventions. &lt;br /&gt;(This is true even though the C and PASCAL calling convention require the caller to remove &lt;br /&gt;stack data for many functions.) These conventions push parameters on the stack before calling a &lt;br /&gt;procedure. If the parameters are to be discarded upon return, the return instruction contains a &lt;br /&gt;number that represents the number of bytes pushed to the stack as parameters. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-19 shows how this type of return erases the data placed on the stack by a few &lt;br /&gt;pushes. The RET four adds a 4 to SP after removing the return address from the stack. Since the &lt;br /&gt;PUSH AX and PUSH BX together place 4 bytes of data on the stack, this return effectively &lt;br /&gt;deletes AX and BX from the stack. This return rarely appears in assembly language programs, &lt;br /&gt;but is used in higher-level programs to clear stack data after a procedure. Notice how parameters &lt;br /&gt;are addressed on the stack by using the BP register, which by default addresses the stack seg-&lt;br /&gt;ment. Parameter stacking is common in procedures written for C or PASCAL using the C or &lt;br /&gt;PASCAL calling conventions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-19 &lt;br /&gt;0000 B8 OOIE MOV AX,30 &lt;br /&gt;0003 BB 00L8 MOV BX,40 &lt;br /&gt;0006 50 PUSH AX ;stack parameter 1 &lt;br /&gt;0007 53 PUSH BX ;stack parameter 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 E8 0('56 '-ALL ADDM ;add parameters from stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program continues here &lt;br /&gt;0071 ADDM PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0071 55 PUSH BP ;save BP &lt;br /&gt;0072 8B EC NOV BP,SP ; address stack with BP &lt;br /&gt;0074 8B 46 04 MOV AX, [BP+4] ;get parameter 1 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6-4 INTRODUCTION TO INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0077 03 46 06 &lt;br /&gt;007A 5D &lt;br /&gt;007B C2 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007E ADm! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AX, [BP+6] &lt;br /&gt;POP BP &lt;br /&gt;RET 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;add parameter 2 &lt;br /&gt;;restore BP &lt;br /&gt;;return, dump parameters &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;203 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with the CALLN and CALLF instructions, there are also variants of the return instruc-&lt;br /&gt;tion: RETN and RETF. As with the CALLN and CALLF instructions, these return variants &lt;br /&gt;should be avoided in favor of using the PROC statement to define the type of call and return. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION TO INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An interrupt is either a hardware-generated CALL (externally derived from a hardware signal) or &lt;br /&gt;a software-generated CALL (internally derived from the execution of an instruction or by some &lt;br /&gt;other internal event). An internal interrupt is sometimes called an exception. Either type inter-&lt;br /&gt;rupts the program by calling an interrupt service procedure or interrupt handler. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section explains software interrupts, which are special types of CALL instructions. &lt;br /&gt;This section explains the three types of software interrupt instructions (INT, INTO, and INT 3), &lt;br /&gt;provides a map of the interrupt vectors, and explains the purpose of the special interrupt return &lt;br /&gt;instruction (lRET). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Vectors &lt;br /&gt;An interrupt vector is a 4-byte number stored in the first 1,024 bytes of the memory &lt;br /&gt;(000000H-0003FFH) when the microprocessor operates in the real mode. In the protected-&lt;br /&gt;mode, the vector table is replaced by an interrupt descriptor table that uses 8-byte descriptors to &lt;br /&gt;describe each of the interrupts. There are 256 different interrupt vectors. Each vector contains the &lt;br /&gt;address of an interrupt service procedure. Table 6-4 lists the interrupt vectors with a brief de-&lt;br /&gt;scription and the memory location of each vector for the real mode. Each vector contains a value &lt;br /&gt;for IP and CS that forms the address of the interrupt service procedure. The first two bytes con-&lt;br /&gt;tain the IP, and the last two bytes contain the CS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Intel reserves the first 32 interrupt vectors for the present and future microprocessor prod-&lt;br /&gt;ucts. The remaining interrupt vectors (32-255) are available for the user. Some of the reserved &lt;br /&gt;vectors are for errors that occur during the execution of software, such as the divide-error-&lt;br /&gt;interrupt. Some vectors are reserved for the coprocessor. Still others occur for normal events in &lt;br /&gt;the system. In a personal computer, the reserved vectors are used for system functions, as de-&lt;br /&gt;tailed later in this section. Vectors 1-6,7,9, 16, and 17 function in the real mode and protected &lt;br /&gt;mode; the remaining vectors function only in the protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Instructions &lt;br /&gt;The microprocessor has three different interrupt instructions available to the programmer: INT, &lt;br /&gt;INTO, and INT 3. In the real mode, each of these instructions fetches a vector from the vector &lt;br /&gt;table and then calls the procedure stored at the location addressed by the vector. In the protected &lt;br /&gt;mode, each of these instructions fetches an interrupt descriptor from the interrupt descriptor table. &lt;br /&gt;The descriptor specifies the address of the interrupt service procedure. The interrupt call is similar &lt;br /&gt;to a far CALL instruction because it places the return address (IPIEIP and CS) on the stack. &lt;br /&gt;INTs. There are 256 different software interrupt instructions (lNT) available to the pro-&lt;br /&gt;grammer. Each INT instruction has a numeric operand whose range is 0 to 255 (OOH-FFH). For &lt;br /&gt;example, the INT 100 uses interrupt vector 100, which appears at memory address 190H-193H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;204 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 6-4 Interrupt vectors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Number Address Microprocessor Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 OH-3H All Divide error &lt;br /&gt;1 4H-7H All Aingle-step &lt;br /&gt;2 8H-BH All NMI pin &lt;br /&gt;3 CH-FH All Breakpoint &lt;br /&gt;4 10H-13H All Interrupt on overflow &lt;br /&gt;5 14H-17H 80186-Pentium Pro Bound instruction &lt;br /&gt;6 18H-1BH 80186-Pentium Pro Invalid opcode &lt;br /&gt;7 1CH-1FH 80186-Pentium Pro Coprocessor emulation &lt;br /&gt;8 20H-23H 80386-Pentium Pro Double fault &lt;br /&gt;9 24H-27H 80386 Coprocessor segment overrun &lt;br /&gt;A 28H-2BH 80386-Pentium Pro Invalid task state segment &lt;br /&gt;B 2CH-2FH 80386-Pentium Pro Segment not present &lt;br /&gt;C 30H-33H 80386-Pentium Pro Stack fault &lt;br /&gt;D 34H-37H 80386-Pentium Pro General protection fault (GPF) &lt;br /&gt;E 38H-3BH 80386-Pentium Pro Page fault &lt;br /&gt;F 3CH-3FH Reserved &lt;br /&gt;10 40H-43H 80286-Pentium Pro Floating-point error &lt;br /&gt;11 44H-47H 80486SX Alignment check interrupt &lt;br /&gt;12 48H-4FH Pentium/Pentium Pro Machine check exception &lt;br /&gt;13-1F 50H-7FH Reserved &lt;br /&gt;20-FF 80H-3FFH User interrupts &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address of the interrupt vector is determined by multiplying the interrupt type number times &lt;br /&gt;four. For example, the INT 10H instruction calls the interrupt service procedure whose address is &lt;br /&gt;stored beginning at memory location 40H (lOH x 4) in the real mode. In protected mode, the in-&lt;br /&gt;terrupt descriptor is located by mUltiplying the type number by 8 instead of 4 because each de-&lt;br /&gt;scriptor is eight bytes long. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each INT instruction is two bytes long. The first byte contains the opcode, and the second &lt;br /&gt;byte contains the vector type number. The only exception to this is INT 3, a I-byte special soft-&lt;br /&gt;ware interrupt used for breakpoints. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever a software interrupt instruction executes, it (I) pushes the flags onto the stack, &lt;br /&gt;(2) clears the T and I flag bits. (3) pushes CS onto the stack, (4) fetches the new value for CS &lt;br /&gt;from the vector, (5) pushes IPIEIP onto the stack, (6) fetches the new value for IPIEIP from the &lt;br /&gt;vector, and (7) jumps to the new location addressed by CS and IPIEIP. The INT instruction per-&lt;br /&gt;forms as a far CALL, except that it not only pushes CS and IP onto the stack, but it also pushes &lt;br /&gt;the flags onto the stack. The INT instruction performs the operation of a PUSHF, foIl owed by a &lt;br /&gt;far CALL instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that when the INT instruction executes, it clears the interrupt flag (I), which con-&lt;br /&gt;trols the external hardware intenupt input pin INTR (interrupt request). When I = 0, the micro-&lt;br /&gt;processor disables the INTR pin: when I = I, the microprocessor enables the INTR pin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Software interrupts are most commonly used to call system procedures because the address &lt;br /&gt;of the system function need not be known. The sy~tem procedures are common to all system and &lt;br /&gt;application software. The intelTllpts often control pnnters, video display~, and disk drives. Besides &lt;br /&gt;relieving the program from remembering the address of the system call, the INT instruction re-&lt;br /&gt;places a far CALL that would otherwise be used to call a system function. The INT instruction is two &lt;br /&gt;bytes long whereas the far CALL is five bytes long. Each time that the INT instruction replaces a far &lt;br /&gt;CALL, it saves three bytes of memory in a program. This can amount to a sizable savings if the INT &lt;br /&gt;instru&amp;lt;.:tion appears often in a program, as it does for system calls. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-4 INTRODUCTION TO INTERRUPTS 205 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRETIIRETD. The interrupt return instruction (IRET) is used only with software or hardware in-&lt;br /&gt;terrupt service procedures. Unlike a simple return instruction (RET), the IRET instruction will &lt;br /&gt;(1) pop stack data back into the IP, (2) pop stack data back into CS, and (3) pop stack data back &lt;br /&gt;into the flag register. The IRET instruction accomplishes the same tasks as the POPF, followed &lt;br /&gt;by a far RET instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever an IRET instruction executes, it restores the contents of I and T from the stack. &lt;br /&gt;This is important, because it preserves the state of these flag bits. If interrupts were enabled be-&lt;br /&gt;fore an interrupt service procedure, they are automatically reenabled by the IRET instruction, be-&lt;br /&gt;cause it restores the flag register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80386 through the Pentium Pro processors, the IRETD instruction is used to return &lt;br /&gt;from an interrupt service procedure that is called in the protected mode. It differs from the IRET &lt;br /&gt;because it pops a 32-bit instruction pointer (EIP) from the stack. The IRET is used in the real &lt;br /&gt;mode, and the IRETD is used in the protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 3. An INT 3 instruction is a special software interrupt designed to be used as a breakpoint. &lt;br /&gt;The difference between it and the other software interrupts is that INT 3 is a I-byte instruction, &lt;br /&gt;while the others are 2-byte instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It is common to insert an INT 3 instruction in software to interrupt or break the flow of the &lt;br /&gt;software. This function is called a breakpoint. A breakpoint occurs for any software interrupt, &lt;br /&gt;but because INT 3 is a I-byte instruction long, it is easier to use for this function. Breakpoints &lt;br /&gt;help to debug faulty software. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTO. Interrupt on overflow (INTO) is a conditional software interrupt that tests the overflow &lt;br /&gt;flag (0). If 0 = 0, the INTO instruction performs no operation; if 0 = 1 and an INTO instruction &lt;br /&gt;executes, an interrupt occurs via vector type number 4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The INTO instruction appears in software that adds or subtracts signed binary numbers. &lt;br /&gt;With these operations it is possible to have an overflow. Either the JO instruction or INTO in-&lt;br /&gt;struction detect the overflow condition. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An Interrupt Service Procedure. Suppose that, in a particular system, a procedure is required to &lt;br /&gt;add the contents of DI, 51, BP, and BX and save the sum in AX. Because this is a common task &lt;br /&gt;in this system, it may occasionally be worthwhile to develop the task as a software interrupt. Re-&lt;br /&gt;alize that interrupts are usually reserved for system events, and this is merely an example &lt;br /&gt;showing how an interrupt service procedure appears. Example 6-20 shows this software inter-&lt;br /&gt;rupt. The main difference between this procedure and a normal far procedure is that it ends with &lt;br /&gt;the IRET instruction instead of the RET instruction, and the contents of the flag register are &lt;br /&gt;saved on the stack during its execution. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-20 &lt;br /&gt;0000 1NTS PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 03 C3 ADD AX,BX &lt;br /&gt;0002 03 C5 ADD AX,BP &lt;br /&gt;0004 03 C7 ADD AX,D1 &lt;br /&gt;0006 03 C6 ADD AX, S1 &lt;br /&gt;0008 CF IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 1NTS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Control &lt;br /&gt;Although this section does not explain hardware interrupts, two instructions are introduced that &lt;br /&gt;control the INTR pin. The set interrupt flag instruction (ST!) places a I into the I flag bit, which &lt;br /&gt;enables the INTR pin. The clear interrupt flag instruction (CLI) places a 0 into the I flag bit, which &lt;br /&gt;disables the INTR pin. The STI instruction enables INTR, and the CLI instruction disables INTR. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;206 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In a software interrupt service procedure. hardware interrupts are enabled as one of the first steps. &lt;br /&gt;This is accomplished by the STI instruction. The reason interrupts are enabled early in an interrupt &lt;br /&gt;service procedure is that just about all of the I/O devices in the personal computer are intelTupt &lt;br /&gt;processed. If the interrupts are disabled too long, severe system problems result. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupts in the Personal Computer &lt;br /&gt;The interrupts found in the personal computer differ somewhat from those presented in Table 6-4. &lt;br /&gt;The reason that they differ is that the original personal computers are 8086/8088 based systems. &lt;br /&gt;This means that they only contained Intel specified interrupts 0-4. This design is carried forward &lt;br /&gt;so that newer systems are compatible with the early personal computers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the personal computer is operated in the real mode, the inten'upt vector table is lo-&lt;br /&gt;cated at addresses 00000H-003FFH. The assignments used by computer system are listed in &lt;br /&gt;Table 6-5. Notice that these differ somewhat from the assignments shown in Table 6-3. Some of &lt;br /&gt;the interrupts shown in this table are used in example programs in later chapters. An example is &lt;br /&gt;the clock tick, which is extremely useful for timing events because it occurs a constant 18.2 &lt;br /&gt;times per second in all personal computers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupts OOH-l FH and 70H-77H are present in the computer no matter what operating &lt;br /&gt;system is installed. If DOS is installed, interrupts 20H-2FH are also present. The BIOS uses in-&lt;br /&gt;terrupts IIH-l FR, the video BIOS uses INT IOH, and the hardware in the system uses interrupts &lt;br /&gt;OOH-OFH and 70H-77H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MACHINE CONTROL AND MISCELLANEOUS INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The last category of real mode instructions found in the microprocessor are the machine control &lt;br /&gt;and miscellaneous group. These instructions provide control of the carry bit, sample the &lt;br /&gt;BUSY /TEST pin, and perf0Il11 various other functions. Because many of these instructions are &lt;br /&gt;used in hardware control, they need only be explained briefly at this point. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Controlling The Carry Flag Bit &lt;br /&gt;The carry flag (C) propagates the carry or borrow in multiple-word/doubleword addition and &lt;br /&gt;subtraction. It also indicates errors in procedures. There are three instructions that control the &lt;br /&gt;contents of the calTY flag: STC (set carry), CLC (clear carry), and CMC (complement carry). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the carry flag is seldom used, except with multiple-word addition and subtraction, &lt;br /&gt;it is available for other uses. The most common task for the carry flag is to indicate an error upon &lt;br /&gt;return from a procedure. Suppose that a procedure reads data from a disk memory file. This op-&lt;br /&gt;eration can be successful or an error such as file-not-found can occur. Upon return from this pro-&lt;br /&gt;cedure, if C = I, an error has occurred; if C = 0, no error occurred. Most of the DOS and BIOS &lt;br /&gt;procedures use the carry flag to indicate error conditions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT &lt;br /&gt;The WAIT instruction monitors the hardware BUSY pin on the 80286 and 80386 and the TEST &lt;br /&gt;pin on the 8086/8088. The name of this pin was changed in the 80286 microprocessor from &lt;br /&gt;TEST to BUSY. If the WAIT instruction executes while the BUSY pin = I, nothing happens and &lt;br /&gt;the next instruction executes. Ifthe BUSY pin = 0 when the WAIT instruction executes, the mi-&lt;br /&gt;croprocessor waits for the BUSY pin to return to a logic 1. This pin indicates a busy condition &lt;br /&gt;when at a logic 0 level. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-5 MACHINE CONTROL ANO MISCELLANEOUS INSTRUCTIONS 207 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 6-5 The hexadeci-&lt;br /&gt;mal interrupt assignments for &lt;br /&gt;the personal computer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;1 &lt;br /&gt;2 &lt;br /&gt;3 &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;6 &lt;br /&gt;7 &lt;br /&gt;8 &lt;br /&gt;9 &lt;br /&gt;A &lt;br /&gt;B-F &lt;br /&gt;10 &lt;br /&gt;11 &lt;br /&gt;12 &lt;br /&gt;13 &lt;br /&gt;14 &lt;br /&gt;15 &lt;br /&gt;16 &lt;br /&gt;17 &lt;br /&gt;18 &lt;br /&gt;19 &lt;br /&gt;1A &lt;br /&gt;1B &lt;br /&gt;1C &lt;br /&gt;10 &lt;br /&gt;1E &lt;br /&gt;iF &lt;br /&gt;20 &lt;br /&gt;21 &lt;br /&gt;22 &lt;br /&gt;23 &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.. Â·25 &lt;br /&gt;26 &lt;br /&gt;27 &lt;br /&gt;28 &lt;br /&gt;2F &lt;br /&gt;31 &lt;br /&gt;33 &lt;br /&gt;67 &lt;br /&gt;70-77 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Divide error &lt;br /&gt;Single-step &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMI pin (often parity error checks) &lt;br /&gt;Breakpoint &lt;br /&gt;Overflows &lt;br /&gt;Print screen key and BOUND instruction &lt;br /&gt;Illegal instruction &lt;br /&gt;Coprocessor emulation &lt;br /&gt;Clock tick (18.2 Hz) &lt;br /&gt;Keyboard &lt;br /&gt;IRQ2 (cascade in AT system) &lt;br /&gt;IRQ3-IRQ7 &lt;br /&gt;Video BIOS &lt;br /&gt;Equipment environment &lt;br /&gt;Conventional memory size &lt;br /&gt;Direct disk services &lt;br /&gt;Serial COM port service &lt;br /&gt;Miscellaneous &lt;br /&gt;Keyboard service &lt;br /&gt;Parallel port (LPT) service &lt;br /&gt;ROM BASIC &lt;br /&gt;Reboot &lt;br /&gt;Clock service &lt;br /&gt;Control-break handler &lt;br /&gt;User timer service &lt;br /&gt;Pointer for video parameter table &lt;br /&gt;Pointer for disk parameter table &lt;br /&gt;Pointer for graphic character pattern table &lt;br /&gt;Terminate program (DOS 1.0) &lt;br /&gt;DOS services &lt;br /&gt;Program termination handler &lt;br /&gt;Control-C handler &lt;br /&gt;Critical error handler &lt;br /&gt;Read disk &lt;br /&gt;Write disk &lt;br /&gt;Terminate and stay resident (TSR) &lt;br /&gt;DOS idle &lt;br /&gt;Multiplex handler &lt;br /&gt;DPMI (DOS protected mode interface) provided by Windows &lt;br /&gt;Mouse driver &lt;br /&gt;VCPI (virtual control program interface) provided by HIMEM.SYS &lt;br /&gt;IRQ8-IRQ15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The BUSY {fEST pin of the microprocessor is usually connected to the BUSY pin of the &lt;br /&gt;8087 through the 80387 numeric coprocessors. This connection allows the microprocessor to &lt;br /&gt;wait until the coprocessor finishes a task. Because the coprocessor is inside the 80486 through &lt;br /&gt;the Pentium Pro, the BUSY pin is not present in these microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HLT &lt;br /&gt;The halt instruction (HL T) stops the execution of software. There are three ways to exit a halt: by &lt;br /&gt;an interrupt, by a hardware reset, or during a DMA operation. This instruction normally appears &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;208 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;in a program to wait for an interrupt. It often synchronizes external hardware interrupts with the &lt;br /&gt;Sllft ware system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Nap &lt;br /&gt;When the microprocessor encounters a no operation instruction (NOP), it takes a short time to &lt;br /&gt;execute. In early years, before software development tools were available, a NOP, which per-&lt;br /&gt;forms absolutely no operation, was often used to pad software with space for future machine lan-&lt;br /&gt;guage instructions. If you are developing machine language programs, which is extremely rare, &lt;br /&gt;it is recommended that you place approximately 10 or so NOPs in your program at 50-byte in-&lt;br /&gt;tervals. This is done in case you need to add instructions at some future point. A NOP may also &lt;br /&gt;find application in time delays to waste short periods of time. Realize that a NOP used for timing &lt;br /&gt;is not very accurate because of the cache and pipelines in modem microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOCK Prefix &lt;br /&gt;The LOCK prefix appends an instruction and causes the LOCK pin to become a logic O. The &lt;br /&gt;LOCK pin often disables external bus masters or other system components. The LOCK prefix &lt;br /&gt;causes the lock pin to activate for the duration of a locked instruction. If more than one sequen-&lt;br /&gt;tial instruction is locked, the LOCK pin remains a logic 0 for the d~ration of the sequence of &lt;br /&gt;locked instructions. The LOCK:MOV AL,[SI] instruction is an example of a locked instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESC &lt;br /&gt;The escape (ESC) instruction passes information to the 8087-Pentium Pro numeric coproces-&lt;br /&gt;sors. Whenever an ESC instruction executes, the microprocessor provides the memory address, &lt;br /&gt;if required, but otherwise performs a NOP. Six bits of the ESC instruction provide the opcode to &lt;br /&gt;the coprocessor and begin executing an instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ESC opcode never appears in a program as ESC and in itself is considered obsolete as &lt;br /&gt;an opcode. In its place are a set of coprocessor instructions (FLD, FST, FMUL, etc.) that as-&lt;br /&gt;semble as ESC instructions for the coprocessor. More detail is provided in Chapter 8, which de-&lt;br /&gt;tails the 8087-Pentium Pro numeric coprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOUND &lt;br /&gt;The BOUND instruction, first made available in the 80186 microprocessor, is a comparison in-&lt;br /&gt;struction that may cause an interrupt (vector type number 5). This instruction compares the con-&lt;br /&gt;tents of any 16- or 32-bit register against the contents of two words or doublewords of memory: &lt;br /&gt;an upper and a lower boundary. If the value in the register compared with memory is not within &lt;br /&gt;the upper and lower boundary, a type 5 interrupt ensues. If it is within the boundary, the next in-&lt;br /&gt;struction in the program executes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, if the BOUND SI,DA TA instruction executes, word-sized location DATA con-&lt;br /&gt;tains the lower boundary and word-sized location DATA + 2 bytes contains the upper boundary. If &lt;br /&gt;the number contained in SI is less than memory location DATA or greater than memory location &lt;br /&gt;DATA + 2 bytes, a type 5 interrupt occurs. Note that when this interrupt occurs the return address &lt;br /&gt;points to the BOUND instruction, not the instruction following BOUND. This differs from a normal &lt;br /&gt;interrupt, where the return address points to the next instruction in the program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENTER and LEAVE &lt;br /&gt;The ENTER and LEAVE instructions, first made available to the 80186 microprocessor, are &lt;br /&gt;used with stack frames. A stack frame is a mechanism used to pass parameters to a procedure &lt;br /&gt;through the stack memory. The stack frame also holds local memory variables for the procedure. &lt;br /&gt;Stack frames provide dynamic areas of memory for procedures in multi-user environments. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-5 MACHINE CONTROL AND MISCELLANEOUS INSTRUCTIONS 209 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 - Old SP location &lt;br /&gt;001 F BP (high) &lt;br /&gt;001 E BP (low) - BP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 6-9 The stack &lt;br /&gt;frame created by the ENTER &lt;br /&gt;8.0 instruction. Notice that BP &lt;br /&gt;is stored beginning at the top &lt;br /&gt;of the stack frame. This is fol-&lt;br /&gt;lowed by an 8-byte area &lt;br /&gt;called a stack frame. I 001D I-----i &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack frame &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001C &lt;br /&gt;~-----I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001B &lt;br /&gt;1-----1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001A &lt;br /&gt;~-----I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0019 &lt;br /&gt;1-----1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0018 &lt;br /&gt;1-----1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;1-----1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0016 - New SP location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ENTER instruction creates a stack frame by pushing BP onto the stack and then &lt;br /&gt;loading BP with the uppermost address of the stack frame. This allows stack frame variables to &lt;br /&gt;be accessed through the BP register. The ENTER instruction contains two operands; the first &lt;br /&gt;operand specifies the number of bytes to reserve for variables on the stack frame, and the second &lt;br /&gt;specifies the level of the procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that an ENTER 8,0 instruction executes. This instruction reserves eight bytes of &lt;br /&gt;memory for the stack frame and the zero specifies level O. Figure 6-9 shows the stack frame set &lt;br /&gt;up by this instruction. Note that this instruction stores BP onto the top of the stack. It then sub-&lt;br /&gt;tracts 8 from the stack pointer, leaving eight bytes of memory space for temporary data storage. &lt;br /&gt;The uppermost location of this 8-byte temporary storage area is addressed by BP. The LEAVE &lt;br /&gt;instruction reverses this process by reloading both SP and BP with their prior values. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 6-21 shows how the ENTER instruction creates a stack frame so that two 16-bit &lt;br /&gt;parameters are passed to a system level procedure. Notice how the ENTER and LEAVE instruc-&lt;br /&gt;tions appear in this program, and how the parameters pass through the stack frame to and from &lt;br /&gt;the procedure. This procedure uses two parameters that pass to it and returns two results through &lt;br /&gt;the stack frame. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 C8 0004 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 Al 00C8 R &lt;br /&gt;0007 89 46 FC &lt;br /&gt;OOOA A1 OOCA R &lt;br /&gt;OOOD 89 46 FE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010E8 0100 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00138B 46 FC &lt;br /&gt;0016A3 00C8 R &lt;br /&gt;00198B 46 FE &lt;br /&gt;001CA3 OOCA R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001F C9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A sequence used to call system software that &lt;br /&gt;uses parameters stored in a stack frame. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENTER 4,0 ;create 4 byte frame &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,DATA1 &lt;br /&gt;MOV [BP-4l,AX isave para 1 &lt;br /&gt;MOV AX,DATA2 &lt;br /&gt;MOV [BP-2l,AX isave para 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL SYS ; call subroutine &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX, [BP-4l ;get result 1 &lt;br /&gt;MOV DATA1,AX ;save result 1 &lt;br /&gt;MOV AX, [BP-2l ;get result 2 &lt;br /&gt;MOV DATA2,AX ;save result 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEAVE &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;210 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(other software continues here) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;system subroutine that uses the stack f:&amp;gt;eame parameters &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 SYS ?ROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 60 PUSHA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0101 8B 46 FC NOV AX, [BP-41 ;get para 1 &lt;br /&gt;0104 8B 5E FE MOV BX, [BP-21 ;get para 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(software that uses the parameters) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0130 89 46 FC MOV [BP-41,AX ; save result 1 &lt;br /&gt;0133 89 5E FE MOV [BP-21,BX ; save result 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0136 61 POPA &lt;br /&gt;0137 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0138 SYS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. There are three types of unconditional jump instructions: short, near, and far. The short jump &lt;br /&gt;allows a branch to within +127 and -128 bytes. The near jump (using a displacement of &lt;br /&gt;Â±32K) allows ajump to anywhere in the current code segment (intrasegment). The far jump &lt;br /&gt;allows a jump to any location in the memory system (intersegment). The near jump in the &lt;br /&gt;80386 through the Pentium Pro is within Â±2G bytes because these microprocessors can use &lt;br /&gt;a 32-bit signed displacement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Whenever a label appears with a JMP instruction or conditional jump, the label, located in &lt;br /&gt;the label field, must be followed by a colon (LABEL:). The JMP DOGGY instruction jumps &lt;br /&gt;to memory location DOGGY:. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The displacement that follows a short or near jump is the distance from the next instruction &lt;br /&gt;to the jump location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. Indirect jumps are available in two forms: (1) jump to the location stored in a register and (2) &lt;br /&gt;jump to the location stored in a memory word (near indirect) or double word (far indirect). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Conditional jumps are all short jumps that test one or more of the flag bits: C, Z, 0, P, or S. &lt;br /&gt;If the condition is lme, a jump occurs; if the condition is false, the next sequential instruction &lt;br /&gt;executes. Note that the 80386 and above also allow a 16-bit signed displacement for the con-&lt;br /&gt;ditional jump instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. A special conditional jump instruction (LOOP) decrements CX and jumps to the label when &lt;br /&gt;CX is not O. Other forms of loop include LOOPE, LOOPNE, LOOPZ, and LOOPNZ. The &lt;br /&gt;LOOPE instruction jumps if CX is not 0, and if an equal condition exists. In the 80386 &lt;br /&gt;through the Pentium Pro, the LOOPD, LOOPED, and LOOPNED instructions also use the &lt;br /&gt;ECX register as a counler. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.7. The 80386 through the Pentium Pro contain conditional set instructions that either set a byte &lt;br /&gt;to OIH or clear it to OOH. If the condition under test is true, the operand byte is set to a 01 H; &lt;br /&gt;if the condition under test is false, the operand byte is cleared to OOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. The.IF and .ENDIF statements are useful in assembly language for making decisions. The &lt;br /&gt;instructions cause the assembler to generate conditional jump statements that modify the &lt;br /&gt;flow of the program. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-6 SUMMARY 211 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The .WHILE and .ENDW statements allow an assembly language program to use the DO-&lt;br /&gt;WHILE construction, and the .REPEAT and .UNTIL statements allow an assembly lan-&lt;br /&gt;guage program to use the REPEAT-UNTIL construct. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. ProC'l'dures are groups of instructions that perform one task and are used from any point in a &lt;br /&gt;program. The CALL instruction links to a procedure; and the RET instruction returns from &lt;br /&gt;a procedure. In assembly language, the PROC directive defines the name and type of proce-&lt;br /&gt;dure. The ENDP directive declares the end of the procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. The CALL instruction is a combination of a PUSH and a JMP instruction. When CALL ex-&lt;br /&gt;ecutes, it pushes the return address on the stack and then jumps to the procedure. A near &lt;br /&gt;CALL places the contents of IP on the stack, and a far CALL places both IP and CS on the &lt;br /&gt;stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The RET instruction returns from a procedure by removing the return address from the stack &lt;br /&gt;and placing it into IP (near return) or IP and CS (far return). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. Interrupts are either software instructions similar to CALL or hardware signals used to call &lt;br /&gt;procedures. This process interrupts the current program and calls a procedure. After the pro-&lt;br /&gt;cedure, a special IRET instruction returns control to the interrupted software. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Real mode interrupt vectors are four bytes long and contain the address (IP and CS) of the &lt;br /&gt;interrupt service procedure. The microprocessor contains 256 interrupt vectors in the first &lt;br /&gt;lK bytes of memory. The first 32 are defined by Intel; the remaining 224 are user interrupts. &lt;br /&gt;In protected mode operation, the interrupt vector is eight bytes long and the interrupt vector &lt;br /&gt;table may be relocated to any section of the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. Whenever an interrupt is accepted by the microprocessor, the flags IP and CS are pushed on &lt;br /&gt;the stack. Besides pushing the flags, the T and I flag bits are cleared to disable both the trace &lt;br /&gt;function and the INTR pin. The final event that occurs for the interrupt is that the interrupt &lt;br /&gt;vector is fetched from the vector table and a jump to the interrupt service procedure occurs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. Software interrupt instructions (INT) often replace system calls. Software interrupts save &lt;br /&gt;three bytes of memory each time they replace CALL instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. A special return instruction (IRET) must be used to return from an interrupt service proce-&lt;br /&gt;dure. The lRET instruction not only removes IP and CS from the stack, it also removes the &lt;br /&gt;flags from the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. Interrupt on an overflow (INTO) is a conditional interrupt that calls an interrupt service pro-&lt;br /&gt;cedure if the overflow flag (0) = 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. The interrupt enable flag (I) controls the INTR pin connection on the microprocessor. If the &lt;br /&gt;STI instruction executes, it sets I to enable the INTR pin. If the CLI instruction executes, it &lt;br /&gt;clears I to disable the INTR pin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. The carry flag bit (C) is cleared, set, and complemented by the CLC, STC, and CMC instructions. &lt;br /&gt;21. The WAIT instruction tests the condition of the BUSY or TEST pin on the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If BUSY or TEST = 1, WAIT does not wait; if BUSY or TEST = 0, WAIT continues testing &lt;br /&gt;the BUSY or TEST pin until it becomes a logic 1. Note that the 8086/8088 contain the TEST &lt;br /&gt;pin, while the 80286-80386 contain the BUSY pin. The 80486 through the Pentium Pro do &lt;br /&gt;not contain a BUSY or TEST pin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22. The LOCK prefix causes the LOCK pin to become a logic 0 for the duration of the locked &lt;br /&gt;instruction. The ESC instruction passes instruction to the numeric coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;23. The BOUND instruction compares the contents of any 16-bit register against the contents of &lt;br /&gt;two words of memory: an upper and a lower boundary. If the value in the register compared &lt;br /&gt;with memory is not within the upper and lower boundary, a type 5 interrupt ensues. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24. The ENTER and LEAVE instructions are used with stack frames. A stack frame is a mech-&lt;br /&gt;anism used to pass parameters to a procedure through the stack memory. The stack frame &lt;br /&gt;also holds local memory variables for the procedure. The ENTER instruction creates the &lt;br /&gt;stack frame, and the LEAVE instruction removes the stack frame from the stack. The BP &lt;br /&gt;register addresses stack frame data. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;212 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;25. Example 6-22 lists a program that uses some of the instructions presented in this chapter as &lt;br /&gt;well as those presented in prior chapters. This example contains a procedure that displays a &lt;br /&gt;character string on the monitor. As a test of the program, a few sample lines are displayed. &lt;br /&gt;Note that the character string is called a null string because it ends with a null (DOH). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 6-22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;00D4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0001 &lt;br /&gt;0003 &lt;br /&gt;0005 &lt;br /&gt;0007 &lt;br /&gt;0009 &lt;br /&gt;OOOB &lt;br /&gt;OOOD &lt;br /&gt;OOOD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0025 &lt;br /&gt;0026 &lt;br /&gt;0029 &lt;br /&gt;002C &lt;br /&gt;002F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;aD &lt;br /&gt;54 &lt;br /&gt;69 &lt;br /&gt;73 &lt;br /&gt;65 &lt;br /&gt;65 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AC &lt;br /&gt;3C &lt;br /&gt;74 &lt;br /&gt;8A &lt;br /&gt;B4 &lt;br /&gt;CD &lt;br /&gt;EB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FC &lt;br /&gt;BE &lt;br /&gt;E8 &lt;br /&gt;BE &lt;br /&gt;E8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OA OA 00 &lt;br /&gt;68 69 73 &lt;br /&gt;73 20 61 &lt;br /&gt;61 6D 70 &lt;br /&gt;20 6C 69 &lt;br /&gt;2E 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;08 &lt;br /&gt;DO &lt;br /&gt;02 &lt;br /&gt;21 &lt;br /&gt;F3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 R &lt;br /&gt;FFD4 &lt;br /&gt;0004 R &lt;br /&gt;FFCE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 &lt;br /&gt;20 &lt;br /&gt;6C &lt;br /&gt;6E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that displays a string of characters &lt;br /&gt;;using the procedure STRING. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL ;select SMALL model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA ;start of DATA segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MES1 DB 13,10,10,0 &lt;br /&gt;MES2 DB 'This is a sample line.',O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE ;start of CODE segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that displays the character string &lt;br /&gt;;addressed by SI in the data segment. The character &lt;br /&gt;;string must end with a null. &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;This procedure changes AX, DX, and SI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LODSB &lt;br /&gt;CMP AL,O &lt;br /&gt;JE STRING1 &lt;br /&gt;MOV DL,AL &lt;br /&gt;MOV AH,2 &lt;br /&gt;INT 21H &lt;br /&gt;JMP STRING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING1: &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING ENDP &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD &lt;br /&gt;MOV SI,OFFSET MES1 &lt;br /&gt;CALL STRING &lt;br /&gt;MOV SI,OFFSET MES2 &lt;br /&gt;CALL STRING &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get string character &lt;br /&gt;;test for null &lt;br /&gt;; if null &lt;br /&gt;;move ASCII code to DL &lt;br /&gt;;select function 02H &lt;br /&gt;;access DOS &lt;br /&gt;;repeat until null &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;return from procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start of program &lt;br /&gt;;select increment &lt;br /&gt;;address MES1 &lt;br /&gt;;display MES1 &lt;br /&gt;;address MES2 &lt;br /&gt;;display MES2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. What is a short JMP? &lt;br /&gt;2. Which type of JMP is used when jumping to any location within the current code segment? &lt;br /&gt;3. Whir..1 JMP instruction allows the program to continue execution at any memory location in &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the system? &lt;br /&gt;4. Which JMP instruction is five bytes long? &lt;br /&gt;5. What is the range of a near jump in the 80386-Pentium Pro microprocessors? &lt;br /&gt;6. Which type of JMP instruction (short, near, or far) assembles for the following: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) if the distance is 0210H bytes &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6-7 QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) if the distance is 0020H bytes &lt;br /&gt;(c) if the distance is 10000H bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. What can.be said about a label that is foIlowed by a colon? &lt;br /&gt;8. The near jump modifies the program address by changing which register or registers? &lt;br /&gt;9. The far jump modifies the program address by changing which register or registers? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;213 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Explain what the JMP AX instruction accomplishes. Also identify it as a near or a far jump &lt;br /&gt;insttuction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. Contrast the operation of a JMP DI with a JMP [DIl. &lt;br /&gt;12. Cdntrast the operation of a JMP [DIl with a JMP FAR PTR [DI]. &lt;br /&gt;13. List the five flag bits tested by the conditional jump instructions. &lt;br /&gt;14. Describe how the JA instruction operates. &lt;br /&gt;IS. When will the JO instruction jump? &lt;br /&gt;16. Which conditional jump instructions foIlow the comparison of signed numbers? &lt;br /&gt;17. Which conditional jump instructions foIlow the comparison of unsigned numbers? &lt;br /&gt;18. Which conditional jump instructions test both the Z and C flag bits? &lt;br /&gt;19. When does the JCXZ instruction jump? &lt;br /&gt;20. Which SET instruction is used to set AL if the flag bits indicate a zero condition? &lt;br /&gt;21. The 8086 LOOP instruction decrements register and tests it for a 0 to de-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cide if ajump occurs. &lt;br /&gt;22. The 80486 LOOPD instruction decrements register and tests it for a 0 to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;decide if a jump occurs. &lt;br /&gt;23. Explain how the LOOPE instruction operates. &lt;br /&gt;24. Develop a short sequence of instructions that stores a DOH into lSOH bytes of memory be-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ginning at extra segment memory location DATA. You must use the LOOP instruction to &lt;br /&gt;help perform this task. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2S. Develop a sequence of instructions that searches through a block of 100H bytes of memory. &lt;br /&gt;This program must count all the unsigned numbers that are above 42H and all that are below &lt;br /&gt;42H. Byte-sized data segment memory location UP must contain the count of numbers above &lt;br /&gt;42H, and data segment location DOWN must contain the count of numbers below 42H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26. Show what assembly language instructions are generated by the following sequence: &lt;br /&gt;.IF AL==3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,2 &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27. What happens if the .WHILE 1 instruction is placed in a program? &lt;br /&gt;28. Develop a short sequence of instructions that uses the REPEAT-UNTIL construct to copy the con-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tents of byte-sized memory BLOCKA into byte-sized memory BLOCKB until a DOH is moved. &lt;br /&gt;29. What is the purpose of the .BREAK directive? &lt;br /&gt;30. Using the DO-WHILE construct, develop a sequence of instructions that add the byte-sized &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;contents of BLOCK A to BLOCKB while the sum is not a 12H. &lt;br /&gt;31. What is a procedure? &lt;br /&gt;32. Explain how the near and far CALL instructions function. &lt;br /&gt;33. How does the near RET instruction function? &lt;br /&gt;34. The last executable instruction in a procedure must be a _____ _ &lt;br /&gt;3S. Which directive identifies the start of a procedure? &lt;br /&gt;36. How is a procedure identified as near or far? &lt;br /&gt;37. Explain what the RET 6 instruction accomplishes. &lt;br /&gt;38. Write a near procedure that cubes the contents of the CX register. This procedure may not &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;affect any register except CX. &lt;br /&gt;39. Write a procedure that multiplies DI by SI and then divides the result by 100H. Make sure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;that the result is left in AX upon returning from the procedure. This prm:t:uun: may not &lt;br /&gt;change any register except AX. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;214 CHAPTER 6 PROGRAM CONTROL INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40. Write a procedure that sums EAX. EBX, ECX, and EDX. If a carry occurs, place a logic I in &lt;br /&gt;ED!. If no carry occurs, place a logic 0 in ED!. The sum should be found in EAX after the &lt;br /&gt;execution of your procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41. What is an interrupt? &lt;br /&gt;42. Which software instructions call an interrupt service procedure? &lt;br /&gt;43. How many different interrupt types are available in the microprocessor? &lt;br /&gt;44. What is the purpose of interrupt vector type number O? &lt;br /&gt;45. Illustrate the contents of an interrupt vector and explain the purpose of each part. &lt;br /&gt;46. How does the IRET instruction differ from the RET instruction? &lt;br /&gt;47. What is the IRETD instruction? &lt;br /&gt;48. The INTO instruction only interrupts the program for what condition? &lt;br /&gt;49. The interrupt vector for an INT 40H instruction is stored at what memory locations? &lt;br /&gt;50. What instructions control the function of the INTR pin? &lt;br /&gt;51. Which personal computer interrupt services the parallel LPT port? &lt;br /&gt;52. Which personal computer interrupt services the keyboard? &lt;br /&gt;53. What instruction tests the BUSY pin? &lt;br /&gt;54. When will the BOUND instruction interrupt a program? &lt;br /&gt;55. An ENTER 16,0 instruction creates a stack frame that contains bytes. &lt;br /&gt;56. Which register moves to the stack when an ENTER instruction executes? &lt;br /&gt;57. Which instruction passes opcodes to the numeric coprocessor? &lt;br /&gt;58. What is a null string? &lt;br /&gt;59. Explain how the STRING procedure operates in Example 6-22. &lt;br /&gt;60. Rewrite Example 6-22 so it displays your name. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CHAPTER 7 &lt;br /&gt;Programming the Microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This chapter develops programs and programming techniques using the MASM macro assem-&lt;br /&gt;bler program, the DOS function calls, and the BIOS function calls. Many of the DOS function &lt;br /&gt;calls and BIOS function calls are used in this chapter, but all are explained in complete detail in &lt;br /&gt;Appendix A. Please scan the function calls listed in Appendix A as you read this chapter. The &lt;br /&gt;MASM assembler has already been explained and demonstrated in prior chapters, but there are &lt;br /&gt;still more features to learn at this point. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Some programming techniques explained in this chapter include macro sequences, &lt;br /&gt;keyboard and display manipulation, program modules, library files, using the mouse, and &lt;br /&gt;interrupt hooks. This chapter is meant as an introduction to programming, yet it provides &lt;br /&gt;valuable programming techniques that provide a wealth of background so that programs &lt;br /&gt;can be easily developed for the personal computer using either PCDOS or MSDOS as a &lt;br /&gt;springboard. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Use the MASM assembler and linker program to create programs that contain more than &lt;br /&gt;one module. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Explain the use of EXTRN and PUBLIC as they apply to modular programming. &lt;br /&gt;3. Set up a library file that contains commonly used subroutines. &lt;br /&gt;4. Write and use MACRO and ENDM to develop macro sequences as used with linear &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;programming. &lt;br /&gt;5. Show how both sequential and random access files are developed for use in a system. &lt;br /&gt;6. Develop programs using DOS function calls. &lt;br /&gt;7. Differentiate a DOS function call from a BIOS function call. &lt;br /&gt;8. Show how to hook into interrupts using DOS function calls. &lt;br /&gt;9. Use conditional assembly language statements in programs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Use the mouse in program examples. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;215 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;216 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MODULAR PROGRAMMING &lt;br /&gt;Many programs are too large to be developed by one person. This means that programs are rou-&lt;br /&gt;tinely developed by teams of programmers. The linker program is provided with MSDOS or &lt;br /&gt;PCDOS so that programming modules can be linked together into a complete program. Linking &lt;br /&gt;is also an internal function of the Programmer's WorkBench program that is bundled with &lt;br /&gt;MASM version 6.11. This section of the text describes the linker, the linking task, library files, &lt;br /&gt;EXTRN, and PUBLIC as they apply to program modules and modular programming, and intro-&lt;br /&gt;duces Programmer's WorkBench, which is also used to manage programs generated by teams. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Assembler and Linker &lt;br /&gt;The assembler program converts a symbolic source module (file) into a hexadecimal object &lt;br /&gt;tile. We have seen many examples of symbolic source files, written in assembly language, in prior &lt;br /&gt;chapters. Example 7-1 shows how the assembler dialog that appears as a source module named &lt;br /&gt;NEW.ASM is assembled.' Note that this dialog is used with version 6.11 at the DOS command &lt;br /&gt;line. This assembler also uses the Programmer's WorkBench program for development without &lt;br /&gt;resorting to the DOS command line. Whenever you create a source file, it should have an exten-&lt;br /&gt;sion of ASM. Source files are created using WorkBench, an editor that comes with the assembler, &lt;br /&gt;or by almost any other word processor or editor capable of genl?rating an ASCII file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-1 &lt;br /&gt;C:\\MASM611\\FILES&amp;gt;ml IFlnew.lst new.asm &lt;br /&gt;Microsoft (R) Macro Assembler Version 6.11 &lt;br /&gt;Copyright (C) Microsoft Corp 1981-1993. All rights reserved. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembling: new.asm &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microsoft (R) Segmented Executable Linker Version 5.31.009 Jul 13 1992 &lt;br /&gt;Copyright (C) Microsoft Corp 1984-1992. All rights reserved. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Object Modules [.obj): new.obj &lt;br /&gt;Run File [new.exe): &amp;quot;new.exe&amp;quot; &lt;br /&gt;List File [nul.map): NUL &lt;br /&gt;Libraries [.lib): &lt;br /&gt;Definitions File [nul.def): &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C:\\MASM611\\FILES&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The assembler program (ML) requires the source file name following ML. In the example, &lt;br /&gt;the IFI switch is used to create a listing file named NEW.LST. This is optional, but recom-&lt;br /&gt;mended so the output of the assembler can be viewed for troub1eshooting problems. The source &lt;br /&gt;listing file (.LST) contains the assembled version of the source file and its hexadecimal machine &lt;br /&gt;language equivalent. The cross-reference file (.CRF), which is not generated in this example, &lt;br /&gt;lists all labels and pertinent information required for cross-referencing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The linker program, which executes as the second part of ML, reads the object files, cre-&lt;br /&gt;ated by the assembler program, and links them into a single execution file. An execution tile is &lt;br /&gt;created with the file name extension EXE. Execution files are selected by typing the file name at &lt;br /&gt;the DOS prompt (A:\\). An example execution fill' is FROG.EXE, which is executed by typing &lt;br /&gt;FROG at the DOS command prompt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If a file is short enough, less than 64K bytes long, it can be converted from an execution file &lt;br /&gt;to a command tile (.COM). The command file is slightly different from an execution file in that &lt;br /&gt;the program must be originated at location lOOH before it can execute. This means that the pro-&lt;br /&gt;gram must be no larger than 64K-lOOH in length. The ML program generates a command file if &lt;br /&gt;the tiny model is used with a starting address of lOOH. Note that Programmer's WorkBench can &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-1 MODULAR PROGRAMMING 217 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;also be configured to generate a command file. The main advantage of a command file is that it &lt;br /&gt;loads off the disk into the computer much more quickly than an execution file. It also requires &lt;br /&gt;less disk storage space than the equivalent execution file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-2 shows the protocol involved with the linker program when it is used to link &lt;br /&gt;the files NEW, WHAT, and DONUT. The linker also links library files (J JBS) so procedures,lo-&lt;br /&gt;cated within LIBS, can be used with the linked execution file. To invoke the linker, type LINK &lt;br /&gt;at the DOS command prompt as illustrated in Example 7-2. Note that before files are linked, &lt;br /&gt;they must first be assembled and they must be errorjree. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-2 &lt;br /&gt;C:\\MASM611\\FILES&amp;gt;ml new.asm what.asm donut.asm &lt;br /&gt;Microsoft (R) Macro Assembler Version 6.11 &lt;br /&gt;Copyright (C) Microsoft Corp 1981-1993. All rights reserved. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembling: new.asm &lt;br /&gt;Assembling: what.asm &lt;br /&gt;Assembling: donut.asm &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microsoft (R) Segmented Executable Linker Version 5.31.009 Ju1 13 1992 &lt;br /&gt;Copyright (C) Microsoft Corp 1984-1992. All rights reserved. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Object Modules [.obj]: new.obj+ &lt;br /&gt;Obj ect Modules [. obj]: &amp;quot;what. obj&amp;quot; + &lt;br /&gt;Object Modules [.obj]: &amp;quot;donut.obj&amp;quot; &lt;br /&gt;Run File [new.exe]: &amp;quot;new.exe&amp;quot; &lt;br /&gt;List File [nul.map]: NUL &lt;br /&gt;Libraries [.lib]: &lt;br /&gt;Definitions File [nul.def]: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C:\\MASM611\\FILES&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this example, after LINK is typed, the linker program asks for the &amp;quot;Object Modules,&amp;quot; &lt;br /&gt;which are created by the assembler. In this example, we have three object modules: NEW, &lt;br /&gt;WHAT, and DONUT. If more than one object file exists, the main program file (NEW in this ex-&lt;br /&gt;ample) is typed first, followed by any other supporting modules. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Library files are entered after the file name and after the switch !LINK. In this example, we &lt;br /&gt;did not enter a library file name. To use a library called NUMB.LIB while assembling a program &lt;br /&gt;called NEW.ASM, type ML NEW.ASM !LINK NUMB.LID &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUBLIC and EXTRN &lt;br /&gt;The PUBLIC and EXTRN directives are very important to modular programming. We use &lt;br /&gt;PUBLIC to declare that labels of code, data, or entire segments are available to other program &lt;br /&gt;modules. We use EXTRN (external) to declare that labels are external to a module. Without &lt;br /&gt;these statements, we could not link modules together to create a program using modular pro-&lt;br /&gt;gramming techniques. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PUBLIC directive is normally placed in the opcode field of an assembly language &lt;br /&gt;statement to define a label as public so that it can be used by other modules. This label can be a &lt;br /&gt;jump address, a data address, or an entire segment. Example 7-3 shows the PUBLIC statement &lt;br /&gt;used to define some labels public to other modules. When segments are made public, they are &lt;br /&gt;combined with other public segments that contain data with the same segment name. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-3 &lt;br /&gt;.MODEL SMALL &lt;br /&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUBLIC DATAl &lt;br /&gt;PUBLIC DATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;declare DATAl and DATA2 public &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;218 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0064 [ DATAl DB 100 DUP ( ?) &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0064 0064[ DATA2 DB 100 DUP ( ?) &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;PUBLIC READ ; declare READ public &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0006 B4 06 MOV AH,6 ;read keyboard &lt;br /&gt;0008 B2 FF MOV DL,OFFH &lt;br /&gt;OOOA CD 21 INT 21H &lt;br /&gt;OOOC 74 F8 JE READ ;if no key typed &lt;br /&gt;OODE CB RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The EXTRN statement appears in both data and code segments to define labels as external &lt;br /&gt;to the segment. If data are defmed as external, their size must be represented as BYTE, WORD, &lt;br /&gt;or DWORD.1f a jump or call address is external, it must be represented as NEAR or FAR. Ex-&lt;br /&gt;ample 7-4 shows how the external statement is used to indicate that several labels are external to &lt;br /&gt;the program listed. Notice in this example that any external address or data are defined with the &lt;br /&gt;letter E in the hexadecimal assembled listing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0005 BF 0000 E &lt;br /&gt;0008 B9 OOOA &lt;br /&gt;OOOB &lt;br /&gt;OOOB 9A 0000 ---- E &lt;br /&gt;0010 AA &lt;br /&gt;0011 E2 FB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Libraries &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXTRN DATA1:BYTE &lt;br /&gt;EXTRN DATA2:BYTE &lt;br /&gt;EXTRN DATA3:WORD &lt;br /&gt;EXTRN DATA4:DWORD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXTRN READ:FAR &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;START: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFSET DATAl &lt;br /&gt;MOV CX,IO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL READ &lt;br /&gt;STOSB &lt;br /&gt;LOOP START &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Library files are collections of procedures that can be used by many different programs. These &lt;br /&gt;procedures are assembled and compiled into a library file by the LIB program that accompanies &lt;br /&gt;the MASM assembler program. Libraries allow common procedures to be collected into one &lt;br /&gt;place so that they can be used by many different applications. The library file (FILENAME.LIB) &lt;br /&gt;is invoked when a program is linked with the linker program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Why bother with library files? A library file is a good place to store a collection of re-&lt;br /&gt;lated procedures. When the library file is linked with a program, only the procedures required &lt;br /&gt;by the program are removed from the library file and added to the program. If any amount of &lt;br /&gt;assembly language programming is to be accomplished efficiently, a good set of library files &lt;br /&gt;is essential. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;EXAMPLE 7-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 52 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 B4 06 &lt;br /&gt;0003 B2 FF &lt;br /&gt;0005 CD 21 &lt;br /&gt;0007 74 F8 &lt;br /&gt;0009 SA &lt;br /&gt;OOOA CB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 52 &lt;br /&gt;0001 B4 06 &lt;br /&gt;0003 8A DO &lt;br /&gt;0005 CD 21 &lt;br /&gt;0007 SA &lt;br /&gt;0008 CB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-1 MODULAR PROGRAMMING 219 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Creating a Library File. A library file is created with the LIB command typed at the DOS &lt;br /&gt;prompt. A library file is a collection of assembled .OBJ files that each perform one procedure or &lt;br /&gt;task. Example 7-5 shows two separate files (READ_KEY and ECHO) that will be used to &lt;br /&gt;structure a library file. Please notice that the name of the procedure must be declared PUBLIC &lt;br /&gt;in a library file and does not necessarily need to match the file name, although it does in this &lt;br /&gt;example. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The first library module is called READ_KEY. This &lt;br /&gt;;procedure reads a key from the keyboard and returns with &lt;br /&gt;;its ASCII code in AL . &lt;br /&gt;. MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUBLIC READ_KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ_KEY PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH DX &lt;br /&gt;READ_KEY1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,6 &lt;br /&gt;MOV DH,OFFH &lt;br /&gt;INT 21H &lt;br /&gt;JE READ_KEY1 &lt;br /&gt;POP DX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ_KEY ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The second library module is called ECHO. This &lt;br /&gt;;procedure displays the ASCII character in AL on the &lt;br /&gt;;video screen . &lt;br /&gt;. MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUBLIC ECHO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECHO PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH DX &lt;br /&gt;MOV AH,6 &lt;br /&gt;MOV DL,AL &lt;br /&gt;INT 21H &lt;br /&gt;POP DX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECHO ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After ~ch file is assembled (note that there are two complete example programs in Ex-&lt;br /&gt;ample 7-5), the LIB program is used to combine them into a library file. The LIB program &lt;br /&gt;prompts for information, as illustrated in Example 7-6, where these files are combined to form &lt;br /&gt;the library 10. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-6 &lt;br /&gt;C:\\MASM611\\FILES\\LIB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microsoft (R) Library Manager Version 3.20.010 &lt;br /&gt;Copyright (C) Microsoft Corp. 1983-1992. All rights reserved. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Library name: 10 &lt;br /&gt;Library file does not exist. Create? Y &lt;br /&gt;Operations: READ_KEY+ECHO &lt;br /&gt;List file: 10 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;220 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The LIB program begins with the copyright message from Microsoft, followed by the &lt;br /&gt;prompt Library name. The library name chosen is 10 for the 10.LIB file. Because this is a new &lt;br /&gt;file, the library program asks if we wish to create the library file. The Operations: prompt is &lt;br /&gt;where the library module names are typed. In this case we create a library using two procedure &lt;br /&gt;files (READ_KEY and ECHO). Note that these files were created and assembled as &lt;br /&gt;READ_KEY.ASM and ECHO.ASM from Example 7-5. The list file shows the contents of the &lt;br /&gt;library and is illustrated for this library in Example 7-7. The list file shows the size and names of &lt;br /&gt;the files used to create the library and also the public label (procedure name) that is used in the &lt;br /&gt;library file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If you must add additional library modules at a later time, type the name of the library file &lt;br /&gt;after invoking LIB. At the Operations: type the new module name preceded with a plus sign to &lt;br /&gt;add a new procedure. If you must delete a library module, use a minus sign before the operation &lt;br /&gt;file name. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-7 &lt;br /&gt;ECHO ................... ECHO READ_KEy ................... READ_KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ_KEY &lt;br /&gt;READ_KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset: OOOOOOlOH Code and data size: BH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ECHO Offset: 00000070H Code and data size: 9H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once the library file is linked to your program file, only the library procedures actually &lt;br /&gt;used by your program are placed in the execution file. Don't forget to use the label EXTRN &lt;br /&gt;when specifying library calls from your program module. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Macros &lt;br /&gt;A macro is a group of instructions that perform one task, just as a procedure performs one task. &lt;br /&gt;The difference is that a procedure is accessed via a CALL instruction, while a macro is inserted &lt;br /&gt;in the program at the point of usage as a new sequence of instructions. Creating a macro is very &lt;br /&gt;similar to creating a new opcode that can be used in the program. Macro sequences execute &lt;br /&gt;faster than procedures because there are no CALL and RET instructions to execute. The macros &lt;br /&gt;instructions are placed in your program by the assembler at the point they are invoked. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The MACRO and ENDM directives are used to delineate a macro sequence. The first &lt;br /&gt;statement of a macro is the MACRO instruction, which contains the name of the macro and any &lt;br /&gt;parameters associated with it. An example is MOVE MACRO A,B, which defines the macro as &lt;br /&gt;MOVE. This new pseudo opcode uses two parameters: A and B. The last statement of a macro is &lt;br /&gt;the ENDM instruction, which is placed on a line by itself. Never place a label in front of the &lt;br /&gt;ENDM statement, or the macro will not assemble. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-8 shows how a macro is created and used in a program. This macro moves the &lt;br /&gt;word-sized contents of memory location B into word-sized memory location A. After the macro &lt;br /&gt;is defined in the example, it is used twice. The macro is expanded by the assembler in this ex-&lt;br /&gt;ample so that you can see how it assembles to generate the moves. Any hexadecimal machine &lt;br /&gt;language statement followed by a number (a 1 in this example) is a macro expansion statement. &lt;br /&gt;The expansion statements are not typed in the source program; they are generated by the assem-&lt;br /&gt;bler to show that the assembler has inserted them into the program. Notice that the comment in &lt;br /&gt;the macro is preceded with a ;; instead of a ; as is customary. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-8 &lt;br /&gt;MOVE HACRO A,B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;MOV AX,B &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-1 MODULAR PROGRAMMING 221 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV A,AX &lt;br /&gt;POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENON &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOVE VAR1,VAR2 ; use the [Â·IOVE macro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 1 PUSH AX &lt;br /&gt;0001 A1 0002 R 1 N AX , VAR2 &lt;br /&gt;0004 A3 onno R 1 NOV VARl.AX &lt;br /&gt;0007 58 1 POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOVE VAR3,VAR4 ;use the MOVE macro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 50 1 PUSH AX &lt;br /&gt;0009 A1 0006 R 1 MOV AX,VAR4 &lt;br /&gt;OOOC A3 0004 R 1 HOV VAR3,AX &lt;br /&gt;OOOF 58 1 POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Local Variables in a Macro. Sometimes macros contain local variables. A local variable is one &lt;br /&gt;that appears in the macro, but is not available outside the macro. To define a local variable, we &lt;br /&gt;use the LOCAL directive. Example 7-9 shows how a local variable, used as ajump address, ap-&lt;br /&gt;pears in a macro definition. If this jump address is not defined as local, the assembler will flag it &lt;br /&gt;with errors on the second and subsequent attempts to use the macro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 52 1 &lt;br /&gt;0001 1 &lt;br /&gt;0001 B4 06 1 &lt;br /&gt;0003 B2 FF 1 &lt;br /&gt;OOOS CD 21 1 &lt;br /&gt;0007 74 F8 1 &lt;br /&gt;0009 A2 0008 R 1 &lt;br /&gt;OOOC SA 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOD S2 1 &lt;br /&gt;OOOE 1 &lt;br /&gt;OOOE B4 06 1 &lt;br /&gt;0010 B2 FF 1 &lt;br /&gt;0012 CD 21 1 &lt;br /&gt;0014 74 F8 1 &lt;br /&gt;0016 A2 0009 R 1 &lt;br /&gt;0019 SA 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ MACRO &lt;br /&gt;LOCAL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH &lt;br /&gt;REA01: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV &lt;br /&gt;NOV &lt;br /&gt;INT &lt;br /&gt;JE &lt;br /&gt;NOV &lt;br /&gt;POP &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH &lt;br /&gt;??OOOO: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV &lt;br /&gt;MOV &lt;br /&gt;INT &lt;br /&gt;JE &lt;br /&gt;MOV &lt;br /&gt;POP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH &lt;br /&gt;??0001: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;NOV &lt;br /&gt;INT &lt;br /&gt;JE &lt;br /&gt;MOV &lt;br /&gt;POP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;READ1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,6 &lt;br /&gt;DL,OFFH &lt;br /&gt;21H &lt;br /&gt;READ1 &lt;br /&gt;A,AL &lt;br /&gt;DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VAR5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,6 &lt;br /&gt;DL,OFFH &lt;br /&gt;21H &lt;br /&gt;??OOOO &lt;br /&gt;VARS,AL &lt;br /&gt;DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VAR6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,6 &lt;br /&gt;DL,OFFH &lt;br /&gt;21H &lt;br /&gt;??0001 &lt;br /&gt;VAR6,AL &lt;br /&gt;DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; ; reads keyboard &lt;br /&gt;;;define READ1 as local &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key into VAR5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key into VAR6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This example reads a character from the keyboard and stores it into the byte-sized memory &lt;br /&gt;location indicated as a parameter with the macro. Notice how the local label READ 1 is treated in &lt;br /&gt;the expanded macros. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;222 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The LOCAL directive must always immediately follow the MACRO directive without any &lt;br /&gt;intervening spaces or comments. If a comment or space appear between MACRO and LOCAL, &lt;br /&gt;the assembler indicates an error and will not accept the variable as local. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Placing Macro Definitions in Their Own Module. Macro definitions can be placed in the pro-&lt;br /&gt;gram file as shown, or can be placed in their own macro module. A file can be created that con-&lt;br /&gt;tains only macros that are to be included with other program files. We use the INCLUDE &lt;br /&gt;directive to indicate that a program file will include a module that contains external macro def-&lt;br /&gt;initions. Although this is not a library file, for all practical purposes it functions as a library of &lt;br /&gt;macro sequences. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When macro sequences are placed in a file (often with the extension INC or MAC), they &lt;br /&gt;do not contain PUBLIC statements. If a file called MACRO.MAC contains macro sequences, the &lt;br /&gt;INCLUDE statement is placed in the program file as INCLUDE C:\\ASSM\\MACRO.MAC. No-&lt;br /&gt;tice that the macro file is on drive C, subdirectory ASSM in this example. The INCLUDE state-&lt;br /&gt;ment includes these macros just as if you had typed them into the file. No EXTRN statement is &lt;br /&gt;needed to access the macro statements that have been included. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conditional Statements in Macro Sequences &lt;br /&gt;Conditional assembly language statements are available to the assembler for use in the assembly &lt;br /&gt;process and also in macro sequences. The conditional statements for assembly flow control &lt;br /&gt;create instructions that control the flow of the program and are variations of IF-THEN, IF-&lt;br /&gt;THEN-ELSE, DO-WHILE, and REPEAT-UNTIL constructs used in high-level programming &lt;br /&gt;languages, which were presented in the last chapter. The conditional statements for macro se-&lt;br /&gt;quence control-presented here-are also available, but function to create instructions only at &lt;br /&gt;assembly time within macro sequences. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conditional Assembly Statements &lt;br /&gt;As mentioned, conditional assembly is implemented with the IF-THEN or IF-THEN-ELSE con-&lt;br /&gt;struct found in higher-level languages. Table 7-1 shows the forms used for the IF statement in &lt;br /&gt;the conditional assembly process. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The IF and ENDIF statements allow portions of the program to assemble if some condition &lt;br /&gt;is met. Otherwise, the statements between IF and ENDIF do not assemble. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-10 shows how the IF, ELSE, and ENDIF statement are used to conditionally as-&lt;br /&gt;semble values for the width and length of paper in a program. Note that TRUE and FALSE are de-&lt;br /&gt;fined as 1 and O. This is important because these values are not predefined by the assembler. Next, &lt;br /&gt;the width and length of the paper are adjusted by using TRUE and FALSE statements. This can be &lt;br /&gt;expanded to ask an entire series of questions about a program so custom versions can be created. &lt;br /&gt;Example 7-10 (a) is the original source code, and Example 7-10 (b) shows how the program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 7-1 Conditional &lt;br /&gt;assembly language IF &lt;br /&gt;statements &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Statement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IF &lt;br /&gt;IFB &lt;br /&gt;IFE &lt;br /&gt;IFDEF &lt;br /&gt;IFNB &lt;br /&gt;IFNDEF &lt;br /&gt;IFIDN &lt;br /&gt;IFDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the expression is true &lt;br /&gt;If argument is blank &lt;br /&gt;If the expression is not true &lt;br /&gt;If the label has been defined &lt;br /&gt;If argument is not blank &lt;br /&gt;I f the label has not been defined &lt;br /&gt;If argument 1 equals argument 2 &lt;br /&gt;If argument 1 does not equal argument 2 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-1 MODULAR PROGRAMMING 223 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;assembles for TRUE answers for both the width and length. Example 7-10 (c) shows the assem-&lt;br /&gt;bled output for a false width and a true length. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When Example 7-10 (a) is assembled, TRUE and FALSE are equated to WIDT and &lt;br /&gt;LENGT to modify the way that the assembler forms the program. In Example 7-10 (b), both &lt;br /&gt;WIDT and LENGT are defined as TRUE, which causes the assembler to modify the way the pro-&lt;br /&gt;gram is assembled so that a page is 72 columns wide and the length is continuous. Example 7-10 &lt;br /&gt;(c) is another example where the WIDT is FALSE and LENGT is TRUE, causing the assembler &lt;br /&gt;to form the instructions that make the page 80 columns wide and the length continuous. The only &lt;br /&gt;form not shown is where the page length is 66 lines. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Examples of some of the other forms listed in Table 7-1 appear later in the text. When one &lt;br /&gt;of these new conditional statement appears, it is explained and shown with an example. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-10 (a) &lt;br /&gt;isource program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRUE EQU 1 ;define true &lt;br /&gt;FALSE EQU a ;define false &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WIDT EQU FALSE ;set to true if 72 columns &lt;br /&gt;; and false if 80 columns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LENGT EQU TRUE ;set to true if continuous &lt;br /&gt;; and false if 66 lines &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IF WIDT ;72 columns &lt;br /&gt;WIDE DB 72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ELSE &lt;br /&gt;WIDE DB 80 ;80 columns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IF LENGT ;if continuous &lt;br /&gt;LONG DB -1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ELSE &lt;br /&gt;LONG DB 66 ;if 66 lines &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-10 (b) &lt;br /&gt;&amp;quot;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;assembled portion with WIDT = TRUE and LENGT TRUE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IF WIDT ;72 columns &lt;br /&gt;0000 48 WIDE DB 72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ELSE &lt;br /&gt;ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IF LENGT ;if continuous &lt;br /&gt;0001 FF LONG DB -1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ELSE &lt;br /&gt;ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-10 (c) &lt;br /&gt;;assembled portion with WIDT = FALSE and LENGT TRUE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IF WIDT ;72 columns &lt;br /&gt;ELSE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 WIDE DB 80 ;80 columns &lt;br /&gt;ENDIF &lt;br /&gt;IF LENGT ; if continuous &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 FF LONG DB -1 &lt;br /&gt;ELSE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDIF &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;224 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Using Conditional Statements in Macros &lt;br /&gt;Macro sequences have their own set of conditional instructions that differ somewhat from the &lt;br /&gt;ones used with the assembler as presented in Chapter 6. For example, macros can use REPEAT &lt;br /&gt;and WHILE, but they do so without the period in front of the keywords REPEAT and WHILE. &lt;br /&gt;The REPEAT has no corresponding UNTIL, and the WHILE statement has no corresponding &lt;br /&gt;ENDW when used in a macro. These statements are available to all versions of the assembler. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The macro statement WHILE and REPEAT commands are not preceded with a period and &lt;br /&gt;use a different set of relational operators. Table 7-2 lists the relational operators used with &lt;br /&gt;WHILE and REPEAT. These operators can also be used with any of the statements listed in &lt;br /&gt;Table 7-1. Note that these are different than the operator specified in Table 6-3 for the .WHILE &lt;br /&gt;and .REPEAT statements. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPEAT Statement in a Macro. The REPEAT statement has a parameter associated with it to re-&lt;br /&gt;peat the macro sequence a fixed number of times. As with any other macro sequence, the repeat &lt;br /&gt;sequence must end with the ENDM statement. The repeat sequence inserts the instruction that &lt;br /&gt;appears between the REPEAT statement and the ENDM statement into the program the number &lt;br /&gt;of times indicated with the REPEAT statement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-11 shows a macro called TESTS and its calling program, which sends the 10 &lt;br /&gt;ASCII characters from zero through 9 to the video screen. Notice how this macro is formed &lt;br /&gt;using the MACRO statement to name the macro TESTS, and also how the REPEAT statement &lt;br /&gt;appears within macro TESTS with its own ENDM statement. Notice that the macro starts by &lt;br /&gt;placing a 6 into AH and the ASCII code for a 0 in DL. This sets up the DOS INT 2lH function &lt;br /&gt;call, so a 0 is displayed on the video screen. Next, the REPEAT statement appears (note that it &lt;br /&gt;does not contain a period as in .REPEAT). This is a different REPEAT statement used only in &lt;br /&gt;macro sequences and available to all versions of MASM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The repeated statements in this example are INT 21H which displays the ASCII contents &lt;br /&gt;of DL, and INC DL, which modifies the ASCII code displayed. In this case, the REPEAT 10 &lt;br /&gt;causes the statements between REPEAT 10 and the first ENDM to be repeated 10 times as illus-&lt;br /&gt;trated. Note that the I and 2 to the left of the instructions are listed to show that these statements &lt;br /&gt;are assembler generated and not entered as part of the source program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-11 &lt;br /&gt;TESTS MACRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,6 &lt;br /&gt;HOV DL, '0' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPEAT 10 &lt;br /&gt;INT 2:j.H &lt;br /&gt;INC DL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDM &lt;br /&gt;ENDH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 MAIN PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TESTS ;display o through 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B4 06 1 MOV AH,6 &lt;br /&gt;0002 B2 30 1 MOV DL,' 0' &lt;br /&gt;1004 CD 21 2 INT 21H &lt;br /&gt;0006 FE C2 2 INC DL &lt;br /&gt;0008 CD 21 2 INT 21H &lt;br /&gt;OOOA FE C2 2 INC DL &lt;br /&gt;OOOC CD 21 2 INT 21H &lt;br /&gt;OOOE FE C2 2 INC DL &lt;br /&gt;0010 CD 21 2 INT 21H &lt;br /&gt;0012 FE C2 2 INC DL &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-1 MODULAR PROGRAMMING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 7-2 Relational &lt;br /&gt;operators used with WHILE &lt;br /&gt;and REPEAT in macro &lt;br /&gt;sequences &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 CD 21 2 &lt;br /&gt;0016 FE C2 2 &lt;br /&gt;0018 CD 21 2 &lt;br /&gt;001A FE C2 2 &lt;br /&gt;001C CD 21 2 &lt;br /&gt;OOlE FE C2 2 &lt;br /&gt;0020 CD 21 2 &lt;br /&gt;0022 FE C2 2 &lt;br /&gt;0024 CD 21 2 &lt;br /&gt;0026 FE C2 2 &lt;br /&gt;0028 CD 21 2 &lt;br /&gt;002A FE C2 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0031 MAIN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operator &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT &lt;br /&gt;INC &lt;br /&gt;INT &lt;br /&gt;INC &lt;br /&gt;INT &lt;br /&gt;INC &lt;br /&gt;INT &lt;br /&gt;INC &lt;br /&gt;INT &lt;br /&gt;INC &lt;br /&gt;INT &lt;br /&gt;INC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQ &lt;br /&gt;NE &lt;br /&gt;LE &lt;br /&gt;LT &lt;br /&gt;GE &lt;br /&gt;GT &lt;br /&gt;NOT &lt;br /&gt;AND &lt;br /&gt;OR &lt;br /&gt;XOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21H &lt;br /&gt;DL &lt;br /&gt;21H &lt;br /&gt;DL &lt;br /&gt;21H &lt;br /&gt;DL &lt;br /&gt;21H &lt;br /&gt;DL &lt;br /&gt;21H &lt;br /&gt;DL &lt;br /&gt;21H &lt;br /&gt;DL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Equal &lt;br /&gt;Not equal &lt;br /&gt;Less than or equal &lt;br /&gt;Less than &lt;br /&gt;Greater than or equal &lt;br /&gt;Greater than &lt;br /&gt;Logical inversion &lt;br /&gt;Logical AND &lt;br /&gt;Logical OR &lt;br /&gt;Logical exclusive-OR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;225 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WHILE Statement in a Macro. The WHILE statement appears in macro sequences in much the &lt;br /&gt;same way as REPEAT appears. That is, the while loop is terminated with the ENDM statement. &lt;br /&gt;The expression associated with WHILE determines how many times the loop is repeated. Again, &lt;br /&gt;note that the WHILE statement in the macro is different from the .WHILE statement described in &lt;br /&gt;Chapter 6. The WHILE statement is available to all versions of MASM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-12 Â·;hows how the WHILE statement is used to generate a table of squares &lt;br /&gt;from 2 squared to whatever value fits into an array of byte-sized memory called SQUARE. The &lt;br /&gt;first statement of the sequence defines the label SQUARE for the first byte of data generated. &lt;br /&gt;The WHILE RES LT 255 repeats the calculation (SEED*SEED) while the result is less than or &lt;br /&gt;equal to 255. Notice that the table generated contains the square of the numbers from 2 to 15 or &lt;br /&gt;225 (EIH). If you look closely at Example 7-12, the value of the SEED + 1 and SEED * SEED &lt;br /&gt;shows the number and its square. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 0001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 01 &lt;br /&gt;0002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;table of byte-sized squares &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SQUARE LABEL BYTE &lt;br /&gt;SEED 1 &lt;br /&gt;RES SEED*SEED &lt;br /&gt;WHILE RES LT 255 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB RES &lt;br /&gt;SEED SEED+l &lt;br /&gt;RES SEED*SEED &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 DB RES &lt;br /&gt;1 SEED &lt;br /&gt;1 RES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEED+1 &lt;br /&gt;SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; ; define label &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;compute square &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;226 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 04 1 DB RES &lt;br /&gt;= 0003 1 SEED SEED+1 &lt;br /&gt;= 0009 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 09 1 DB RES &lt;br /&gt;= 0004 1 SEED SEED+1 &lt;br /&gt;= 0010 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003 10 1 DB RES &lt;br /&gt;= 0005 1 SEED SEED+l &lt;br /&gt;= 0019 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 19 1 DB RES &lt;br /&gt;= 0006 1 SEED SEED+1 &lt;br /&gt;= 0024 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0005 24 1 DB RES &lt;br /&gt;= 0007 1 SEED SEED+1 &lt;br /&gt;= 0031 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0006 31 1 DB RES &lt;br /&gt;= 0008 1 SEED SEED+1 &lt;br /&gt;= 0040 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 40 1 DB RES &lt;br /&gt;= 0009 1 SEED SEED+1 &lt;br /&gt;= 0051 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 51 1 DB RES &lt;br /&gt;= OOOA 1 SEED SEED+1 &lt;br /&gt;= 0064 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 64 1 DB RES &lt;br /&gt;= OOOB 1 SEED SEED+1 &lt;br /&gt;= 0079 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA 79 1 DB RES &lt;br /&gt;= OOOC 1 SEED SEED+1 &lt;br /&gt;= 0090 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB 90 1 DB RES &lt;br /&gt;= DODD 1 SEED SEED+1 &lt;br /&gt;= 00A9 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC A9 1 DB RES &lt;br /&gt;= OOOE 1 SEED SEED+l &lt;br /&gt;= 00C4 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOD C4 1 DB RES &lt;br /&gt;OOOF 1 SEED SEED+l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= OOEI 1 RES SEED*SEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FOR Statement in a Macro. The FOR statement iterates a list of data. If you are familiar with &lt;br /&gt;BASIC, the FOR statement functions like the READ statement and the list of data associated &lt;br /&gt;with it functions like the DATA statement. Example 7-13 shows how the FOR statement is used &lt;br /&gt;to display a series of characters on the video display. Notice that the CHR:VARARG indicates &lt;br /&gt;the variable name CHR that is of variable size (V ARARG). The first use of the DISP macro gen-&lt;br /&gt;erates the code required to display BARRY. The second use ofDISP generates the code required &lt;br /&gt;to display BREY. The FOR statement counts the variable used after display and repeats the com-&lt;br /&gt;mands between FOR and ENDM for each variable, in this case each ASCII character. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B4 02 &lt;br /&gt;0002 B2 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP MACRO CHR:VARARG &lt;br /&gt;MOV AH,2 &lt;br /&gt;FOR ARG,&amp;lt;CHR&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,ARG &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDM &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP 'B', 'A', 'R' I 'R', 'Y' &amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL, 'B' &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-1 MODULAR PROGRAMMING 227 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 CD 21 2 INT 21H &lt;br /&gt;0006 B2 41 2 MOV DL,' A' &lt;br /&gt;0008 CD 21 2 INT 21H &lt;br /&gt;OOOA B2 52 2 MOV DL, 'P' &lt;br /&gt;OOOC CD 21 2 INT 21H &lt;br /&gt;OOOE B2 52 2 MOV DL, 'P.' &lt;br /&gt;0010 CD 21 2 INT 21H &lt;br /&gt;0012 B2 59 2 MOV DL, 'Y' &lt;br /&gt;0011 CD 21 2 INT 21H &lt;br /&gt;0016 B2 20 2 MOV DL, ' , &lt;br /&gt;0018 CD 21 2 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP 'B', 'R', 'E', 'Y' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001A B4 02 1 MOV AH,2 &lt;br /&gt;OOlC B2 42 2 MOV DL, 'B' &lt;br /&gt;DOlE CD 21 2 INT 21H &lt;br /&gt;0020 B2 52 2 MOV DL, 'R' &lt;br /&gt;0022 CD 21 2 INT 21H &lt;br /&gt;0024 B2 45 2 MOV DL, 'E' &lt;br /&gt;0026 CD 21 2 INT 21H &lt;br /&gt;0028 B2 59 2 MOV DL, 'Y' &lt;br /&gt;002A CD 21 2 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IF, ELSE, and ENDIF Statements in a Macro. The IF statement is used in a macro to make deci-&lt;br /&gt;sions based on the parameters sent to the macro. As before, note that IF is used in a macro and &lt;br /&gt;.IF is used in a program. Only the IF statement is available to all versions of the assembler, &lt;br /&gt;whereas .IF is available only to version 6.X. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In Example 7-14, a macro is developed that uses a number of conditional assembly state-&lt;br /&gt;ments to read a key, display a character, or display a carriage return and line feed combination. &lt;br /&gt;This example illustrates the use of IF, IFB, INB, ENDIF, and ELSE. The macro is called 10. If &lt;br /&gt;10 is used on a line by itself, the assembler generates the code to read a key. IfIO -1 appears as &lt;br /&gt;a statement, the assembler generates the code required to display a carriage return and line feed. &lt;br /&gt;If 10 'B' appears as a statement, the assembler generates the code required to display the letter &lt;br /&gt;B. This example is listed in expanded form so that the code generated by the assembler can be &lt;br /&gt;viewed and studied. As before, the lines that contain a number between the hexadecimal code &lt;br /&gt;and the statement in the program are assembler generated and are not included in the original &lt;br /&gt;source program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;.MODEL TINY &lt;br /&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;the 10 macro functions in 3 ways &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; (1) 10 read a key with echo &lt;br /&gt;; (2) IO -1 display a carriage return &amp;amp; line feed &lt;br /&gt;; (3) IO 'B' display the letter 'B' &lt;br /&gt;;or 10 AL display contents of AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 MACRO CHAR &lt;br /&gt;IFB &amp;lt;CHAR&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1FNB &amp;lt;CHAR&amp;gt; &lt;br /&gt;MOV AH,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IF CHAR EQ -1 &lt;br /&gt;MOV DL,13 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;if CHAR is blank &lt;br /&gt;;;read key function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;if CHAR not blank &lt;br /&gt;;;display character &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;if CHAR equals -1 &lt;br /&gt;; ; display return &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;228 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 B4 02 1 &lt;br /&gt;0102 B2 OD 1 &lt;br /&gt;0104 CD 21 1 &lt;br /&gt;0106 B2 OA 1 &lt;br /&gt;0108 CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010A B4 02 1 &lt;br /&gt;010C B2 42 1 &lt;br /&gt;010E CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0110 B4 02 1 &lt;br /&gt;0112 B2 45 1 &lt;br /&gt;0114 CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0116 B4 01 1 &lt;br /&gt;0118 CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;011A B4 02 1 &lt;br /&gt;011C B2 OD 1 &lt;br /&gt;011r; CD 21 1 &lt;br /&gt;0120 B2 OA 1 &lt;br /&gt;0122 CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ELSE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,CHAR &lt;br /&gt;ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;disp1ay line feed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; ; if CHAR not -1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;load CHAR to DL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;This program does a carriage return, line feed then &lt;br /&gt;;displays the letters BE on the video screen. Next it &lt;br /&gt;;waits for a key to be typed. Following the key, a &lt;br /&gt;;carriage return/line feed is displayed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IO -1 ;return &amp;amp; line feed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL,13 &lt;br /&gt;INT 21H &lt;br /&gt;MOV DL,10 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IO 'B' ;display 'B' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL, 'B' &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IO 'E' ;disp1ay 'E' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL, 'E' &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IO ;read key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IO -1 ;return &amp;amp; line feed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL,13 &lt;br /&gt;INT 21H &lt;br /&gt;MOV DL,lO &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first part of the macro uses the IFB &amp;lt;CHAR&amp;gt; statement to test CHAR for a blank con-&lt;br /&gt;dition. If CHAR is blank, the assembler generates the MOY AH,l instruction followed by the &lt;br /&gt;very last instruction in the macro, INT 21H, to read a key with echo. This is used in the program &lt;br /&gt;with the 10 statement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The second part of the macro contains the IFNB &amp;lt;CHAR&amp;gt; statement to test if CHAR is not &lt;br /&gt;blank. If CHAR is not blank, another IF-ELSE-ENDIF sequence appears to test the contents of &lt;br /&gt;CHAR. If CHAR is a -I, the assembler generates the code required to display a carriage return &lt;br /&gt;and line feed combination. If CHAR is not a -I, the ELSE statement places CHAR into DL for &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-2 USING THE KEYBOARD AND VIDEO DISPLAY 229 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;display. This is a very powerful macro that can handle most keyboard and single-character dis-&lt;br /&gt;play functions. It also illustrates the power of the conditional assembly statements when used &lt;br /&gt;within a macro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Modular Programming Approach &lt;br /&gt;The modular programming approach often involves a team of people assigned different pro-&lt;br /&gt;gramming tasks. This allows the team manager to assign portions of the program to different &lt;br /&gt;team members. Often, the team manager develops the system flowchart or shell and then divides &lt;br /&gt;it into modules for team members. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A team member might be assigned the task of developing a macro definition file. This file &lt;br /&gt;might contain macro definitions that handle the 110 operations for the system. Another team &lt;br /&gt;member might be assigned the task of developing the procedures used for the system. In most &lt;br /&gt;cases, the procedures are organized as a library file that is linked to the program modules. Fi-&lt;br /&gt;nally, several program files or modules might be used for the final system, each developed by &lt;br /&gt;different team members. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This approach requires a high level of communication between team members and good &lt;br /&gt;documentation. Documentation is the key so that modules interface correctly. Communication &lt;br /&gt;among members also plays a key role in this approach. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;USING THE KEYBOARD AND VIDEO DISPLAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Today there are few programs that don't use the keyboard and video display. This section of the &lt;br /&gt;text explains how to use the keyboard and video display connected to the IBM PC or compatible &lt;br /&gt;computer running under either MSDOS or PCDOS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reading the Keyboard with DOS Functions &lt;br /&gt;The keyboard of the personal computer is read via a DOS function call. A complete listing of the &lt;br /&gt;DOS function calls appears in Appendix A. This section uses INT 21H with various DOS func-&lt;br /&gt;tion calls to read the keyboard. Data read from the keyboard are either in ASCII-coded form or &lt;br /&gt;in extended ASCII-coded form. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ASCII-coded data appears as outlined in Table 1-7. The extended character set of &lt;br /&gt;Table 1-8 applies to printed or displayed data only and not to keyboard data. Notice that the &lt;br /&gt;ASCII codes in Table 1-7 correspond to most of the keys on the keyboard. Also available &lt;br /&gt;through the keyboard are extended ASCII-coded keyboard data. Table 7-3 lists most of the ex-&lt;br /&gt;tended ASCII codes obtained with various keys and key combinations. Notice that most keys on &lt;br /&gt;the keyboard have alternative key codes. Each function key has four sets of codes selected by the &lt;br /&gt;function key alone, the shift-function key combination, the alternate-function key combination, &lt;br /&gt;and the control-function key combination. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are three ways to read the keyboard. The first method reads a key and echoes (or dis-&lt;br /&gt;plays) the key on the video screen. The second way simply tests to see if a key is pressed-if it &lt;br /&gt;is, the function reads the key; otherwise, it returns without any key. The third way allows an en-&lt;br /&gt;tire character line to be read from the keyboard. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reading a Key with an Echo. Example 7-15 shows how a key is read from the keyboard and &lt;br /&gt;echoed (sent) back out to the video display using a procedure called KEY. Although this is the &lt;br /&gt;easiest way to read a key, it is also the most limited because this method always echoes the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;230 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 7-3 The keyboard &lt;br /&gt;scanning and extended ASCII Extended ASCII code with .... &lt;br /&gt;codes as returned from the &lt;br /&gt;keyboard Key Scan Code Nothing Shift Control Alternate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Esc 01 01 &lt;br /&gt;1 02 78 &lt;br /&gt;2 03 03 79 &lt;br /&gt;3 04 7A &lt;br /&gt;4 05 7B &lt;br /&gt;5 06 7C &lt;br /&gt;6 07 7D &lt;br /&gt;7 08 7E &lt;br /&gt;8 09 7F &lt;br /&gt;9 OA 80 &lt;br /&gt;0 OB 81 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OC 82 &lt;br /&gt;+ OD 83 &lt;br /&gt;Bksp OE OE &lt;br /&gt;Tab OF OF 94 A5 &lt;br /&gt;Q 10 10 &lt;br /&gt;W 11 11 &lt;br /&gt;E 12 12 &lt;br /&gt;R 13 13 &lt;br /&gt;T 14 14 &lt;br /&gt;Y 15 15 &lt;br /&gt;U 16 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 17 &lt;br /&gt;0 18 18 &lt;br /&gt;P 19 19 &lt;br /&gt;[ 1A 1A &lt;br /&gt;1 18 18 &lt;br /&gt;Enter 1C 1C &lt;br /&gt;Enter 1C A6 &lt;br /&gt;Lctrl 10 &lt;br /&gt;Rctrl 10 &lt;br /&gt;A 1E 1E &lt;br /&gt;S 1F 1F &lt;br /&gt;D 20 20 &lt;br /&gt;F 21 21 &lt;br /&gt;G 22 22 &lt;br /&gt;H 23 23 &lt;br /&gt;J 24 24 &lt;br /&gt;K 25 25 &lt;br /&gt;L 26 26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27 27 &lt;br /&gt;28 28 &lt;br /&gt;29 29 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Lshft 2A &lt;br /&gt;\\ 28 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-2 USING THE KEYBOARD AND VIDEO DISPLAY 231 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 7-3 (continued) &lt;br /&gt;Extended ASCII code with. ... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Key Scan Code Nothing Shift Control Alternate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Z 2C 2C &lt;br /&gt;X 20 20 &lt;br /&gt;C 2E 2E &lt;br /&gt;V 2F 2F &lt;br /&gt;8 30 30 &lt;br /&gt;N 31 31 &lt;br /&gt;M 32 32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33 33 &lt;br /&gt;34 34 &lt;br /&gt;35 35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Gray / 35 95 A4 &lt;br /&gt;Rshft 36 &lt;br /&gt;PrtSc EO 2A EO 37 &lt;br /&gt;L alt 38 &lt;br /&gt;R alt 38 &lt;br /&gt;Space 39 &lt;br /&gt;Caps 3A &lt;br /&gt;F1 38 38 54 5E 68 &lt;br /&gt;F2 3C 3C 55 5F 69 &lt;br /&gt;F3 30 30 56 60 6A &lt;br /&gt;F4 3E 3E 57 61 68 &lt;br /&gt;F5 3F 3F 58 62 6C &lt;br /&gt;F6 40 40 59 63 60 &lt;br /&gt;F7 41 41 5A 64 6E &lt;br /&gt;F8 42 42 58 65 6F &lt;br /&gt;F9 43 43 5C 66 70 &lt;br /&gt;F10 44 44 50 67 71 &lt;br /&gt;F11 57 85 87 89 88 &lt;br /&gt;F12 58 86 88 8A 8C &lt;br /&gt;Num 45 &lt;br /&gt;Scroll 46 &lt;br /&gt;Home EO 47 47 47 77 97 &lt;br /&gt;Up 48 48 48 80 98 &lt;br /&gt;Pgup EO 49 49 49 84 99 &lt;br /&gt;Gray - 4A &lt;br /&gt;Left 48 48 48 73 98 &lt;br /&gt;Center 4C &lt;br /&gt;Right 40 40 40 74 90 &lt;br /&gt;Gray + 4E &lt;br /&gt;End E04F 4F 4F 75 9F &lt;br /&gt;Oown EO 50 50 50 91 AO &lt;br /&gt;Pgdn EO 51 51 51 76 A1 &lt;br /&gt;Ins EO 52 52 52 92 A2 &lt;br /&gt;Oel EO 53 53 53 93 A3 &lt;br /&gt;Pause EO 1045 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;232 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;character to the screen even if it is an unwanted character. The DOS function number 0 I H also &lt;br /&gt;responds to the control-C key combination and exits to DOS if it is typed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-15 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B4 01 &lt;br /&gt;0002 CD 21 &lt;br /&gt;0004 OA CO &lt;br /&gt;0006 75 03 &lt;br /&gt;0008 CD 21 &lt;br /&gt;OOOA F9 &lt;br /&gt;OOOB &lt;br /&gt;OOOB CB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;INT &lt;br /&gt;OR &lt;br /&gt;JNZ &lt;br /&gt;!NT &lt;br /&gt;STC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,l &lt;br /&gt;21H &lt;br /&gt;AL,AL &lt;br /&gt;KEY1 &lt;br /&gt;21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;function 01H &lt;br /&gt;;read key &lt;br /&gt;;test for DOH, clear carry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get extended &lt;br /&gt;;indicate extended &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To read and echo a character, the AH register is loaded with DOS function number 01H. &lt;br /&gt;This is followed by the INT 21H instruction. Upon return from the INT 21H, the AL register &lt;br /&gt;contains the ASCII character typed; the video display also shows the typed character. If AL = 0 &lt;br /&gt;after the return, the INT 21H instruction must again be executed to obtain the extended ASCII-&lt;br /&gt;coded character (see Table 7-3). The procedure of Example 7-15 returns with carry set (1) to in-&lt;br /&gt;dicate an extended ASCII character and carry cleared (0) to indicate a normal ASCII character. &lt;br /&gt;Reading a Key without an Echo. The best single character key-reading function is function &lt;br /&gt;number 06H. This function reads a key without an echo to the screen. It also allows extended &lt;br /&gt;ASCII characters and does not respond to the control-C key combination. This function uses AH &lt;br /&gt;for the function number (06H) and DL = OFFH to indicate that the function call (INT 21H) will &lt;br /&gt;read the keyboard without an echo. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-16 &lt;br /&gt;000 KEYS PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B4 06 ~lOV AH,6 ;function 06H &lt;br /&gt;0002 B2 FF MOV DL,OFFH &lt;br /&gt;0004 CD 21 INT 21H ;read key &lt;br /&gt;0006 74 F8 JE KEYS ;if no key &lt;br /&gt;0008 OA CO OR AL,AL ;test for DOH, clear carry &lt;br /&gt;OOOA 75 03 JNE KEYS1 &lt;br /&gt;OOOC CD 21 INT 21H ;get extended &lt;br /&gt;OOOE F9 STC ;indicate extended &lt;br /&gt;OOOF KEYS1: &lt;br /&gt;OOOF CB RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 KEYS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-16 shows a procedure that uses function number 06H to read the keyboard. &lt;br /&gt;This performs as shown in Example 7-15 except that no character is echoed to the video display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If you examine the Â·procedure, there is one other difference. Function call number 06H re-&lt;br /&gt;turns from the INT 21H instruction even if no key is typed, while function call OIH waits for a &lt;br /&gt;key to be typed. This is an important difference that should be noted. This feature allows soft-&lt;br /&gt;ware to perform other tasks between checking the keyboard for a character. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Read an Entire Line with an Echo. Sometimes it is advantageous to read an entire line of data &lt;br /&gt;with one function call. Function call number OAH reads an entire line of information-up to 255 &lt;br /&gt;characters-from the keyboard. It continues to acquire keyboard data until either the enter key &lt;br /&gt;(ODH) is typed or the character count expires. This function requires that AH = OAH and DS:DX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-2 USING THE KEYBOARD AND VIDEO DISPLAY 233 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addresses the keyboard buffer (a memory area where the ASCII data are stored). The first byte of &lt;br /&gt;the buffer area must contain the maximum number of keyboard characters read by this function. &lt;br /&gt;If the number typed exceeds this maximum number, the function returns just as if the enter key &lt;br /&gt;were typed. The second byte of the buffer contains the count of the actual number of characters &lt;br /&gt;typed, and the remaining locations in the buffer contain the ASCII keyboard data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-17 shows how this function reads two lines of information into two memory &lt;br /&gt;buffers (BUFI and BUF2). Before the call to the DOS function through the LINE procedure, the &lt;br /&gt;first byte of the buffer is loaded with a 255, so up to 255 characters can be typed. If you assemble &lt;br /&gt;and execute this program, the first and second lines are accepted. The only problem is that the &lt;br /&gt;second line appears on top of the first line. The next section of the text explains how to output &lt;br /&gt;characters to the video display to solve this problem. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 0101 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0101 0101 [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 C6 06 0000 &lt;br /&gt;001C BA 0000 R &lt;br /&gt;001F E8 OOOF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0022 C6 06 0101 &lt;br /&gt;0027 BA 0101 R &lt;br /&gt;002A EB 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that reads two lines of data from the keyboard &lt;br /&gt;;using DOS INT 21H function number OAH. &lt;br /&gt;;***uses*** &lt;br /&gt;;LINE procedure to read a line . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;BUFl DB 257 DUP ( 7) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUF2 DB 257 DUP (7 ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;R FF MOV BUF1,255 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFSET BUF1 &lt;br /&gt;CALL LINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R FF MOV BUF2,255 &lt;br /&gt;MOV DX,OFFSET BUF2 &lt;br /&gt;CALL LINE &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start DATA segment &lt;br /&gt;;define BUFl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define BUF2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start CODE segment &lt;br /&gt;;start program &lt;br /&gt;;character count of &lt;br /&gt;;address BUFl &lt;br /&gt;;read a line &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;255 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;character count of 255 &lt;br /&gt;;address BUF2 &lt;br /&gt;;read a line &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The LINE procedure uses DOS INT 21H function OAH to &lt;br /&gt;;read and echo an entire line from the keyboard. &lt;br /&gt;;***parameters*** &lt;br /&gt;;DX must contain the data segment offset address of the &lt;br /&gt;;buffer. The first location in the buffer contains the &lt;br /&gt;;number of characters to be read for the line. &lt;br /&gt;;Upon return the second location in the buffer contains &lt;br /&gt;;the line length. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0031 LINE PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0031 B4 OA &lt;br /&gt;0033 CD 21 &lt;br /&gt;0035 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0036 LINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;INT &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH,OAH &lt;br /&gt;21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Writing to the Video Display with DOS Functions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;se1ect function OAH &lt;br /&gt;;access DOS &lt;br /&gt;; return from procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;With almost aMy program, data must be displayed on the video display. Video data is displayed in &lt;br /&gt;a number of different ways with DOS function calls. We use functions 02H or 06H for displaying &lt;br /&gt;one character at a time or function 09H for displaying an entire string of characters. Because func-&lt;br /&gt;tions 02H and 06H are identical, we tend to use function 06H because it is also used to read a key. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;234 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displaying One ASCII Character. Both DOS functions 02H and 06H are explained together be-&lt;br /&gt;cause they are identical for displaying ASCII data. Example 7-18 shows how this function is &lt;br /&gt;used to display a carriage return (ODH) and a line feed (OAH). Here a macro, called DISP (dis-&lt;br /&gt;play), is used to display the carriage return and line feed. The combination of a carriage return &lt;br /&gt;and a line feed moves the cursor to the next line at the left margin of the video screen. This two-&lt;br /&gt;step process is used to correct the problem that occurred between the lines typed through the key-&lt;br /&gt;board in Example 7-17. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 B4 06 1 &lt;br /&gt;0102 B2 OD 1 &lt;br /&gt;0104 CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 B4 06 1 &lt;br /&gt;0108 B2 OA 1 &lt;br /&gt;010A CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that displays a carriage return and a line &lt;br /&gt;; feed using the DISP macro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;DISP MACRO A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,06H &lt;br /&gt;MOV DL,A &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP ODH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,06H &lt;br /&gt;MOV DL,ODH &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP OAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,06H &lt;br /&gt;MOV DL,OAH &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select TINY model &lt;br /&gt;;start CODE segment &lt;br /&gt;;;display A macro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;DOS function 06H &lt;br /&gt;;;place parameter A in DL &lt;br /&gt;;;display parameter A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display carriage return &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display line feed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displaying a Character String. A character string is a series of ASCII-coded characters that end &lt;br /&gt;with a $ (24H) when used with DOS function call number 09H. Example 7-19 shows how a &lt;br /&gt;message is displayed at the current cursor position on the video display. Function call number &lt;br /&gt;09H requires that DS:DX address the character string before executing the !NT 21H instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 OD OA OA 54 &lt;br /&gt;68 69 73 20 &lt;br /&gt;69 73 20 61 &lt;br /&gt;20 74 65 73 &lt;br /&gt;74 20 6C 69 &lt;br /&gt;6E 65 2E 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B4 09 &lt;br /&gt;0019 SA 0000 R &lt;br /&gt;001C CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MES DB 13,10,10, 'This &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,9 &lt;br /&gt;MOV DX,OFFSET MES &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start DATA segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;is a test line.$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start CODE segmen~ &lt;br /&gt;;start program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select function 09H &lt;br /&gt;;address character string &lt;br /&gt;;access DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-2 USING THE KEYBOARD AND VIDEO DISPLAY 235 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This example program can be entered into the assembler, linked, and executed to produce &lt;br /&gt;&amp;quot;This is a test line&amp;quot; on the video display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The .EXIT directive embodies the DOS function 4CH. As shown in Appendix A, DOS &lt;br /&gt;function 4CH terminates a program. The .EXIT directive inserts a series of two instructions in &lt;br /&gt;the program, MOV AH,4CH, folIowed by an INT 21H instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Using BIOS Video Function Calls &lt;br /&gt;In addition to the DOS function calI INT 21H, we also have video BIOS (basic I/O system) func-&lt;br /&gt;tion calIs at INT 1OH. The DOS function calIs alIow a key to be read and a character to be dis-&lt;br /&gt;played with ease, but the cursor is difficult to position at the desired screen location. The video &lt;br /&gt;BIOS function calls allow more control over the video display than do the DOS function calIs. &lt;br /&gt;The video BIOS function calIs also require less time to execute than the DOS function calIs. The &lt;br /&gt;DOS function calls do not allow cursor placement, while the video BIOS function ca11s do. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cursor Position. Before any information is placed on the video screen, the position of the cursor &lt;br /&gt;should be known. This allows the screen to be cleared and started at any desired location. Video &lt;br /&gt;BIOS function number 03H allows the cursor position to be read from the video interface. Video &lt;br /&gt;BIOS function number 02H allows the cursor to be placed at any screen position. Table 7-4 &lt;br /&gt;shows the contents of various registers for both functions 02H and 03H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The page number, in register BH, should be 0 before setting the cursor position. Most &lt;br /&gt;modern software does not normally access the other pages (1-7) of the video display. The page &lt;br /&gt;number is often ignored after a cursor read. The 0 page is available in the CGA (color graphics &lt;br /&gt;adapter), EGA (enhanced graphics adapter), and VGA (variable graphics array) text modes of &lt;br /&gt;operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The cursor position assumes that the left-hand page column is column 0 progressing across &lt;br /&gt;a line to column 79. The row number corresponds to the character line number on the screen. &lt;br /&gt;Row 0 is the uppermost line while row 24 is the last line on the screen. This assumes that the text &lt;br /&gt;mode selected for the video adapter is 80 characters per line by 25 lines. Other text modes, such &lt;br /&gt;as 40 x 25 and 96 x 43, are also available. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-20 shows how the video BIOS function call INT IOH is used to clear the video &lt;br /&gt;screen. This is just one method of clearing the screen. Notice that the first function call positions &lt;br /&gt;the cursor to row 0 and column 0, which is called the home position. Next, we use the DOS &lt;br /&gt;function call to write 2,000 (80 characters per line x 25 lines) blank spaces (20H) on the video &lt;br /&gt;display. Finally, the cursor is again moved back to the home position. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that clears the screen and homes the &lt;br /&gt;;cursor to the upper left-hand corner of the screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY ;select TINY model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE ;start CODE segment &lt;br /&gt;HOME MACRO ; ; home cursor macro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 ;;function 02H &lt;br /&gt;MOV BH,O ; ;page 0 &lt;br /&gt;MOV DX,O i ; row 0, line 0 &lt;br /&gt;INT 10H ; ; home cursor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 7-4 Video BIOS function INT 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H &lt;br /&gt;03H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Description &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sets cursor position &lt;br /&gt;Reads cursor position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Parameters &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DH = row, DL = column, and BH = page number &lt;br /&gt;DH = row, DL = column, and BH = page number &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;236 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 B4 02 1 &lt;br /&gt;0102 B7 00 1 &lt;br /&gt;0104 BA 0000 1 &lt;br /&gt;0107 CD 10 1 &lt;br /&gt;0109 B9 07DO &lt;br /&gt;010C B4 06 &lt;br /&gt;010E B2 20 &lt;br /&gt;0110 MAIN1: &lt;br /&gt;0110 CD 21 &lt;br /&gt;0112 E2 FC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0114 B4 02 1 &lt;br /&gt;0116 B7 00 1 &lt;br /&gt;0118 BA 0000 1 &lt;br /&gt;011B CD 10 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;HOME &lt;br /&gt;MOV AH,2 &lt;br /&gt;MOV BH,O &lt;br /&gt;MOV DX,O &lt;br /&gt;!NT 10H &lt;br /&gt;MOV CX,25*80 &lt;br /&gt;MOV AH,6 &lt;br /&gt;MOV DL, I , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 21H &lt;br /&gt;LOOP MAIN1 &lt;br /&gt;HOME &lt;br /&gt;MOV AH,2 &lt;br /&gt;MOV BH,O &lt;br /&gt;MOV DX,O &lt;br /&gt;INT 10H &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start program &lt;br /&gt;;home cursor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load character count &lt;br /&gt;;se1ect function 06H &lt;br /&gt;;se1ect a space &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display a space &lt;br /&gt;;repeat 2000 times &lt;br /&gt;;home cursor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;; end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If this example is assembled, linked, and executed, a problem surfaces. This program is too &lt;br /&gt;slow to be useful in most cases. To correct this situation, another video BIOS function call is &lt;br /&gt;used. We can use the scroll function (06H) to clear the screen at a much higher speed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function 06H is used with a OOH in AL to blank the entire screen. This allows Example &lt;br /&gt;7-20 to be rewritten so that the screen clears at a much higher speed. See Example 7-21 for a &lt;br /&gt;faster clear and home cursor program. Here function call number 08H reads the character attrib-&lt;br /&gt;utes for blanking the screen. Next, they are positioned in the correct registers and DX is loaded &lt;br /&gt;with the screen size, 4FH (79) and 19H (25). If this program is assembled, linked, executed, and &lt;br /&gt;compared with Example 7-20, there is a big difference in the speed at which the screen is &lt;br /&gt;cleared. (Make sure that the lines in the program that are macro expansion ending in a 1 are not &lt;br /&gt;typed into the program.) Please refer to Appendix A for other video BIOS INT IOH function &lt;br /&gt;calls that may prove useful in your applications. Also listed in Appendix A is a complete listing &lt;br /&gt;of all of the INT functions available in most computers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 B7 00 &lt;br /&gt;0102 B4 08 &lt;br /&gt;0104 CD 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 8A DF &lt;br /&gt;0108 8A FC &lt;br /&gt;010A B9 0000 &lt;br /&gt;010D BA 194F &lt;br /&gt;0110 B8 0600 &lt;br /&gt;0113 CD 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0115 B4 02 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that clears the screen and homes the cursor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;HOME MACRO &lt;br /&gt;MOV AH,2 &lt;br /&gt;MOV BH,O &lt;br /&gt;MOV DX,O &lt;br /&gt;INT 10H &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BH,O &lt;br /&gt;MOV AH,8 &lt;br /&gt;INT 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL,BH &lt;br /&gt;MOV BH,AH &lt;br /&gt;MOV CX,O &lt;br /&gt;MOV DX,194FH &lt;br /&gt;MOV AX,600H &lt;br /&gt;INT 10H &lt;br /&gt;HOME &lt;br /&gt;MOV AH,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select TINY model &lt;br /&gt;;start code segment &lt;br /&gt;; ; home cursor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read video attribute &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load page number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load attributes &lt;br /&gt;line 25, column 79 &lt;br /&gt;select scroll function &lt;br /&gt;scroll screen &lt;br /&gt;home cursor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-2 USING THE KEYBOARD AND VIDEO DISPLAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0117 87 00 1 MOV BH,O &lt;br /&gt;0119 8A 0000 1 MOV DX,O &lt;br /&gt;011C CD 10 1 INT 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Display Macro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;237 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;One of the more usable macro sequences is the one illustrated in Example 7-22. Although it is &lt;br /&gt;simple and has been presented before, it saves much typing when creating programs that must dis-&lt;br /&gt;play many individual characters. What makes this macro so useful is that a register can be speci-&lt;br /&gt;fied as the argument, an ASCII character in quotes, or the numeric value for an ASCII character. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 B2 41 1 &lt;br /&gt;0102 B4 06 1 &lt;br /&gt;0104 CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 80 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 8A DO 1 &lt;br /&gt;OOOA B4 06 1 &lt;br /&gt;OOOC CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE 82 OD 1 &lt;br /&gt;0010 84 06 1 &lt;br /&gt;0012 CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 B2 OA 1 &lt;br /&gt;0016 B4 06 1 &lt;br /&gt;0018 CD 21 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Mouse &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that displays AB followed by a carriage &lt;br /&gt;;return and line feed combination using the DISP macro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;DISP MACRO VAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,VAR &lt;br /&gt;MOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;. STARTUP &lt;br /&gt;DISP 'A' &lt;br /&gt;MOV DL, 'A' &lt;br /&gt;MOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, '8' &lt;br /&gt;DISP AL &lt;br /&gt;MOV DL,AL &lt;br /&gt;MOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP 13 &lt;br /&gt;MOV DL,13 &lt;br /&gt;MOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP 10 &lt;br /&gt;MOV DL,10 &lt;br /&gt;MOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select TINY model &lt;br /&gt;;start CODE segment &lt;br /&gt;;;display VAR macro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start program &lt;br /&gt;;display 'A' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load AL with '8' &lt;br /&gt;;display '8' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display carriage return &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;disp1ay line feed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The mouse pointing device is controlled with INT 33H. Refer to Appendix A for a list of the Mi-&lt;br /&gt;crosoft-compatible mouse functions associated with INT 33H. Unlike with DOS INT 21H, the &lt;br /&gt;function number is se.lected through the AL register and AH is usually set to OOH before the INT &lt;br /&gt;33H is executed. There are a total of 50 mouse functions available, of which only the main func-&lt;br /&gt;tions are described in this section of the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Testing for a Mouse &lt;br /&gt;To determine if a mouse driver is installed in the system, test the contents of interrupt vector &lt;br /&gt;33H. If interrupt vector 33H contains a 0000:0000, the mouse driver is not installed in the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;238 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;system. In some systems, a vector exists even though no mouse driver is present. In this instance. &lt;br /&gt;the INT 33H vector address points to an IRET instruction (CFH). The interrupt vector address is &lt;br /&gt;retrieved by using the DOS INT 21H function 35H. The address is then tested for 0000:0000; if &lt;br /&gt;it contains another value, the contents of the address pointed to by interrupt vector 33H are tested &lt;br /&gt;for CFH. Refer to Example 7-23 for a procedure that tests for the existence of the mouse driver. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once it is determined that a possible mouse driver exists, the mouse is reset to make certain &lt;br /&gt;it is connected to the system and functioning. The mouse reset is accomplished by using mouse &lt;br /&gt;function OOH. The return from function OOH is AX = OOOOH if no mouse is present. The CHKM &lt;br /&gt;procedure returns if the mouse exists with carry cleared and if no mouse exists with carry set. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B8 3533 &lt;br /&gt;0003 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0005 8C CO &lt;br /&gt;0007 OB C3 &lt;br /&gt;0009 F9 &lt;br /&gt;OOOA 74 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC 26: 80 3F CF &lt;br /&gt;0010 F9 &lt;br /&gt;0011 74 OC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0013 B8 0000 &lt;br /&gt;0016 CD 33 &lt;br /&gt;0018 83 F8 00 &lt;br /&gt;OOlB F9 &lt;br /&gt;001C 74 01 &lt;br /&gt;001E F8 &lt;br /&gt;001F &lt;br /&gt;001F C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that tests for the presence of a mouse driver. &lt;br /&gt;;***Output parameters*** &lt;br /&gt;;Carry 1, if no mouse present &lt;br /&gt;;Carry = 0, if mouse is present &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM1 : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;piwc NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,3533H ;get INT 33H vector &lt;br /&gt;INT 21H ;returns vector in &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,ES &lt;br /&gt;OR AX,BX ;test for 0000:0000 &lt;br /&gt;STC ;indicate no mouse &lt;br /&gt;JZ CHKM1 ;if no mouse driver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP BYTE PTR ES: [BX],OCFH &lt;br /&gt;STC &lt;br /&gt;JE CHKM1 ;if no mouse driver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,O &lt;br /&gt;INT 33H ireset mouse &lt;br /&gt;CMP AX,O &lt;br /&gt;STC &lt;br /&gt;JZ CHKM1 iif no mouse &lt;br /&gt;CLC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES:BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 CHKM ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Which Mouse and Driver? &lt;br /&gt;The mouse function interrupt determines both the type of mouse connected to the system and the &lt;br /&gt;driver version number. Example 7-24 lists a program that displays the mouse type and driver &lt;br /&gt;version number after a test is made to determine if the mouse is present using the procedure of &lt;br /&gt;Example 7-23. Here mouse INT 33H, function 24H locates the mouse driver version number &lt;br /&gt;and mouse driver type. The return from function 24H leaves the mouse driver number in BX &lt;br /&gt;(BH = major and BL = minor) and the mouse type in CH. If the mouse driver version is 8.00, &lt;br /&gt;then BH = 08H and BL = OOH. The mouse types that are returned in register CH are currently &lt;br /&gt;bus = 1, serial = 2, InPort = 3, PS/2 = 4, and Hewlett-Packard = 5. As time passes, this list of &lt;br /&gt;mouse types may grow. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A program that displays the mouse driver version &lt;br /&gt;number and the type of mouse installed . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-2 USING THE KEYBOARD AND VIDEO DISPLAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 00 OA 4E 6F 20 40 MES1 &lt;br /&gt;4F 55 53 45 2F 40 &lt;br /&gt;4F 55 53 45 20 44 &lt;br /&gt;52 49 56 45 52 20 &lt;br /&gt;66 6F 75 6E 64 2E &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001F 00 OA 40 6F 75 73 MES; &lt;br /&gt;65 20 64 72 69 76 &lt;br /&gt;65 72 20 76 65 72 &lt;br /&gt;73 69 GF 6Â£ 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0036 20 20 20 20 20 20 M1 &lt;br /&gt;20 00 OA 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0040 0040 R 0051 R TYPES &lt;br /&gt;0058 R 005F R &lt;br /&gt;0064 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004A 42 75 73 24 Tl &lt;br /&gt;004E 53 65 72 69 61 6C T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24 &lt;br /&gt;0055 49 6E 50 6F 72 74 T3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24 &lt;br /&gt;005C 50 53 2F 32 24 T4 &lt;br /&gt;0061 48 50 24 T5 &lt;br /&gt;0064 20 60 6F 75 73 65 MES3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 69 6E 73 74 61 &lt;br /&gt;6C 6C 65 64 2E 00 &lt;br /&gt;OA 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 E8 0041 &lt;br /&gt;OOlA 73 05 &lt;br /&gt;OOlC BA 0000 R &lt;br /&gt;001F EB 32 &lt;br /&gt;0021 &lt;br /&gt;0021 &lt;br /&gt;0024 &lt;br /&gt;0026 &lt;br /&gt;0029 &lt;br /&gt;002B &lt;br /&gt;002E &lt;br /&gt;0031 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B8 0024 &lt;br /&gt;CO 33 &lt;br /&gt;BF 0039 R &lt;br /&gt;81'~ C7 &lt;br /&gt;E8 0040 &lt;br /&gt;C6 05 2E &lt;br /&gt;47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0032 8A C3 &lt;br /&gt;0034 E8 0044 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0037 BA 0022 R &lt;br /&gt;003A B4 09 &lt;br /&gt;003C CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003E BE 0043 R &lt;br /&gt;0041 B4 00 &lt;br /&gt;0043 8A C5 &lt;br /&gt;0045 48 &lt;br /&gt;0046 03 FO &lt;br /&gt;0048 03 FO &lt;br /&gt;004A 8B 14 &lt;br /&gt;004C B4 09 &lt;br /&gt;004E CD 21 &lt;br /&gt;0050 BA 0067 R &lt;br /&gt;0053 &lt;br /&gt;0053 B4 09 &lt;br /&gt;0055 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAINl: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 13,10, 'No MOUSE/t10USE DRIVER found. $' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 13,10, 'Mouse driver version' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB ',13,10, '$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dv1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB &lt;br /&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tl,T2,T3,T4,T5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'Bus$' &lt;br /&gt;'SerialS' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'InPort$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'PS/2$' &lt;br /&gt;'HP$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB , mouse installed.' ,13,10, '$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;CALL CHKM &lt;br /&gt;JNC MAINl &lt;br /&gt;MOV DX,OFFSET MESI &lt;br /&gt;JMP MAIN2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,24H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;test for mouse &lt;br /&gt;;if mouse present &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;iif no mouse &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 33H ;get driver version &lt;br /&gt;MOV DI,OFFSET M1 &lt;br /&gt;MOV AL,BH ;save major version &lt;br /&gt;CALL DISP &lt;br /&gt;MOV BYTE PTR [DIJ,'.' ;save period &lt;br /&gt;INC 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,BL &lt;br /&gt;CALL DISP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFSET MES2 &lt;br /&gt;MOV AH,9 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV SI,OFFSET TYPES &lt;br /&gt;MOV AH,O &lt;br /&gt;MOV AL,CH &lt;br /&gt;DEC AX &lt;br /&gt;ADD SI,AX &lt;br /&gt;ADD SI,AX &lt;br /&gt;MOV OX, [SIJ &lt;br /&gt;MOV AH,9 &lt;br /&gt;INT 21H &lt;br /&gt;MOV DX,OFFSET MES3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,9 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save minor version &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display version &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;index type &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display type &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that tests for the presence of a mouse. &lt;br /&gt;j***Output parameters*** &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;005B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Carry 1, if no mouse present &lt;br /&gt;;Carry = 0, if mouse is present &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;239 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;240 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;005B B8 3533 &lt;br /&gt;005E CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0060 8C CO &lt;br /&gt;0062 OB C3 &lt;br /&gt;0064 F9 &lt;br /&gt;0065 74 13 &lt;br /&gt;0067 26: 80 3F CF &lt;br /&gt;006B F9 &lt;br /&gt;006C 74 OC &lt;br /&gt;006E B8 0000 &lt;br /&gt;0071 CD 33 &lt;br /&gt;0073 83 F8 00 &lt;br /&gt;0076 F9 &lt;br /&gt;0077 74 01 &lt;br /&gt;0079 F8 &lt;br /&gt;007A &lt;br /&gt;007A C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007B B4 00 &lt;br /&gt;007D D4 OA &lt;br /&gt;007F 05 3030 &lt;br /&gt;0082 80 FC 30 &lt;br /&gt;0085 74 03 &lt;br /&gt;0087 88 25 &lt;br /&gt;0089 47 &lt;br /&gt;008A &lt;br /&gt;008A 88 05 &lt;br /&gt;008C 47 &lt;br /&gt;008D C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;008E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Using the Mouse &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,3533H ;get INT 33H vector &lt;br /&gt;INT 21H ;vector in ES:BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,ES &lt;br /&gt;OR AX,BX ;test for 0000:0000 &lt;br /&gt;STC &lt;br /&gt;JZ CHKM1 ;if no mouse driver &lt;br /&gt;CMP BYTE PTR ES: [BX) ,OCFH &lt;br /&gt;STC &lt;br /&gt;JE CHKM1 ;if no mouse driver &lt;br /&gt;MOV AX,O &lt;br /&gt;INT 33H ;reset mouse &lt;br /&gt;CMP AX,O &lt;br /&gt;STC &lt;br /&gt;JZ CHKM1 ;if no mouse &lt;br /&gt;CLC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM1: &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save the ASCII coded version number &lt;br /&gt;;***input parameters*** &lt;br /&gt;;AL = version &lt;br /&gt;;DS:DI = address where stored &lt;br /&gt;;***output pararneters*** &lt;br /&gt;;ASCII version number stored at DS:DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,O &lt;br /&gt;AAM ;convert to BCD &lt;br /&gt;ADD AX,3030H &lt;br /&gt;CMP AH,30H ;save ASCII version &lt;br /&gt;JE DISPl ;suppress zero &lt;br /&gt;MOV [DI),AH &lt;br /&gt;INC DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP1: &lt;br /&gt;MOV [DI) ,AL &lt;br /&gt;INC DI &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The mouse functions in either text mode or graphics mode. This section illustrates how to enable &lt;br /&gt;the mouse for use with a text mode program. The mouse also functions in graphics mode, but in-&lt;br /&gt;stead of being displayed as a block, the cursor or mouse pointer is displayed as an arrow. As with &lt;br /&gt;the prior examples, the first step is to check for the presence of a mouse driver. Example 7-25 &lt;br /&gt;uses the CHKM procedure to test for the presence of the mouse. If no mouse is present, a return &lt;br /&gt;from TM_ON occurs with the carry flag set. If the mouse is present, the cursor is displayed and &lt;br /&gt;a return the carry flag cleared is made. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-25 &lt;br /&gt;;The TM_ON procedure tests for the presence of a mouse &lt;br /&gt;;and enables mouse pointer. &lt;br /&gt;;uses the CHKM (check for mouse) procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;***output parameters*** &lt;br /&gt;;Carry 0, if mouse is present pointer enabled &lt;br /&gt;;Carry = 1, if no mouse present &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-2 USING THE KEYBOARD AND VIDEO DISPLAY 241 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 TM_ON PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E8 FFDD CALL CHKM test for mouse &lt;br /&gt;0003 72 06 JC TM_ON1 if no mouse &lt;br /&gt;0005 B8 0001 MOV AX,l show mouse pointer &lt;br /&gt;0008 CD 33 INT 33H &lt;br /&gt;OOOA F8 CLC ; show mouse present &lt;br /&gt;OOOB TM_ON1 : &lt;br /&gt;OOOB C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC TM_ON ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure of Example 7-25 only enables the mouse and displays the mouse cursor. To &lt;br /&gt;use the mouse, a program must be written that tracks the mouse and its position. Such a program &lt;br /&gt;appears in Example 7-26. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-26 &lt;br /&gt;;a program that displays the mouse pointer and its &lt;br /&gt;;X and Y position. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;0000 . DATA &lt;br /&gt;0000 OD 58 20 50 6F 73 MES DB 13, 'X position= , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;69 74 69 6F 6E 3D &lt;br /&gt;20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOD 20 20 20 20 20 20 MX DB &lt;br /&gt;0013 59 20 50 6F 73 69 DB 'Y Position= , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74 69 6F 6E 3D 20 &lt;br /&gt;001F 20 20 20 20 20 20 MY DB $ , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24 &lt;br /&gt;0026 0000 X DW ? ;X position &lt;br /&gt;0028 0000 Y DW ? ;Y position &lt;br /&gt;0000 . CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0017 E8 006D CALL TM_ON ;enable mouse &lt;br /&gt;001A 72 47 JC MAIN4 ;if no mouse &lt;br /&gt;001C MAINl: &lt;br /&gt;001C B8 0003 MOV AX,3 ;get mouse status &lt;br /&gt;001F CD 33 INT 33H &lt;br /&gt;0021 83 FB 01 CMP BX,l &lt;br /&gt;0024 74 38 JE MAIN3 ; if left button &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0026 3B OE 0026 R CMP CX,X &lt;br /&gt;002A 75 06 JNE MAIN2 ;if X changed &lt;br /&gt;002C 3B 16 0028 R CMP DX,Y &lt;br /&gt;0030 74 EA JE MAIN1 ;if Y did not change &lt;br /&gt;0032 MAIN2: &lt;br /&gt;0032 89 OE 0026 R MOV X,CX ; save new position &lt;br /&gt;0036 89 16 0028 R MOV Y,DX &lt;br /&gt;003A BF OOOD R MOV DI,OFFSET MX &lt;br /&gt;003D 8B C1 MOV AX,CX &lt;br /&gt;003F E8 0051 CALL PLACE ;store ASCII X &lt;br /&gt;0042 BF 001F R MOV DI,OFFSET MY &lt;br /&gt;0045 A1 0028 R MOV AX,Y &lt;br /&gt;0048 E8 0048 CALL PLACE ;store ASCII Y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004B B8 0002 MOV AX,2 &lt;br /&gt;004E CD 33 INT 33H ;hide mouse pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0050 B4 09 MOV AH,9 &lt;br /&gt;0052 BA 0000 R MOV DX,OFFSET MES &lt;br /&gt;0055 CD 21 INT 21H ;display position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0057 B8 0001 MOV AX,l &lt;br /&gt;005A CD 33 INT 33H ;show mouse pointer &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;242 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOSC &lt;br /&gt;OOSE &lt;br /&gt;005E &lt;br /&gt;0061 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0063 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0067 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0067 &lt;br /&gt;006A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;006C &lt;br /&gt;006E &lt;br /&gt;0070 &lt;br /&gt;0071 &lt;br /&gt;0073 &lt;br /&gt;0077 &lt;br /&gt;007B &lt;br /&gt;007A &lt;br /&gt;007D &lt;br /&gt;007F &lt;br /&gt;00B2 &lt;br /&gt;0083 &lt;br /&gt;00B5 &lt;br /&gt;00B6 &lt;br /&gt;0086 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0087 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B7 &lt;br /&gt;OOBA &lt;br /&gt;OOB.C &lt;br /&gt;OOBF &lt;br /&gt;0091 &lt;br /&gt;0092 &lt;br /&gt;0092 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0093 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0093 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0093 &lt;br /&gt;0096 &lt;br /&gt;0099 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EB BE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B8 0000 &lt;br /&gt;CD 33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B8 3S33 &lt;br /&gt;CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BC CO &lt;br /&gt;DB C3 &lt;br /&gt;F9 &lt;br /&gt;74 13 &lt;br /&gt;26: BO 3F CF &lt;br /&gt;F9 &lt;br /&gt;74 DC &lt;br /&gt;BB 0000 &lt;br /&gt;CD 33 &lt;br /&gt;83 F8 00 &lt;br /&gt;F9 &lt;br /&gt;74 01 &lt;br /&gt;F8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EB FFDD &lt;br /&gt;72 06 &lt;br /&gt;BB 0001 &lt;br /&gt;CD 33 &lt;br /&gt;FB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B9 0000 &lt;br /&gt;BB OOOA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN3: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN4: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP MAIN1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,O &lt;br /&gt;INT 33H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;do again &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reset mouse &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that tests for the presence of a mouse &lt;br /&gt;;***Output parameters*** &lt;br /&gt;;Carry 1, if no mouse present &lt;br /&gt;;Carry = 0, if mouse is present &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,3533H &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,ES &lt;br /&gt;AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get INT 33H vector &lt;br /&gt;;vector in ES:BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;test for 0000:0000 OR &lt;br /&gt;STC &lt;br /&gt;JZ &lt;br /&gt;CMP &lt;br /&gt;STC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM1 ;if no mouse driver &lt;br /&gt;BYTE PTR ES:[BX),OCFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JE CHKM1 &lt;br /&gt;MOV AX,O &lt;br /&gt;INT 33H &lt;br /&gt;CMP AX,O &lt;br /&gt;STC &lt;br /&gt;JZ &lt;br /&gt;CLC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHKM1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if no mouse driver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reset mouse &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if no mouse &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The TM_ON procedure tests for the presence of a &lt;br /&gt;;mouse and enables mouse pointer. &lt;br /&gt;;uses the CHKM (check for mouse) procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;***output parameters*** &lt;br /&gt;;Carry 0, if mouse is present pointer enabled &lt;br /&gt;;Carry = 1, if no mouse present &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TM.-ON1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL CHKM &lt;br /&gt;JC TM_ON1 &lt;br /&gt;MOV AX,l &lt;br /&gt;INT 33H &lt;br /&gt;CLC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;test for mouse &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;show mouse pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The PLACE procedure converts the contents of AX &lt;br /&gt;;into a decimal ASCII-coded number stored at the &lt;br /&gt;;memory location addressed by DS:DI. &lt;br /&gt;;***input parameters*** &lt;br /&gt;;AX = number to be converted to decimal ASCII code &lt;br /&gt;;DS:DI = address where number is stored &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PLACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PLACE1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,O &lt;br /&gt;MOV BX,10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear count &lt;br /&gt;;set divisor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-3 DATA CONVERSIONS 243 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0099 BA 0000 MOV ox, a ;clear ox &lt;br /&gt;D09C F7 F3 OIV BX ;divide by 10 &lt;br /&gt;009E 52 PUSH ox &lt;br /&gt;009F 41 INC CX &lt;br /&gt;DOAO 83 F8 00 CMP AX,O &lt;br /&gt;00A3 75 F4 JNE PLACE1 ;if quotient != a &lt;br /&gt;00A5 PLACE2: &lt;br /&gt;00A5 BB 0005 MOV BX,5 &lt;br /&gt;00A8 2B 09 SUB BX,CX &lt;br /&gt;OOAA PLACE3: &lt;br /&gt;OOAA SA POP ox &lt;br /&gt;OOAB 80 C2 30 ADD OL,30H ;convert to ASCII &lt;br /&gt;OOAE 88 15 MOV [OIl ,OL ;S1:ore digit &lt;br /&gt;OOBO 47 INC OI &lt;br /&gt;00B1 E2 F7 LOOP PLACE3 &lt;br /&gt;00B3 83 FB 00 CMP BX,O &lt;br /&gt;00B6 74 08 JE PLACES &lt;br /&gt;00B8 8B CB MOV CX,BX &lt;br /&gt;OOBA PLACE4: &lt;br /&gt;OOBA C6 05 20 MOV BYTE PTR [OI],20H &lt;br /&gt;OOBO 47 INC OI &lt;br /&gt;OOBE E2 FA LOOP PLACE4 &lt;br /&gt;OOCO PLACE5: &lt;br /&gt;OOCO C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C1 PLACE ENOP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The program in Example 7-26 displays the mouse cursor by placing a OOOIH into AX, fol-&lt;br /&gt;lowed by the INT 33H instruction. Next, the status of the mouse is read with function AX = &lt;br /&gt;0003H. The status function returns with the status of the mouse buttons in BX, the X coordinate &lt;br /&gt;of the mouse pointer in CX, and the Y coordinate in DX. (Refer to Appendix A for more com-&lt;br /&gt;plete information on the status for the mouse.) In this example program terminates if the left &lt;br /&gt;mouse button is pressed; otherwise, the coordinates are compared with the prior values saved in &lt;br /&gt;X and Y. If a change has occurred in these coordinates, the new coordinates are calculated and &lt;br /&gt;displayed. Notice that before the video display is accessed, the mouse pointer is hidden using &lt;br /&gt;INT 33H with AX = 0002H. This is very important. If you don't hide the mouse pointer, the dis-&lt;br /&gt;play will become unstable and the computer may even re-boot. In most cases, a copy of the &lt;br /&gt;mouse pointer remains on the screen if data are displayed without turning off the mouse pointer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA CONVERSIONS &lt;br /&gt;In computer systems, data is seldom in the correct form. One main task of the system is to con-&lt;br /&gt;vert data from one form to another. This section of the chapter describes conversions between bi-&lt;br /&gt;nary and ASCll. Binary data are removed from a register or memory and converted to ASCII for &lt;br /&gt;the video display. In many cases, ASCII data are converted to binary as they are typed on the &lt;br /&gt;keyboard. We also explain converting between ASCII and hexadecimal data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Converting from Binary to ASCII &lt;br /&gt;Conversion from binary to ASCII is accomplished in two ways: (1) by the AAM instruction if &lt;br /&gt;the number is less than 100 or (2) by a series of decimal divisions (divide by 10). Both tech-&lt;br /&gt;niques are presented in this section. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The AAM instruction converts the value in AX into a two-digit unpacked BCD number in &lt;br /&gt;AX. If the number in AX is 0062H (98 decimal) before AAM executes, AX contains a 0908H &lt;br /&gt;after AAM executes. This is not ASCII code, but it is converted to ASCII code by adding a &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;244 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3030H to AX. Example 7-27 illustrates a program that uses the procedure DISP that processes &lt;br /&gt;the binary value in AL (0-99) and displays it on the video screen as decimal. The DISP proce-&lt;br /&gt;dure blanks a leading zero, which occurs for the numbers 0-9, with an ASCII space code. This &lt;br /&gt;example program displays the number 74 (test data) on the video screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 BO 4A &lt;br /&gt;0102 E8 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0109 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0109 52 &lt;br /&gt;010A B4 00 &lt;br /&gt;010C D4 OA &lt;br /&gt;010E 80 C4 20 &lt;br /&gt;0111 80 FC 20 &lt;br /&gt;0114 74 03 &lt;br /&gt;0116 80 C4 10 &lt;br /&gt;0119 &lt;br /&gt;0119 8A D4 &lt;br /&gt;011B B4 06 &lt;br /&gt;OllD 50 &lt;br /&gt;OllE CD 21 &lt;br /&gt;0120 58 &lt;br /&gt;0121 8A DO &lt;br /&gt;0123 80 C2 30 &lt;br /&gt;0126 CD 21 &lt;br /&gt;0128 5A &lt;br /&gt;0129 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that uses the DISP procedure to display 74 &lt;br /&gt;;decimal on the video display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MOV AL,4AH &lt;br /&gt;CALL DISP &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select TINY mode &lt;br /&gt;;start code segment &lt;br /&gt;;start program &lt;br /&gt;;load test data to AL &lt;br /&gt;;display AL in decimal &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The DISP procedure displays AL (0 to 99) as a decimal &lt;br /&gt;;number. AX is destroyed by this procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH DX &lt;br /&gt;MOV AH,O &lt;br /&gt;AAM &lt;br /&gt;ADD AH,20H &lt;br /&gt;CMP AH,20H &lt;br /&gt;JE DISP1 &lt;br /&gt;ADD AH,10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP1: &lt;br /&gt;MOV DL,AH &lt;br /&gt;MOV AH,6 &lt;br /&gt;PUSH AX &lt;br /&gt;INT 21H &lt;br /&gt;POP AX &lt;br /&gt;MOV DL,AL &lt;br /&gt;ADD DL,30H &lt;br /&gt;INT 21H &lt;br /&gt;POP DX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save DX &lt;br /&gt;;clear AH &lt;br /&gt;;convert to BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;test for leading zero &lt;br /&gt;;if leading zero &lt;br /&gt;;convert to ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display first digit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;convert second digit to ASCII &lt;br /&gt;;display second digit &lt;br /&gt;;restore DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The reason that AAM converts any number between 0 and 99 to a two-digit unpacked &lt;br /&gt;BCD number is because it divides AX by 10. The result is left in AX, so AH contains the quo-&lt;br /&gt;tient and AL the remainder. This same scheme of dividing by 10 can be expanded to convert any &lt;br /&gt;whole number of any number system from binary to an ASCII coded-character string that can be &lt;br /&gt;displayed on the video screen. For example, if AX is divided by 8 instead of 10, the number is &lt;br /&gt;displayed in octal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The algorithm for converting from binary to ASCII code is: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Divide by the 10 and save the remainder on the stack as a significant BCD digit. &lt;br /&gt;2. Repeat step 1 until the quotient is a O. &lt;br /&gt;3. Retrieve each remainder and add a 30H to convert to ASCII before displaying or printing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-28 shows how the unsigned 16-bit contents of AX are converted to ASCII and &lt;br /&gt;displayed on the video screen. Here we divide AX by 10 and save the remainder on the stack &lt;br /&gt;after each division for later conversion to ASCII. After all the digits have been converted, the re-&lt;br /&gt;sult is displayed on the video screen by removing the remainders from the stack and converting &lt;br /&gt;them to ASCII code. This procedure (DISPX) also blanks any leading zeros that occur. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-3 DATA CONVERSIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 B8 04A3 &lt;br /&gt;0103 E8 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010A 52 &lt;br /&gt;010B 51 &lt;br /&gt;010C 53 &lt;br /&gt;010D B9 0000 &lt;br /&gt;0110 BB OOOA &lt;br /&gt;0113 &lt;br /&gt;0113 BA 0000 &lt;br /&gt;0116 F7 F3 &lt;br /&gt;0118 52 &lt;br /&gt;0119 41 &lt;br /&gt;OllA OB CO &lt;br /&gt;OllC 75 F5 &lt;br /&gt;OUE &lt;br /&gt;DUE 5A &lt;br /&gt;aUF B4 06 &lt;br /&gt;0121 80 C2 30 &lt;br /&gt;0124 CD 21 &lt;br /&gt;0126 E2 F6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0128 5B &lt;br /&gt;0129 59 &lt;br /&gt;012A SA &lt;br /&gt;012B C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that uses DISPX to display AX in decimal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MOV AX,4A3H &lt;br /&gt;CALL DISPX &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select TINY model &lt;br /&gt;;start CODE segment &lt;br /&gt;;start program &lt;br /&gt;;load AX with test data &lt;br /&gt;;display AX in decimal &lt;br /&gt;;exic co DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The DISPX procedure displays AX in decimal. &lt;br /&gt;;AX is destroyed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPX PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH DX &lt;br /&gt;PUSH CX &lt;br /&gt;PUSH BX &lt;br /&gt;MOV CX, a &lt;br /&gt;MOV BX,10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPX1: &lt;br /&gt;MOV DX, a &lt;br /&gt;DIV BX &lt;br /&gt;PUSH DX &lt;br /&gt;INC CX &lt;br /&gt;OR AX,AX &lt;br /&gt;JNZ DISPX1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPX2: &lt;br /&gt;POP DX &lt;br /&gt;MOV AH,6 &lt;br /&gt;ADD DL,30H &lt;br /&gt;INT 21H &lt;br /&gt;LOOP DISPX2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP BX &lt;br /&gt;POP CX &lt;br /&gt;POP DX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPX ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save DX, CX, and BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear digit counter &lt;br /&gt;;set for decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear DX &lt;br /&gt;;divide DX:AX by 10 &lt;br /&gt;;save remainder &lt;br /&gt;;count remainder &lt;br /&gt;;test for quotient of zero &lt;br /&gt;;if quotient is not zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get remainder &lt;br /&gt;;select function 06H &lt;br /&gt;;convert to ASCII &lt;br /&gt;;display digit &lt;br /&gt;;repeat for all digits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;restore BX, CX, and DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Converting from ASCII to Binary &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;245 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conversions from ASCII to binary usually start with keyboard entry. If a single key is typed, the &lt;br /&gt;conve}sion occurs when a 30H is subtracted from the number. If more than one key is typed, &lt;br /&gt;conversion from ASCII to binary still requires 30H to be subtracted, but there is one additional &lt;br /&gt;step. After subtracting 30H, the number is added to the result after the prior result is first multi-&lt;br /&gt;plied by 10. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,The algorithm for converting from ASCII to binary is: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Begin with a binary result of o. &lt;br /&gt;2. Subtract 30H from the character typed on the keyboard to convert it to BCD. &lt;br /&gt;3. Multiply the result by 10 and add the new BCD digit. &lt;br /&gt;4. Repeat steps 2 and 3 until the character typed is not an ASCII-coded number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-29 illustrates a procedure (READN) used in a program that implements this al-&lt;br /&gt;gorithm. Here the binary number returns in the AX register as a 16-bit result, which is then &lt;br /&gt;stored in memory location TEMP. If a larger result is required, the procedure must be reworked &lt;br /&gt;for 32-bit addition. Each time this procedure is called, it reads a number from the keyboard until &lt;br /&gt;any key other than 0 through 9 is typed. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;246 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-29 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 0000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 E8 0007 &lt;br /&gt;001A A3 0000 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 53 &lt;br /&gt;0022 51 &lt;br /&gt;0023 B9 OOOA &lt;br /&gt;0026 BB 0000 &lt;br /&gt;0029 &lt;br /&gt;0029 B4 01 &lt;br /&gt;002B CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002D 3C 30 &lt;br /&gt;002F 72 14 &lt;br /&gt;0031 3C 39 &lt;br /&gt;0033 77 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0035 2C 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0037 &lt;br /&gt;0038 &lt;br /&gt;003A &lt;br /&gt;003C &lt;br /&gt;003E &lt;br /&gt;003F &lt;br /&gt;0041 &lt;br /&gt;0043 &lt;br /&gt;0045 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50 &lt;br /&gt;8B C3 &lt;br /&gt;F7 E1 &lt;br /&gt;8B D8 &lt;br /&gt;58 &lt;br /&gt;B4 00 &lt;br /&gt;03 D8 &lt;br /&gt;EB E4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0045 8B C3 &lt;br /&gt;0047 59 &lt;br /&gt;0048 5B &lt;br /&gt;0049 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that reads one decimal number from the &lt;br /&gt;;keYboard and stores the binary value at TEMP. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;TEMP DI'i ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;CALL READN &lt;br /&gt;MOV TEMP, AX &lt;br /&gt;. EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select TINY model &lt;br /&gt;;start DATA segment &lt;br /&gt;;define TEMP &lt;br /&gt;;start CODE segment &lt;br /&gt;;start program &lt;br /&gt;;read a number &lt;br /&gt;;save it in TEMP &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The READN procedure reads a decimal number from the &lt;br /&gt;;keyboard and returns its binary value in AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READN PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READN1 : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READN2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH BX &lt;br /&gt;PUSH CX &lt;br /&gt;MOV CX,10 &lt;br /&gt;MOV BX,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP AL,'O' &lt;br /&gt;JB READN2 &lt;br /&gt;CMP AL, '9' &lt;br /&gt;JA READN2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AL,' 0' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;MOV AX,BX &lt;br /&gt;MUL CX &lt;br /&gt;MOV BX,AX &lt;br /&gt;POP AX &lt;br /&gt;MOV AH,O &lt;br /&gt;ADD BX,AX &lt;br /&gt;JMP READN1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,BX &lt;br /&gt;POP CX &lt;br /&gt;POP BX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READN ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save BX and CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load 10 for decimal &lt;br /&gt;;clear result &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read key with echo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if below '0' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if above '9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;convert to ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save digit &lt;br /&gt;;multiply result by 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;add digit value to result &lt;br /&gt;; repeat &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get binary result into AX &lt;br /&gt;;restore CX and BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displaying and Reading Hexadecimal Data &lt;br /&gt;Hexadecimal data are easier to read from the keyboard and display than decimal data. This type &lt;br /&gt;of data are not used at the applications level, but at the system level. System level data is often &lt;br /&gt;hexadecimal and must either be displayed in hexadecimal form or read from the keyboard as &lt;br /&gt;hexadecimal data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reading Hexadecimal Data. Hexadecimal data appear -lS 0 to 9 and A to F. The ASCII codes ob-&lt;br /&gt;tained from the keyboard for hexadecimal data are 30H to 39H for the numbers 0 through 9 and &lt;br /&gt;41H to 46H (A-F) or 61H to 66H (a-f) for the letters. To be useful, a procedure that reads hexa-&lt;br /&gt;decimal data must be able to accept both lowercase and uppercase letters. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-30 shows two procedures: one (CONV) converts the contents of the data in &lt;br /&gt;AL from ASCII code to a single hexadecimal digit, while the other (READ H) reads a 4-digit &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-3 DATA CONVERSIONS 247 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;hexadecimal number from the keyboard and returns with it in register AX. This procedure can be &lt;br /&gt;modified to read any size hexadecimal number from the keyboard. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 0000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 E8 0007 &lt;br /&gt;001A A3 0000 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 &lt;br /&gt;0022 &lt;br /&gt;0023 &lt;br /&gt;0026 &lt;br /&gt;0028 &lt;br /&gt;002B &lt;br /&gt;002B &lt;br /&gt;002D &lt;br /&gt;002F &lt;br /&gt;0032 &lt;br /&gt;0034 &lt;br /&gt;0036 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;51 &lt;br /&gt;53 &lt;br /&gt;B9 0004 &lt;br /&gt;8B F1 &lt;br /&gt;BB 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B4 01 &lt;br /&gt;CD 21 &lt;br /&gt;E8 OOOA &lt;br /&gt;D3 E3 &lt;br /&gt;02 D8 &lt;br /&gt;4E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0037 75 F2 &lt;br /&gt;0039 8B C3 &lt;br /&gt;003B 5B &lt;br /&gt;003C 59 &lt;br /&gt;003D C3 &lt;br /&gt;003E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003E 3C 39 &lt;br /&gt;0040 76 08 &lt;br /&gt;0042 3C 61 &lt;br /&gt;0044 72 02 &lt;br /&gt;0046 2C 20 &lt;br /&gt;0048 &lt;br /&gt;0048 2c 07 &lt;br /&gt;004A &lt;br /&gt;004A 2C 30 &lt;br /&gt;004C C3 &lt;br /&gt;004D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that reads a 4-digit hexadecimal number from &lt;br /&gt;;the keyboard and stores the result in word-sized &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory location TEMP . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;DW ? &lt;br /&gt;. CODE &lt;br /&gt;. STARTUP &lt;br /&gt;CALL READH &lt;br /&gt;MOV TEMP,AX &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select SMALL model &lt;br /&gt;;start DATA segment &lt;br /&gt;;define TEMP &lt;br /&gt;;start CODE segment &lt;br /&gt;;start program &lt;br /&gt;;read hexadecimal number &lt;br /&gt;;save it at TEMP &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The READH procedure that reads a 4-digit hexadecimal &lt;br /&gt;;number from the keyboard and returns it in AX. &lt;br /&gt;;This procedure does next check for errors and uses CONV. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READH1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH CX &lt;br /&gt;PUSH BX &lt;br /&gt;MOV CX,4 &lt;br /&gt;MOV SI,CX &lt;br /&gt;MOV BX,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 21H &lt;br /&gt;CALL CONV &lt;br /&gt;SHL BX,CL &lt;br /&gt;ADD BL,AL &lt;br /&gt;DEC SI &lt;br /&gt;JNZ READH1 &lt;br /&gt;MOV AX,BX &lt;br /&gt;POP BX &lt;br /&gt;POP CX &lt;br /&gt;RET &lt;br /&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save BX and CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load CX and SI with 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear result &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read a key with echo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;convert to binary &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;form result in BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;repeat 4 times &lt;br /&gt;;move result to AX &lt;br /&gt;;restore BX and CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The CONV procedure converts AL into hexadecimal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONV1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONV2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP AL,'9' &lt;br /&gt;JBE CONV2 &lt;br /&gt;CMP AL, 'a' &lt;br /&gt;JB CONV1 &lt;br /&gt;SUB AL,20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AL,7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AL,30H &lt;br /&gt;RET &lt;br /&gt;ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if 0 through 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if uppercase A through F &lt;br /&gt;;convert to uppercase &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displaying Hexadecimal Data. To display hexadecimal data, a number must be divided into &lt;br /&gt;4-bit segments that are converted into hexadecimal digits. Conversion is accomplished by adding &lt;br /&gt;a 30H to the numbers 0 to 9 and a 37H to the letters A to F. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A procedure (DSIPH) that displays the contents of the AX register on the video display ap-&lt;br /&gt;pears in the program of Example 7-31. Here the number is rotated left so that the leftmost digit &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;248 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;is displayed first. Because AX contains a 4-digit hexadecimal number, the procedure displays &lt;br /&gt;four hexadecimal digits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-31 &lt;br /&gt;;A program that displays the hexadecimal value in AX. &lt;br /&gt;;This program uses DISPH to display a 4-digit value. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY ;select TINY model &lt;br /&gt;0000 . CODE ;start CODE segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP ;start program &lt;br /&gt;0100 B8 OABC MOV AX,OABCH ;load:~ with test data &lt;br /&gt;0103 E8 0004 CALL DISPH ;display AX in hexadecimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT ;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; The DISPH procedure displays AX as a 4-digit hex number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010A DISPH PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010A 53 PUSH BX isave BX and CX &lt;br /&gt;010B 51 PUSH CX &lt;br /&gt;010C Bl 04 MOV CL,4 ; load rotate count &lt;br /&gt;010E B5 04 MOV CH,4 ; load digit count &lt;br /&gt;0110 DISPHl: &lt;br /&gt;0110 D3 CO ROL AX,CL ;position digit &lt;br /&gt;0112 50 PUSH AX &lt;br /&gt;0113 24 OF AND AL,OFH ;convert it to ASCII &lt;br /&gt;0115 04 30 ADD AL,30H &lt;br /&gt;0117 3C 39 CMP AL, '9' &lt;br /&gt;0119 76 02 JBE DISPH2 &lt;br /&gt;011B 04 07 ADD AL,7 &lt;br /&gt;011D DISPH2: &lt;br /&gt;011D B4 02 MOV AH,2 ;display hexadecimal digit &lt;br /&gt;011F 8A DO MOV DL,AL &lt;br /&gt;0121 CD 21 INT 21H &lt;br /&gt;0123 58 POP AX &lt;br /&gt;0124 FE CD DEC CH &lt;br /&gt;0126 75 E8 JNZ DISPHI ; repeat for 4 digits &lt;br /&gt;0128 59 POP CX ;restore registers &lt;br /&gt;0129 5B POP BX &lt;br /&gt;012A C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012B DISPH ENDP &lt;br /&gt;END ; end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Using Lookup Tables for Data Conversions &lt;br /&gt;Lookup tables are often used to convert from one data form to another. A lookup table is formed &lt;br /&gt;in the memory as a list of data that is referenced by a procedure to perform conversions. In the &lt;br /&gt;case of many lookup tables, the XLAT instruction can often be used to lo?k up data in a table &lt;br /&gt;provided that the table contains 8-bit wide data and its length is less than or equal to 256 bytes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Converting from BCD to 7-segment Code. One simple application that uses a lookup table is &lt;br /&gt;BCD to 7-segment code conversion. Example 7-32 illustrates a lookup table that contains the &lt;br /&gt;7-segment codes for the numbers 0 to 9. These codes are used with the 7-segment display pic-&lt;br /&gt;tured in Figure 7-1. This 7-segment display uses active high (logic 1) inputs to light a segment. &lt;br /&gt;The code is arranged so that the segment is in bit position 0 and the g sep,ment is in bit position 6. &lt;br /&gt;Bit position 7 is zero in this example, but can be used for displaying a decimal point. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-32 &lt;br /&gt;0000 SEG7 PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 53 PUSH BX &lt;br /&gt;0001 BB 0008 R MOV BX,OFFSET TABLE &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-3 DATA CONVERSIONS 249 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 7-1 The I ~~ 7 -segment display ~' a Control byte &lt;br /&gt;101 9 If lei d lei b lal ~: 9 ~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;d U I I &lt;br /&gt;0004 2E: D7 XLAT CS:TABLE ;see text &lt;br /&gt;0006 5B POP BX &lt;br /&gt;0007 CB RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 3F TABLE DB 3FH ; 0 &lt;br /&gt;0009 06 DB 6 ; 1 &lt;br /&gt;OOOA 5B DB 5BH ;2 &lt;br /&gt;OOOB 4F DB 4FH ; 3 &lt;br /&gt;OOOC 66 DB 66H ;4 &lt;br /&gt;DODD 6D DB 6DH ; 5 &lt;br /&gt;OOOE 7D DB 7DH ; 6 &lt;br /&gt;OOOF 07 DB 7 ; 7 &lt;br /&gt;0010 7F DB 7FH ; 8 &lt;br /&gt;DOll 6F DB 6FH ; 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0012 SEG7 ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure that performs the conversion contains only two instructions and assumes &lt;br /&gt;that AL contains the BCD digit to be converted to 7-segment code. One of the instructions ad-&lt;br /&gt;dresses the lookup table by loading its address into BX, and the other performs the conversion &lt;br /&gt;and returns the 7 -segment code in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the lookup table is located in the code segment, and the XLA T instruction ac-&lt;br /&gt;cesses the data segment by default, the XLAT instruction includes a segment override. Notice &lt;br /&gt;that a dummy operand (TABLE) is added to the XLAT instruction so the (CS:) code segment &lt;br /&gt;override prefix can be added to the instruction. Normally, XLAT does not contain an operand &lt;br /&gt;unless its default segment must be overridden. The LODS and MOVS instructions are also over-&lt;br /&gt;ridden in the same manner as XLAT by using a dummy operand. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;USing a Lookup Table to Access ASCII Data. Some programming techniques require that nu-&lt;br /&gt;meric codes be converted to ASCII character strings. For example, suppose that you need to dis-&lt;br /&gt;play the days of the week for a calendar program. Because the number of ASCII characters in &lt;br /&gt;each day is different, some type of lookup table must be used to reference the ASCII-coded days &lt;br /&gt;of the week. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The program in Example 7-33 shows a table that references ASCII-coded character strings &lt;br /&gt;located in the code segment. Each character string contains an ASCII-coded day of the week. &lt;br /&gt;The table references each day of the week. The procedure that accesses the day of the week uses &lt;br /&gt;the AL register and the numbers 0 to 6 to refer to Sunday through Saturday. If AL contains a 2 &lt;br /&gt;when this procedure is called, the word Tuesday is displayed on the video screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-33 &lt;br /&gt;A program that displays the current day of the &lt;br /&gt;week by using the system clock/calendar. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL ;select SMALL model &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;250 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . DATA ;start DATA segment &lt;br /&gt;0000 OOOE R 0015 R DTAB DW SUN,MON,TUE,WED,THU,FRI,SAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlC R 0024 R &lt;br /&gt;002E R 0037 R &lt;br /&gt;C03E R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE 53 75 6E 64 61 79 SUN DB 'Sunday$ , &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0015 4D 6F 6E 64 61 79 MON DB 'Monday$ , &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlC 54 75 65 73 64 61 TUE DB 'Tuesday$ , &lt;br /&gt;79 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 57 65 64 6E 65 73 WED DB 'WednesdayS , &lt;br /&gt;64 61 79 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002E 54 68 75 72 73 64 THU DB 'Thursday$' &lt;br /&gt;61 79 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0037 46 72 69 64 61 79 FRI DB 'Friday$' &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003E 53 61 74 75 72 64 SAT DB 'Saturday$ , &lt;br /&gt;61 79 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE ;start CODE segment &lt;br /&gt;. STARTUP ;start program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B4 2A MOV AH,2AH ;get day of week &lt;br /&gt;0019 CD 21 INT 21H ;access DOS &lt;br /&gt;OOlB E8 0004 CALL DAYS ;display day of week &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT ;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0022 DAYS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0022 52 PUSH DX ;save DX and SI &lt;br /&gt;0023 56 PUSH SI &lt;br /&gt;0024 BE 0000 R MOV SI,OFFSET DTAB ;address table &lt;br /&gt;0027 B4 00 MOV AH,O ;find day of week &lt;br /&gt;0029 03 CO ADD AX,AX &lt;br /&gt;002B 03 FO ADD SI,AX &lt;br /&gt;002D 8B 14 MOV DX, lSI] ;get day of week &lt;br /&gt;002F B4 09 MOV AH,9 ;display string &lt;br /&gt;0031 CD 21 INT 21H &lt;br /&gt;0033 5E POP SI irestore registers &lt;br /&gt;0034 5A POP DX &lt;br /&gt;0035 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0036 DAYS ENDP &lt;br /&gt;END ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This procedure first addresses the table by loading its address into the SI register. Next, the &lt;br /&gt;number in AL is converted into a 16-bit number and doubled because the table contains two &lt;br /&gt;bytes for each entry. This index is then added to SI to address the correct entry in the lookup &lt;br /&gt;table. The address of the ASCII character string is now loaded into DX by the MOV DX,CS:[SI] &lt;br /&gt;instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before the INT 21H DOS function is called, the DS register is placed on the stack and &lt;br /&gt;loaded with the segment address of CS. This allows DOS function number 09H (display a string) &lt;br /&gt;to be used to display the day of the week. This procedure converts the numbers 0 to 6 to the days &lt;br /&gt;of the week. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An Example Program Using Data Conversions &lt;br /&gt;A program example is required to combine some of the data conversion DOS functions. Suppc&amp;gt;se that &lt;br /&gt;you must display the time and date on the video screen. This example program (see Example 7-34) &lt;br /&gt;displays the time as 10:45 P.M. and the date as Tuesday, May 14, 1999. The program is short be-&lt;br /&gt;cause it calls a procedure that displays the time and a second that displays the date. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The time is available from DOS using an INT 21H function call number 2CH. This returns &lt;br /&gt;with the hours in CH and minutes in CL. Also available are seconds in DH and hundredths of &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-3 DATA CONVERSIONS 251 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;seconds in DL. The date is available using an INT 21H function call number 2AH. This leaves &lt;br /&gt;the day of the week in AL, the year in ex, the day of the month in DH, and the month in DL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-34 &lt;br /&gt;;A program that displays the time and date in the &lt;br /&gt;;form: 10:34 A.M., Tuesday July 4, 1999. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL ;select SMALL model &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. NOLISTMACRO ;don't expand macros &lt;br /&gt;0000 . DATA ;start CODE segment &lt;br /&gt;0000 0026 R 002F R DTAB DW SUN,MON,TUE,WED,THU,FRI,SAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 R 0042 R &lt;br /&gt;004E R 0059 R &lt;br /&gt;0062 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE 006D R 0076 R MTAB DW JAN,FEB,MAR,APR,MAY,JUN &lt;br /&gt;0080 R 0087 R &lt;br /&gt;008E R 0093 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001A 0099 R 009F R DW JUL,AUG,SEP,OCT,NOV,DCE &lt;br /&gt;00A7 R 00B2 R &lt;br /&gt;OOBB R 00C5 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0026 53 75 6E 64 61 79 SUN DB 'Sunday, $ , &lt;br /&gt;2C 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002F 4D 6F 6E 64 61 79 MON DB 'Monday, $ , &lt;br /&gt;2C 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 54 75 65 73 64 61 TUE DB 'Tuesday, $ , &lt;br /&gt;79 2C 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0042 57 65 64 6E 65 73 WED DB 'Wednesday, $ , &lt;br /&gt;64 61 79 2C 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004E 54 68 75 72 73 64 THU DB 'Thursday, $ , &lt;br /&gt;61 79 2C 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0059 46 72 69 64 61 79 FRI DB 'Friday, $ , &lt;br /&gt;2C 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0062 53 61 74 75 72 64 SAT DB 'Saturday, $ , &lt;br /&gt;61 79 2C 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;006D 4A 61 6E 75 61 72 JAN DB 'January $' &lt;br /&gt;79 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0076 46 65 62 72 75 61 FEB DB 'February $ , &lt;br /&gt;72 79 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0080 4D 61 72 63 68 20 MAR DB 'March $ , &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0087 41 70 72 69 6C 20 APR DB 'April $ , &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;008E 4D 61 79 20 24 MAY DB 'May $' &lt;br /&gt;0093 4A 75 6E 65 20 24 JUN DB 'June $' &lt;br /&gt;0099 4A 75 6C 79 20 24 JUL DB 'July $' &lt;br /&gt;009F 41 75 67 75 73 74 AUG DB 'August $' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 24 &lt;br /&gt;00A7 53 65 70 74 65 6D SEP DB 'September $ , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62 65 72 20 24 &lt;br /&gt;00B2 4F 63 74 6F 62 65 OCT DB 'October $' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;72 20 24 &lt;br /&gt;OOBB 4E 6F 76 65 6D 62 NOV DB 'November $ , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;65 72 20 24 &lt;br /&gt;DOCS 44 65 63 65 6D 62 DCE DB 'December $ , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;65 72 20 24 &lt;br /&gt;0000 . CODE ;start CODE segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP MACRO CHAR &lt;br /&gt;PUSH AX ; isave AX and DX &lt;br /&gt;PUSH DX &lt;br /&gt;MOV DL,CHAR ; ;display character &lt;br /&gt;MOV AH,2 &lt;br /&gt;INT 21H &lt;br /&gt;POP DX ;;restore AX and DX &lt;br /&gt;POP AX &lt;br /&gt;ENDM &lt;br /&gt;. STARTUP ;start program &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;252 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 E8 0007 CALL TIMES ;display time &lt;br /&gt;001A E8 00A3 CALL DATES ;display date &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT ;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 TIMES PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 B4 2C MOV AH,2CH ;get time from DOS &lt;br /&gt;0023 CD 21 INT 21H &lt;br /&gt;0025 B7 41 MOV BH, 'A' ;set 'A' for AM &lt;br /&gt;0027 80 FD OC CMP CH,12 &lt;br /&gt;002A 72 05 JB TIMES1 ;if below 12:00 noon &lt;br /&gt;002C B7 50 MOV BH, 'P' ;set 'P' for PM &lt;br /&gt;002E 80 ED OC SUB CH,12 ;adjust to 12 hours &lt;br /&gt;0031 TIMES1: &lt;br /&gt;0031 OA ED OR CH,CH ;test for o hour &lt;br /&gt;0033 75 02 JNE TIMES2 ;if not 0 hour &lt;br /&gt;0035 B5 OC MOV CH,12 ;change 0 hour to 12 &lt;br /&gt;0037 TIMES2: &lt;br /&gt;0037 8A C5 MOV AL,CH &lt;br /&gt;0039 B4 00 MOV AH,O &lt;br /&gt;003B D4 OA AAM ;convert hours &lt;br /&gt;003D OA E4 OR AH,AH &lt;br /&gt;003F 74 OD JZ TIMES3 ;if no tens of hours &lt;br /&gt;0041 80 C4 30 ADD AH, '0' ; convert tens &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP AH ; display tens &lt;br /&gt;004E TIMES3: &lt;br /&gt;004E 04 30 ADD AL, '0' ; convert units &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP AL ; display units &lt;br /&gt;DISP ':' ;display colon &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0064 8A C1 MOV AL,CL &lt;br /&gt;0066 B4 00 MOV AH,O &lt;br /&gt;0068 D4 OA AAM ;convert minutes &lt;br /&gt;006A 05 3030 ADD AX,3030H &lt;br /&gt;006D 50 PUSH AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP AH ;display tens &lt;br /&gt;0078 58 POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP AL ; display units &lt;br /&gt;DISP ;display space &lt;br /&gt;DISP BH ; display 'A' or 'P' &lt;br /&gt;DISP , , ;display &lt;br /&gt;DISP 'M' ; display M &lt;br /&gt;DISP ; display &lt;br /&gt;DISP ; display space &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOBF C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCO TIMES ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCO DATES PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, OOCO B4 2A MOV AH,2AH ;get date from DOS &lt;br /&gt;00C2 CD 21 INT 21H &lt;br /&gt;00C4 52 PUSH DX &lt;br /&gt;00C5 B4 00 MOV AH,O ;get day of week &lt;br /&gt;00C7 03 CO ADD AX,AX &lt;br /&gt;00C9 BE 0000 R MOV SI,OFFSET DTAB ; address day table &lt;br /&gt;OOCC 03 FO ADD SI,AX &lt;br /&gt;OOCE 8B 14 MOV DX, [SI] ;address day of week &lt;br /&gt;OODO B4 09 MOV AH,9 ; display day of week &lt;br /&gt;00D2 CD 21 INT 21H &lt;br /&gt;00D4 5A POP DX &lt;br /&gt;00D5 52 PUSH DX &lt;br /&gt;00D6 8A C6 MOV AL,DH ;get month &lt;br /&gt;00D8 FE C8 DEC AL &lt;br /&gt;OODA B4 00 MOV AH,O &lt;br /&gt;OODC 03 CO ADD AX,AX &lt;br /&gt;OODE BE OOOE R MOV SI,OFFSET MTAB ;address month table &lt;br /&gt;00E1 03 Fa ADD SI,AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-4 DISK FILES 253 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00E3 8B 14 MOV DX, [51] ;address month &lt;br /&gt;00E5 B4 09 MOV AH,9 ;display month &lt;br /&gt;00E7 CD 21 1NT 21H &lt;br /&gt;00E9 5A POP DX &lt;br /&gt;OOEA 8.lI. C2 MOV AL,DL ;get day of month &lt;br /&gt;OOEC B4 00 MOV AH,O &lt;br /&gt;OOEE D4 OA AAll iconvert to BCD &lt;br /&gt;OOFO OA E4 OR AH,AH &lt;br /&gt;00F2 74 OD JZ DATES1 ;if tens is 0 &lt;br /&gt;OOF4 80 C4 30 ADD AH,30H ; convert tens &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP AH ;display tens &lt;br /&gt;0101 DATES1 : &lt;br /&gt;0101 04 30 ADD AL,30H ; convert units &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D1SP AL ;display units &lt;br /&gt;D1SP ;display comma &lt;br /&gt;D1SP ;display space &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0121 81 F9 07DO CMP CX,2000 ;test for year 2000 &lt;br /&gt;0125 72 19 JB DATES2 ;if below year 2000 &lt;br /&gt;0127 83 E9 64 SUB CX,100 ;scale to 1900 - 1999 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP '2 ' ;display 2 &lt;br /&gt;D1SP '0 ' ;display 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;013E EB 14 JMP DATES3 &lt;br /&gt;0140 DATES2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP '1' ;display 1 &lt;br /&gt;D1SP '9 ' ;display 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0154 DATES3 : &lt;br /&gt;0154 81 E9 076C SUB CX,1900 ;scale to 00 - 99 &lt;br /&gt;0158 8B C1 MOV AX,CX &lt;br /&gt;015A D4 OA AAM ; convert to BCD &lt;br /&gt;015C 05 3030 ADD AX,3030H ; convert to ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D1SP AH ;display tens &lt;br /&gt;D1SP AL ;display units &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0173 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0174 DATES ENDP &lt;br /&gt;END ;end of file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This procedure uses two ASCII lookup tables that convert the day and month to ASCII &lt;br /&gt;character strings. It also uses the AAM instruction to convert from binary to BCD for the time &lt;br /&gt;and date. The displaying of data is hand~ed in two ways: by character string (function 09H) and &lt;br /&gt;by single character (function 06H). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory model (SMALL) consists of two segments: .DATA and .CODE. The data &lt;br /&gt;~egment contains the character strings used with the procedures that display time and date. The &lt;br /&gt;code segment contains TIMES and DATES procedures and a macro (DISP) that displays an &lt;br /&gt;ASCII character. The main program is very short and consists of two CALL instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISK FILES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data are found stored on the disk in the form of files. The disk itself is organized in four main &lt;br /&gt;parts: the boot sector, the file allocation table (FAT), the root directory, and the data storage &lt;br /&gt;areas. The first sector on the disk is the boot sector. The boot sector is used to load the disk op-&lt;br /&gt;erating system (DOS) from the disk into the memory when power is applied to the computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The FAT is where the names of files/subdirectories and their locations on the disk are &lt;br /&gt;stored by DOS. All references to any disk file are handled through the FAT. All other subdirec-&lt;br /&gt;tories and files are referenced through the root directory. The disk files are all considered se-&lt;br /&gt;quential access files, meaning that they are accessed a byte at a time from the beginning of the &lt;br /&gt;file toward the end. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;254 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sector--~ &lt;br /&gt;___ ---- Track 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Index hole &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;___ -- Inner track &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Drive hub &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 7-2 Structure of the 51f/' floppy disk &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Disk Organization &lt;br /&gt;Figure 7-2 illustrates the organization of sectors and tracks on the surface of the disk. This &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;organization applies to both floppy and hard disk memory systems. The outer track is always &lt;br /&gt;track 0 and the inner track is 39 (double-density) or 79 (high-density) on floppy disks. The inner &lt;br /&gt;track on a hard disk is determined by the disk size and could be 10000 or higher for very large &lt;br /&gt;hard disks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 7-3 shows the organization of data on a disk. The length of the FAT is determined &lt;br /&gt;by the size of the disk. Likewise, the length of the root directory is determined by the number of &lt;br /&gt;files and subdirectories located within it. The boot sector is always a single 512-byte-long sector &lt;br /&gt;located in the outer track at sector 0, the first sector. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The boot sector contains a bootstrap loader program that is read into RAM when the &lt;br /&gt;system is powered. The bootstrap loader then executes and loads the IO.SYS and MSDOS.SYS &lt;br /&gt;programs into RAM. Next, the bootstrap loader passes control to the MSDOS control pro-&lt;br /&gt;gram, allowing the computer to be under the control of the DOS command processor called &lt;br /&gt;COMMAND.COM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The FAT indicates which sectors are free, which are corrupted (unusable), and which con-&lt;br /&gt;tain data. The FAT table is referenced each time that DOS writes data to the disk so that it can &lt;br /&gt;find a free sector. Each free cluster is indicated by a OOOOH in the FAT and each occupied sector &lt;br /&gt;is indic2tGd by the cluster number. A cluster can be anything from one sector to any number of &lt;br /&gt;sectors long. Many hard disk memory systems use four sectors per cluster, which means that the &lt;br /&gt;smallest file is 512 x 4 or 2,048 bytes long. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 7-4 shows the format of each directory entry in the root or any other directory or &lt;br /&gt;subdirectory. Each entry contains the name, extension, attribute, time, date, location, and length. &lt;br /&gt;The length of the file is stored as a 32-bit number. This means that a file can have a maximum &lt;br /&gt;length of 4G bytes. The location is the starting cluster number. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-4 DISK FILES 255 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 7-3 Main data Boot &lt;br /&gt;storage areas on a disk I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ &lt;br /&gt;FAT Root Files and t::'her directories &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ &lt;br /&gt;Track 0 &lt;br /&gt;Sector 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 7-4 Format to any *Note: year 8 = 1988, year 9 = 1989, year 10 = 1990, etc. &lt;br /&gt;directory or subdirectory entry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;81 4 2 1 16 8 4 2 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Year* I ;Month I Day I &lt;br /&gt;16 8 4 2 1 32 16 8: 4 2 1 X X X X X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hours Mi+tes Unused &lt;br /&gt;17 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o I A IDH S H R I 10 A = Archive D = Subdirectory V = Volume label &lt;br /&gt;S = System file &lt;br /&gt;H = Hidden file &lt;br /&gt;R = Read-only &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-35 shows how part of the root directory appears in a hexadecimal dump. Try to &lt;br /&gt;identify the date, time, location, and length of each entry. Also identify the attribute for each entry. &lt;br /&gt;The listing shows both hexadecimal and ASCII data, as is customary for most computer dumps. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-35 &lt;br /&gt;0000 49 4F 20 20 20 20 20 20 53 59 53 07 00 00 00 DO IO SYS &lt;br /&gt;0010 00 00 DO 00 00 00 00 00 93 11 02 00 39 82 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 4D 53 44 4F 53 20 20 20 53 59 53 07 00 00 00 00 MSDOS SYS &lt;br /&gt;0030 00 DO 00 DO 00 00 CO 44 93 12 13 00 92 00 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0040 43 4F 4D 4D 41 4E 44 20 43 4F 4D 00 00 00 00 00 COMMAND COM &lt;br /&gt;0050 00 00 00 00 00 00 00 00 93 11 26 00 B5 92 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0060 42 41 52 52 59 20 42 52 45 59 20 28 00 00 00 00 BARRY BREY &lt;br /&gt;0070 00 00 DO 00 DO 00 EO AD 6A 13 00 00 00 00 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G080 50 43 54 4F 4F 4C 53 20 20 20 20 10 00 DO 00 00 PC TOOLS &lt;br /&gt;0090 00 00 00 00 DO 00 80 AE 6A 13 5C 00 00 00 00 DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOAO 44 4F 53 20 20 20 20 20 20 20 20 10 00 00 00 00 DOS &lt;br /&gt;0080 00 00 00 00 00 DO EO 80 6A 13 4E 00 00 00 OD 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCO 52 55 4E 5F 46 57 20 20 42 41 54 00 00 00 00 DO FUN_FW 8AT &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;256 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DODO 00 00 00 00 00 00 40 ED 6A 13 97 OF 4A 00 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ODED 46 4F 4E 54 57 41 52 45 20 20 20 10 00 00 00 00 &lt;br /&gt;OOFO 00 00 00 00 00 00 60 ED 6A 13 6E 00 00 00 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FONTWARE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Files are usually accessed through DOS !NT 2lH function calls. There are two ways to ac-&lt;br /&gt;cess a file using INT 21H. One way uses a file control block, and the other uses a file handle. &lt;br /&gt;Today, all software accesses files via a file handle, so this text also uses file handles for file ac-&lt;br /&gt;cess. File control blocks are a carryover from an earlier operating system called CPM (control &lt;br /&gt;program micro), which was used with 8-bit computer systems based on the Z80 or 8080 micro-&lt;br /&gt;processor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sequential File Access &lt;br /&gt;All DOS files are sequential files. A sequential file is stored and accessed from the beginning of &lt;br /&gt;the file toward the end, with the first byte and all bytes between it and the last accessed to read &lt;br /&gt;the last byte. Fortunately, 'files are read and written with the DOS !NT 21H function calls (refer &lt;br /&gt;to Appendix A), which makes their access and manipulation easy. This section of the text de-&lt;br /&gt;scribes how to create, read, write, delete, and rename a sequential access file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;File Creation. Before a file can be used, it must exist on the disk. A file is created by the !NT &lt;br /&gt;21H function call number 3CH. The file name must be stored at a location addressed by DS:DX &lt;br /&gt;before calling the function, and CX must contain the attribute of the file (or subdirectory) created. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A file name is always stored as an ASCII-Z string and may contain the drive and directory &lt;br /&gt;path(s) if needed. Example 7-36 shows several ASCII-Z string file names stored in a data seg-&lt;br /&gt;ment for access by the file utilities. An ASCIIÂ·Z string is a character string that ends with a OOH &lt;br /&gt;or null character. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-36 &lt;br /&gt;0000 44 4F 47 2E 54 58 FILE1 DE 'OOG.TXT',O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;54 00 &lt;br /&gt;0008 43 3A 44 41 54 41 FILE2 DE 'C:DATA.DOC',O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E 44 4F 43 00 &lt;br /&gt;0013 43 3A 5C 44 52 45 FILE3 DE 'C:\\DREAD\\ERROR.FIL',O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41 44 5C 45 52 52 &lt;br /&gt;4F 52 2E 46 49 4C &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that you have filled a 256 memory buffer area with data that must be stored in a &lt;br /&gt;new file called DAT A.NEW on the default disk drive. Before data can be written to this new file, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 7-5 File attribute definitions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;3 &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Value &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01H &lt;br /&gt;02H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H &lt;br /&gt;08H &lt;br /&gt;10H &lt;br /&gt;20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AttrLbute &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Read-only &lt;br /&gt;Hidden &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System &lt;br /&gt;Volume &lt;br /&gt;Sub-directory &lt;br /&gt;Arphive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A read-only file or directory &lt;br /&gt;Prevents the file or directory from appearing in &lt;br /&gt;a directory listing &lt;br /&gt;Specifies a system file &lt;br /&gt;Specifies the name of the disk volume &lt;br /&gt;Specifies a subdirectory name &lt;br /&gt;Indicates that a file has ~hanged since the last &lt;br /&gt;backup &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-4 DISK FILES 257 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the file must first be created. Example 7-37 lists a short procedure that creates this new file on &lt;br /&gt;the disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 44 41 54 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E 4E 45 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B4 3C &lt;br /&gt;0019 B9 0000 &lt;br /&gt;001C BA 0000 R &lt;br /&gt;001F CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41 &lt;br /&gt;57 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that creates file DATA.NEW. &lt;br /&gt;;DO NOT RUN this program because the file is not closed . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FILEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SHALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;DB 'DATA.NEW' ,0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MOV AH,3CH &lt;br /&gt;MOV CX,O &lt;br /&gt;MOV DX,OFFSET FILEN &lt;br /&gt;INT 21H &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;create file function &lt;br /&gt;;norma1 file attribute &lt;br /&gt;;address file name &lt;br /&gt;;access DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever a file is created, the CX register must contain the attributes or characteristics of &lt;br /&gt;the file. Table 7-5 lists and defines the attribute bit positions. A logic I in a bit selects the at-&lt;br /&gt;tribute, while a logic 0 does not. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After returning from the INT 21H, the carry flag indicates whether or not an error occurred &lt;br /&gt;(CF = 1) during the creation of the file. Some errors that can occur are path not found, no file handles &lt;br /&gt;available, or media error; they are obtained if needed by !NT 2lH function call number 59H. If &lt;br /&gt;carry is cleared, no error has occurred and the AX register contains a file handle. The file handle &lt;br /&gt;is a number that is used to refer to the file after it is created or opened. The file handle allows a file &lt;br /&gt;to be accessed without using the ASCII-Z string name of the file, speeding the operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Writing to a File. Now that we have created a new file, called FILE.NEW, data can be written to &lt;br /&gt;it. Before writing to a file, the file must have been created or opened. When a file is created or &lt;br /&gt;opened, the file handle returns in the AX register. The file handle is used to refer to the file &lt;br /&gt;whenever data are written. Function number 40H is used to write data to an opened or newly cre-&lt;br /&gt;ated file. In addition to loading a 40H into AH, we must also load BX = the file handle, CX = the &lt;br /&gt;number of bytes to be written, and DS:DX = the address of the area to be written to the disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that we must write all 256 bytes of BUFFER to the file. This is accomplished as &lt;br /&gt;illustrated in Example 7-38 using function 40H. If an error occurs during a write operation, the &lt;br /&gt;carry flag is set. If no error occurs, the carry flag is cleared and the number of bytes written to the &lt;br /&gt;file is returned in the AX register. Errors that occur for writes usually indicate that the disk is full &lt;br /&gt;or that there is some type of media error. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 8B D8 MOV BX,AX ;move handle to BX &lt;br /&gt;0012 B4 40 MOV AH,40H ; load write function &lt;br /&gt;0014 B9 0100 MOV CX,256 ;load count &lt;br /&gt;0017 BA 0009 R MOV DX,OFFSET BUFFER ;address BUFFER &lt;br /&gt;OOlA CD 21 INT 2lH ;write 256 bytes from BUFFER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlC 72 32 JC ERROR1 ion write error &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;258 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opening, Reading, and Closing a File. To read a file, it must first be opened. When a file is &lt;br /&gt;opened, DOS checks the directory to determine if the file exists and returns the DOS file handle &lt;br /&gt;in register AX. The DOS file handle must be used for reading, writing, and closing a file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-39 shows a sequence of instructions that open a file, read 256 bytes from the &lt;br /&gt;file into memory area BUFFER, and then close the file. When a file is opened (AH = 3DH), the &lt;br /&gt;AL register specifies the type of operation allowed for the opened file. If AL = OOH, the file is &lt;br /&gt;opened for a read; if AL = OIH, the file is opened for a write; and if AL = 02H, the file is opened &lt;br /&gt;for a read or a write. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-39 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 54 45 4D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E 41 53 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 0100 [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B8 3D02 &lt;br /&gt;001A BA 0000 R &lt;br /&gt;OOlD CD 21 &lt;br /&gt;OOlF 8B D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 B4 3F &lt;br /&gt;0023 B9 0100 &lt;br /&gt;0026 BA 0009 R &lt;br /&gt;0029 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002B B4 3E &lt;br /&gt;002D CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50 &lt;br /&gt;4D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that opens the file TEMP.ASM and reads the &lt;br /&gt;;first 256 bytes into an area of memory called BUF . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;FILEN DB 'TEMP.ASM',O ;fi1e name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUF DB 256 DUP (?) ;buffer area &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MOV AX,3D02H ; open file function &lt;br /&gt;MOV DX,OFFSET FILEN ;address file name &lt;br /&gt;INT 21H ;access DOS &lt;br /&gt;MOV BX,AX ;file handle to BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,3FH &lt;br /&gt;MOV CX,256 &lt;br /&gt;MOV DX,OFFSET BUF &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,3EH &lt;br /&gt;INT 21H &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read file function &lt;br /&gt;;read 256 bytes &lt;br /&gt;;store data at BUF &lt;br /&gt;;access DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;close file function &lt;br /&gt;;access DOS \\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function number 3FH causes a file to be read. As with the write function, BX contains the &lt;br /&gt;file handle, CX contains the number of bytes to be read, and DS:DX contains the location of a &lt;br /&gt;memory area where the data are stored. As with all disk functions, the carry flag indicates an &lt;br /&gt;error with a logic 1. If a logic Â° is indicated, the AX register indicates the number of bytes read &lt;br /&gt;from the file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Closing a file is very important. If a file is left open, some serious problems can occur that &lt;br /&gt;can actually destroy the disk and all of its data. If a file is written and not closed, the FAT can be-&lt;br /&gt;come corrupted, making it difficult or impossible to retrieve data from the disk. Always be cer-&lt;br /&gt;tain to close a file after it is read or written. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The File Pointer. When a file is opened, written, or read, the file pointer addresses the current &lt;br /&gt;location in the sequential file. When a file is opened, the file pointer always addresses the first &lt;br /&gt;byte of the file. If a file is 1,024 bytes long, and a read function reads 1,023 bytes, the file pointer &lt;br /&gt;addresses the last byte of the file, but not the end of the file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The file pointer is a 32-bit numb.~r that addresses any byte in a file. Once a file is opened, &lt;br /&gt;the file pointer can be changed with the move file pointer function number 42H. A file pointer can &lt;br /&gt;be moved from the start of the file (AL = OOH), from the current location (AL = OIH), or from the &lt;br /&gt;end of the file (AL = 02H). In practice, all three directions of the move are used to access different &lt;br /&gt;parts of the file. The distance moved by the file pointer is specified by registers CX and DX. The &lt;br /&gt;DX register holds the least-significant part of the distance, and CX the most significant part. Reg-&lt;br /&gt;ister BX must contain the file handle before using function 42H to move the file pointer. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;EXAMPLE 7-41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 0000 &lt;br /&gt;0002 0000 &lt;br /&gt;0004 44 41 54 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E 54 4D &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-4 DISK FILES 259 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a file exists on the disk and that you must append the file with 256 bytes of &lt;br /&gt;new infonnation. When the file is opened, the file pointer addresses the first byte of the file. If &lt;br /&gt;you attempt to write without moving the file pointer to the end of the file, the new data will over-&lt;br /&gt;write the first 256 bytes of the file. Example 7-40 shows a procedure that opens a file, moves the &lt;br /&gt;file pointer to the end of the file, writes 256 bytes of data, and then closes the file. This appends &lt;br /&gt;the file with 256 new bytes of data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-40 &lt;br /&gt;;A program that opens FILE.NEW and appends it with 256 &lt;br /&gt;;bytes of data from BUF . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;0000 . DATA &lt;br /&gt;0000 46 49 4C 45 FILEN DB 'FILE.NEW',O ;file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E 4E 45 57 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 0100 [ BUF DB 256 DUP (? ) ;buffer &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;0000 .CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0017 B8 3D02 MOV AX,3D02H ;open FILE.NEW &lt;br /&gt;OOlA BA 0000 R MOV DX,OFFSET FILEN &lt;br /&gt;001D CD 21 INT 21H &lt;br /&gt;001F 8B D8 MOV BX,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 B8 4202 MOV AX,4202H ;move file pointer to end &lt;br /&gt;0024 BA GOOO MOV DX,O &lt;br /&gt;0027 B9 0000 MOV CX,O &lt;br /&gt;002A CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002C B4 40 MOV AH,40H ;write BUF to end of file &lt;br /&gt;002E B9 0100 MOV CX,256 &lt;br /&gt;0031 BA 0009 R MOV DX,OFFSET BUF &lt;br /&gt;0034 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0036 B4 3E MOV AH,3EH ;close file &lt;br /&gt;0038 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;One of the more difficult file maneuvers is inserting new data into the middle of the file. &lt;br /&gt;Figure 7-5 shows how this is accomplished by creating a second file. Notice that the part of the &lt;br /&gt;file before the insertion point is copied into the new file. This is followed by the new infonnation &lt;br /&gt;before the remainder of the file is appended after the insertion into the new file. Once the new &lt;br /&gt;file is complete, the old file is deleted and the new file is renamed to the old file name. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-41 shows a program that inserts new data into an old file. This program copies &lt;br /&gt;the DATA.NEW file into the DATA.OLD file at a point after the first 256 bytes of the &lt;br /&gt;DATA.OLD file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41 &lt;br /&gt;50 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that adds the 256 byte contents of the file &lt;br /&gt;;DATA.NEW to DATA.OLD at a point between the first 256 &lt;br /&gt;;bytes of DATA.OLD and the remainder of the file . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;HAN1 DW ; file handle for DATA.TMP &lt;br /&gt;HAN2 DW ; file handle for DATA. OLD &lt;br /&gt;FILE1 DB 'DATA.TMP',O &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;260 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Old file New file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ Old file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Insert point &lt;br /&gt;Insert data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ Insert data ... Old file &lt;br /&gt;FIGURE 7-5 Inserting new data within an old file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DODD 44 41 54 4 FILE2 DB 'DATA.OLD',O &lt;br /&gt;2E 4F 4C 44 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0016 44 41 54 41 FILE3 DB 'DATA.NEW' ,0 &lt;br /&gt;2E 4E 45 57 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001F 0100 [ BUF DB 256 DUP (?) ;data buffer area &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;0000 .CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0017 B4 3C MOV AH,3CH ;create DATA.TMP &lt;br /&gt;0019 B9 0000 MOV CX,O &lt;br /&gt;001C BA 0004 R MOV DX,OFFSET FILEl &lt;br /&gt;001F CD 21 INT 21H &lt;br /&gt;0021 A3 0000 R MOV HAN1,AX ; save handle at HANl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 B8 3D02 MOV AX,3D02H ; open DATA. OLD &lt;br /&gt;0027 BA DODD R MOV DX,OFFSET FILE2 &lt;br /&gt;002A CD 21 INT 21H &lt;br /&gt;002C 8B D8 MOV BX,AX &lt;br /&gt;002E A3 0002 R MOV HAN2,AX ; save handle at HAN2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0031 B4 3F MOV AH,3FH ;read 256 bytes of DATA. OLD into BUF &lt;br /&gt;0033 B9 0100 MOV CX,256 &lt;br /&gt;0036 BA 001F R MOV DX,OFFSET BUF &lt;br /&gt;0039 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003B B4 40 MOV AH,40H ;write BUF to DATA.TMP &lt;br /&gt;003D 8B 1E 0000 R MOV BX,BANl ;get handle &lt;br /&gt;0041 B9 0100 MOV CX,256 &lt;br /&gt;0044 BA 001F R MOV DX,OFFSET BUF &lt;br /&gt;0047 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0049 B8 3D02 MOV AX,3D02H ;open DATA.NEW &lt;br /&gt;004C BA 0016 R MOV DX,OFFSET FILE3 &lt;br /&gt;004F CD 21 INT 21H &lt;br /&gt;0051 8B D8 MOV BX,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0053 B4 3F MOV AH,3FH ;read 256 bytes from DATA.NEW to BUF &lt;br /&gt;0055 B9 0100 MOV CX,256 &lt;br /&gt;0058 BA OOIF R MOV DX,OFFSET BUF &lt;br /&gt;005B CD 21 HIT 21H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;0050 B4 &lt;br /&gt;005F CD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0061 B4 &lt;br /&gt;0063 8B &lt;br /&gt;,11)67 B9 &lt;br /&gt;J06A BA &lt;br /&gt;,1060 CD &lt;br /&gt;U06F &lt;br /&gt;006F B4 &lt;br /&gt;0071 8B &lt;br /&gt;0075 B9 &lt;br /&gt;0078 BA &lt;br /&gt;007B CD &lt;br /&gt;0070 OB &lt;br /&gt;007F 74 &lt;br /&gt;0081 B4 &lt;br /&gt;0')83 8B &lt;br /&gt;(j087 B9 &lt;br /&gt;G08A BA &lt;br /&gt;0080 CD &lt;br /&gt;008F EB &lt;br /&gt;0091 &lt;br /&gt;0091 B4 &lt;br /&gt;0093 CD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0095 B4 &lt;br /&gt;0097 BA &lt;br /&gt;009A CD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;009C B4 &lt;br /&gt;009E 8B &lt;br /&gt;00A2 CD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOM 8C &lt;br /&gt;00A6 8E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00A8 B4 &lt;br /&gt;OOAA BA &lt;br /&gt;OOAD BF &lt;br /&gt;OOBO CD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-4 DISK FILES 261 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3E MOV AH,3EH ;close DATA.NEW &lt;br /&gt;21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40 MOV AH,40H ;write BUF to DATA.TMP &lt;br /&gt;1E 0000 R MOV BX,HAN1 ;get handle &lt;br /&gt;0100 MOV CX,256 &lt;br /&gt;001F R MOV DX,OFFSET BUF &lt;br /&gt;21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN1: &lt;br /&gt;3F MOV AH,3FH ;read 256 byt~s from DATA.OLD to BUF &lt;br /&gt;1E 0002 R MOV BX,HAN2 &lt;br /&gt;0100 MOV CX,256 &lt;br /&gt;001F R MOV DX,OFFSET BUF &lt;br /&gt;21 INT 21H &lt;br /&gt;CO OR AX, AX ;test for zero byte read &lt;br /&gt;10 JZ MAIN2 ; if file empty &lt;br /&gt;40 MOV AH,40H ;write BUF to DATA.TMP &lt;br /&gt;1E 0000 R MOV BX,HAN1 &lt;br /&gt;0100 MOV CX,256 &lt;br /&gt;001F R MOV DX,OFFSET BUF &lt;br /&gt;21 INT 21H &lt;br /&gt;DE JMP MAIN1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN2: &lt;br /&gt;3E MOV AH,3EH ;close DATA.OLD &lt;br /&gt;21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41 MOV AH,41H ;delete DATA.OLD &lt;br /&gt;0000 R MOV DX,OFFSET FILE2 &lt;br /&gt;21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3E MOV AH,3EH ;close DATA.TMP &lt;br /&gt;1E 0000 R MOV BX,HAN1 &lt;br /&gt;21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;08 MOV AX,DS &lt;br /&gt;CO MOV ES,AX ;overlap OS and ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;56 MOV AH,56H ;rename DATA.TMP to DATA. OLD &lt;br /&gt;0004 R MOV DX,OFFSET FILE1 ;old name &lt;br /&gt;0000 R MOV DI,OFFSET FILE2 inew name &lt;br /&gt;21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This program uses two new INT 21H function calls. The delete and rename function calls &lt;br /&gt;are used to delete the old file before the temporary file is renamed to the old file name. Note that &lt;br /&gt;the rename function uses both the DS and ES segment registers to address the two file names. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Random Access Files &lt;br /&gt;Random access files are developed through software using sequential access files. A random ac-&lt;br /&gt;cess file is addressed by a record number rather than by going through the file searching for data. &lt;br /&gt;The move pointer function call becomes very important when random access files are created. &lt;br /&gt;Random access files are much easier to use for large volumes of data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Creating a Random Access File. Planning ahead is paramount to creating a random access file &lt;br /&gt;system. Suppose that a random access file is required for storing the names of customers. Each &lt;br /&gt;customer record requires 16 bytes for the last name, 16 bytes for the first name, and 1 byte for the &lt;br /&gt;middle initial. Each customer record contains two street address lines of 32 bytes each, a city line &lt;br /&gt;of 16 bytes, 2 bytes for the state code, and 9 bytes for the ZIP Code. The basic customer infor-&lt;br /&gt;mation requires 105 bytes. Additional information expands the record to 256 bytes in length. Be-&lt;br /&gt;cause the business is growing, provisions are made for 5,000 customers. This means that the total &lt;br /&gt;random access file is 1,280,000 bytes long. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;262 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-42 illustrates a short program that creates a file called CUST.FIL and inserts &lt;br /&gt;5,000 blank records of 256 bytes each. A blank record contains OOH in each byte. This appears to &lt;br /&gt;be a large file, but it fits on a single high-density 51/4&amp;quot; or 3112&amp;quot; floppy disk drive; in fact, this pro-&lt;br /&gt;gram assumes that the disk is in drive A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-42 &lt;br /&gt;;A program that creates CUST.FIL and then fills 5,000 &lt;br /&gt;;records of 256 bytes each with zeros . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;0000 . DATA &lt;br /&gt;0000 43 55 53 54 FILE1 DB 'CUST.FIL',O ;file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E 46 49 4C &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 0100 [ BUF DB 256 DUP (0) ;buffer &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;0000 .CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0017 B4 3C MOV AH,3CH ;create CUST.FIL &lt;br /&gt;0019 B9 0000 MOV CX,O &lt;br /&gt;001C BA 0000 R MOV DX,OFFSET FILE1 &lt;br /&gt;001F CD 21 INT 21H &lt;br /&gt;0021 8B D8 MOV BX,AX ; handle to BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0023 BD 1388 MOV BP,5000 ; record counter &lt;br /&gt;0026 MAIN1: &lt;br /&gt;0026 B4 40 MOV AH,40H ;write record &lt;br /&gt;0028 B9 0100 MOV CX,256 &lt;br /&gt;002B BA 0009 R MOV DX,OFFSET BUF &lt;br /&gt;002E CD 21 INT 21H &lt;br /&gt;0030 4D DEC BP ;decreme~t record count &lt;br /&gt;0031 75 F3 JNZ MAIN1 ;for 5000 records &lt;br /&gt;0033 B4 3E MOV AH,3EH ; close file &lt;br /&gt;0035 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reading and Writing a Record. Whenever a record must be read, the record number is loaded &lt;br /&gt;into the BP register and the procedure listed in Example 7-43 is called. This procedure assumes &lt;br /&gt;that FIL contains the handle number and that the CUST.FIL remains open at all times. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice how the record number is multiplied by 256 to obtain a count for the move pointer &lt;br /&gt;function. In each case, the file pointer is moved from the start of the file to the desired record be-&lt;br /&gt;fore it is read into memory area BUFFER. Although not shown, writing a record is performed in &lt;br /&gt;the same manner as reading. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-43 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 8B IE 0100 R &lt;br /&gt;0004 B8 0100 &lt;br /&gt;0007 F7 E5 &lt;br /&gt;0009 8B CA &lt;br /&gt;OOOB 8B DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The READ procedure reads one record from CUST.FIL. &lt;br /&gt;;Input parameters are: &lt;br /&gt;;FIL (word) = CUST.FIL handle &lt;br /&gt;;BP = record number &lt;br /&gt;;Output parameters are: &lt;br /&gt;; BUFFER (256 bytes) = customer record &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BX,FIL ;get handle &lt;br /&gt;MOV AX,256 ;multiply by 256 &lt;br /&gt;MUL BP &lt;br /&gt;MOV CX,DX &lt;br /&gt;MOV DX,AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-5 EXAMPLE PROGRAMS 263 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DODD BB 4200 MOV AX,4200H ;move pointer &lt;br /&gt;0010 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0012 B4 3F MOV AH,3FH ;read record &lt;br /&gt;0014 B9 0100 MOV CX,256 &lt;br /&gt;0017 BA 0000 R MOV DX,OFFSET BUFFER &lt;br /&gt;OOlA CD 21 INT 21H &lt;br /&gt;ODIC CB RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlD READ ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE PROGRAMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Now that many of the basic programming building blocks have been discussed, we present some &lt;br /&gt;example application programs. Although these example programs may seem trivial, they present &lt;br /&gt;some additional programming techniques and illustrate programming styles for the micro-&lt;br /&gt;processor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Calculator Program &lt;br /&gt;This program demonstrates how data conversion plays an important part in many application &lt;br /&gt;programs. Example 7-44 illustrates a program that accepts two numbers and adds, subtracts, &lt;br /&gt;multiplies, or divides them. To limit the complexity of the program, the numbers are limited to &lt;br /&gt;two-digit numbers. For example, if you type a 12 + 24 followed by =, the program will cakulate &lt;br /&gt;the result and display a 36 as an answer. To further simplify the program, the numbers 0-9 must &lt;br /&gt;be entered as two-digit numbers 0-9. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-44 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClOD EB 001E &lt;br /&gt;0103 BA DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010D EB 0011 &lt;br /&gt;0110 02 D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OllA EB 003F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;ca1culator program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;DISP MACRO PARA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;MOV AH,6 &lt;br /&gt;MOV DL,PARA &lt;br /&gt;INT 2lH &lt;br /&gt;POP AX &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GET MACRO &lt;br /&gt;. repeat &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,6 &lt;br /&gt;MOV DL,-l &lt;br /&gt;INT 21H &lt;br /&gt;.UNTIL AL&amp;gt;='O' &amp;amp;&amp;amp; AL &amp;lt;= '9' &lt;br /&gt;DISP &lt;br /&gt;SUB &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL &lt;br /&gt;MOV &lt;br /&gt;DISP &lt;br /&gt;CALL &lt;br /&gt;ADD &lt;br /&gt;DISP &lt;br /&gt;CALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL &lt;br /&gt;AL, '0' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READN &lt;br /&gt;BL,AL &lt;br /&gt;'+ ' &lt;br /&gt;READN &lt;br /&gt;BL,AL &lt;br /&gt;, =' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get first number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display + &lt;br /&gt;;get second number &lt;br /&gt;;forrn sum &lt;br /&gt;;display &lt;br /&gt;;display sum &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;264 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0121 READN PROC NEAR USES BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GET ;get first digit &lt;br /&gt;013A B3 OA MOV BL,10 &lt;br /&gt;013C F6 E3 MUL BL ;multiply by 10 &lt;br /&gt;013E 8A D8 MOV BL,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GET ;get second digit &lt;br /&gt;0158 02 C3 ADD AL,BL ; form number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015C READN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015C DISPA PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISC 8A C3 MOV AL,BL ;get answer &lt;br /&gt;015E BB OOOA MOV BX,10 &lt;br /&gt;0161 53 PUSH BX &lt;br /&gt;0162 B4 00 MOV AH,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;0164 BA 0000 MOV DX,O &lt;br /&gt;0167 F7 F3 DIV BX &lt;br /&gt;0169 52 PUSH DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL AX == 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE 1 &lt;br /&gt;016E 58 POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.BREAK .IF AL 10 &lt;br /&gt;0173 04 30 ADD AL,' 0' ;make ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP AL &lt;br /&gt;.ENDW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;017F C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0180 DISPA ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note that this program uses many of the techniques presented thus far in this chapter, in-&lt;br /&gt;cluding conditional assembly directives such as .REPEAT, .IF, .BREAK, and .WHILE. Also in-&lt;br /&gt;cluded are procedures and macros. This program does not support a backspace to correct an &lt;br /&gt;erroneous entry. To reduce the length of the program, no attempt has been made to recover from &lt;br /&gt;any errors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Numeric Sort Program &lt;br /&gt;At times, numbers must be sorted into numeric order. This is often accomplished with a bubble &lt;br /&gt;sort. Figure 7-6 shows five numbers that are sorted with a bubble sort. Notice that the set of five &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 7-6 A bubble sort &lt;br /&gt;showing data as they are &lt;br /&gt;sorted. Note: Sorting five &lt;br /&gt;numbers may require four &lt;br /&gt;passes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6~6 6 6 6 &lt;br /&gt;9--'9~1 1 1 &lt;br /&gt;1 1--'9~3 3 &lt;br /&gt;3 3 3--'9~2 &lt;br /&gt;2 2 2 2--'9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6~1 1 1 &lt;br /&gt;1--' 6~ 3 3 &lt;br /&gt;3 3~6~2 &lt;br /&gt;2 2 2--'6 &lt;br /&gt;999 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I~I 1 &lt;br /&gt;3--'3~2 &lt;br /&gt;2 2--' 3 &lt;br /&gt;666 &lt;br /&gt;999 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pass 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pass 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pass 3 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-5 EXAMPLE PROGRAMS 265 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;numbers is tested four times with four passes. For each pass, two consecutive numbers are com-&lt;br /&gt;pared and sometimes exchanged. Also notice that during the first pass, there are four compar-&lt;br /&gt;isons, during the second three, etc. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-45 illustrates a program that accepts 10 numbers from the keyboard &lt;br /&gt;(0-65535). After these 16-bit numbers are acceptec' and stored in memory section ARRAY, they &lt;br /&gt;are sorted using the bubble sorting technique. This bubble sort uses a flag to determine if any &lt;br /&gt;numbers were exchanged in a pass. If no numbers were exchanged, the numbers are in order and &lt;br /&gt;the sort terminates. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-45 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001E &lt;br /&gt;001F &lt;br /&gt;0022 &lt;br /&gt;0025 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA [ &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OD OA 45 &lt;br /&gt;72 20 31 &lt;br /&gt;75 6D 62 &lt;br /&gt;3A OD OA &lt;br /&gt;OD OA OA &lt;br /&gt;74 65 64 &lt;br /&gt;74 61 3A &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FC &lt;br /&gt;B9 OOOA &lt;br /&gt;BF 0000 R &lt;br /&gt;BC DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;6E &lt;br /&gt;30 &lt;br /&gt;65 &lt;br /&gt;OA &lt;br /&gt;53 &lt;br /&gt;20 &lt;br /&gt;OD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74 65 &lt;br /&gt;20 6E &lt;br /&gt;72 73 &lt;br /&gt;24 &lt;br /&gt;6F 72 &lt;br /&gt;44 61 &lt;br /&gt;OA OA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;ARRAY DW 10 DUP (?) ;array &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MES1 DB 13,10, 'Enter 10 numbers:',13,10,10, '$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MES2 DB 13,10,10, 'Sorted Data:' ,13,10,10, '$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP MACRO PARA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;MOV AH,6 &lt;br /&gt;MOV DL,PARA &lt;br /&gt;INT 21H &lt;br /&gt;POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDM &lt;br /&gt;GET MACRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;MOV AH,6 &lt;br /&gt;M~ DL,-l &lt;br /&gt;INT \\ 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL (AL&amp;gt;='O' &amp;amp;&amp;amp; AL &amp;lt;='9') I I AL==13 I I AL==',' &lt;br /&gt;DISP AL &lt;br /&gt;.IF AL==13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP 10 &lt;br /&gt;.ENDIF &lt;br /&gt;.IF AL&amp;gt;='O' &amp;amp;&amp;amp; AL&amp;lt;='9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AL, '0' &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING MACRO WHERE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFSET WHERE &lt;br /&gt;MOV AH,9 &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDM &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING MES1 &lt;br /&gt;CLD &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CX,10 &lt;br /&gt;DI,OFFSET ARRAY &lt;br /&gt;AX,DS &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;266 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0027 8E CO MOV ES,A)( &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0029 E8 0026 CALL GETN ;get 10 numbers &lt;br /&gt;.UNTILCXZ &lt;br /&gt;STRING MES2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0035 E8 008B CALL SORT ;sort 10 numbers &lt;br /&gt;0038 B9 0009 MOV CX,9 &lt;br /&gt;003B BE 0000 R MOV 5I,OFFSET ARRAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT ;disp1ay 10 numbers &lt;br /&gt;003E E8 0061 CALL DI5PN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DI5P &lt;br /&gt;.UNTILCXZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004B E8 0054 CALL DISPN &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0052 GETN PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0052 BD OOOA MOV BP,10 &lt;br /&gt;0055 BB 0000 MOV BX,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE 1 &lt;br /&gt;GET &lt;br /&gt;. BREAK .IF AL==13 II AL===', , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0094 93 XCHG .A)(,BX &lt;br /&gt;0095 F7 E5 MUL BP &lt;br /&gt;0097 93 XCHG A)(,BX &lt;br /&gt;0098 B4 00 MOV AH,O &lt;br /&gt;009A 03 D8 ADD BX,A)( &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;009E 8B C3 MOV AX,BX &lt;br /&gt;OOAO AB STOSW &lt;br /&gt;00A1 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00A2 GETN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00A2 OISPN PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00A2 BB OOOA MOV BX,10 &lt;br /&gt;OOA5 53 PUSH BX &lt;br /&gt;OOM AD LODSW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;00A7 BA 0000 MOV OX,O &lt;br /&gt;OOAA F7 F3 DIV BX &lt;br /&gt;OOAC 52 PUSH OX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. UNTIL A)(== 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE 1 &lt;br /&gt;00B1 58 POP A)( &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. BREAK .IF AL==10 &lt;br /&gt;00B6 04 30 ADD AL, '0' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DI5P AL &lt;br /&gt;.ENDW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C2 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C3 DISPN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C3 SORT PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C3 BB 0009 MOV BX,9 &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C6 8B CB MOV CX,BX &lt;br /&gt;00C8 BE 0000 R MOV SI,OFFSET ARRAY &lt;br /&gt;OOCB B2 00 MOV OL,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;OOCO AD LOOSW &lt;br /&gt;OOCE 3B 04 CMP A)(, lSI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. IF !CARRY? &lt;br /&gt;0002 8B 2C MOV BP, lSI] &lt;br /&gt;0004 89 6C FE MOV [SI-2],BP &lt;br /&gt;0007 89 04 MOV lSI] ,A)( &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;00D9 FE C2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OODD 4B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOE6 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00E7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-46 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0102 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0202 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;021A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0221 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OD OA &lt;br /&gt;6D 75 &lt;br /&gt;6E 74 &lt;br /&gt;20 66 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6E 61 &lt;br /&gt;24 &lt;br /&gt;OD OA &lt;br /&gt;20 6E &lt;br /&gt;6F 75 &lt;br /&gt;24 &lt;br /&gt;OD OA &lt;br /&gt;20 63 &lt;br /&gt;70 74 &lt;br /&gt;OD OA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;59 &lt;br /&gt;73 &lt;br /&gt;65 &lt;br /&gt;69 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;46 &lt;br /&gt;6F &lt;br /&gt;6E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;46 &lt;br /&gt;6F &lt;br /&gt;OD &lt;br /&gt;32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-5 EXAMPLE PROGRAMS 267 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC DL &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;DEC BX &lt;br /&gt;.UNTIL BX==O II DL==O &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SORT ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once the numbers are sorted, they are displayed on the video screen in ascending numeric &lt;br /&gt;order. No provision is made for errors as each number is typed. The program terminates after &lt;br /&gt;sorting one set of 10 numbers and must be invoked again to sort 10 new numbers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hexadecimal File Dump &lt;br /&gt;An example program that displays a file in hexadecimal format allows us to practice disk &lt;br /&gt;memory access. It also gives us the opportunity to read a parameter (the file name) from the DOS &lt;br /&gt;command line. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever a command (program name) is typed at the DOS command line, any parameters &lt;br /&gt;that follow are placed in a program segment prefix. The program segment prefix (PSP) is listed &lt;br /&gt;in Appendix A, Figure A-6. Notice that the length of the command line and the command line &lt;br /&gt;parameters appear in the PSP along with other information. Upon execution of a program, the &lt;br /&gt;DS segment register addresses the PSP, so an offset address of 80H is used to access the length &lt;br /&gt;(byte-sized) of the command line. After obtaining the length, the command line and its parame-&lt;br /&gt;ters can be accessed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 7-46 lists a program that obtains a file name from the command line and then dis-&lt;br /&gt;plays the file in a hexadecimal listing. This program is useful for debugging faulty programs and &lt;br /&gt;also as practice with disk file access and conversions. The parameter following the command al-&lt;br /&gt;ways starts with a space (20H) at offset address 81H and always ends with a carriage return &lt;br /&gt;(ODH). The length of the parameter is always one greater. For example, if DUMPS FROG is &lt;br /&gt;typed at the command line a~d DUMPS is the name of the program, the parameter FROG &lt;br /&gt;is stored beginning with a 20H iat offset 81H, and the length is 5. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;SECT DW ? &lt;br /&gt;BUFFER DB 256 DUP ( ?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FILE DB 256 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6F 75 20 MES1 DB 13,10, 'You must enter a file , &lt;br /&gt;74 20 65 &lt;br /&gt;72 20 61 &lt;br /&gt;6C 65 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 'name', 13, 10,' $ &lt;br /&gt;65 OD OA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;69 6C 65 MES2 DB 13,10, 'File not found',13,10, '$' &lt;br /&gt;74 20 66 &lt;br /&gt;64 OD OA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;69 6C 65 MES3 DB 13,10, 'File corrupt' ,13,10, '$' &lt;br /&gt;72 72 75 &lt;br /&gt;OA 24 &lt;br /&gt;35 36 20 MES4 DB 13,10, '256 byte Section: $ , &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;268 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62 79 74 65 20 53 &lt;br /&gt;65 63 74 69 6F 6E &lt;br /&gt;3A 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;025A OD OA 24 MESS DB 13,10, '$' &lt;br /&gt;025D OD OA 54 79 70 65 MES6 DB 13 ,10, 'Type a space to continue:$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 61 20 73 70 61 &lt;br /&gt;63 65 20 74 6F 20 &lt;br /&gt;63 6F 6E 74 69 6E &lt;br /&gt;75 65 3A 20 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE &lt;br /&gt;STRING MACRO WHERE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,9 &lt;br /&gt;MOV DX,OFFSET WHERE &lt;br /&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OPEN MACRO WHERE &lt;br /&gt;MOV AX,3D02H &lt;br /&gt;MOV CX,O &lt;br /&gt;MOV DX,OFFSET WHERE &lt;br /&gt;INT 21H &lt;br /&gt;MOV BX,AX ;save handle in BX &lt;br /&gt;MOV SECT, -1 ;indicate first sector &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ MACRO BUF,COUNT &lt;br /&gt;MOV AH,3FH &lt;br /&gt;MOV CX,COUNT &lt;br /&gt;MOV DX,OFFSET BUF &lt;br /&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLOSE MACRO &lt;br /&gt;MOV AH,3EH &lt;br /&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP MACRO NUM &lt;br /&gt;MOV AH,6 &lt;br /&gt;MOV DL,NUM &lt;br /&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCII MACRO &lt;br /&gt;AND AL,15 &lt;br /&gt;ADD AL, , 0' &lt;br /&gt;.IF AL&amp;gt;'9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;DISP AL &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0017 1E PUSH DS ;swap segments &lt;br /&gt;0018 06 PUSH ES &lt;br /&gt;0019 1F POP DS &lt;br /&gt;001A 07 POP ES &lt;br /&gt;001B BE 0082 MOV SI,82H ;address command line &lt;br /&gt;DOlE 8A 4C FE MOV CL, [SI-2) ;get length &lt;br /&gt;0021 B5 00 MOV CH,O &lt;br /&gt;0023 80 F9 00 CMP CL,O &lt;br /&gt;0026 75 10 JNE 11AIN1 ; if file name present &lt;br /&gt;0028 B8 --_ .. R HOV AX,DGROUP &lt;br /&gt;002B 8E D8 MOV DS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING MES1 ;display MES1 &lt;br /&gt;.EXIT ;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 MAIN1: &lt;br /&gt;0038 49 DEC ex &lt;br /&gt;0039 BF 0102 R MOV DI,OFFSET FILE &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-5 EXAMPLE PROGRAMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003C F3/ A4 &lt;br /&gt;003E 88 2D &lt;br /&gt;0040 8C CO &lt;br /&gt;0042 8E D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0057 73 OB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0064 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0064 FF 06 0000 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0072 73 OB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;008B E8 OOOD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0095 B4 01 &lt;br /&gt;0097 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;009B &lt;br /&gt;009B 8B C8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00A4 8B 2E 0000 R &lt;br /&gt;00A8 E8 0028 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B2 BE 0002 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B5 8B C6 &lt;br /&gt;00B7 2D 0002 R &lt;br /&gt;OOBA 8B E8 &lt;br /&gt;OOBC 83 EO OF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCA E8 0006 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCD E8 002B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00D2 C3 &lt;br /&gt;00D3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00D3 &lt;br /&gt;00D4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00D7 &lt;br /&gt;00D9 &lt;br /&gt;OODB &lt;br /&gt;OODD &lt;br /&gt;OODF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOFB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B9 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D1 C5 &lt;br /&gt;D1 C5 &lt;br /&gt;D1 C5 &lt;br /&gt;D1 C5 &lt;br /&gt;8B C5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;MAIN2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN3: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DUMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DUMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOFB DISPN &lt;br /&gt;OOFB AC &lt;br /&gt;OOFC DO C8 &lt;br /&gt;OOFE DO C8 &lt;br /&gt;0100 DO C8 &lt;br /&gt;0102 DO C8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REP MOVSB &lt;br /&gt;MOV [DIj,CH &lt;br /&gt;MOV AX,ES &lt;br /&gt;MOV DS,AX &lt;br /&gt;OPEN FILE &lt;br /&gt;JNC MAIN2 &lt;br /&gt;STRING MES2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE 1 &lt;br /&gt;INC SECT &lt;br /&gt;READ BUFFER,256 &lt;br /&gt;JNC MAIN3 &lt;br /&gt;STRING MES3 &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF AX==O &lt;br /&gt;CL09E &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save file name &lt;br /&gt;;make it ASCII-Z &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;segment DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; if file found &lt;br /&gt;;display MES2 &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;increment sector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; if file read &lt;br /&gt;;display MES3 &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; end of file &lt;br /&gt;;close file &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL DUMP &lt;br /&gt;STRING MES6 &lt;br /&gt;~display sector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEAR &lt;br /&gt;CX,AX &lt;br /&gt;MES4 &lt;br /&gt;BP,SECT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;wait for key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save count &lt;br /&gt;;display sector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC &lt;br /&gt;MOV &lt;br /&gt;STRING &lt;br /&gt;MOV &lt;br /&gt;CALL &lt;br /&gt;STRING &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPA ;display 16-bit hex &lt;br /&gt;MES5 ;display CR &amp;amp; LF &lt;br /&gt;SI,OFFSET BUFFER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;MOV AX,SI &lt;br /&gt;SUB AX,OFFSET BUFFER &lt;br /&gt;MOV BP,AX &lt;br /&gt;AND AX,l5 &lt;br /&gt;.IF AX==O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRING MES5 &lt;br /&gt;CALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;CALL DISPN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;RET &lt;br /&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;MOV CX,4 &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL &lt;br /&gt;ROL &lt;br /&gt;ROL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BP,l &lt;br /&gt;BP,l &lt;br /&gt;BP,l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL BP,l &lt;br /&gt;MOV AX,BP &lt;br /&gt;ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;DISP &lt;br /&gt;RET &lt;br /&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;LODSB &lt;br /&gt;ROR AL,l &lt;br /&gt;ROR AL,l &lt;br /&gt;ROR AL,l &lt;br /&gt;ROR AL,l &lt;br /&gt;ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;USES CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;269 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;270 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0114 8A 44 FF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012D C3 &lt;br /&gt;012E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 7 PROGRAMMING THE M!CROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;ASCII &lt;br /&gt;DISP &lt;br /&gt;RET &lt;br /&gt;ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL, [SI-1] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTERRUPT HOOKS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hooks are used to tap into or intercept the interrupt structure of the microprocessor. For example, &lt;br /&gt;we might hook into the keyboard interrupt so that we can detect a special keystroke called a hot-&lt;br /&gt;key. Whenever the hot-key is typed, we can access a terminate and stay resident (TSR) program &lt;br /&gt;that performs a special task. Some examples of hot-key software include pop-up calculators and &lt;br /&gt;pop-up clocks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Intercepting an Interrupt &lt;br /&gt;In order to intercept an interrupt, we must use a DOS function call that reads the current address &lt;br /&gt;from the interrupt vector. The DOS function call number 35H is used to read the current interrupt &lt;br /&gt;vector, and DOS function call number 25H is used to change the address of the current vector. In &lt;br /&gt;both DOS function calls, AL indicates the vector type number (OOH-FFH) and AH indicates the &lt;br /&gt;DOS function call number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When the vector is read using function 35H, the offset address is returned in register BX &lt;br /&gt;and the segment address is in register ES. These two registers are saved so that they can be re-&lt;br /&gt;stored when the interrupt hook is removed from memory. When the vector is set, it is set to the &lt;br /&gt;address stored at the memory location addressed by DS:DX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The process of installing an interrupt handler through a hook is illustrated in the program &lt;br /&gt;of Example 7-47. This program intercepts the divide error interrupt by first reading the current &lt;br /&gt;interrupt vector address and storing it into a double-word memory location for access by the new &lt;br /&gt;interrupt service procedure. Next, the address of the new interrupt service procedure, stored in &lt;br /&gt;DS:DX, is placed into the vector using DOS function call number 25H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 EB 05 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0102 00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 CF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0107 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0107 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0107 8C C8 &lt;br /&gt;0109 8E D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A sequence of instructions that show the installation &lt;br /&gt;;or a new interrupt for vector 0 (divide error) . &lt;br /&gt;;Note this is not a complete program . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;JMP MAIN ;skip &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD DR DD ? ;old interrupt vector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEW PROC FAR ;new interrupt procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRET ;do nothing interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;!lEW ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,CS ;address CS with DS &lt;br /&gt;MOV DS,AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-6 INTERRUPT HOOKS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010B B8 3500 &lt;br /&gt;010E CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0110 89 1E 0102 R &lt;br /&gt;0114 8C 06 0104 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0118 B8 2500 &lt;br /&gt;011B BA 0106 R &lt;br /&gt;011E CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get vector 0 address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,3500H &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save vector address at ADDR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV WORD PTR ADDRESS,BX &lt;br /&gt;MOV WORD PTR ADDRESS+2,ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;install new interrupt vector 0 address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,2500H &lt;br /&gt;MOV DX,OFFSET NEW &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;other installation software continues here &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example TSR Alarm &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;271 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A fairly simple example showing an interrupt hook and TSR causes a beep on the speaker after &lt;br /&gt;one hour or one-half hour. We all seem to get lost in computer processing, and this program &lt;br /&gt;makes it easy to keep track of time because of the audible beep. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The beep is caused by using timer 2 of the timer found inside the PC in order to generate &lt;br /&gt;an audio tone at the speaker. (Refer to Section 10-5 in Chapter 10 for a discussion of the timer, &lt;br /&gt;and see Figure 7-7 for its connection in the computer.) Programming timer 2 with a particular &lt;br /&gt;beep frequency or tone is accomplished by programming timer 2 with 1,193,180 divided by the &lt;br /&gt;desired tone. For example, if we divide 1,193,180 by 800, the speaker generates an 800 Hz audio &lt;br /&gt;tone. Refer to the BEEP proJ;_edtire (see Example 7-48) for programming the timer and turning &lt;br /&gt;the speaker on and off after a short wait determined by the number of clock ticks. This procedure &lt;br /&gt;uses six clock ticks to produce a beep lasting about 113 of a second. Note that each clock tick oc-&lt;br /&gt;curs about 18.2 times per second (the actual time is closer to 18.206). This is accomplished by &lt;br /&gt;using the user wait timer locations in the first segment of the memory. The user wait timer is up-&lt;br /&gt;dated 18.2 times per second by the computer so that it can be used to time events. The program &lt;br /&gt;that uses the BEEP procedure causes an audio tone of 1000 Hz, 1200 Hz, and 1400 Hz (each &lt;br /&gt;with a 113-second duration) to repeat four times. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-48 &lt;br /&gt;;A program that beeps the speaker with some sample audio &lt;br /&gt;; tones that each have a duration of 1/3 second. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;0000 .CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0100 B8 0000 MOV AX,O &lt;br /&gt;0103 8E D8 MOV DS,AX ;address segment OOOOH &lt;br /&gt;0105 B9 0004 MOV CX,4 ;set count to 4 &lt;br /&gt;0108 E4 61 IN AL,61H ;enab1e timer and speaker &lt;br /&gt;010A DC 03 OR AL,3 ;set PBO and PB1 &lt;br /&gt;010C E6 61 OUT 61H,AL &lt;br /&gt;010E MAIN1: &lt;br /&gt;010E BB 03E8 MOV BX,1000 ;select 1000 Hz tone &lt;br /&gt;0111 E8 0018 CALL BEEP &lt;br /&gt;0114 BB 04BO MOV BX,1200 ;select 1200 Hz tone &lt;br /&gt;0117 E8 0012 CALL BEEP &lt;br /&gt;011A BB 0578 MOV BX,1400 ;select 1400 Hz tone &lt;br /&gt;011D E8 OOOC CALL BEEP &lt;br /&gt;0120 E2 EC LOOP MAIN1 ; repeat 4 times &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0122 E4 61 IN AL,61H ;turn speaker off &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;272 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;Timer 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eLK Out Gate IRQ Vector 8 (18.2 Hz) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer 1 &lt;br /&gt;eLK Out Gate DRQO (DRAM refresh) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer 2 &lt;br /&gt;1,193,180 Hz eLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PBO Gate Out &lt;br /&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PB1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 7-7 The speaker and timer circuit in the personal computer (I/O ports 40-43H program &lt;br /&gt;the timer, and I/O port 61 H programs PBO and PB1) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0124 34 03 &lt;br /&gt;0126 E6 61 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012C &lt;br /&gt;012F &lt;br /&gt;0132 &lt;br /&gt;0134 &lt;br /&gt;0136 &lt;br /&gt;0138 &lt;br /&gt;013A &lt;br /&gt;DUD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DUE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DUE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DUE &lt;br /&gt;0141 &lt;br /&gt;0144 &lt;br /&gt;0148 &lt;br /&gt;014C &lt;br /&gt;014C &lt;br /&gt;0150 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B8 34DC &lt;br /&gt;BA 0012 &lt;br /&gt;F7 F3 &lt;br /&gt;E6 42 &lt;br /&gt;8A C4 &lt;br /&gt;E6 42 &lt;br /&gt;E8 0001 &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA 0006 &lt;br /&gt;BB 0000 &lt;br /&gt;03 16 046C &lt;br /&gt;13 1E 046E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8B 2E 046C &lt;br /&gt;A1 046E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR AL,3 &lt;br /&gt;OUT 61H,AL &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear PBO and PB1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The BEEP procedure programs timer 2 to beep the speaker &lt;br /&gt;;for 1/3 of a second with the frequency BX. &lt;br /&gt;i***input parameters*** &lt;br /&gt;;BX = desired audio tone &lt;br /&gt;;***uses*** &lt;br /&gt;;WAITS procedure to wait for 1/3 second &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEEP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEEP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,34DCH &lt;br /&gt;MOV DX,12H &lt;br /&gt;DIV BX &lt;br /&gt;OUT 42H,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;OUT 42H,AL &lt;br /&gt;CALL WAITS &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;beep speaker 1/3 second &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load AX with 1,193,180 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;find count &lt;br /&gt;;program timer 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;wait 1/3 second &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;the WAITS procedure waits 1/3 of a second &lt;br /&gt;i***uses*** &lt;br /&gt;;memory doubleword location 0000:46CH to time the wait &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAITS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAITl: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,6 &lt;br /&gt;MOV BX,O &lt;br /&gt;ADD DX,DS: [46CH] &lt;br /&gt;ADC BX,DS: [46EH] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BP,DS: [46CH] &lt;br /&gt;MOV AX,DS: [46EH] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;number of clock ticks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get tick count plus time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;test for elapsed time &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-6 INTERRUPT HOOKS 273 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0153 2B EA SUB BP,DX &lt;br /&gt;0155 1B C3 SBB AX,BX &lt;br /&gt;0157 72 F3 JC WAIT1 ;keep testing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0159 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015A WAITS ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CHIME program (see Example 7-49) hooks into interrupt vector 8 and beeps the &lt;br /&gt;speaker once each half-hour and twice on the hour. This program is a TSR and remains active &lt;br /&gt;until the computer is turned off. Note how the TSR is installed and how the interrupt vector is &lt;br /&gt;hooked. Also notice that the normal interrupt vector 8 procedure continues to execute even as the &lt;br /&gt;beeper is activated. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-49 &lt;br /&gt;;A terminate and stay resident program that hooks into &lt;br /&gt;;interrupt vector 8 to beep the speaker one time per &lt;br /&gt;;half-hour and two times per hour. &lt;br /&gt;;***must be assembled as a .COM file*** for use with &lt;br /&gt;;version 5.10 of MASM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0103 &lt;br /&gt;0104 &lt;br /&gt;0108 &lt;br /&gt;0109 &lt;br /&gt;010A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0111 &lt;br /&gt;0113 &lt;br /&gt;0118 &lt;br /&gt;0118 &lt;br /&gt;0119 &lt;br /&gt;011E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E9 OOCE &lt;br /&gt;03E8 &lt;br /&gt;00 &lt;br /&gt;00000000 &lt;br /&gt;00 &lt;br /&gt;00 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TONE &lt;br /&gt;COUNT &lt;br /&gt;ADD8 &lt;br /&gt;PASS &lt;br /&gt;BEEP &lt;br /&gt;FLAG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E: 80 3E 010A R &lt;br /&gt;00 &lt;br /&gt;74 05 &lt;br /&gt;2E: FF 2E 0104 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC81: &lt;br /&gt;9C &lt;br /&gt;2E: FF IE 0104 R &lt;br /&gt;2E: C6 06 010A R &lt;br /&gt;01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0124 FB &lt;br /&gt;0125 2E: 80 3E 0108 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00' &lt;br /&gt;75 2C &lt;br /&gt;50 &lt;br /&gt;51 &lt;br /&gt;52 &lt;br /&gt;B4 02 &lt;br /&gt;CD 1A &lt;br /&gt;80 FE 00 &lt;br /&gt;75 68 &lt;br /&gt;80 F9 00 &lt;br /&gt;74 10 &lt;br /&gt;80 F9 30 &lt;br /&gt;75 5E &lt;br /&gt;E8 0065 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012B &lt;br /&gt;012D &lt;br /&gt;012E &lt;br /&gt;012F &lt;br /&gt;0130 &lt;br /&gt;0132 &lt;br /&gt;0134 &lt;br /&gt;0137 &lt;br /&gt;0139 &lt;br /&gt;013C &lt;br /&gt;ODE &lt;br /&gt;0141 &lt;br /&gt;0143 &lt;br /&gt;0146 2E: C6 06 0108 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;014C EB 53 &lt;br /&gt;014E VEC82: &lt;br /&gt;014E E8 005A &lt;br /&gt;0151 2E: C6 06 0108 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;JMP &lt;br /&gt;EQU &lt;br /&gt;DB &lt;br /&gt;DD &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INSTALL &lt;br /&gt;1000 &lt;br /&gt;o &lt;br /&gt;? &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP CS:FLAG,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JE VEC81 &lt;br /&gt;JMP CS:ADD8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHF &lt;br /&gt;CALL CS:ADD8 &lt;br /&gt;MOV CS:FLAG,1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STI &lt;br /&gt;CMP CS:PASS,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JNE VEC83 &lt;br /&gt;PUSH AX &lt;br /&gt;PUSH CX &lt;br /&gt;PUSH DX &lt;br /&gt;MOV AH,2 &lt;br /&gt;INT 1AH &lt;br /&gt;CMP DH,O &lt;br /&gt;JNE VEC86 &lt;br /&gt;CMP CL,O &lt;br /&gt;JE VEC82 &lt;br /&gt;CMP CL,30H &lt;br /&gt;JNE VEC86 &lt;br /&gt;CALL BEEPS &lt;br /&gt;MOV CS:PASS,l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP VEC86 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL BEEPS &lt;br /&gt;MOV CS:PASS,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;install interrupt &lt;br /&gt;;set tone at 1000 Hz &lt;br /&gt;;elapsed time counter &lt;br /&gt;;old vector address &lt;br /&gt;;1 or 2 beeps &lt;br /&gt;; beep or silent &lt;br /&gt;;busy flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;interrupt procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; test busy flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; if not busy &lt;br /&gt;;if busy do normal INT 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;do normal INT 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;show busy &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;allow other interrupts &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if beep counter active &lt;br /&gt;;save registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get time from BIOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;is it 00 seconds &lt;br /&gt;;not time yet, so return &lt;br /&gt;;test for hour &lt;br /&gt;;if hour beep 2 times &lt;br /&gt;;test for half-hour &lt;br /&gt;;if not half-hour &lt;br /&gt;;start speaker beep &lt;br /&gt;;set number of beeps to 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start speaker beep &lt;br /&gt;;set number of beeps to 2 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;274 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0157 &lt;br /&gt;0159 &lt;br /&gt;0159 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015F &lt;br /&gt;0161 &lt;br /&gt;0166 &lt;br /&gt;0168 &lt;br /&gt;0168 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;016E &lt;br /&gt;0170 &lt;br /&gt;0175 &lt;br /&gt;0177 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;017D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0183 &lt;br /&gt;0184 &lt;br /&gt;0186 &lt;br /&gt;0188 &lt;br /&gt;018A &lt;br /&gt;018C &lt;br /&gt;018C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0192 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0198 &lt;br /&gt;0199 &lt;br /&gt;019B &lt;br /&gt;019D &lt;br /&gt;019F &lt;br /&gt;01A1 &lt;br /&gt;01A1 &lt;br /&gt;01A2 &lt;br /&gt;01A3 &lt;br /&gt;01A3 &lt;br /&gt;01M &lt;br /&gt;01M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02 &lt;br /&gt;EB 48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC83: &lt;br /&gt;2E: 80 3E 0103 R &lt;br /&gt;00 &lt;br /&gt;74 07 &lt;br /&gt;2E: FE OE 0103 R &lt;br /&gt;EB 3C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC84: &lt;br /&gt;2E: 80 3E 0109 R &lt;br /&gt;00 &lt;br /&gt;75 1C &lt;br /&gt;2E: FE OE 0108 R &lt;br /&gt;74 2D &lt;br /&gt;2E: C6 06 0103 R &lt;br /&gt;09 &lt;br /&gt;2E: C6 06 0109 R &lt;br /&gt;01 &lt;br /&gt;50 &lt;br /&gt;E4 61 &lt;br /&gt;OC 03 &lt;br /&gt;E6 61 &lt;br /&gt;EB 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC85: &lt;br /&gt;2E: C6 06 0103 R &lt;br /&gt;09 &lt;br /&gt;2E: C6 06 0109 R &lt;br /&gt;00 &lt;br /&gt;50 &lt;br /&gt;E4 61 &lt;br /&gt;34 03 &lt;br /&gt;E6 61 &lt;br /&gt;EB 02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SA &lt;br /&gt;59 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;58 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC86: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC87: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC88: &lt;br /&gt;2E: C6 06 010A &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01M CF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01AB VEC8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP VEC86 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP CS:COUNT,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JE VEC84 &lt;br /&gt;DEC CS:COUNT &lt;br /&gt;JMP VEC88 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP CS:BEEP,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JNE VEC85 &lt;br /&gt;DEC CS:PASS &lt;br /&gt;JZ VEC88 &lt;br /&gt;MOV CS:COUNT,9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CS:BEEP,l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;IN AL,61H &lt;br /&gt;OR AL,3 &lt;br /&gt;OUT 61H,AL &lt;br /&gt;JMP VEC87 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CS:COUNT, 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CS:BEEP,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;IN AL,61H &lt;br /&gt;XOR AL,3 &lt;br /&gt;OUT 61H,AL &lt;br /&gt;JMP VEC87 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP DX &lt;br /&gt;POP CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CS:FLAG,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;test for end of delay &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if time delay has elapsed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;test beep on &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if beep is on &lt;br /&gt;;test for 2 beeps &lt;br /&gt;;if second beep not needed &lt;br /&gt;;reset count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;beep on for second beep &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable speaker for beep &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reset count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;show beep is off &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;disable speaker &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;end it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;restore registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;show not busy &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;interrupt return &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The BEEPS procedure programs the speaker for the &lt;br /&gt;;frequency stored as TONE using an equate at assembly &lt;br /&gt;;time. The duration of the beep is 1/2 second. &lt;br /&gt;;***uses registers AX, CX, and DX*** &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01AB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01AB &lt;br /&gt;01BO &lt;br /&gt;01B3 &lt;br /&gt;01B6 &lt;br /&gt;01B8 &lt;br /&gt;01BA &lt;br /&gt;01BC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01BE &lt;br /&gt;OlCO &lt;br /&gt;01C2 &lt;br /&gt;01C4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEEPS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E: 8B OE 03E8 &lt;br /&gt;B8 34DC &lt;br /&gt;BA 0012 &lt;br /&gt;F7 Fl &lt;br /&gt;E6 42 &lt;br /&gt;8A C4 &lt;br /&gt;E6 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E4 61 &lt;br /&gt;OC 03 &lt;br /&gt;E6 61 &lt;br /&gt;2E: C6 06 0103 R &lt;br /&gt;09 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01CA 2E: C6 06 0109 R &lt;br /&gt;01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01DO C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX, CS : TONE &lt;br /&gt;MOV AX,34DCH &lt;br /&gt;MOV DX,12H &lt;br /&gt;DIV CX &lt;br /&gt;OUT 42H,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;OUT 42H,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,61H &lt;br /&gt;OR AL,3 &lt;br /&gt;OUT 61H,AL &lt;br /&gt;MOV CS:COUNT,9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CS:BEEP,l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;beep speaker &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set tone &lt;br /&gt;; load AX with 1,193,180 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;calculate count &lt;br /&gt;;program timer 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set count for 1/2 second &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;indicate beep is on &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-6 INTERRUPT HOOKS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01D1 BEEPS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01D1 INSTALL: &lt;br /&gt;OlD1 8C C8 MOV &lt;br /&gt;01D3 8E D8 MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01D5 B8 3508 MOV &lt;br /&gt;01D8 CD 21 INT &lt;br /&gt;01DA 89 1E 0104 R MOV &lt;br /&gt;01DE 8C 06 0106 R MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01E2 B8 2508 MOV &lt;br /&gt;01E5 BA 010B R MOV &lt;br /&gt;01E8 CD 21 INT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OlEA BA 01D1 R MOV &lt;br /&gt;01ED B1 04 MOV &lt;br /&gt;01EF D3 EA SHR &lt;br /&gt;01F1 42 INC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01F2 B8 3100 MOV &lt;br /&gt;01F5 CD 21 INT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX,CS &lt;br /&gt;DS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX,3508H &lt;br /&gt;21H &lt;br /&gt;WORD PTR ADD8,BX &lt;br /&gt;WORD PTR ADD8+2,ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX,2508H &lt;br /&gt;DX,OFFSET VEC8 &lt;br /&gt;21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFFSET INSTALL &lt;br /&gt;CL,4 &lt;br /&gt;DX,CL &lt;br /&gt;DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX,3100H &lt;br /&gt;21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;install interrupt VEC8 &lt;br /&gt;;overlap CS and DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get current vector 8 &lt;br /&gt;;and save it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address interrupt VEC8 &lt;br /&gt;;install vector 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;find paragraphs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS as TSR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;275 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CHIME program uses several memory locations as flags to signal the operation of the &lt;br /&gt;interrupt service procedure. The first flag tested by CHIME is the busy flag (FLAG), which in-&lt;br /&gt;dicates that a part of the interrupt service procedure is active. If FLAG = 1 (busy condition), the &lt;br /&gt;procedure jumps to the normal vector 8 interrupt (JMP CS:ADDS), which ends VECS's execu-&lt;br /&gt;tion. If FLAG = 0 (not busy), the interrupt service procedure continues at VECSI. The default &lt;br /&gt;address for all direct memory data is the data segment. In the TSR software used in this example &lt;br /&gt;and others, it is important to use the segment override prefix (CS:) to ensure that the program ad-&lt;br /&gt;dresses data in the code segment, where it appears. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;At VECSl, the normal vector S interrupt is executed with a forced interrupt call (PUSHF &lt;br /&gt;followed by a CALL CS:ADD8). Upon return from the normal vector S interrupt (required to &lt;br /&gt;keep accurate time), the busy flag is set to show a busy condition (FLAG = 1), and other inter-&lt;br /&gt;rupts are enabled with the STI instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The pass flag is now tested to see if the VECS procedure is currently beeping the speaker. &lt;br /&gt;If PASS = 0 (not beeping speaker), the time of day is retrieved from BIOS using the INT lAH &lt;br /&gt;instruction. It is important not to access DOS from within a TSR or interrupt service procedure. &lt;br /&gt;If DOS is accessed at this time, it may be in the process of executing an operation that affects the &lt;br /&gt;interrupt. This would cause the program to crash. The INT lAH instruction returns the number &lt;br /&gt;of seconds (DH), minutes (CL), and hours (CH) in BCD form. After obtaining the current time, &lt;br /&gt;the number of seconds is tested for zero. If it is not zero seconds, the interrupt procedure ends. If &lt;br /&gt;it is zero seconds, then CL is tested for 00 minute (hour) and 30 minutes. If either case is true, the &lt;br /&gt;speaker is enabled and TONE is programmed in the timer by a call to BEEPS. If neither case is &lt;br /&gt;true, the interrupt ends. Notice that the BEEPS procedure programs timer 2, enables the speaker, &lt;br /&gt;and sets the count to 9. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The time delay counter (COUNT) is decremented each time the interrupt occurs. If the &lt;br /&gt;count reaches zero, the procedure tests BEEP to control the speaker. If the speaker is beeping, &lt;br /&gt;the procedure turns it off and resets the time delay count to 9. If the speaker is not beeping, the &lt;br /&gt;procedure tests PASS to determine if another beep is required on the hour. The time delay is liz &lt;br /&gt;second (COUNT = 9) in this program and cannot be less. If a delay of less than liz second is &lt;br /&gt;chosen, the speaker will beep twice for both the hour and half hour. The reason is that the clock &lt;br /&gt;(INT lAH) is checked for the zero second. If a time delay of less than liz second is used, the &lt;br /&gt;half-hour will be picked up twice. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The TSR program is loaded into memory at the DOS command line by typing the name of &lt;br /&gt;the program; in this case, the program is called CHIME. If DOS version 5.0 or 6.x is in use, you &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;276 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;can load CHIME into the upper memory or high memory area by typing LOADHIGH CHIME. &lt;br /&gt;Once this program loads into memory, it remains in the background beeping off the time until &lt;br /&gt;the power to the computer is disconnected or until it is rebooted. This is an excellent, and not too &lt;br /&gt;annoying, addition to the system to keep track of time. If desired, a hot-key could be used to en-&lt;br /&gt;able and disable CHIME. The next section of the text describes hot-keys. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Hot-Key Program &lt;br /&gt;Hot-keys are keystrokes that invoke programs that are tenninate and stay resident. For example, &lt;br /&gt;an ALT + C key could be defined as a hot-key that calls a program that displays the time. Note &lt;br /&gt;that the hot-key is detected inside most applications, but not at the DOS command line, where it &lt;br /&gt;may lock up the system if used. To detect a hot-key, we usually hook into interrupt vector 9, &lt;br /&gt;which is the keyboard interrupt that occurs if any key is typed. This allows us to test the key-&lt;br /&gt;board and detect a hot-key before the nonnal interrupt processes the keystroke. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A hot-key is installed with a TSR program and interrupt hooks. To illustrate a hot-key pro-&lt;br /&gt;gram that can be useful, a program is developed that counts keystrokes. The keystroke counter &lt;br /&gt;program (see Example 7-50) is useful in a business environment that uses computers for data &lt;br /&gt;entry or other tasks. With this type of program, productivity can be assessed. The keystroke &lt;br /&gt;counter program counts each keystroke and displays the count only when the ALT + K key is &lt;br /&gt;pressed. (It is important to note that businesses sometimes use this program to monitor workers. &lt;br /&gt;It is the duty of any company using this program to notify workers of its use. It may even be the &lt;br /&gt;responsibility of the company to obtain permission from workers before a program such as this &lt;br /&gt;is placed into service.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This program can be modified to keep track of keystrokes by the hour or any other time &lt;br /&gt;unit. In this example, the keystroke count (up to 4 billion) accumulates keystrokes for as long &lt;br /&gt;as power is applied to the computer. The program also stores the installation time for security &lt;br /&gt;purposes. This is important because if a machine is reset, the start time for this TSR will be &lt;br /&gt;reset. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This program hooks into interrupt 8 and 9 to count keys. The interrupt 9 hook detects the &lt;br /&gt;hot-key (ALT + K) and counts keystrokes. When the hot-key is detected, the 18.2 Hz interrupt 8 &lt;br /&gt;activates the hot-key program that displays the keystroke count and time of installation. This &lt;br /&gt;type of TSR is often called a pop-up program, because it pops up when the hot-key is typed. No-&lt;br /&gt;tice that this program uses INT 16H to test the keyboard. Never use a DOS INT 21H function &lt;br /&gt;call within a TSR or interrupt hook because serious problems can arise. This program also uses &lt;br /&gt;direct manipulation of the video text memory that begins at location B8000H. This memory is &lt;br /&gt;organized with two bytes per ASCII character. The first byte contains the ASCII code, and the &lt;br /&gt;following byte contains the background and character color. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 7-50 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 E9 0241 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0103 00 &lt;br /&gt;0104 00000000 &lt;br /&gt;0108 00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A TSR program that counts keystrokes and reports the &lt;br /&gt;;time of installation and number of accumulated &lt;br /&gt;;keystrokes when the ALT-K key combination is activated. &lt;br /&gt;;***requires an 80386 or newer microprocessor*** &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;JMP INSTALL ;install VEC8 and VEC9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HFLAG DB 0 Hot-key detected &lt;br /&gt;ADD8 DD ? old vector 8 address &lt;br /&gt;ADD9 DD ? old vector 9 address &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7--6 INTERRUPT HOOKS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010C &lt;br /&gt;0110 &lt;br /&gt;0111 &lt;br /&gt;0112 &lt;br /&gt;0113 &lt;br /&gt;0114 &lt;br /&gt;0115 &lt;br /&gt;0116 &lt;br /&gt;0117 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01B7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01BE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01CE &lt;br /&gt;01CF &lt;br /&gt;OlD1 &lt;br /&gt;01D3 &lt;br /&gt;01D8 &lt;br /&gt;01DA &lt;br /&gt;01DD &lt;br /&gt;OlDE &lt;br /&gt;OlEO &lt;br /&gt;01E3 &lt;br /&gt;01E4 &lt;br /&gt;01E9 &lt;br /&gt;01EE &lt;br /&gt;01FO &lt;br /&gt;01FO &lt;br /&gt;01F1 &lt;br /&gt;01F4 &lt;br /&gt;01F9 &lt;br /&gt;01FD &lt;br /&gt;01FE &lt;br /&gt;01FE &lt;br /&gt;01FF &lt;br /&gt;0203 &lt;br /&gt;0204 &lt;br /&gt;0206 &lt;br /&gt;0207 &lt;br /&gt;0209 &lt;br /&gt;020D &lt;br /&gt;0212 &lt;br /&gt;0213 &lt;br /&gt;0215 &lt;br /&gt;021A &lt;br /&gt;021A &lt;br /&gt;021B &lt;br /&gt;021D &lt;br /&gt;021F &lt;br /&gt;0221 &lt;br /&gt;0223 &lt;br /&gt;0225 &lt;br /&gt;0227 &lt;br /&gt;0229 &lt;br /&gt;022A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0230 &lt;br /&gt;0232 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0233 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 COUNT &lt;br /&gt;00 HOUR &lt;br /&gt;00 MIN &lt;br /&gt;o 0 SFLAG &lt;br /&gt;00 FLAG8 &lt;br /&gt;25 KEY &lt;br /&gt;08 HMASK &lt;br /&gt;08 MKEY &lt;br /&gt;OOAO [ SCRN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;54 69 6D 65 MES1 &lt;br /&gt;20 3D 20 &lt;br /&gt;20 20 20 4B MES2 &lt;br /&gt;65 79 53 74 &lt;br /&gt;72 6F 6B 65 &lt;br /&gt;73 20 3D 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FB &lt;br /&gt;661 50 &lt;br /&gt;E4 60 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E: 3A 06 0114 R &lt;br /&gt;75 16 &lt;br /&gt;B8 0000 &lt;br /&gt;1E &lt;br /&gt;8E D8 &lt;br /&gt;AO 0417 &lt;br /&gt;1F &lt;br /&gt;2E: 22 06 0115 R &lt;br /&gt;2E: 3A 06 0116 R &lt;br /&gt;74 2A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC91: &lt;br /&gt;51 &lt;br /&gt;B9 0003 &lt;br /&gt;661 2E: A1 010C R &lt;br /&gt;661 83 CO 01 &lt;br /&gt;27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9C &lt;br /&gt;661 C1 C8 08 &lt;br /&gt;90 &lt;br /&gt;14 00 &lt;br /&gt;27 &lt;br /&gt;E2 F5 &lt;br /&gt;661 C1 C8 08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC92: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 2E: A3 010C R &lt;br /&gt;59 &lt;br /&gt;661 58 &lt;br /&gt;2E: FF 2E 0108 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC93: &lt;br /&gt;FA &lt;br /&gt;E4 61 &lt;br /&gt;DC 80 &lt;br /&gt;E6 61 &lt;br /&gt;24 7F &lt;br /&gt;E6 61 &lt;br /&gt;BO 20 &lt;br /&gt;E6 20 &lt;br /&gt;FB &lt;br /&gt;2E: C6 06 0103 R &lt;br /&gt;01 &lt;br /&gt;661 58 &lt;br /&gt;CF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;7 &lt;br /&gt;7 &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;2~;{ &lt;br /&gt;8 &lt;br /&gt;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DD &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB &lt;br /&gt;DB 160 DUP (7) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 'Time = &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB KeyStrokes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STI &lt;br /&gt;PUSH EAX &lt;br /&gt;IN AL,60H &lt;br /&gt;CMP AL,CS:KEY &lt;br /&gt;JNE VEC91 &lt;br /&gt;MOV AX,O &lt;br /&gt;PUSH DS &lt;br /&gt;MOV DS,AX &lt;br /&gt;MOV AL,DS: [417H] &lt;br /&gt;POP DS &lt;br /&gt;AND AL,CS:HMASK &lt;br /&gt;CMP AL,CS:MKEY &lt;br /&gt;JE VEC93 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH CX &lt;br /&gt;MOV CX,3 &lt;br /&gt;MOV EAX,CS:COUNT &lt;br /&gt;ADD EAX,l &lt;br /&gt;DAA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHF &lt;br /&gt;ROR EAX,8 &lt;br /&gt;POPF &lt;br /&gt;ADC AL,O &lt;br /&gt;DAA &lt;br /&gt;LOOP VEC92 &lt;br /&gt;ROR EAX,8 &lt;br /&gt;MOV CS:COUNT,EAX &lt;br /&gt;POP CX &lt;br /&gt;POP EAX &lt;br /&gt;JMP CS:ADD9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLI &lt;br /&gt;IN AL,61H &lt;br /&gt;OR AL,80H &lt;br /&gt;OUT 61H,AL &lt;br /&gt;AND AL,7FH &lt;br /&gt;OUT 61H,AL &lt;br /&gt;MOV AL,20H &lt;br /&gt;OUT 20H,AL &lt;br /&gt;STI &lt;br /&gt;MOV CS:HFLAG,l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP EAX &lt;br /&gt;IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Keystroke counter &lt;br /&gt;;start-up time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; start-up flag &lt;br /&gt;;interrupt 8 busy &lt;br /&gt;;scan code for K &lt;br /&gt;;a1ternate key mask &lt;br /&gt;;alternate key &lt;br /&gt;;screen buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;keyboard intercept &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable interrupts &lt;br /&gt;;save EAX &lt;br /&gt;;get scan code &lt;br /&gt;;test for K &lt;br /&gt;;no hot-key &lt;br /&gt;;address segment 0000 &lt;br /&gt;;save DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get shift/alternate data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;iso1ate alternate key &lt;br /&gt;;test for alternate key &lt;br /&gt;;if hot-key found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;add one to BCD COUNT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;make result BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;propagate carry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;do normal interrupt &lt;br /&gt;;if hot-key pressed &lt;br /&gt;;interrupts off &lt;br /&gt;;clear keyboard and &lt;br /&gt;;throw away hot key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reset keyboard interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable interrupts &lt;br /&gt;;indicate hot-key pressed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;277 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;278 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0233 VEC8 PROC FAR ;clock tick interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0233 2E: 80 3E 0113 R CMP CS:FLAG8,0 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0239 74 05 JZ VEC81 ;if not busy &lt;br /&gt;023B 2E: FF 2E 0104 R JMP CS:ADD8 ;if busy &lt;br /&gt;0240 VEC81: &lt;br /&gt;0240 2E: 80 3E 0103 R CMP CS:HFLAG,0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;0246 75 37 JNZ VEC83 ;it hot-key detected &lt;br /&gt;0248 2E: 80 3E 0112 R CMP CS:SFLAG,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;024E 74 05 JZ VEC82 ;ii start-up &lt;br /&gt;0250 2E: FF 2E 0104 R JMP CS:ADD8 ;ii not hot-key or start &lt;br /&gt;0255 VEC82: &lt;br /&gt;0255 9C PUSHF ;do old interrupt 8 &lt;br /&gt;0256 2E: FF 1E 0104 R CALL CS:ADD8 &lt;br /&gt;025B 2E: C6 06 0113 R MOV CS:FLAG8,1 ;indicate busy &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;0261 FB ST1 ;enable interrupts &lt;br /&gt;0262 50 PUSH AX &lt;br /&gt;0263 51 PUSH CX &lt;br /&gt;0264 52 PUSH DX &lt;br /&gt;0265 B4 02 MOV AH,2 ;get start-up time &lt;br /&gt;0267 CD 1A 1NT 1AH &lt;br /&gt;0269 2E: 88 2E 0110 R MOV CS:HOUR,CH ;save hour &lt;br /&gt;026E 2E: 88 OE 0111 R MOV CS:M1N,CL ;save minute &lt;br /&gt;0273 5A POP DX ;restore registers &lt;br /&gt;0274 59 POP CX &lt;br /&gt;0275 58 POP AX &lt;br /&gt;0276 2E: C6 06 0112 R MOV CS:SFLAG,l ; indicate started &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;027C E9 00A5 JMP VEC89 ;end it &lt;br /&gt;027F VEC83: ;do hot-key display &lt;br /&gt;027F 9C PUSHF ;do old interrupt 8 &lt;br /&gt;0280 2E: FF 1E 0104 R CALL CS:ADD8 &lt;br /&gt;0285 2E: C6 06 0113 R MOV CS:FLAG8,1 ;indicate busy &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;028B FB ST1 ;enable interrupts &lt;br /&gt;028C 50 PUSH AX ;save registers &lt;br /&gt;028D 53 PUSH BX &lt;br /&gt;028E B4 OF MOV AH,OFH ;get video mode &lt;br /&gt;0290 CD 10 1NT 10H &lt;br /&gt;0292 3C 03 CMP AL,3 &lt;br /&gt;0294 76 05 JBE VEC84 ; if DOS text mode &lt;br /&gt;0296 5B POP BX ; ignore if graphics mode &lt;br /&gt;0297 58 POP AX &lt;br /&gt;0298 E9 0083 JMP VEC88 &lt;br /&gt;029B VEC84: ;tor text mode &lt;br /&gt;029B 51 PUSH CX &lt;br /&gt;029C 661 52 PUSH EDX &lt;br /&gt;029E 57 PUSH D1 &lt;br /&gt;029F 56 PUSH S1 &lt;br /&gt;02AO 1E PUSH DS &lt;br /&gt;02A1 06 PUSH ES &lt;br /&gt;02A2 FC CLD &lt;br /&gt;02A3 8C C8 MOV AX,CS ; address this segment &lt;br /&gt;02A5 8E co MOV ES,AX &lt;br /&gt;02A7 B8 B800 MOV AX,OB800H ;address text memory &lt;br /&gt;02AA 8E D8 MOV DS,AX &lt;br /&gt;02AC B9 OOAO MOV CX,160 ;save top screen line &lt;br /&gt;02AF BF 0117 R MOV D1,OFFSET SCRN &lt;br /&gt;02B2 BE 0000 MOV S1,O &lt;br /&gt;02B5 F3/ A4 REP MOVSB &lt;br /&gt;02B7 1E PUSH DS ;swap segments &lt;br /&gt;02B8 06 PUSH ES &lt;br /&gt;02B9 1F POP DS &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-6 INTERRUPT HOOKS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02BA &lt;br /&gt;02BB &lt;br /&gt;02BE &lt;br /&gt;02C1 &lt;br /&gt;02C3 &lt;br /&gt;02C6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07 &lt;br /&gt;BF 0050 &lt;br /&gt;BE 01B7 R &lt;br /&gt;B4 OF &lt;br /&gt;B9 0007 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02C6 AC &lt;br /&gt;02C7 AB &lt;br /&gt;02C8 E2 FC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC85 : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E: 8A 16 0111 R &lt;br /&gt;2E: 8A 36 0110 R &lt;br /&gt;661 C1 E2 10 &lt;br /&gt;B9 0002 &lt;br /&gt;B3 30 &lt;br /&gt;E8 004B &lt;br /&gt;BO 3A &lt;br /&gt;AB &lt;br /&gt;B9 0002 &lt;br /&gt;B3 80 &lt;br /&gt;EB 0040 &lt;br /&gt;BE 01BE R &lt;br /&gt;B9 0010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AC &lt;br /&gt;AB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC86: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP ES &lt;br /&gt;MOV DI,80 &lt;br /&gt;MOV SI,OFFSET MES1 &lt;br /&gt;MOV AH,OFH &lt;br /&gt;MOV CX,7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LODSB &lt;br /&gt;STOSW &lt;br /&gt;LOOP VEC85 &lt;br /&gt;MOV DL,CS:MIN &lt;br /&gt;MOV DH,CS:HOUR &lt;br /&gt;SHL EDX,16 &lt;br /&gt;MOV CX,2 &lt;br /&gt;MOV BL,30H &lt;br /&gt;CALL DISP &lt;br /&gt;MOV AL,'Â·' &lt;br /&gt;STOSW &lt;br /&gt;MOV CX,2 &lt;br /&gt;MOV BL,80H &lt;br /&gt;CALL DISP &lt;br /&gt;MOV S1,OFFSET MES2 &lt;br /&gt;MOV CX,16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LODSB &lt;br /&gt;STOSW &lt;br /&gt;LOOP VEC86 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02CA &lt;br /&gt;02CF &lt;br /&gt;02D4 &lt;br /&gt;02D8 &lt;br /&gt;02DB &lt;br /&gt;02DD &lt;br /&gt;02EO &lt;br /&gt;02E2 &lt;br /&gt;02E3 &lt;br /&gt;02E6 &lt;br /&gt;02E8 &lt;br /&gt;02EB &lt;br /&gt;02EE &lt;br /&gt;02F1 &lt;br /&gt;02F1 &lt;br /&gt;02F2 &lt;br /&gt;02F3 &lt;br /&gt;02F5 &lt;br /&gt;02FB &lt;br /&gt;02FE &lt;br /&gt;0300 &lt;br /&gt;0303 &lt;br /&gt;0303 &lt;br /&gt;0305 &lt;br /&gt;0307 &lt;br /&gt;0309 &lt;br /&gt;030A &lt;br /&gt;030D &lt;br /&gt;0310 &lt;br /&gt;0313 &lt;br /&gt;0315 &lt;br /&gt;0316 &lt;br /&gt;0317 &lt;br /&gt;0318 &lt;br /&gt;0319 &lt;br /&gt;031B &lt;br /&gt;031C &lt;br /&gt;031D &lt;br /&gt;031E &lt;br /&gt;031E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E2 FC &lt;br /&gt;661 2E: &lt;br /&gt;B9 0008 &lt;br /&gt;B3 30 &lt;br /&gt;E8 0028 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8B 16 010C R MOV EDX,CS:COUNT &lt;br /&gt;MOV CX,8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0324 &lt;br /&gt;0324 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B4 01 &lt;br /&gt;CD 16 &lt;br /&gt;74 FA &lt;br /&gt;FC &lt;br /&gt;BE 0117 R &lt;br /&gt;BF 0000 &lt;br /&gt;B9 OOAO &lt;br /&gt;F3/ A4 &lt;br /&gt;07 &lt;br /&gt;IF &lt;br /&gt;5E &lt;br /&gt;5F &lt;br /&gt;661 5A &lt;br /&gt;59 &lt;br /&gt;5B &lt;br /&gt;58 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC87: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC88: &lt;br /&gt;2E: C6 06 0103 R &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VEC89: &lt;br /&gt;2E: C6 06 0113 R &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL,30H &lt;br /&gt;CALL D1SP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 16H &lt;br /&gt;JZ VEC87 &lt;br /&gt;CLD &lt;br /&gt;MOV S1,OFFSET SCRN &lt;br /&gt;MOV DI,O &lt;br /&gt;MOV CX,160 &lt;br /&gt;REP MOVSB &lt;br /&gt;POP ES &lt;br /&gt;POP DS &lt;br /&gt;POP SI &lt;br /&gt;POP DI &lt;br /&gt;POP EDX &lt;br /&gt;POP CX &lt;br /&gt;POP BX &lt;br /&gt;POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CS:HFLAG,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CS:FLAG8,0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;032A CF IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;032B VEC8 ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start display at center &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load white on black &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display &amp;quot;Time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; display hours &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display colon &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display minutes &lt;br /&gt;;display KeyStrokes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;idisplay count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;wait for any key (BIOS) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;restore text &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;indicate not busy &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The DISP procedure displays the BCD contents of EDX. &lt;br /&gt;;&amp;quot;'input parameters'&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;032B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;032B 661 C1 C2 04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;CX number of digits &lt;br /&gt;;BL 30H for blank leading zeros or BOH for no blanking &lt;br /&gt;;ES segment address of text mode display &lt;br /&gt;iD1 offset address of text mode display &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP PROC NEAR ;display &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL EDX,4 ;position number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;279 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;280 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;032F BA C2 MOV AL,DL &lt;br /&gt;0331 24 OF AND AL,OFH &lt;br /&gt;0333 04 30 ADD AL,30H convert to ASCII &lt;br /&gt;0335 AB STOSW store in text display &lt;br /&gt;0336 3A C3 CMP AL,BL test for blanking &lt;br /&gt;033B 74 04 JE DISP1 if blanking needed &lt;br /&gt;033A B3 BO MOV BL,BOH ;turn off blanking &lt;br /&gt;033C EB 03 JMP DISP2 ;continue &lt;br /&gt;033E DISP1: &lt;br /&gt;033E B3 EF 02 SUB DI,2 ;blank digit &lt;br /&gt;0341 DISP2: &lt;br /&gt;0341 E2 EB LOOP DISP &lt;br /&gt;0343 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0344 DISP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0344 INSTALL: ; install VEC8 and VEC9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0344 BC CB MOV AX,CS ;load DS &lt;br /&gt;0346 BE DB MOV DS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;034B BB 350B MOV AX,350BH ;get current vector B &lt;br /&gt;034B CD 21 INT 21H ;and save it &lt;br /&gt;034D B9 IE 0104 R MOV WORD PTR ADDB,BX &lt;br /&gt;0351 BC 06 0106 R MOV WORD PTR ADDB+2,ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0355 BB 3509 MOV AX,3509H ;get current vector 9 &lt;br /&gt;035B CD 21 INT 21H ; and save it &lt;br /&gt;035A B9 IE 010B R MOV WORD PTR ADD9,BX &lt;br /&gt;035E BC 06 010A R MOV WORD PTR ADD9+2,ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0362 BB 2508 MOV AX,2508H &lt;br /&gt;0365 BA 0233 R MOV DX,OFFSET VEC8 ; address interrupt procedure &lt;br /&gt;0368 CD 21 INT 21H ; install vector B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;036A B8 2509 MOV AX,2509H &lt;br /&gt;036D BA 01CE R MOV DX,OFFSET VEC9 ;address interrupt procedure &lt;br /&gt;0370 CD 21 INT 21H ;install vector 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0372 BA 0344 R MOV DX,OFFSET INSTALL ;find paragraphs &lt;br /&gt;0375 C1 EA 04 SHR DX,4 &lt;br /&gt;0378 42 INC DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0379 BB 3100 MOV AX,3100H ;set as a TSR &lt;br /&gt;037C CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note that the pop-up portion of this program only functions in the text mode and will count &lt;br /&gt;any unseen keystrokes that DOS generates. It also counts shift, alternate, and other keys as they &lt;br /&gt;are pressed and released. For example, the capital A will be counted as two or three keystrokes. &lt;br /&gt;This means that the keystroke count will be inflated. Even so, this program is useful for counting &lt;br /&gt;kt?ystrokes by a given operator. If the operator reboots the system, the new reboot time is dis-&lt;br /&gt;played and the count is cleared to zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The VEC9 interrupt service procedure intercepts all keystrokes. The IN AL,60H instruc-&lt;br /&gt;tion reads the scan code from the keyboard interface within the personal computer. This is then &lt;br /&gt;tested for the K scan code. (See Table 7-3 for the key scan codes). If the K sc~ code is not &lt;br /&gt;fouT. &amp;quot;, the procedure increments the BCD count stored at location COUNT and returns to the &lt;br /&gt;normal keyboard interrupt handler. If the K scan code is detected, the contents of memory loca-&lt;br /&gt;tion 0000:0417 are tested for the alternate key. If an alternate key is detected, the program sets &lt;br /&gt;the HFLAG to 1, tosses away the hot-key, and returns. Notice how the hot-key is discarded by &lt;br /&gt;strobing 110 port number 61H. The keyboard is cleared by sending a logic I in bit position 7 of &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-7 SUMMARY 281 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;port 61H, followed by sending a logic 0 in bit position 7. The intelTupt controller in the computer &lt;br /&gt;must also be cleared by sending a 20H out to liD port number 20H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The VEC8 interrupt service procedure tests the HFLAG for the hot-key and the SFLAG &lt;br /&gt;for system startup. If the SFLAG = 0, the system has just been installed and the time is stored &lt;br /&gt;in HOUR and MIN. If the HFLAG = 1, a hot-key was detected by VEC9. The VRC8 procedure &lt;br /&gt;responds to the hot-key by storing the contents of the top line of the text display at memory &lt;br /&gt;a.rray SCRN. Once the top is stored, the message &amp;quot;Time = &amp;quot; is displayed, followed by the in-&lt;br /&gt;stallation time. Next, the message &amp;quot;Keystrokes = &amp;quot; is displayed, followed by the BCD number &lt;br /&gt;stored in COUNT. Recall that count is incremented each time VEC9 detects that a key is typed &lt;br /&gt;on the keyboard. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;1. The assembler program assembles modules that contain PUBLIC variables and segments &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;plus EXTRN (external) variables. The linker program links modules and library files to &lt;br /&gt;create a run-time program executed from the DOS command line. The run-time program &lt;br /&gt;usually has the extension EXE. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The MACRO and ENDM directives create a new opcode for use in programs. These macros &lt;br /&gt;are similar to procedures except that there is no call or return. In place of them, the assem-&lt;br /&gt;bler inserts the code of the macro sequence into a program each time it is invoked. Macros &lt;br /&gt;can include variables that pass information and data to the macro sequence. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The DOS INT 21H function call provides a method of using the keyboard and video display. &lt;br /&gt;Function number 06H, placed into register AH, provides an interface to the keyboard and &lt;br /&gt;display. If DL = OFFH, this function tests the keyboard for a keystroke. If no keystroke is de-&lt;br /&gt;tected, it returns equal. If a keystroke is detected, the standard ASCII character returns in AL. &lt;br /&gt;If an extended ASCII character is typed, it returns with AL = OOH, where the function must &lt;br /&gt;again be called to return with the extended ASCII character in AL. To display a character, &lt;br /&gt;DL is loaded with the character and AH with 06H before the INT 21H is used in a program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. Character strings are displayed using function number 09H. The DS:DX register combina-&lt;br /&gt;tion addresses the character string, which must end with a $. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The INT lOH instruction accesses video BIOS (basic liD system) procedures that control the &lt;br /&gt;video display and keyboard. The video BIOS functions are independent of DOS and func-&lt;br /&gt;tion with any operating system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. The mouse driver is installed at interrupt vector 33H. &lt;br /&gt;7. Data conversion from binary to BCD is accomplished with the AAM instruction for num-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bers that are less than 100 or by repeated division by 10 for larger numbers. Once converted &lt;br /&gt;to BCD, a 30H is added to convert each digit to ASCII code for the video display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. When converting from an ASCII number to BCD, a 30H is subtracted from each digit. To &lt;br /&gt;obtain the binary equivalent, we multiply by 10. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. Lookup tables are used for code conversion with the XLAT instruction if the code is an 8-bit &lt;br /&gt;code. If the code is wider than 8-bits, then a short procedure that accesses a lookup table pro-&lt;br /&gt;vides the conversion. Lookup tables are also used to hold addresses so that different parts of &lt;br /&gt;a program or different procedures can be selected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Conditional assembly language statements allow portions of a program to be assembled if a &lt;br /&gt;condition is met. These are useful for tailoring software to an application &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. The disk memory system contains tracks that hold information stored in sectors. Many disk &lt;br /&gt;systems store 512 bytes of information per sector. Data on the disk are organized in a boot &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;282 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sector, file allocation table, root directory, and a data storage area. The boot sector loads the &lt;br /&gt;DOS system from the disk into the computer memory system. The FAT indicates which sec-&lt;br /&gt;tors are present and whether they contain data. The root directory contains file names and &lt;br /&gt;subdirectories, through which all disk files are accessed. The data storage area contains all &lt;br /&gt;subdirectories and data files. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. Files are manipulated with the DOS INT 21H function call. To read a disk file, the file must &lt;br /&gt;be opened, read, and then closed. To write to a disk file; the file must be opened, written, and &lt;br /&gt;then closed. When a file is opened, the file pointer addresses the first byte of the file. To ac-&lt;br /&gt;cess data at other locations, the file pointer is moved before data are read or written. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. A sequential access file is a file that is accessed sequentially from the beginning to the end. &lt;br /&gt;A random access file is a file that is accessed at any point. Although all disk files are se-&lt;br /&gt;quential, they can be treated as random access files by using software procedures. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The program segment prefix (PSP) contains information about a program. One important &lt;br /&gt;part of the PSP is the command line parameters. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. Interrupt hooks allow application software to gain access to or intercept an interrupt. We &lt;br /&gt;often hook into the timer click interrupt (vector 8) or the keyboard interrupt (vector 9). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. A terminate and stay resident (TSR) program is a program that remains in the memory and &lt;br /&gt;is often accessed through a hooked interrupt using either the timer click or a hot-key. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. A hot-key is a key that activates a terminate and stay resident program through the keyboard &lt;br /&gt;interrupt hook. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ql)ESTIONS AND PROBLEMS &lt;br /&gt;1. The assembler converts a source file to a(n) file. &lt;br /&gt;2. What files are generated from the source file TEST.ASM if it is processed by MASM? &lt;br /&gt;3. The linker program links object files and files to create an execution file. &lt;br /&gt;4. What does the PUBLIC directive indicate when placed in a program module? &lt;br /&gt;5. What does the EXTRN directive indicate when placed in a program module? &lt;br /&gt;6. What directives appear with labels defined external? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. 7. Describe how a library file works when it is linked to other object files by the linker pro-&lt;br /&gt;gram. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. What assembler language directives delineate a macro sequence? &lt;br /&gt;9. What is a macro sequence? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. How are parameters transferred to a macro sequence? &lt;br /&gt;11. Develop a macro called ADD32 that adds the 32-bit contents of DX-CX to the 32-bit con-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tents of BX-AX. &lt;br /&gt;12. How is the LOCAL directive used within a macro sequence? &lt;br /&gt;13. Develop a macro called ADDLIST PARAl,PARA2 that adds the contents of PARAI to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PARA2. Each of these parameters represents an area of memory. The number of bytes &lt;br /&gt;added is indicated by register CX before the macro is invoked. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Develop a macro that sums a list of byte-sized data invoked by the macro ADDM &lt;br /&gt;LIST,LENGTH. The label LIST is the starting address of the data block, and length is the &lt;br /&gt;number of data added. The result must be a 16-bit sum found in AX at the end of the macro &lt;br /&gt;sequence. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. What is the purpose of the INCLUDE directive? &lt;br /&gt;16. Develop a procedure called RANDOM. This procedure must return an 8-bit random number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;in register CL at the end of the subroutine. (One way to generate a random number is to in-&lt;br /&gt;crement CL each time the DOS function 06H tests the keyboard and finds no keystroke. In &lt;br /&gt;this way, a random number is generated.) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7-8 QUESTIONS AND PROBLEMS 283 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. Develop a macro that uses the REPEAT statement to insert 10 NOP instructions in a pro-&lt;br /&gt;gram. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. Develop a macro that uses the IFBIIFNB statements to test the parameter PARA in the &lt;br /&gt;macro DISP MACRO PARA. If PARA is blank, display a carriage retumlline feed combi-&lt;br /&gt;nation; if PARA is not blank, display PARA as an ASCII-coded character. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. Develop a procedure that displays a character string that ends with a OOH. Your procedure &lt;br /&gt;must use the DS:DX register to address the start of the character string. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. Develop a procedure that reads a key and dispiays the hexadecimal value of an extended &lt;br /&gt;ASCII-coded keyboard character if it is typed. If a normal character is typed, ignore it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21. Use BIOS INT lOH to develop a procedure that positions the cursor at line 3, column 6. &lt;br /&gt;22. What INT instruction is used to access the mouse? &lt;br /&gt;23. Describe how to test for the existence of the mouse in a computer system. &lt;br /&gt;24. How is it determined if the mouse is a serial or a bus mouse? &lt;br /&gt;25. How is it determined if the right mouse button is pressed? &lt;br /&gt;26. Why must the mouse be disabled when data are displayed in the video display? &lt;br /&gt;27. When a number is converted from binary to BCD, the instruction accom-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;plishes the conversion, provided the number is less than 100 decimal. &lt;br /&gt;28. How is a large number (over 100 decimal) converted from binary to BCD? &lt;br /&gt;29. A BCD digit is converted to ASCII code by adding a _____ _ &lt;br /&gt;30. An ASCII-coded number is converted to BCD by subtracting ______ , &lt;br /&gt;31. Develop a procedure that reads an ASCII number from the keyboard and stores it as a BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;number into memory array DATA. The number ends when anything other than a number is &lt;br /&gt;typed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32. Explain how a three-digit ASCII-coded number is converted to binary. &lt;br /&gt;33. Develop a procedure that converts all lowercase ASCII-coded letters into uppercase ASCII-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;coded letters. Your procedure may not change any other character except the letters a-z. &lt;br /&gt;34. Develop a lookup table that converts hexadecimal data OOH-OFH into the ASCII coded &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;characters that represent the hexadecimal digits. Make sure to show the lookup table and any &lt;br /&gt;software required for the conversion. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;35. Develop a program sequence that jumps to memory location ONE if AL = 6, TWO if AL = 7, &lt;br /&gt;and THREE if AL = 8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36. Show how to use the XLAT instruction to access a lookup table called LOOK that is located &lt;br /&gt;in the stack segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37. Develop a short sequence of instructions that place the line MOY AL,6 into a program if the &lt;br /&gt;contents memory location BED are true. You must use the IF statement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38. Explain the purpose of a boot sector, FAT, and root directory. &lt;br /&gt;39. The surface of a disk is divided into tracks that are further subdivided into _____ _ &lt;br /&gt;40. What is a bootstrap loader and where is it found? &lt;br /&gt;41. What is a cluster? &lt;br /&gt;42. A directory entry contains an attribute byte. What information does this byte indicate about &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the entry? &lt;br /&gt;43. A directory entry contains the length of the disk file or subdirectory stored in ____ _ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bytes of memory. &lt;br /&gt;44. What is the maximum length of a file? &lt;br /&gt;45. Develop a procedure that opens a file called TEST.LST, reads 512 bytes from the file into &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data segment memory area ARRAY, and closes the file. &lt;br /&gt;46. Develop a procedure that renames file TEST.LST to TEST.LlS. &lt;br /&gt;47. Write a program that reads any decimal number between 0 and 65,535 and displays the 16-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bit binary version on the video display. &lt;br /&gt;48. Write a program that displays the binary powers of 2 (in decimal) on the video screen for the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;powers 0 through 7. Your display shows 2&amp;quot; = value for each power of 2. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;284 CHAPTER 7 PROGRAMMING THE MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;49. Using the technique learned in question 16, develop a program that displays random num-&lt;br /&gt;bers between 1 and 47 (or whatever) for your state's lottery. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50. Develop a program that displays the hexadecimal contents of a block of 256 bytes of &lt;br /&gt;memory. Your software must be able to accept the starting address as a hexadecimal number &lt;br /&gt;between OOOOOH and FFFOOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;51. Develop a program that hooks into interrupt vector 0 to display the following message on a &lt;br /&gt;divide error: &amp;quot;Oops, you have attempted to divide by 0&amp;quot;. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 &lt;br /&gt;8086/8088 Hardware Specifications &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this chapter, we describe the pin functions of both the 8086 and 8088 microprocessors and &lt;br /&gt;provide details on the following hardware topics: clock generation, bus buffering, bus latching, &lt;br /&gt;timing, wait states, and minimum mode operation versus maximum mode operation. These &lt;br /&gt;simple microprocessors are explained first, because of their simple structure, as an introduction &lt;br /&gt;to the Intel family of microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before it is possible to connect or interface anything to the microproce~sor, it is necessary &lt;br /&gt;to understand the pin functions and timing. Thus, the information in this chapter is essential to &lt;br /&gt;a complete understanding of memory and I/O interfacing, which we cover in the later chapters &lt;br /&gt;of the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Describe the function of each 8086 and 8088 pin. &lt;br /&gt;2. Understand the microprocessor's DC characteristics and inqicate its fan-out to common &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;logic families. &lt;br /&gt;3. Use the clock generator chip (8284A) to provide the clock for the microprocessor. &lt;br /&gt;4. Connect buffers and latches to the buses. &lt;br /&gt;5. Interpret the timing diagrams. &lt;br /&gt;6. Describe wait states and connect the circuitry required to cause various numbers waits. &lt;br /&gt;7. Explain the difference between minimum and maximum mode operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN-OUTS AND THE PIN FUNCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this section we explain the function, and in some cases the multiple functions, of each of the &lt;br /&gt;microprocessor's pins. In addition, we discuss the DC characteristics to provide a basis for un-&lt;br /&gt;derstanding the later sections on buffering and latching. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;285 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;286 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pin-Out &lt;br /&gt;Figure 8-1 illustrates the pin-outs of the 8086 and 8088 microprocessors. As a close comparison &lt;br /&gt;reveals, there is virtually no difference between these two microprocessors-both are packaged &lt;br /&gt;in 40-pin dual in-line packages (DIPs). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As mentioned in Chapter 1, the 8086 is a 16-bit microprocessor with a 16-bit data bus, and &lt;br /&gt;the 8088 is a 16-bit microprocessor with an 8-bit data bus. (As the pin-outs show, the 8086 has &lt;br /&gt;pin connections ADo-AD'5' and the 8088 has pin connections ADo-AD7.) Data bus width is &lt;br /&gt;therefore the only major difference between these microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There is, however, a minor difference in one of the control signals. The 8086 has an M/IO &lt;br /&gt;pin, and the 8088 has an 101M pin. The only other hardware difference appears on Pin 34 of both &lt;br /&gt;chips: on the 8088, it is an SSO pin, while on the 8086, it is a BHE/S7 pin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Power Supply Requirements &lt;br /&gt;Both the 8086 and 8088 microprocessors require +5.0 V with a supply voltage tolerance of Â±1O &lt;br /&gt;percent. The 8086 draws a maximum supply current of 360 rnA, and the 8088 draws a maximum &lt;br /&gt;of 340 mAo Both microprocessors operate in ambient temperatures of between 32Â° F and about &lt;br /&gt;180Â° F. This range is not wide enough to be used outdoors in the winter or even in the summer, &lt;br /&gt;but extended temperature-range versions of the 8086 and 8088 microprocessors are available. &lt;br /&gt;There is also a CMOS version, which requires a very low supply current and also has an ex-&lt;br /&gt;tended temperature range. The 80C88 and 80C86 are CMOS versions that require only lOrnA of &lt;br /&gt;power supply current and function in temperature extremes of -40Â° F through +225Â° F. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DC Characteristics &lt;br /&gt;It is impossible to connect anything to the pins of the microprocessor without knowing the input &lt;br /&gt;current requirement for an input pin and the output current drive capability for an output pin. &lt;br /&gt;This knowledge allows the hardware designer to select the proper interface components for use &lt;br /&gt;with the microprocessor without the fear of damaging anything. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) The MAX MIN &lt;br /&gt;pin-out of the 8086 micro- MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;{ MIN} &lt;br /&gt;MODE MODE {M~&amp;amp;} &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;processor; (b) the pin-out of GND vee GND vcc &lt;br /&gt;the 8088 microprocessor. AD14 AD15 A14 AD15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD13 A16/S3 A13 A16/S3 &lt;br /&gt;AD12 A17iS4 A12 A17/S4 &lt;br /&gt;ADll A1B/S5 All A1B/S5 &lt;br /&gt;AD10 A19iS6 Al0 A19/S6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD9 BHE/S7 A9 sso (HIGH) &lt;br /&gt;ADS MN/MX AS MN/MX &lt;br /&gt;AD7 REi AD7 REi &lt;br /&gt;AD6 ROtGTO (HOLD) AD6 HOLD iRQ/GTO) &lt;br /&gt;AD5 ROiGTl (HlDA) AD5 HlDA (ROtGT1) &lt;br /&gt;AD4 lOCK (WA) AD4 WR (lOCK) &lt;br /&gt;AD3 52 (MJiO) AD3 Io/M (52) &lt;br /&gt;AD2 81 (DT/R) AD2 DT/A (81) &lt;br /&gt;ADl so (DEN) AOl DEN (SO) &lt;br /&gt;ADO OSO (ALE) Ar 1 ALE (OSO) &lt;br /&gt;NMI OSl (INTA) NMI INTA (OSl) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR TEST INTR TEST &lt;br /&gt;ClK READY ClK READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND RESET GND RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) (b) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-1 PIN-OUTS AND THE PIN FUNCTIONS 287 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 8-1 Input charac-&lt;br /&gt;teristics of the 8086 and 8088 &lt;br /&gt;microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Logic Level &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Voltage &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0.8 V maximum &lt;br /&gt;2.0 V minimum &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â±1 0 ~A maximum &lt;br /&gt;Â±1 0 ~A maximum &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Input Characteristics. The input characteristics of these microprocessors are compatible with all &lt;br /&gt;the standard logic components available today. Table 8-1 depicts the input voltage levels and the &lt;br /&gt;input current requirements for any input pin on either microprocessor. The input current leveis &lt;br /&gt;are very small because the inputs are the gates connections of MOSFETs and represent only &lt;br /&gt;leakage currents. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Output Characteristics. Table 8-2 illustrates the output characteristics of all the output pins of &lt;br /&gt;these microprocessors. The logic 1 voltage level of the 8086/8088 is compatible with that of &lt;br /&gt;most standard logic families, but the logic 0 level is not. Standard logic circuits have a maximum &lt;br /&gt;logic 0 voltage of 0.4 V, and the 8086/8088 microprocessor have a maximum of 0.45 V. Thus &lt;br /&gt;there is a difference of 0.05 V. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This difference reduces the noise immunity from a standard level of 400 m V (0.8 V - 0.45 V) &lt;br /&gt;to 350 m V. (The noise immunity is the difference between the logic 0 output voltage and the &lt;br /&gt;logic 0 input voltage levels.) This reduced noise immunity may result in problems with long wire &lt;br /&gt;connections or too many loads. It is therefore recommended that no more than 10 loads of any &lt;br /&gt;type or combination be connected to an output pin without buffers. If this loading is exceeded, &lt;br /&gt;noise will begin to take its toll in timing problems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 8-3 lists some of the more common logic families and the recommended fan-out &lt;br /&gt;from the 8086/8088. The best choice of component types for the connection to an 8086/8088 &lt;br /&gt;output pin is an LS, 74ALS, or 74HC logic component. Note that even though some of the cur-&lt;br /&gt;rent calculates to more than 10 loads, it is recommended that if a fan-out of more than 10 loads &lt;br /&gt;is required, the system should be buffered. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Connections &lt;br /&gt;The 8088 address/data bus lines compose the multiplexed address data &lt;br /&gt;bus of the 8088 and contain the rightmost 8-bits of the memory address &lt;br /&gt;or I/O port number whenever ALE is active (logic 1) or data whenever &lt;br /&gt;ALE is active (logic 0). These pins are at their high-impedance state &lt;br /&gt;during a hold acknowledge. &lt;br /&gt;The 8088 address bus provides the upper-half memory address bits that &lt;br /&gt;are present throughout a bus cycle. These address connections go to their &lt;br /&gt;high-impedance state during a hold acknowledge. &lt;br /&gt;The 8086 address/data bus lines compose the upper multiplexed &lt;br /&gt;address/data bus on the 8086. These lines contain address bits A1S-Ag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 8-2 Output charac-&lt;br /&gt;teristics of the 8086 and 8088 &lt;br /&gt;microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Logic Level &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Voltage &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0.45 V maximum &lt;br /&gt;2.4 V minimum &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2.0 mA maximum &lt;br /&gt;-400 ~A maximum &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;288 CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 8-3 Recommended &lt;br /&gt;fan-out from any 8086/8088 Family Sink Current Source Current Fan-out &lt;br /&gt;pin connection &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 8-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TTL (74) -1.6 mA 40J.lA 1 &lt;br /&gt;TTL (74LS) -0.4 mA 20J.lA 5 &lt;br /&gt;TTL (74S) -2.0mA 50 J.lA 1 &lt;br /&gt;TTL (74ALS) -0.1 mA 20J.lA 10 &lt;br /&gt;TTL (74AS) -o.5mA 25J.lA 10 &lt;br /&gt;TTL (74F) -0.5 mA 25 J.lA 10 &lt;br /&gt;CMOS (74HC) -10 J.lA 10 J.lA 10 &lt;br /&gt;CMOS (CD4) -10J.lA 10 J.lA 10 &lt;br /&gt;NMOS -10 J.l 10 J.lA 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;whenever ALE is a logic 1, and data bus connections DIs-Os' These pins &lt;br /&gt;enter a high-impedance state whenever a hold acknowledge occurs. &lt;br /&gt;The address/status bus bits are multiplexed to provide address signals &lt;br /&gt;A 19-A16 and also status bits S6-S3' These pins also attain a high-&lt;br /&gt;impedance state during the hold acknowledge. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Status bit S6 always remains a'logic 0, bit Ss indicates the &lt;br /&gt;condition of the IF flag bits, and S4 and S3 show which segment is &lt;br /&gt;accessed during the current bus cycle. Refer to Table 8-4 for the truth &lt;br /&gt;table of S4 and S3' These two st~rus bits could be used to address four &lt;br /&gt;separate 1M byte memory banh by decoding them as A21 and A2o' &lt;br /&gt;Whenever the read signal is a logic 0, the data b!Is is receptive to data &lt;br /&gt;from the memory or I/O devices connected to the system. This pin floats &lt;br /&gt;to its ~igh-impedance state during a hold acknowledge. &lt;br /&gt;This input is controlled to insert wait states into the timing of the &lt;br /&gt;microprocessor. If the READY pin is placed at a logic 0 level, the &lt;br /&gt;microprocessor enters into wait states and remains idle. If the READY &lt;br /&gt;pin is placed at a logic 1 level, it has no effect on the operation of the &lt;br /&gt;microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt request is used to request a hardware interrupt. If INTR is &lt;br /&gt;held high when IF = 1, the 8086/8088 enters an interrupt acknowledge &lt;br /&gt;cycle (INT A becomes active) after the current instruction has completed &lt;br /&gt;execution. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Test pin is an input that is tested by the WAIT instruction. If TEST &lt;br /&gt;is a logic 0, the WAIT instruction functions as a NOP. If TESTis a logic &lt;br /&gt;1, then the WAIT instruction waits for TEST to become a logic O. This &lt;br /&gt;pin is most often connected to the 8087 numeric coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function of &lt;br /&gt;status bits S3 and S4 S4 S3 Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 Extra segment &lt;br /&gt;0 1 Stack segment &lt;br /&gt;1 0 Code or no segment &lt;br /&gt;1 1 Data segment &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-1 PIN-OUTS AND THE PIN FUNCTIONS 289 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MN/MX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The non-maskable interrupt input is similar to INTR except that the &lt;br /&gt;NMI interrupt does not check to see if the IF tlag bit is a logic I. If NMI &lt;br /&gt;is activated, this interrupt input uses interrupt vector 2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The reset input causes the microprocessor to reset itself if this pin is held &lt;br /&gt;high for a minimum of four clocking periods. Whenever the 8086 or &lt;br /&gt;8088 is reset, it begins executing instructions at memory location &lt;br /&gt;FFFFOH and disables future interrupts by clearing the IF tlag bit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The clock pin provides the basic timing signal to the microprocessor. &lt;br /&gt;The clock signa! must have a duty cycle of 33% (high for one-third of &lt;br /&gt;the clocking period and low for two-thirds) to provide proper internal &lt;br /&gt;timing for the 8086/8088. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This power supply input provides a +5.0 Y, Â±10 % signal to the &lt;br /&gt;microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ground connection is the return for the power supply. Note that the &lt;br /&gt;8086/8088 microprocessors have two pins labeled GND-both must be &lt;br /&gt;connected to ground for proper operation. &lt;br /&gt;The minimum/maximum mode pin selects either minimum mode or &lt;br /&gt;maximum mode operation for the microprocessor. If minimum mode is &lt;br /&gt;selected, the MN/MX pin must be connected directly to +5.0 Y. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bus high enable pin is used in the 8086 to enable the most-&lt;br /&gt;significant data bus bits (DIS-Ds) during a read or a write operation. The &lt;br /&gt;state of S7 is always a logic 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Minimum Mode Pins. Minimum mode operation of the 8086/8088 is obtained by connecting &lt;br /&gt;the MN/MX pin directly to +5.0 Y. Do not connect this pin to +5.0 Y through a pull-up resister &lt;br /&gt;or it will not function correctly. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IO/Mor M/IO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 10/M (8088) or the MilO (8086) pin selects memory or I/O. This &lt;br /&gt;pin indicates that the microprocessor address bus contains either a memory &lt;br /&gt;address or an I/O port address. This pin is at its high-impedance state during &lt;br /&gt;a hold acknowledge. &lt;br /&gt;The write line is a strobe that indicates that the 8086/8088 is outputting &lt;br /&gt;data to a memory or I/O device. During the time that the WR is a logic 0, &lt;br /&gt;the data bus contains valid data for memory or I/O. This pin floats to a &lt;br /&gt;high-impedance during a hold acknowledge. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt acknowledge signal is a response to the INTR input pin. &lt;br /&gt;The INT A pin is normally used to gate the interrupt vector number onto &lt;br /&gt;the data bus in response to an interrupt request. &lt;br /&gt;Address latch enable shows that the 8086/8088address/data bus &lt;br /&gt;contains address information. This address can be a memory address or &lt;br /&gt;an I/O port number. Note that the ALE signal does not float during a &lt;br /&gt;hold acknowledge. &lt;br /&gt;The data transmit/receive signal shows that the microprocessor data &lt;br /&gt;bus is transmitting (DT/R = 1) or receiving (DT/R = 0) data. This signal &lt;br /&gt;is used to enable external data bus buffers. &lt;br /&gt;Data bus enable activates external data bus buffers. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;290 CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 8-5 Bus cycle &lt;br /&gt;10iM DTiFi SSO status (8088) using SSO Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOLD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HLDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 Interrupt acknowledge &lt;br /&gt;0 0 1 Memory read &lt;br /&gt;0 1 0 Memory write &lt;br /&gt;0 1 1 Halt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 Opcode fetch &lt;br /&gt;0 1 I/O read &lt;br /&gt;1 0 I/O write &lt;br /&gt;1 1 Passive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The hold input requests a direct memory access (DMA). If the HOLD &lt;br /&gt;signal is a logic 1, the microprocessor stops executing software and &lt;br /&gt;places its address, data, and control bus at the high-impedance state. &lt;br /&gt;If the HOLD pin is a logic 0, the microprocessor executes software &lt;br /&gt;normally. &lt;br /&gt;Hold acknowledge indicates that the 8086/8088 microprocessors have &lt;br /&gt;entered the hold state. &lt;br /&gt;The SSO status line is equivalent to the So pin in maximum mode opera-&lt;br /&gt;tion of the microprocessor. This signal is combined with laIR and DTIR &lt;br /&gt;to decode the function of the current bus cycle (refer to Table 8-5). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Maximum Mode Pins. In order to achieve maximum mode for use with extemal coprocessors, &lt;br /&gt;connect the MN/MX pin to ground. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S2, SI, and SO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RO!GTl and &lt;br /&gt;RO!GTO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The status bits indicate the function of the current bus cycle. These &lt;br /&gt;signals are normally decoded by the 8288 bus controller described later &lt;br /&gt;in this chapter. Table 8-6 shows the function of these three status bits in &lt;br /&gt;the maximum mode. &lt;br /&gt;The request/grant pins request direct memory accesses (DMA) during &lt;br /&gt;maximum mode operation. These lines are both bi-directional and are &lt;br /&gt;used to request and grant a DMA operation. &lt;br /&gt;The lock output is used to lock peripherals off the system. This pin is &lt;br /&gt;activated by using the LOCK: prefix on any instruction. &lt;br /&gt;The queue status bits show the status of the internal instruction queue. &lt;br /&gt;These pins are provided for access by the numeric coprocessor (8087). &lt;br /&gt;Refer to Table 8-7 for the operation of the queue status bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 8-6 Bus control &lt;br /&gt;functions generated by the S2 S1 SO Function &lt;br /&gt;bus controller (8288) using &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 Interrupt acknowledge S2, S1, and SO &lt;br /&gt;0 0 1 I/O read &lt;br /&gt;0 1 0 I/O write &lt;br /&gt;0 1 1 Halt &lt;br /&gt;1 0 0 Opcode fetch &lt;br /&gt;1 0 1 Memory read &lt;br /&gt;1 1 0 Memory write &lt;br /&gt;1 1 Passive &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-2 CLOCK GENERATOR (8284A) 291 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 8-7 Queue status &lt;br /&gt;bits OS, Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;1 &lt;br /&gt;o &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Queue is idle &lt;br /&gt;First byte of opcode &lt;br /&gt;Que'Je is empty &lt;br /&gt;Subsequent byte of opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLOCK GENERATOR (8284A) &lt;br /&gt;This section describes the clock generator (8284A), the RESET signal, and introduces the &lt;br /&gt;READY signal for the 8086/8088 microprocessors. The READY signal and its associated cir-&lt;br /&gt;cuitry are treated in detail in Section 8-5. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8284A Clock Generator &lt;br /&gt;The 8284A is an ancillary component to the 8086/8088 microprocessors. Without the clock gen-&lt;br /&gt;erator, many additional circuits are required to generate the clock (CLK) in an 8086/8088-based &lt;br /&gt;system. The 8284A provides the following basic functions or signals: clock generation, RESET &lt;br /&gt;synchronization, READY synchronization, and a TTL level peripheral clock signal. Figure 8-2 &lt;br /&gt;illustrates the pin-out of the 8284A clock generator. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Functions. The 8284A is an 18-pin integrated circuit designed specifically for use with the &lt;br /&gt;8086/8088 microprocessors. The following is a list of each pin and its function: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AENI and &lt;br /&gt;AEN2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDYI and &lt;br /&gt;RDY2 &lt;br /&gt;ASYNC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Xl and X2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address enable pins are provided to qualify the bus ready signals, RDYI &lt;br /&gt;and RDY2, respectively. Section 8-5 illustrates the use of these two pins, &lt;br /&gt;which are used to cause wait states, along with the ROY! and RDY2 inputs. &lt;br /&gt;Wait states are generated by the READY pin of the 8086/8088 &lt;br /&gt;microprocessors, which is controlled by these two inputs. &lt;br /&gt;The bus ready inputs are provided in conjunction with the AENl and AEN2 &lt;br /&gt;pins to cause wait states in an 8086/8088-based system. &lt;br /&gt;The ready synchronization selection input selects either one or two stages of &lt;br /&gt;synchronization for the ROY! and RDY2 inputs. &lt;br /&gt;Ready is an output pin that connects to the 8086/8088 READY input. This &lt;br /&gt;signal is synchronized with the RDYl and RDY2 inputs. &lt;br /&gt;The crystal oscillator pins connect to an external crystal used as the timing &lt;br /&gt;source for the clock generator and all its functions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The pinout of CSYNC Vee &lt;br /&gt;the 822844A clock generator PCLK Xl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AENl X2 &lt;br /&gt;RDYl ASVfm &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY EFI &lt;br /&gt;RDY2 F/~ &lt;br /&gt;A!R2 OSC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK RES &lt;br /&gt;GND RESET &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;292 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F/e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EFI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;CSYNC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The frequency/crystal select input chooses the clocking source for the 8284A. &lt;br /&gt;If this pin is held high, an external clock is provided to the EFI input pin; if it &lt;br /&gt;is held low, the internal crystal oscillator provides the timing signal. &lt;br /&gt;The external frequency input is used when the F/C pin is pulled high. EFI &lt;br /&gt;supplies the timing whenever the Fie pin is high. &lt;br /&gt;The clock output pin provides the CLK input signal to the 8086/8088 micro-&lt;br /&gt;processors and other components in the system. The CLK pin has an output &lt;br /&gt;signal that is one-third of the crystal or EFI input frequency and has a 33 per-&lt;br /&gt;cent duty cycle, which is required by the 8086/8088. &lt;br /&gt;The peripheral clock signal is one-sixth the crystal or EFI input frequency &lt;br /&gt;and has a 50 percent duty cycle. The PCLK output provides a clock signal to &lt;br /&gt;the peripheral equipment in the system. &lt;br /&gt;The oscillator output is a TTL level signal that is at the same frequency as the &lt;br /&gt;crystal or EFI input. The OSC output provides an EFI input to other 8284A &lt;br /&gt;clock generators in some multiple-processor systems. &lt;br /&gt;The reset input is an active-low input to the 8284A. The RES pin is often &lt;br /&gt;connected to an RC network that provides power-on resetting. &lt;br /&gt;The reset output is connected to the 8086/8088 RESET input pin. &lt;br /&gt;The clock synchronization pin is used whenever the EFI input provides &lt;br /&gt;synchronization in systems with mUltiple processors. If the internal crystal &lt;br /&gt;oscillator is used, this pin must be grounded. &lt;br /&gt;The ground pin connects to ground. &lt;br /&gt;This power supply pin connects to +5.0 V with a tolerance ofÂ±IO percent. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation of the 8284A &lt;br /&gt;The 8284A is a relatively easy component to understand. Figure 8-3 illustrates the internal logic &lt;br /&gt;diagram of the 8284A clock generator. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The internal &lt;br /&gt;liES block diagram of the 8284A ----------------------------~D~----~D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;clock generator &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Xl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;X2 OSC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fie &lt;br /&gt;PClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EFI &lt;br /&gt;CSYNC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDYl &lt;br /&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AENl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IIDY2 &lt;br /&gt;CKf &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AEN2 D Q READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASYNC &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-2 CLOCK GENERATOR (8284A) 293 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 MHz &lt;br /&gt;X, CLK CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 MHz[ZZJ &lt;br /&gt;X~ 8086 &lt;br /&gt;FiE or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8284A 8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CSYNC &lt;br /&gt;RESET RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;RES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-r + JIOILF &lt;br /&gt;System &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;reset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-4 The clock generator (8284A) and the 8086 and 8088 microprocessor illustrating &lt;br /&gt;the connection for the clock and reset signals. A 15 MHz crystal provides the 5 MHz clock for &lt;br /&gt;the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation of the Clock Section. The top half of the logic diagram represents the clock and reset &lt;br /&gt;synchronization section of the 8284A clock generator. As the diagram shows, the crystal oscil-&lt;br /&gt;lator has two inputs: Xl and X2. If a crystal is attached to Xl and X2, the oscillator generates a &lt;br /&gt;square-wave signal at the same frequency as the crystal. The square-wave signal is fed to an &lt;br /&gt;AND gate and also to an inverting buffer that provides the OSC output signal. The OSC signal is &lt;br /&gt;sometimes used as an EFI input to other 8284A circuits in a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An inspection of the AND gate reveals that when F/c is a logic 0, the oscillator output is &lt;br /&gt;steered through to the divide-by-3 counter. If F/C is a logic 1, then EFI is steered through to the &lt;br /&gt;counter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The output of the divide-by-3 counter generates the timing for ready synchronization, a &lt;br /&gt;signal for another counter (divide-by-2), and the CLK signal to the 8086/8088 microprocessors. &lt;br /&gt;The CLK signal is also buffered before it leaves the clock generator. Notice that the output ofthe &lt;br /&gt;first counter feeds the second. These two cascaded counters provide the divide-by-6 output at &lt;br /&gt;PCLK, the peripheral clock output. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 8-4 shows how an 8284A is connected to the 8086/8088. Notice (1) that F/C and &lt;br /&gt;CSYNC are grounded to select the crystal oscillator and (2) that a 15 MHz crystal provides the &lt;br /&gt;normal 5 MHz clock signal to the 8086/8088 as well as a 2.5 MHz peripheral clock signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation of the Reset Section. The reset section of the 8284A is very simple. It consists of a &lt;br /&gt;Schmitt trigger buffer and a single D-type flip-flop circuit. The D-type flip-flop ensures that the &lt;br /&gt;timing requirements of the 8086/8088 RESET input are met. This circuit applies the RESET &lt;br /&gt;signal to the microprocessor on the negative edge (1-to-O transition) of each clock. The &lt;br /&gt;8086/8088 microprocessors sample RESET at the positive edge (0-to-1 transition) of the clocks; &lt;br /&gt;therefore, this circuit meets the timing requirements of the 8086/8088. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Refer again to Figure 8-4. Notice that an RC circuit provides a logic 0 to the RES input pin &lt;br /&gt;when power is first applied to the system. After a short time, the RES input becomes a logic 1 be-&lt;br /&gt;cause the capacitor charges toward +5.0 V through the resistor. A push-button switch allows the &lt;br /&gt;microprocessor to be reset by the operator. Correct reset timing requires the RESET input to &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;294 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 80B6/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;become a logic I no later than four clocks after system power is applied and to be held high for &lt;br /&gt;at least 50 Ils. The flip-flop makes certain that RESET goes high in four clocks, and the RC time &lt;br /&gt;constant ensures that it stays high for at least 50 Ils. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUS BUFFERING AND LATCHING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before the 8086/8088 microprocessors can be used with memory or I/O interfaces, their multi-&lt;br /&gt;plexed buses must be demultiplexed. This section provides the detail required to demultiplex the &lt;br /&gt;buses and illustrates how the buses are buffered for very large systems. (Because the maximum &lt;br /&gt;fan-out is 10, the system must be buffered if it contains more than 10 other components.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Demultiplexing the Buses &lt;br /&gt;The address/data bus on the 8086/8088 is multiplexed (shared) to reduce the number of pins re-&lt;br /&gt;quired for the 8086/8088 integrated circuit. Unfortunately, this burdens the hardware designer &lt;br /&gt;with the task of extracting or demultiplexing information from these multiplexed pins. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Why not leave the buses multiplexed? Memory and I/O require that the address remains &lt;br /&gt;valid and stable throughout a read or write cycle. If the buses are multiplexed, the address &lt;br /&gt;changes at the memory and I/O, which causes them to read or write data in the wrong locations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All computer systems have three buses: (I) an address bus that provides the memory and &lt;br /&gt;I/O with the memory address or the I/O port number, (2) a data bus that transfers data between &lt;br /&gt;the microprocessor and the memory and I/O in the system, and (3) a control bus that provides &lt;br /&gt;control signals to the memory and I/O. These buses must be present in order to interface to &lt;br /&gt;memory and I/O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Demultiplexing the 8088. Figure 8-5 illustrates the 8088 microprocessor and the components &lt;br /&gt;required to demultiplex its buses. In this case, two 74LS373 transparent latches are used to de-&lt;br /&gt;multiplex the address/data bus connections AD7-ADo and the multiplexed address/status con-&lt;br /&gt;nections A,glS6-A'6/S3' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;These transparent latches, which are like wires whenever the address latch enable pin &lt;br /&gt;(ALE) becomes a logic I, pass the inputs to the outputs. After a short time, ALE returns to its &lt;br /&gt;logic 0 condition, which causes the latches to remember the inputs at the time of the change to a &lt;br /&gt;logic O. In this case, A7-AO are stored in the bottom latch and A'9-A'6 in the top latch. This &lt;br /&gt;yields a separate address bus with connections A'9-AO' These address connections allow the &lt;br /&gt;8088 to address 1M byte of memory space. The fact that the data bus is separate allows it to be &lt;br /&gt;connected to any 8-bit peripheral device or memory component. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Demultiplexing the 8086. Like the 8088, the 8086 system requires separate address, data, and &lt;br /&gt;control buses. It differs primarily in the number of multiplexed pins. In the 8088, only AD7-ADo &lt;br /&gt;and A,glS6-A,JS3 are multiplexed. In the 8086, the multiplexed pins include AD,s-ADo' &lt;br /&gt;AI9/S6-A,JS3' and BHE/S7. All of these signals must be demultiplex &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 8-6 illustrates a demultiplexed 8086 with all three buses: address (AI9-AO and &lt;br /&gt;BHE), data (DIs-Do)' and control (M/lO, RO, and WR). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TI.::. circuit shown in Figure 8-6 is almost identical to the one pictured in Figure 8-5, ex-&lt;br /&gt;cept that an additional 74LS373 latch has been added to demultiplex the address/data bus pins &lt;br /&gt;AO IS-A08 and a BHE/S7 input has been added to the top 74LS373 to select the high-order &lt;br /&gt;memory bank in the 16-bit memory system of the 8086. Here the memory and I/O system see the &lt;br /&gt;8086 as a device with a 20-bit address bus (A'9-AO)' a l6-bit data bus (D,s-Do), and a 3-line &lt;br /&gt;control bus (M/IO, RO, and WR). &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-3 BUS BUFFERING AND LATCHING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;A19/S6 OE &lt;br /&gt;AIR/S5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'373 AI7/Sâ¢ &lt;br /&gt;AIM~.' G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI.' 8088 &lt;br /&gt;AI. &lt;br /&gt;AI.' &lt;br /&gt;AI&amp;quot; &lt;br /&gt;All &lt;br /&gt;AlII &lt;br /&gt;A4 &lt;br /&gt;Ax &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD7 &lt;br /&gt;AD&amp;quot; &lt;br /&gt;AD., &lt;br /&gt;AD. &lt;br /&gt;AD, &lt;br /&gt;AD1 &lt;br /&gt;ADI &lt;br /&gt;ADo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M &lt;br /&gt;RD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MN/MX WR &lt;br /&gt;T &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI9 &lt;br /&gt;AIH &lt;br /&gt;A\\7 &lt;br /&gt;A lo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI.' &lt;br /&gt;AI. &lt;br /&gt;AIJ &lt;br /&gt;AI~ &lt;br /&gt;All &lt;br /&gt;A lo &lt;br /&gt;A&amp;quot; &lt;br /&gt;Ax &lt;br /&gt;A7 &lt;br /&gt;Ao &lt;br /&gt;As &lt;br /&gt;A. &lt;br /&gt;A, &lt;br /&gt;A1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ir AI lAo &lt;br /&gt;G '373 OE ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;295 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D7 &lt;br /&gt;Do &lt;br /&gt;D.' &lt;br /&gt;D. &lt;br /&gt;D, Data bu~ &lt;br /&gt;D1 &lt;br /&gt;DI &lt;br /&gt;Do &lt;br /&gt;101M&amp;quot; } &lt;br /&gt;RD Control bus &lt;br /&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-5 The BOBB microprocessor shown with a demultiplexed address bus. This is the &lt;br /&gt;model used to build many BOBB-based systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Buffered System &lt;br /&gt;If more than 10 unit loads are attached to any bus pin, the entire 8086 or 8088 system must be &lt;br /&gt;buffered. The demultiplexed pins are already buffered by the 74LS373 latches, which have been &lt;br /&gt;designed to drive the high-capacitance buses encountered in microcomputer systems. The &lt;br /&gt;buffer's output currents have been increased so that more TTL unit loads may be driven: a logic &lt;br /&gt;o output provides up to 32 mA of sink current, and a logic I output provides up to 5.2 rnA of &lt;br /&gt;source current. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A fully buffered signal will introduce a timing delay to the system. This causes no diffi-&lt;br /&gt;culty unless memory or VO devices are used, which function at near the maximum speed of the &lt;br /&gt;bus. Section 8-4 treats this problem and the time delays involved in more detail. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;296 CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I* &lt;br /&gt;BHE/S7 r- OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A 19/S6 r-&lt;br /&gt;A IR/S5 r- '373 &lt;br /&gt;A 17/s4 r-&lt;br /&gt;AI6IS~ I- G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE r- G &lt;br /&gt;'373 OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD ls i I 1 ADI4 &lt;br /&gt;AD I.' &lt;br /&gt;ADI2 &lt;br /&gt;ADII &lt;br /&gt;AD 10 &lt;br /&gt;AD9 &lt;br /&gt;ADs &lt;br /&gt;AD7 &lt;br /&gt;AD6 &lt;br /&gt;ADs &lt;br /&gt;AD~ &lt;br /&gt;AD., &lt;br /&gt;AD2 &lt;br /&gt;ADI &lt;br /&gt;ADo &lt;br /&gt;MilO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD &lt;br /&gt;MN/MX WI{&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;r-- G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ '373 OE f&amp;gt;+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHE &lt;br /&gt;AI9 &lt;br /&gt;A is &lt;br /&gt;AI7 &lt;br /&gt;AI6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A ls &lt;br /&gt;AI4 &lt;br /&gt;AD &lt;br /&gt;AI2 &lt;br /&gt;All &lt;br /&gt;AIO Address bus &lt;br /&gt;A9 &lt;br /&gt;As &lt;br /&gt;A7 &lt;br /&gt;A6 &lt;br /&gt;As &lt;br /&gt;A4 &lt;br /&gt;A~ &lt;br /&gt;A2 &lt;br /&gt;AI &lt;br /&gt;Ao &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIS &lt;br /&gt;0 14 &lt;br /&gt;01] &lt;br /&gt;0 12 &lt;br /&gt;011 &lt;br /&gt;010 &lt;br /&gt;0 9 &lt;br /&gt;Os 0 7 Data bus &lt;br /&gt;0 6 &lt;br /&gt;Os &lt;br /&gt;0 4 &lt;br /&gt;0, 0; &lt;br /&gt;0 1 &lt;br /&gt;Do &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MilO} RD Control bus &lt;br /&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-6 The BOB6 microprocessor shown with a demultiplexed address bus. This is the &lt;br /&gt;model used to build many BOB6-based systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Fully Buffered 8088. Figure 8-7 depicts a fully buffered 8088 microprocessor. Notice that &lt;br /&gt;the remaining eight address pins, AI5-Ag, use a 74LS244 octal buffer; the eight data bus pins, &lt;br /&gt;D7-DO' use a 74LS245 octal bi-directional bus buffer; and the control bus signals, 101M, RD, &lt;br /&gt;and WR, use a 74LS244 buffer. A fully buffered 8088 system requires two 74LS244s, one &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-3 BUS BUFFERING AND LATCHING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IO/M~----------------------1 &lt;br /&gt;RD ~----------------------1 &lt;br /&gt;WR~----------------------1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;M~I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f-&lt;br /&gt;OE &lt;br /&gt;'244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;297 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M} Buffered &lt;br /&gt;RD control &lt;br /&gt;WR bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;uc '----------------&amp;lt;1 A &lt;br /&gt;, : 19 t---------------o- AI8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'373 A!7/S4 j l AI6/S3 ~G &lt;br /&gt;8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A ls &lt;br /&gt;AI4 &lt;br /&gt;AI3 &lt;br /&gt;A IZ &lt;br /&gt;All &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AIO &lt;br /&gt;A9 &lt;br /&gt;As OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE G '373 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD7 &lt;br /&gt;AD6 &lt;br /&gt;ADs &lt;br /&gt;AD, &lt;br /&gt;AD3 &lt;br /&gt;ADz &lt;br /&gt;ADI &lt;br /&gt;ADo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R DEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I &lt;br /&gt;FIGURE 8-7 A fully buffered 8088 microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE ~ &lt;br /&gt;A7 B7 &lt;br /&gt;A6 B6 &lt;br /&gt;As Bs &lt;br /&gt;A, '245 B, &lt;br /&gt;A3 B3 &lt;br /&gt;Az Bz &lt;br /&gt;AI BI &lt;br /&gt;Ao Bo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G DIR &lt;br /&gt;'I' I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI7 &lt;br /&gt;AI6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A IS &lt;br /&gt;AI4 &lt;br /&gt;AI3 &lt;br /&gt;A IZ Buffered &lt;br /&gt;All address &lt;br /&gt;AIO bus &lt;br /&gt;A9 &lt;br /&gt;As &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Buffered &lt;br /&gt;data &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS245, and two 74LS373s. The direction of the 74LS245 is controlled by the DTJR signal, &lt;br /&gt;and is enabled and disabled by the DEN signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Fully Buffered 8086. Figure 8-8 illustrates a fully buffered 8086 microprocessor. Its ad-&lt;br /&gt;dress pins are already buffered by the 74LS373 address latches; its data bus employs two &lt;br /&gt;74LS245 octal bi-directional bus buffers; and the control bus signals, 101M, MilO, RD, and WR &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;298 CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MilO &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD -&lt;br /&gt;'244 WR -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE ~ &lt;br /&gt;BHE/S7 r--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI9/S6 r--&lt;br /&gt;AIR/S5 r-- '373 &lt;br /&gt;AI7IS4 r--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086 AI6IS3 r-- G OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE G r-- G &lt;br /&gt;'373 OE ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD I5 &lt;br /&gt;AD Iâ¢ &lt;br /&gt;AD I.' &lt;br /&gt;ADI2 &lt;br /&gt;AD'I &lt;br /&gt;ADIO &lt;br /&gt;AD9 &lt;br /&gt;ADg &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD, &lt;br /&gt;AD6 &lt;br /&gt;ADs &lt;br /&gt;AD. &lt;br /&gt;AD3 &lt;br /&gt;AD2 &lt;br /&gt;ADI &lt;br /&gt;ADo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEN &lt;br /&gt;DT/R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I l &lt;br /&gt;'373 OE ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'245 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G DIR &lt;br /&gt;Y I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'245 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G DIR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Y I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t--&lt;br /&gt;f---. &lt;br /&gt;t--&lt;br /&gt;f---. &lt;br /&gt;f---. &lt;br /&gt;f---. &lt;br /&gt;f---. &lt;br /&gt;f---. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f---. &lt;br /&gt;&amp;gt;---. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f---. &lt;br /&gt;---. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:--&lt;br /&gt;:--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/iO } Buffered &lt;br /&gt;RD control &lt;br /&gt;WR bu, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BHE &lt;br /&gt;AI9 &lt;br /&gt;AIM &lt;br /&gt;An &lt;br /&gt;All) &lt;br /&gt;AI5 &lt;br /&gt;AI. &lt;br /&gt;AI3 &lt;br /&gt;AI2 &lt;br /&gt;A II Buffered &lt;br /&gt;A III address &lt;br /&gt;A9 bus &lt;br /&gt;A. &lt;br /&gt;A, &lt;br /&gt;A6 &lt;br /&gt;A5 &lt;br /&gt;A. &lt;br /&gt;A., &lt;br /&gt;A2 &lt;br /&gt;AI &lt;br /&gt;Ao &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-8 A fully buffered 8086 microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;use a 74LS244 buffer. A fully buffered 8086 system requires one 74LS244, two 74LS245s, &lt;br /&gt;and three 74LS373s. The 8086 requires one more buffer than the 8088 because of the extra &lt;br /&gt;eight data bus connections, Dis-Ds. It also has a BHE signal that is buffered for memory-ban &lt;br /&gt;selection. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-4 BUS TIMING 299 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUS TIMING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It is essential to understand system bus timing before choosing a memory or I/O device for inter-&lt;br /&gt;facing to the 8086 or 80:-\\8 microprocessors. This section provides insight into the operation of &lt;br /&gt;the bus signals and the basic read and write timing of the 8086/8088. It is important to note that &lt;br /&gt;we discuss only the times that affect memory and I/O interfacing in this section. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Basic Bus Operation &lt;br /&gt;The three buses of the 8086 and 8088-address, data, and control-function in exactly the same &lt;br /&gt;manner as those of any other microprocessor. If data are written to the memory (see the simpli-&lt;br /&gt;fied timing for write in Figure 8-9), the microprocessor outputs the memory address on the ad-&lt;br /&gt;dress bus, outputs the data to be written into memory on the data bus, and issues a write (WR) to &lt;br /&gt;memory and 101M = 0 for the 8088 and MilO = 1 for the 8086. If data are read from the memory &lt;br /&gt;(see the simplified timing for read in Figure 8-10), the microprocessor outputs the memory ad-&lt;br /&gt;dress on the address bus, issues a read (RD) memory signal, and accepts the data via the data bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timing in General &lt;br /&gt;The 8086/8088 microprocessors use the memory and I/O in periods of time called bus cycles. &lt;br /&gt;Each bus cycle equals four system-clocking periods (T states). Some new microprocessors di-&lt;br /&gt;vide the bus cycle into as few as two clocking periods. If the clock is operated at 5 MHz (the &lt;br /&gt;basic operating frequency for these two microprocessors), then one 8086/8088 a bus cycle is &lt;br /&gt;complete in 800 ns. This means that the microprocessor reads or writes data between itself and &lt;br /&gt;memory or, I/O at a maximum rate of 1.25 million times per second. (Because of the internal &lt;br /&gt;queue, the 8086/8088 can execute 2.5 million instructions per second (MIPS) in bursts.) Other &lt;br /&gt;available versions of these microprocessors operate at much higher transfer rates due to higher &lt;br /&gt;clock frequencies. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;During the first clocking period in a bus cycle, which is called T1, many things happen. &lt;br /&gt;The address of the memory or I/O location is sent out via the address bus and the address/data &lt;br /&gt;bus connections. (The address/data bus is multiplexed and sometimes contains memory-&lt;br /&gt;addressing information, sometimes data.) Also output during Tl are the control signals ALE, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~--------------ONEBUSCYCLE----------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDRESS ----(~ _______________ V_A_L_ID_A_D_D_R_E_S_S ____________ _J)~-----&lt;br /&gt;ADDRESS/DATA --{ ADDRESS X'-____ D_A_TA __ W_R_I_TT_E_N_T_O __ M_E_M_O_R_Y __ ~))------&lt;br /&gt;\\~ __ ----J/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-9 Simplified 8086/8088 write bus cycle &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;300 CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~--------------ONEBUSCYCLE----------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f--T,-----+---- T2-----+----T3-----+----T.--l &lt;br /&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDRESS ----(~ ______________ V_A_L_I_D_A_D_D_R_E_S_S ____________ _J)~-----&lt;br /&gt;ADDRESSIDATA --&amp;lt; ADDRESS ),..----C( DATA FROM MEMORY )t----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\'--__ -----J/ &lt;br /&gt;FIGURE 8-10 Simplified 8086/8088 read bus cycle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R, and 101M (8088) or M/D (8086). The 101M or MilO signal indicates whether the address &lt;br /&gt;bus contains a memory address or an I/O device (port) number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;During T2, the 8086/8088 microprocessors issue the RD or WR signal, DEN, and, in the &lt;br /&gt;case of a write, the data to be written appears on the data bus. These events cause the memory or &lt;br /&gt;I/O device to begin to perform a read or a write. The DEN signal turns on the data bus buffers, if &lt;br /&gt;they are present in the system, so the memory or I/O can receive data to be written or so the mi-&lt;br /&gt;croprocessor can accept the data read from the memory or I/O for a read operation. If this hap-&lt;br /&gt;pens to be a write bus cycle. then the data are sent out to the memory or I/O through the data bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY is sampled at the end of T2, as illustrated in Figure 8-11. If READY is low at this &lt;br /&gt;time, T3 becomes a wait state (T w)' More detail is provided in Section 8-5. This clocking period &lt;br /&gt;is provided to allow the memory time to access data. If the bus cycle happens to be a read bus &lt;br /&gt;cycle, the data bus is sampled at the end of T3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In T4, all bus signals are deactivated in preparation for the next bus cycle. This is also the &lt;br /&gt;time when the 8086/8088 microprocessors sample the data bus connections for data that are read &lt;br /&gt;from memory or I/O. In addition, at this point, the trailing edge of the WR signal transfers data &lt;br /&gt;to the memory or I/O, which activate and write when theWR signal returns to a logic 1 level. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Read Timing &lt;br /&gt;Figure 8-11 also depicts the read timing for the 8088 microprocessor. The 8086 read timing is &lt;br /&gt;identical except that the 8086 has 16 rather than 8 data bus bits. A close look at this timing dia-&lt;br /&gt;gram should allow you to identify all the main events described for each T state. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The most important item contained in the read timing diagram is the amount of time al-&lt;br /&gt;lowed the memory or I/O to read the data. Memory is chosen by its access time, which is the &lt;br /&gt;fixed amount of time the microprocessor allows it to access data for the read operation. It is &lt;br /&gt;therefore extremely important that the memory you choose comply with the limitations of the &lt;br /&gt;system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The microprocessor timing diagram does not, however, provide a straightforward memory &lt;br /&gt;access time. Instead. it is necessary to combine several times to arrive at the access time. To find &lt;br /&gt;memory access time in this diagram, we must first locate the point in T3 when data are sampled. &lt;br /&gt;If you examine the timing diagram closely, you will notice a line that extends from the end of T3 &lt;br /&gt;down to the data bus. The end of T3 is where the microprocessor samples the data bus. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-4 BUS TIMING 301 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tl T2 TJ Tw T4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eLK (8284 Outpul) &lt;br /&gt;v:~~r-TClCl-rCH'CH2v-L~~~n-~ TCHCTV ~ TCHCl i f-- TelCH-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M, SSo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROY (8284 Inpul) &lt;br /&gt;SEE NOTE S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY (8088 Inpul) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ CYCLE &lt;br /&gt;(NOTE 1) &lt;br /&gt;(~, ilIn. VOH) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;! &lt;br /&gt;' , , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1s - Aa (FIO!!I dunng INTA) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCLAV-&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;r-- TflOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TClAX -&lt;br /&gt;-I TCHDX -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A19- A16 I I I 1\\ 51-5J &lt;br /&gt;: TCllH- f TlHTl--.::::: 1 T I-- TllAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I &lt;br /&gt;I TCHllJ f-- Â± -T&amp;quot;'VCl &lt;br /&gt;i !- TAVAl- V'H- \\:' , ,,&amp;gt;&amp;quot;~\\' I ' &amp;quot; &lt;br /&gt;i &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;' ' v ~ r-' &lt;br /&gt;'I' - f- TCl&amp;quot;'X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I ' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I &lt;br /&gt;TRYLCL-i -- I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I-} I I - -TCHRYX I &lt;br /&gt;T&amp;quot;YHCH 1 : 1 -&lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;!-TClAZ TDVCl- f--Tc,oX-:-1 I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD1-ADo DATA IN \\I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-M TAZAl- TClRH- --1 r ~ &lt;br /&gt;-=----.z- TCHCTV TClRL I TRlRH I 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCVCTV- ~ TCVCTX - ! &lt;br /&gt;FIGURE 8-11 Minimum mode 8088 bus timing for a read operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r--&lt;br /&gt;I~ __ -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~0B~0~~~\\\\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FlOA:-1 &lt;br /&gt;'-- TAHAV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHCTV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory access time starts when the address appears on the memory address bus and &lt;br /&gt;continues until the microprocessor s,amples the memory da:ta at T3. Approximately three T &lt;br /&gt;states elapse between these times. (Refer to Figure 8-12 for the following times.) The ad-&lt;br /&gt;dress does not appear until TCLAV time (110 ns if the clock is 5 MHz) after the start of Tl. &lt;br /&gt;This means that T CLA v time must be subtracted from the three clocking states (600 ns) that &lt;br /&gt;separate the appearance of the address (T1) and the sampling of the data (T3). One other time &lt;br /&gt;must also be subtracted: the data setup time (T OVCL)' which occurs before T3. Memory access &lt;br /&gt;time is thus three clocking states minus the sum of TCLAV and TOVCL' Because TOVCL is 30 ns &lt;br /&gt;with a 5 MHz clock, the allowed memory access time is only 460 ns (access time = 600 ns &lt;br /&gt;- 110 ns - 30 ns). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Actually, the memory devices chosen for connection to the 8086/8088 operated at 5 MHz &lt;br /&gt;must be able to access data in less than 460 ns because of the time delay introduced by the ad-&lt;br /&gt;dress decoders and buffers in the system. At least a 30 or 40 ns margin should exist for the oper-&lt;br /&gt;ation of these circuits. Therefore, the memory speed should be no slower than about 420 ns to &lt;br /&gt;operate correctly with the 8086/8088 microprocessors. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;302 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-12 &lt;br /&gt;characteristics &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 AC A.C. CHARACTERISTICS (8088: TA â¢ OOC to 70&amp;quot;C, Vee - 5V %10%)' &lt;br /&gt;(8088Â·2: TA = O'C to 70'C, Vee - 5V %5%) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MINIMUM COMPLEXITY SYSTEM TIMING REQUIREMENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOll &lt;br /&gt;_02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;',mbol ,.,. ....... , Min. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCLCl ClK Cycle P&amp;quot;lod 200 &lt;br /&gt;TClCH ClKlowTime lIB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHCl CLK High Time 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCH1CH2 eLKRi_Time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCL2CLI ClK FaU Time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TDVCl Dati in Setup Tim, 3D &lt;br /&gt;TCLDX Oat. In Hold Time 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROY Setup Time &lt;br /&gt;TR1VCl into 8284 (Sel 35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note. 1. 2) &lt;br /&gt;ROY Hold Time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TClR1X into 8284 (Sel 0 &lt;br /&gt;Not .. 1, 2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRYHCH READY Setup 118 Time into &lt;br /&gt;8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHRYX READY Hold Time !O into 8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRYlCl READY Inactive to -8 ClK (S3e Note 3) &lt;br /&gt;THVCH HOLD Setup Time 35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR, NMI, TEST &lt;br /&gt;TINVCH Setup Timo (Sel 3D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note 2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIUH Input Rise Tima (Except ClK) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIHll Input Fall Time (Except ClK) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A.C. CHARACTERISTICS (Continued) &lt;br /&gt;TIMING RESPONSES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOll &lt;br /&gt;',mbol Parl&amp;quot;,,&amp;quot;r Min. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TClAV Addr ... Valid tleloy 10 &lt;br /&gt;TClAX Address Hold Time 10 &lt;br /&gt;TClAZ Addr ... FIOIt Delay TClAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TlHLL AlEWidlh TCLCH-20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCllH ALE Active DeilY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHll ALE Inactive Delay &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TllAX Addr ... Hold Time to TCHCl-l0 ALE Inactive &lt;br /&gt;TClDV Data Valid Delay 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHDX Data Hold Time 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TWHDX Dota Hold Time Altar \\Wi TClCH-3D &lt;br /&gt;TCVCTV Control Acll .. Dalay I 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHCTV Control Active Oalay 2 10 &lt;br /&gt;TCVCTX Conlrollnactiv8 Oelay 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TAZRl Add .... Float to READ 0 Active &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TClRl RD Active Delay 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TClRH AD Inactive Delay 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRHAV RD Inactive to Next TClCl-45 Address Active &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TC~HAV HlDA Valid DeilY 10 &lt;br /&gt;TRlRH RDWidth 2TClCl-75 &lt;br /&gt;TWLWH WRWidth 2TClCl-60 &lt;br /&gt;TAVAl Address Volld to ALE low TClCH-80 &lt;br /&gt;TOlOH Output Ri .. Time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TOHOl Output Fall Time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M â¢â¢â¢ Min. M ... Unlit 'lUI Condition. &lt;br /&gt;500 125 500 nl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II nl &lt;br /&gt;44 no &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 10 &lt;br /&gt;From 1.0V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;na t03,5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 10 no From3,5Y tol.OY &lt;br /&gt;20 na &lt;br /&gt;10 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;35 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;88 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-8 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 20 no FromO.BV to 2.0Y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 12 n. &lt;br /&gt;From 2,OV &lt;br /&gt;toO.8V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1088-2 &lt;br /&gt;Ma â¢â¢ Min. Ma â¢â¢ Unll. T ... Condilion. &lt;br /&gt;110 10 10 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 TClAX 50 n. &lt;br /&gt;TClCH-l0 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80 50 n. &lt;br /&gt;85 55 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHCl-l0 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 10 80 n. c.. â¢ 20-100 pF lor &lt;br /&gt;10 no all 8088 Output. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In addition to &lt;br /&gt;TCLCH-3D n. internal load, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 to 70 no &lt;br /&gt;110 10 60 n. &lt;br /&gt;110 10 70 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 no &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;165 10 100 ns &lt;br /&gt;150 10 80 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TGlCl-40 ns &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;160 10 100 n. &lt;br /&gt;2TCLCl-50 ns &lt;br /&gt;2TCLCl-40 na &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TClCH-40 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 20 no From 0,8Y to 2.0Y &lt;br /&gt;12 t2 na From 2,OV to 0,8Y &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-4 BUS TIMING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T, T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;elK (8284 Output. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHDX 1_ &lt;br /&gt;--~--~~r-~==~~ r-~-------------+------~/r-----Â­I AD, - ADo _+-__ -+--' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WRITE CYCLE &lt;br /&gt;NOTE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA CYCLE &lt;br /&gt;NOTES 1,3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(iW,iiR-YOH) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SOFTWARE HALT -&lt;br /&gt;i5!lii,iiD,WR,iNTA ~ YO&amp;quot; &lt;br /&gt;DT/lI&amp;quot; INDÂ£T'ERMINATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD7 -ADo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCLAV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOTES: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-TCLAZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLOAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHCTV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INVALID ADDRESS SOFTWARE HAL T &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. :~~~~~:~LS SWITCH BETWEEN VOH AND VoL UNLESS OTHERWISE &lt;br /&gt;2. RDY IS SAMPLED NEAR THE END OF T2, T., Tw TO DETERMINE IF Tw &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MACHINES STATES ARE TO BE INSERTED. &lt;br /&gt;3. TWO INTA CYCLES RUN BACKÂ·T()'8ACK. THE ION LOCAL ADDRIDATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUS IS FLOATING DURING BOTH INTA CYCLES. CONTROL SIGNALS &lt;br /&gt;ARE SHOWN FOR THE SECOND INTA CYCLE. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. SIGNALS AT .214 ARE SHOWN FOR REFERENCE ONLY. &lt;br /&gt;5. ALL TIMING MEASUREMENTS ARE MADE AT I.5Y UNLESS OTH~RWISE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOTED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-13 Minimum mode 8088 write bus timing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-TWHDX-&lt;br /&gt;TCVCTX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;303 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The only other timing factor that may affect memory operation is the width of the RD &lt;br /&gt;strobe. On the timing diagram, the read strobe width is given as T RLRH' The time for this strobe &lt;br /&gt;is 325 ns (5 MHz clock rate), which is wide enough for almost all memory devices manufactured &lt;br /&gt;with an access time of 400 ns or less. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Write Timing &lt;br /&gt;Figure 8-13 illustrates the write timing diagram for the 8088 microprocessor. Again. the 8086 is &lt;br /&gt;so nearly identical that it need not be presented here in a separate timing diagram. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The main differences between read and write timing are minimal. The RD strobe is re-&lt;br /&gt;placed by the WR strobe, the data bus contains information for the memory rather than informa-&lt;br /&gt;tion from the memory, and DTIR remains a logic I instead of a logic 0 throughout the bus cycle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When interfacing some memory devices, timing may be especially critical between the &lt;br /&gt;point at which WR becomes a logic I and the time when the data are removed from the data bus. &lt;br /&gt;This is the case because, as you will recall. memory data are written at the trailing edge of the &lt;br /&gt;WR strobe. According to the timing diagram, this critical period is TwHDX or 88 ns when the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;304 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 is operated with a 5 MHz clock. Hold time is often much less than this, and is in fact often &lt;br /&gt;o ns for memory devices. The width of the WR strobe is T WLWH or 340 ns at a 5 MHz clock rate. &lt;br /&gt;This rate, too, is compatible with most memory devices that have an access time of 400 ns or less. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY AND THE WAIT STATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As we mentioned earlier in this chapter, the READY input causes wait states for slower memory &lt;br /&gt;and I/O components. A wait state (Tw) is an extra clocking period, inserted between T2 and T3, &lt;br /&gt;that lengthens the bus cycle. If one wait state is inserted, then the memory access time, normally &lt;br /&gt;460 ns with a 5 MHz clock, is lengthened by one clocking period (200 ns) to 660 ns. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this section, we discuss the READY synchronization circuitry inside the 8284A clock &lt;br /&gt;generator, show how to insert one or more wait states selectively into the bus cycle, and examine &lt;br /&gt;the READY input and the synchronization times it requires. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The READY Input &lt;br /&gt;The READY input is sampled at the end of T2 and again, if applicable, in the middle of Tw. If &lt;br /&gt;READY is a logic 0 at the end of T2, then n is delayed and Tw is inserted between T2 and n. &lt;br /&gt;READY is next sampled at the middle of Tw to determine if the next state is Tw or T3. It is &lt;br /&gt;tested for a logic 0 on the I-to-O transition of the clock at the end of T2 and for a 1 on the O-to-l &lt;br /&gt;transition of the clock in the middle of Tw. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The READY input to the 8086/8088 has some stringent timing requirements. The timing &lt;br /&gt;diagram in Figure 8-14 shows READY causing one wait state (Tw) along with the required &lt;br /&gt;setup and hold times from the system clock. The timing requirement for this operation is met by &lt;br /&gt;the internal READY synchronization circuitry of the 8284A clock generator. When the 8284A is &lt;br /&gt;used for READY, the RDY (ready input to the 8284A) input occurs at the end of each T state. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROY and the 8284A &lt;br /&gt;RDY is the synchronized ready input to the 8284A clock generator. The timing diagram for this &lt;br /&gt;input is provided in Figure 8-15. Although it differs from the timing for the READY input to the &lt;br /&gt;8086/8088, the internal 8284A circuitry guarantees the accuracy of the READY synchronization &lt;br /&gt;provided to the 8086/8088. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 8-16 again depicts the internal structure of the 8284A. The bottom half of this dia-&lt;br /&gt;gram is the READY synchronization circuitry. At the leftmost side, the RDYI and AENI inputs &lt;br /&gt;are ANDed, as are the RDY2 and AEN2 inputs. The outputs of the AND gates are then ORed to &lt;br /&gt;generate the input to the one or two stages of synchronization. In order to obtain a logic 1 at the &lt;br /&gt;inputs to the flip-flops, RDYI ANDed with AENI must be active or RDY2 ANDed with AEN2 &lt;br /&gt;must be active. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-------T2-----+-----Tw-----f--T3 &lt;br /&gt;eLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-14 8086/8088 READY input timing &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-5 READY AND THE WAIT STATE 305 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T~ Tw ----------~---T3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ tj&amp;quot;~o&amp;quot;'i / elK RDY &lt;br /&gt;FIGURE 8-15 8284A ROY input timing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ASYNC input selects one stage of synchronization when it is a logic I and two stages &lt;br /&gt;when a logic O. If one stage is selected, then the ROY signal is kept from reaching the 8086/8088 &lt;br /&gt;READY pin until the next negative edge of the clock. If two stages are selected, the first positive &lt;br /&gt;edge of the clock captures RDY in the first flip-flop. The output of this flip-flop is fed to the &lt;br /&gt;second flip-flop so that the second flip-flop captures RDY on the next negative edge of the clock. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 8-17 illustrates a circuit used to introduce almost any number of wait states for the &lt;br /&gt;8086/8088 microprocessors. Here, an 8-bit serial shift register (74LSI64) shifts a logic 0 for one &lt;br /&gt;or more clock periods from one of its Q outputs through to the RDYI input of the 8284A. With &lt;br /&gt;appropriate strapping, this circuit can provide various numbers of wait states. Notice also how &lt;br /&gt;the shift register is cleared back to its stating point. The output of the register is forced high when &lt;br /&gt;the the second flip-flop captures RD, WR, and !NT A pins are all logic l' s. These three signals &lt;br /&gt;are high until state T2, so the shift register shifts for the first time when the positive edge of the &lt;br /&gt;T2 arrive~. If one wait is desired, then output QB is connected to the OR gate. If two waits are de-&lt;br /&gt;sired, output Qc is connected, and so forth. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also notice in Figure 8-17 that this circuit does not always generate wait states. It is en-&lt;br /&gt;abled from the memory only for memory devices that require the insertion of waits. If the selec-&lt;br /&gt;tion signal from a memory device is a logic 0, the device is selected; then this circuit will &lt;br /&gt;generate a wait state. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 8-18 illustrates the timing diagram for this shift register wait state generator when &lt;br /&gt;it is wired to insert one wait state. The timing diagram also illustrates the internal contents of the &lt;br /&gt;shift register's flip-flops to present a more detailed view of its operation. In this example, one &lt;br /&gt;wait state is generated. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-16 The internal &lt;br /&gt;block diagram of the 8284A &lt;br /&gt;clock generator (Courtesy of &lt;br /&gt;Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RES------------------------------~L7&amp;gt;-----~D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;X1-----i &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;X2----~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XTAl &lt;br /&gt;OSCillATOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIC -----------r-l.:&amp;gt;o-iI....-.1 &lt;br /&gt;+3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EFI -----------------L..-I &lt;br /&gt;CSYNC--------------------------------~--_+;_--~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDY1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CKI &lt;br /&gt;D Q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASYNC--------------------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;306 CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROY, &lt;br /&gt;CS from memory device &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AEN, &lt;br /&gt;-8:!84A RDY! &lt;br /&gt;-Clock &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;gellcmtol&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Q&amp;quot; QaQ(' QIl QF. QFQo QH &lt;br /&gt;ClK 1--....... ----.; CLK '164 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY CLR &lt;br /&gt;SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;shift direction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY &lt;br /&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD &lt;br /&gt;XOXX WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or &lt;br /&gt;XOX6 INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-17 A circuit that will cause between 0 and 7 wait states &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T, T~ Tw T, T. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;elK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROY, \\ / &lt;br /&gt;Q, / \\ &lt;br /&gt;QII / \\ &lt;br /&gt;Q(' / \\ &lt;br /&gt;RO \\ / &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-18 Wait state generation timing of the circuit of Figure 8-17 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vcc o r~j &lt;br /&gt;8284A &lt;br /&gt;CLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QINERATOR &lt;br /&gt;-RES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 RDY &lt;br /&gt;OND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-6 MINIMUM MODE VERSUS MAXIMUM MODE 307 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MINIMUM MODE VERSUS MAXIMUM MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are two available modes of operation for the 8086/8088 microprocessors: minimum mode &lt;br /&gt;and maximum mode. Minimum mode operation is obtained by connecting the mode selectior &lt;br /&gt;pin MN/MX to +5.0 V, and maximum mode is selected by grounding this pin. Both modes en-&lt;br /&gt;able different control structures for the 8086/8088 microprocessors. The mode of operation pro-&lt;br /&gt;vided by minimum mode is similar to that of the 8085A, the most recent Intel 8-bit &lt;br /&gt;microprocessor, whereas maximum mode is new and unique and deigned to be used whenever a &lt;br /&gt;coprocessor exists in a system. Note that the maximum mode was dropped from the Intel family &lt;br /&gt;beginning with the 80286 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Minimum Mode Operation &lt;br /&gt;Minimum mode operation is the least-expensive way to operate the 8086/8088 microprocessors &lt;br /&gt;(see Figure 8-19 for the minimum mode 8088 system). It costs less because all the control sig-&lt;br /&gt;nals for the memory and I/O are generated by the microprocessor. These control signals are iden-&lt;br /&gt;tical to those of the Intel 8085A, an earlier 8-bit microprocessor. The minimum mode allows the &lt;br /&gt;8085A, 8-bit peripherals to be used with the 8086/8088 without any special considerations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Maximum Mode Operation &lt;br /&gt;Maximum mode operation differs from minimum mode in that some of the control signals must &lt;br /&gt;be externally generated. This requires the addition of an external bus controller-the 8288 bus &lt;br /&gt;controller (see Figure 8-20 for the maximum mode 8088 system). There are not enough pins on &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;elK MNIIIt rVcc &lt;br /&gt;RUDY lOIII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- â¢â¢ SET 101 &lt;br /&gt;WI! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-CPU 1m &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DTIII r---~ &lt;br /&gt;II!Ii r---J I &lt;br /&gt;ALE STI I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND Oi 1H2 I &lt;br /&gt;ADo-AD, ~DDR/DATA LATCH ADDRESS Ai-A,. (1.20R 3) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J &lt;br /&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II~ T Oi &amp;quot;'&amp;quot; DATA TRANSCEIVER 1111 liTI II &lt;br /&gt;I' IR WE 06 III es IOID &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;J\\ 2142 R ..... (2) 271' 2 PRQM MesÂ·1O PERIPHERAL &lt;br /&gt;V INT:.-I I--CONTROL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT VL-- 1RO-7 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rr-&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-19 Minimum mode 8088 system &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;308 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;NO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;i &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.. '&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;c.u &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;so &lt;br /&gt;So &lt;br /&gt;S; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OND C ... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50 &lt;br /&gt;S. &lt;br /&gt;ii .... &lt;br /&gt;DEN c~~~&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MiiDC &lt;br /&gt;iiWiC &lt;br /&gt;.III\\IIl: .c &lt;br /&gt;iQ-c &lt;br /&gt;&amp;quot;we &lt;br /&gt;~ .c &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L' -__________________ ~.~&amp;quot; CONTM)L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-20 Maximum mode 8088 system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the 8086/8088 for bus control during maximum mode because new pins and new features have &lt;br /&gt;replaced some of them. Maximum mode is used only when the system contains external co-&lt;br /&gt;processors such as the 8087 arithmetic coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8288 Bus Controller &lt;br /&gt;An 8086/8088 system that is operated in maximum mode must have an 8288 bus controller to &lt;br /&gt;provide the signals that are eliminated from the 8086/8088 by the maximum mode operation. &lt;br /&gt;Figure 8-21 illustrates the block diagram and pin-out of the 8288 bus controller circuit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that the control bus developed by the 8288 bus controller contains separate signals &lt;br /&gt;for I/O (IORC and lOWC) and memory (MRDC and MWTC). It also contains advanced &lt;br /&gt;memory (AMWC) and I/O (AIOWC) write strobes and the INTA signal. These signals replace &lt;br /&gt;the minimum mode ALE, WR, 101M, DTlR, DEN, and 1NT A, which are lost when the &lt;br /&gt;8086/8088 is operated in the maximum mode. &lt;br /&gt;Pin Functions. The following list provides a description of each pin of the 8288 bus controller. &lt;br /&gt;S2. SI. and SO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE &lt;br /&gt;DEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Status inputs are connected to the status output pins on the 8086/8088 &lt;br /&gt;microprocessors. These three signals are decoded to generate the timing &lt;br /&gt;signals for the system. &lt;br /&gt;The clock input provid~s internal timing and must be connected to the &lt;br /&gt;CLK output pin of the 8284A clock generator. &lt;br /&gt;The address latch enable output is used to demultiplex the address/data bus. &lt;br /&gt;The data bus enable pin controls the bi-directional data bus buffers in the &lt;br /&gt;system. Note that this is an active high-output pin that is the opposite &lt;br /&gt;polarity from the DEN signal found on the microprocessor when operated &lt;br /&gt;in the minimum mode. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;STA~J ~--&lt;br /&gt;, 52--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IClk -CONTROL AEN --INPUT CEN-&lt;br /&gt;10B-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-7 SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STATUS &lt;br /&gt;DECODER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTROL &lt;br /&gt;LOGIC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ 5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COMÂ· &lt;br /&gt;MAND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SIGNAL &lt;br /&gt;GENERÂ· &lt;br /&gt;ATOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTROL &lt;br /&gt;SIGNAL &lt;br /&gt;GENERÂ· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ATOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MRDC I &lt;br /&gt;-- MWTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AMWC MUL TlBUS'1II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IDRC I COMMAND iOWC SIGNALS &lt;br /&gt;AIOWC &lt;br /&gt;INrA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DTIA } ADDRESS LATCH, DATA &lt;br /&gt;DEN TRANSCEIVER, AND &lt;br /&gt;MCElPDEN INTERRUPT CONTROL &lt;br /&gt;ALE SIGNALS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;309 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOB VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK SO &lt;br /&gt;51 S2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R MCElPDEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE DEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AEN CEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MRDC INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AM we 10RC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MWTC Alowe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND lowe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 8-21 The 8288 bus controller. (a) block diagram (b) pinout &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DTIR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CEN &lt;br /&gt;lOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AIOWC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10WC &lt;br /&gt;ffiRC &lt;br /&gt;AMWC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MWTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MCE/PDEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The data transmit/receive signal is output by the 8288 to control the &lt;br /&gt;direction of the bi-directional data bus buffers, &lt;br /&gt;The address enable input causes the 8288 to enable the memory control &lt;br /&gt;signals, &lt;br /&gt;The control enable input enables the command output pins on the 8288. &lt;br /&gt;The I/O bus mode input selects either the I/O bus mode or system bus &lt;br /&gt;mode operation. &lt;br /&gt;The advanced I/O write command output provides I/O with an advanced &lt;br /&gt;I/O write control signal. &lt;br /&gt;The I/O write command output provides I/O with its main write signal. &lt;br /&gt;The I/O read command output provides I/O with its read control signal. &lt;br /&gt;The advanced memory write control pin provides memory with an early &lt;br /&gt;or advanced write signal. &lt;br /&gt;The memory write control pin provides memory with its normal write &lt;br /&gt;control signal. &lt;br /&gt;The memory read control pin provides memory with a read control &lt;br /&gt;signal. &lt;br /&gt;The interrupt acknowledge output acknowledges an interrupt request &lt;br /&gt;input applied to the INTR pin. &lt;br /&gt;The master cascade/peripheral data output selects cascade operation for &lt;br /&gt;an interrupt controller if lOB is grounded and enables the I/O bus &lt;br /&gt;transceivers if lOB is tied high. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. The main differences between the 8086 and 8088 are (a) an 8-bit data bus on the 8088 and a &lt;br /&gt;16-bit data bus on the 8086, (b) an SSO pin on the 8088 in place ofBHE/S7 on the 8086, and &lt;br /&gt;(c) an 101M pin on the 8088 instead of an MilO on the 8086. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;310 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 8086/8088 HARDWARE SPECIFICATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Both the 8086 and 8088 require a single +5.0 V power supply with a tolerance ofÂ±IO%. &lt;br /&gt;3. The 8086/8088 microprocessors are TTL compatible if the noise immunity figure is de-rated &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to 350 mV from the customary 400 mY. &lt;br /&gt;4. The 8086/8088 microprocessors can drive one 74XX, five 74LSXX, one 74SXX, ten &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALSXX, and ten 74HCXX unit loads. &lt;br /&gt;5. The 8284A clock generator provides the system clock (CLK), READY synchronization, and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET synchronization. &lt;br /&gt;6. The standard 5 MHz 8086/8088 operating frequency is obtained by attaching a 15 MHz &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;crystal to the 8284A clock generator. The PCLK output contains a TTL-compatible signal at &lt;br /&gt;one-half of the CLK frequency. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Whenever the 8086/8088 microprocessors are reset, they begin executing software at memory &lt;br /&gt;location FFFFOH (FFFF:OOOO) with the interrupt request pin disabled. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Because the 8086/8088 buses are multiplexed and most memory and I/O devices aren't, the &lt;br /&gt;system must be demultiplexed before interfacing with memory or I/O. Demultiplexing is ac-&lt;br /&gt;complished by an 8-bit latch whose clock pulse is obtained from the ALE signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. In a large system, the buses must be buffered because the 8086/8088 microprocessors are &lt;br /&gt;capable of driving only ten unit loads and large systems often have many more. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Bus timing is very important in the remaining chapters of the text. A bus cycle that consists &lt;br /&gt;of four clocking periods acts as the basic system timing. Each bus cycle is able to read or &lt;br /&gt;write data between the microprocessor and the memory or I/O system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. A bus cycle is broken into four states or T periods. T1 is used by the microprocessor to send &lt;br /&gt;the address to the memory or I/O and the ALE signal to the demultiplexers. T2 is used to &lt;br /&gt;send data to memory for a write and to test the READY pin and activate control signals RD &lt;br /&gt;or WR. T3 allows the memory time to access data and allows data to be transferred between &lt;br /&gt;the microprocessor and the memory or I/O. T4 is where data are written. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The 8086/8088 microprocessors allow the memory and I/O 460 ns to access data when they &lt;br /&gt;are operated with a 5 MHz clock. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. Wait states (Tw) stretch the bus cycle by one or more clocking periods to allow the memory &lt;br /&gt;and I/O additional access time. Wait states are inserted by controlling the READY input to &lt;br /&gt;the 8086/8088. READY is sampled at the end ofT2 and during Tw. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Minimum mode operation is similar to that of the Intel 8085A microprocessor, while max-&lt;br /&gt;imum mode operation is new and specifically designed for the operation of the 8087 arith-&lt;br /&gt;metic coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. The 8288 bus controller must be used in the maximum mode to provide the control bus sig-&lt;br /&gt;nals to the memory and I/O. This is because the maximum mode operation of the 8086/8088 &lt;br /&gt;removes some of the system's control signal lines in favor of control signals for the co-&lt;br /&gt;processors. The 8288 reconstructs these removed control signals. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. List the differences between 8086 and 8088 microprocessors. &lt;br /&gt;2. Is the 8086/8088 TTL compatible? Explain your answer. &lt;br /&gt;3. What is the fan-cut from the 8086/8088 to the following devices: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) 74XXX TTL &lt;br /&gt;(b) 74ALSXXX TTL &lt;br /&gt;(c) 74HCXXX CMOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. What information appears on the address/data bus of the 8088 while ALE is active? &lt;br /&gt;5. What is the purpose of status bits S3 and S4? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;B-B QUESTIONS AND PROBLEMS 311 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. What condition does a logic 0 on the 8086/8088 RD pin indicate? &lt;br /&gt;7. Explain the operation of the TEST pin and the WAIT instruction. &lt;br /&gt;8. Describe the signal that is applied to the CLK input pin of the 8086/8088 microprocessors. &lt;br /&gt;9. What mode of operation is selected when MN/MX is grounded? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Wh&amp;quot;t does the WR strobe signal from the 8086/8088 indicate about the operation of the &lt;br /&gt;8086/8088? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II. When does ALE float to its high-impedance state? &lt;br /&gt;12. When DT/R is a logic I, what condition does it indicate about the operation of the 8086/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088'1 &lt;br /&gt;13. What happens when the HOLD input to the 8086/8088 is placed at its logic i level? &lt;br /&gt;14. What three minimum mode 8086/8088 pins are decoded to discover if the processor is &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;halted? &lt;br /&gt;15. Explain the operation of the LOCK pin. &lt;br /&gt;16. What conditions do the QSI and QSo pins indicate about the 8086/8088? &lt;br /&gt;17. What three housekeeping chores are provided by the 8284A clock generator? &lt;br /&gt;18. By what factor does the 8284A clock generator divide the crystal oscillator's output fre-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;quency? &lt;br /&gt;19. If the Fie pin is placed at a logic 1 level, the crystal oscillator is disabled. Where is the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;timing input signal attached to the 8284A under this condition? &lt;br /&gt;20. The PCLK output of the 8284A is MHz if the crystal oscillator is oper-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ating at 14 MHz. &lt;br /&gt;21. The RES input to the 8284A is placed at a logic level in order to reset the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086/8088. &lt;br /&gt;22. Which bus connections on the 8086 microprocessor are typically demultiplexed? &lt;br /&gt;23. Which bus connections on the 8088 microprocessor are typically demultiplexed? &lt;br /&gt;24. Which TTL integrated circuit is often used to demultiplex the buses on the 8086/8088? &lt;br /&gt;25. What is the purpose of the demultiplexed BHE signal on the 8086 microprocessor? &lt;br /&gt;26. Why are buffers often required in an 8086/8088-based system? &lt;br /&gt;27. What 8086/8088 signal is used to select the direction of the data flows through the 74LS245 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bi-directional bus buffer? &lt;br /&gt;28. A bus cycle is equal to clocking periods. &lt;br /&gt;29. If the CLK input to the 8086/8088 is 4 MHz, how long is one bus cycle? &lt;br /&gt;30. What two 8086/8088 operations occur during a bus cycle? &lt;br /&gt;31. How many MIPS is the 8086/8088 capable of obtaining when operated with a 10 MHz &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;clock? &lt;br /&gt;32. Briefly describe the purpose of each T state listed: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) T1 &lt;br /&gt;(b) T2 &lt;br /&gt;(c) T3 &lt;br /&gt;(d) T4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33. How much time is allowed for memory access when the 8086/8088 microprocessors are op-&lt;br /&gt;erated with a 5 MHz clock? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. How wide is DEN if the 8088 is operated with a 5 MHz clock? &lt;br /&gt;35. If the READY pin is grounded, it will introduce states into the bus cycle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;of the 8086/8088. &lt;br /&gt;&amp;quot;7&amp;quot;':'=~ 36. What does the ASYNC input to the 8284A accomplish? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37. What logic levels must be applied to AENI and ROY 1 to obtain a logic 1 at the READY &lt;br /&gt;pin? (Assume that AEN2 is at a logic 1 level.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38. Contrast minimum and maximum mode 8086/8088 operation. &lt;br /&gt;39. What main function is provided by the 8288 bus controller when used with 8086/8088 max-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;imum mode operation? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;312 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 9 &lt;br /&gt;Memory Interface &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;Whether simple or complex, every microprocessor-based system has a memory system. The &lt;br /&gt;Intel family of microprocessors is no different from any other in this respect. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Almost all systems contain two main types of memory: read-only memory (ROM) and &lt;br /&gt;random access memory (RAM) or read/write memory. Read-only memory contains system &lt;br /&gt;software and permanent system data, while RAM contains temporary data and application soft-&lt;br /&gt;ware. This chapter explains how to interface both memory types to the Intel family of micro-&lt;br /&gt;processors. We demonstrate memory interface to an 8-, 16-,32-, and 64-bit data bus using &lt;br /&gt;various memory address sizes. This allows virtually any microprocessor to be interfaced to any &lt;br /&gt;memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. Decode the memory address and use the outputs of the decoder to select various memory &lt;br /&gt;components. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Use programmable logic devices (PLDs) to decode memory addresses. &lt;br /&gt;3. Explain how to interface both RAM and ROM to a microprocessor. &lt;br /&gt;4. Explain how parity can detect memory errors. &lt;br /&gt;5. Interface memory to an 8-, 16-,32-, and 64-bit data bus. &lt;br /&gt;6. Explain the operation of a dynamic RAM controller. &lt;br /&gt;7. Interface dynamic RAM to the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MEMORY DEVICES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before attempting to interface memory to the microprocessor, it is essential to completely un-&lt;br /&gt;derstand the operation of memory components. In this section, we explain the function of the &lt;br /&gt;four common types of memory: read-only memory (ROM), flash memory (EEPROM), static &lt;br /&gt;random access memory (SRAM), and dynamic random access memory (DRAM). &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;!1-1 MEMORY DEVICES 313 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Pin Connections &lt;br /&gt;Pin connections common to all memory devices are the address inputs, data outputs or input/out-&lt;br /&gt;puts, some type of selection input, and at least one control input used to select a read or write op-&lt;br /&gt;eration. See Figure 9-1 for ROM and RAM generic-memory devices. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address Connections. All memory devices have address inputs that select a memory location &lt;br /&gt;within the memory device. Address inputs are almost always labeled from Ao' the least signifi-&lt;br /&gt;cant address input, to An' where subscript n can be any value but is always labeled as one less &lt;br /&gt;than the total number of address pins. For example, a memory device that has 10 address pins has &lt;br /&gt;its address pins labeled from Ao to A9 . The number of address pins found on a memory device is &lt;br /&gt;determined by the number of memory locations found within it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Today, the more common memory devices have between lK (1,024) to 16M (16,777,216) &lt;br /&gt;memory locations, with 256M memory location devices on the horizon. A IK memory device &lt;br /&gt;has 10 address pins (Ao-A9); therefore, 10 address inputs are required to select any of its 1,024 &lt;br /&gt;memory locations. It takes a lO-bit binary number (1,024 different combinations) to select any &lt;br /&gt;single location on a 1,024-10cation device. If a memory device has II address connections &lt;br /&gt;(Ao-A lO), it has 2,048 (2K) internal memory locations. The number of memory locations can &lt;br /&gt;thus be extrapolated from the number of address pins. For example, a 4K memory device has 12 &lt;br /&gt;address connections, an 8K device has 13, and so forth. A device that contains 1M locations re-&lt;br /&gt;quires a 20-bit address (Ao-A19). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A 400H represents a lK-byte section of the memory system. If a memory device is de-&lt;br /&gt;coded to begin at memory address 10000H, and it is a lK device, its last location is at address &lt;br /&gt;103FFH-one location less than 400H. Another important hexadecimal number to remember is &lt;br /&gt;a 1000H, because 1000H is 4K. A memory device containing a starting address of 14000H that &lt;br /&gt;is 4K bytes in size ends at location 14FFFH-one location less than 1000H. A third number is &lt;br /&gt;64K or 10000H. A memory that starts at location 30000H and ends at location 3FFFFH is a 64K &lt;br /&gt;byte memory. Finally, because 1M of memory is not uncommon, a 1M memory contains &lt;br /&gt;100000H memory locations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Connections. All memory devices have a set of data outputs or input/outputs. The device &lt;br /&gt;illustrated in Figure 9-1 has a common set of input/output (110) connections. Today, many &lt;br /&gt;memory devices have bi-directional common 110 pins. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The data connections are the points at which data are entered for storage or extracted for &lt;br /&gt;reading. Data pins on memory devices are almost always labeled Do through D7for an 8-bit-wide &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-1 A pseudo-&lt;br /&gt;memory component illustrat-&lt;br /&gt;ing the address, data, and An &lt;br /&gt;control connections AI &lt;br /&gt;Addre~s A2 &lt;br /&gt;connections &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Select Read &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;314 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory device. In this sample memory device, there are eight I/O connections, which means &lt;br /&gt;that the memory device stores 8-bits of data in each of its memory locations. An 8-bit-wide &lt;br /&gt;memory device is often called a byte-wide memory. Although most devices are currently 8-bits &lt;br /&gt;wide, not all memory devices are 8-bits wide. Some devices are 16-bits, 4-bits, or just I-bit wide. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Catalog listings of memory devices often refer to memory locations times bits per location. &lt;br /&gt;For example, a memory device with IK memory locations and 8-bits in each location is often &lt;br /&gt;listed as a lK x 8 by the manufacturer. A 16K x 1 is a memory device containing 16K I-bit &lt;br /&gt;memory locations. Memory devices are also often classified according to total bit capacity. For &lt;br /&gt;example, a IK x 8 bit memory device is sometimes listed as an 8K memory device, or a 64K x 4 &lt;br /&gt;memory device is listed as a 256K device. These variations occur from one manufacturer to an-&lt;br /&gt;other. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selection Connections. Each memory device has an input-sometimes more than one--that se-&lt;br /&gt;lects or enables the memory device. This kind of input is most often called a chip select (CS), &lt;br /&gt;chip enable (CE), or simply select (5) input. RAM memory generally has at least one CS or 5 &lt;br /&gt;input, and ROM at least one CEo If the CE, CS, or 5 input is active (a logic 0 in this case, becaus &lt;br /&gt;of the over-bar), the memory device performs a read or a write; if it is inactive (a logic 1 in this &lt;br /&gt;case), the memory device cannot do a read or a write because it is turned off or disabled. If more &lt;br /&gt;than one CS connection is present, all must be activated to read or write data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control Connections. All memory devices have some form of control input or inputs. A ROM &lt;br /&gt;usually has only one control input, while a RAM often has one or two control inputs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The control input most often found on a ROM is the output enable (OE) or gate (0) con-&lt;br /&gt;nection, which allows data to flow out of the output data pins of the ROM. If OE and the selec-&lt;br /&gt;tion input are both active, then the output is enabled; if OE is inactive, the output is disabled at &lt;br /&gt;its high-impedance state. The OE connection enables and disables a set of three-state buffers lo-&lt;br /&gt;cated within the memory device and must be active to read data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A RAM memory device has either one or two control inputs. If there is one control input, &lt;br /&gt;it is often called R/W. This pin selects a read operation or a write operation only if the device is &lt;br /&gt;selected by the selection input (CS). If the RAM has two control inputs, they are usually labeled &lt;br /&gt;WE (or W) and OE (or 0). Here, WE (write enable) must be active to perform a memory write &lt;br /&gt;operation, and OE must be active to perform a memory read operation. When these two controls &lt;br /&gt;(WE) and OE) are present, they must never both be active at the same time. If both control inputs &lt;br /&gt;are inactive (logic 1 's), then data are neither written nor read and the data connections are at their &lt;br /&gt;high-impedance state. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROM Memory &lt;br /&gt;The read-only memory (ROM) permanently stores programs and data that are resident to the &lt;br /&gt;system and must not change when power is disconnected. The ROM is permanently pro-&lt;br /&gt;grammed so data are always present, even when power is disconnected. This type of memory is &lt;br /&gt;often called nonvolatile memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ROM is available in many forms today. A device we call a ROM is purchased in mass &lt;br /&gt;quantities from a manufacturer and programmed during its fabrication at the factory. The &lt;br /&gt;EPROM (erasable programmable read-only memory), a type of ROM, is more commonly &lt;br /&gt;used when software must be changed often or when too limited a number are in demand to make &lt;br /&gt;the ROM economical. For a ROM to be practical, we u~&amp;quot;'dlly must purchase at least 10,000 de-&lt;br /&gt;vices. An EPROM is programmed in the field on a device called an EPROM programmer. The &lt;br /&gt;EPROM is also erasable if exposed to high-intensity ultraviolet light for about 20 minutes or &lt;br /&gt;less, depending on the type of EPROM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROM memory devices are also available, but they are not as common today. The PROM &lt;br /&gt;(programmable read-only memory) is also programmed in the field by burning open tiny &lt;br /&gt;Nichrome or silicon oxide fuses, but once programmed it cannot be erased. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-1 MEMORY DEVICES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO-Al0 &lt;br /&gt;PD/PGM &lt;br /&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00-07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN CONFIGURATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A7~VCC &lt;br /&gt;AS S ~ ~~ ~A8 &lt;br /&gt;AS 3 22 Ag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN NAMES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDRESSES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vpp &lt;br /&gt;cs &lt;br /&gt;AlO &lt;br /&gt;PD/PGM &lt;br /&gt;Or &lt;br /&gt;Os &lt;br /&gt;05 &lt;br /&gt;04 &lt;br /&gt;O:l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POWER DOWN/PROGRAM &lt;br /&gt;CHIP SELECT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTPUTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MODE SELECTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ PD/PGM CS MODE (18) (20) &lt;br /&gt;Read VIL V IL &lt;br /&gt;L'â¬;select Don't care VIH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f--&lt;br /&gt;Power Down VIH Don't care &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Program Pulsed V IL to V IH VIH &lt;br /&gt;Program Verify VIL &lt;br /&gt;Program Inhibit VIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCCo-----&lt;br /&gt;GNDo-----&lt;br /&gt;Vppo-----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BLOCK DIAGRAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs~ CHIP SELECT, &lt;br /&gt;PD/PGM - POWER DOWN, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND PROG. LOGIC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ Y &lt;br /&gt;DECODER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO-A 10 &lt;br /&gt;ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INPUTS X ~ &lt;br /&gt;DECODER &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vpp &lt;br /&gt;(21) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5 &lt;br /&gt;+5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;315 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC OUTPUTS &lt;br /&gt;(24) (9-11. 13.(7) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5 DOUT &lt;br /&gt;+5 High Z &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5 High Z &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5 DIN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5 DOUT &lt;br /&gt;+5 High Z &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA OUTPUTS &lt;br /&gt;0 0-07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTPUT BUFFERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;yÂ·GATING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16,384-BIT &lt;br /&gt;CELL MATRIX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-2 The pin-out of the 2716, 2K x 8 EPROM (Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Still another, newer type of read-mostly memory (RMM) is called the flash memory. The &lt;br /&gt;flash memory! is also often called an EEPROM (electrically erasable programmable ROM), &lt;br /&gt;EAROM (electrically alterable ROM), or a NOVRAM (nonvolatile RAM). These memory de-&lt;br /&gt;vices are electrically erasable in the system, but require more time to erase than a normal RAM. &lt;br /&gt;The flash memory device is used to store setup information for systems such as the video card in &lt;br /&gt;the computer. It may also soon replace the EPROM in the computer for the BIOS memory. Some &lt;br /&gt;systems contain a password stored in the flash memory device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-2 illustrates the 2716 EPROM, which is representative of most EPROMs. This de-&lt;br /&gt;vice contains 11 address inputs and 8 data outputs. The 2716 is a 2K x 8 memory device. The &lt;br /&gt;27XXX series of the EPROMs contains the following part numbers: 2704 (512 x 8), 2708 (lK x 8), &lt;br /&gt;2716 (2K x 8), 2732 (4K x 8), 2764 (8K x 8), 27128 (l6K x 8), 27256 (32K x 8), 27512 (64K x 8), &lt;br /&gt;and 271024 (128K x 8). Each of these parts contains address pins, eight data connections, one or &lt;br /&gt;more chip selection inputs (CE), and an output enable pin (OE). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-3 illustrates the timing diagram for the 2716 EPROM. Data only appear on the &lt;br /&gt;output connections after a logic 0 is placed on both the CE and OE pin connections. If CE and OE &lt;br /&gt;are not both logic O's, the data output connections remain at their high-impedance or off states. Note &lt;br /&gt;that the V pp pin must be placed at a logic 1 for data to be read from the EPROM. In some cases, the &lt;br /&gt;V pp pin is in the same position as the WE pin on the SRAM. This can allow a single socket to hold &lt;br /&gt;either an EPROM or an SRAM. Examples are the 2716 EPROM and the 6116 SRAM, both 2K x 8 &lt;br /&gt;devices that have the same pin-out, except for V pp on the EPROM and WE on the SRAM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;One important piece of information provided by the timing diagram and data sheet is the &lt;br /&gt;memory access time-the time that it takes the memory to read information. As Figure 9-3 il-&lt;br /&gt;lustrates, memory access time (T ACC) is measured from the appearance of the address at the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I Flash memory is a registered trademark of Intel Corporation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;316 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A.C. Characteristics &lt;br /&gt;TA = OÂ°C to 70Â°C. VCc(1) = +5V Â±5%, Vpp(2) = VCC Â±0.6V(3) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Symbol Parameter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tACC1 Address to Output De[ay &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tACC2 PD/PGM to Output Delay &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tco Chip Se[ect to Output Delay &lt;br /&gt;tpF PD/PGM to Output Float &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tOF Chip Deselect to Output F [oat &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tOH Address to Output Hold &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Capacitancel51 T A E 25Â°C, f = 1 MHz &lt;br /&gt;Symbol Parameter Typ. Max. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CIN Input Capacitance 4 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COUT Output Capacitance 8 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAVEFORMS &lt;br /&gt;A. Read Mode &lt;br /&gt;PD/PGM = VIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADORESS )&amp;lt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ &lt;br /&gt;lAce' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HIGHZ &lt;br /&gt;OUTPUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;pF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;pF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Limits &lt;br /&gt;Min. Typ.(4) Max. Unit Test Conditions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;250 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;280 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Conditions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V1N =OV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VOUT= OV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;450 ns PD/PGM = CS = VIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;450 ns CS = V1L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;120 ns PD/PGMÂ· VIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100 ns CS= VIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100 ns PD/PGM =VIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ns PD/PGM = CS = VIL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A.C. Test Conditions: &lt;br /&gt;Output Load: 1 TTL gate and CL = 100 pF &lt;br /&gt;Input Rise and Fan Times: ';;20 ns &lt;br /&gt;Input Pulse Levels: 0.8V to 2.2V &lt;br /&gt;Timing Measurement Reference Level: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Inputs 1 V and 2V &lt;br /&gt;Outputs 0.8V and 2V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;gt;&amp;lt; &lt;br /&gt;_'oH_ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ &lt;br /&gt;-'&amp;lt;:0_ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_'0'_ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J DATA OUT VALID , &lt;br /&gt;\\ / &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-3 The timing diagram of AC characteristics of the 2716 EPROM (Courtesy of Intel &lt;br /&gt;Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;address inputs until the appearance of the data at the output connections. This is based on the as-&lt;br /&gt;sumption that the CE input goes low at the same time that the address inputs become stable. &lt;br /&gt;Also, OE must be a logic 0 for the output connections to become active. The basic speed of th &lt;br /&gt;EPROM is 450 ns. (Recall from Chapter 7 that the 8086/8088 operated with a 5 MHz clock al-&lt;br /&gt;lowed memory 460 ns to access data.) This type of memory component requires wait states to &lt;br /&gt;operate properly with the 8086/8088 microprocessors because of its rather long access time. If &lt;br /&gt;wait states are not desired, higher speed versions of the EPROM are available at an additional &lt;br /&gt;cost. Today, EPROM memory is available with access times of as little as 100 ns. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Static Ram (SRAM) Devices &lt;br /&gt;Static RAM memory devices retain data for as long as DC power is applied. Because 110 special ac-&lt;br /&gt;tion (except power) is required to retain stored data, these devices are called static memory. They &lt;br /&gt;are also called volatile memory because they will not retain data without power. The main differ-&lt;br /&gt;ence between a ROM and a RAM is that a RAM is written under normal operation, while a ROM &lt;br /&gt;is programmed outside the computer and is only normally read. The SRAM stores temporary data &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-1 MEMORY DEVICES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-4 The pin-out &lt;br /&gt;of the TMS4016, 2K x 8 static &lt;br /&gt;RAM (SRAM). (Courtesy &lt;br /&gt;of Texas Instruments &lt;br /&gt;Incorporated.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMS4016 .â¢. NL PACKAGE &lt;br /&gt;(TOP VIEW) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;AB &lt;br /&gt;A9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A4 Vi &lt;br /&gt;A3 G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1D &lt;br /&gt;Al S-&lt;br /&gt;AD 008 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007 &lt;br /&gt;006 &lt;br /&gt;005 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vss 004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN NOMENCLATURE &lt;br /&gt;AD - A10 &lt;br /&gt;DQl - DaB &lt;br /&gt;G &lt;br /&gt;~ &lt;br /&gt;Vee &lt;br /&gt;VSS &lt;br /&gt;W &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addresses &lt;br /&gt;Data In/Data Out &lt;br /&gt;Output Enable &lt;br /&gt;Chip Select &lt;br /&gt;+5-V Supply &lt;br /&gt;Ground &lt;br /&gt;Write Enable &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;317 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and is used when the size of the read/write memory is relatively small. Today, a small memory is &lt;br /&gt;one that is less than 1 M byte. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-4 illustrates the 4016 SRAM, which is a 2K x 8 read/write memory. This device &lt;br /&gt;has 11 address inputs and 8 data input/output connections. This device is representative of all &lt;br /&gt;SRAM devices. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The control inputs of this RAM are slightly different from those presented earlier. The OE &lt;br /&gt;pin is labeled G, the CS pin S, and the WE pin W. Despite the altered designations, the control &lt;br /&gt;pins function exactly the same as those outlined previously. Other manufacturers make this pop-&lt;br /&gt;ular SRAM under the part numbers 2016 and 6116. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-5 depicts the timing diagram for. the 4016 SRAM. As the read cycle timing re-&lt;br /&gt;veals, the access time is ta (A). On the slowest version of the 4016, this time is 250 ns, which is &lt;br /&gt;fast enough to connect to an 8088 or an 8086 operated at 5 MHz without wait states. Again, it is &lt;br /&gt;important to remember that the access time must be checked to determine the compatibility of &lt;br /&gt;memory components with the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-6 illustrates the pin-out of the 62256, 32K x 8 static RAM. This device is pack-&lt;br /&gt;aged in a 28-pin integrated circuit, and is available with access times of 120 ns or 150 ns. Other &lt;br /&gt;common SRAM devices are available in 8K x 8 and 128K x 8 sizes with access times of as little &lt;br /&gt;as 10 ns for SRAM used in computer cache memory systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dynamic Ram (DRAM) Memory &lt;br /&gt;About the largest static RAM available today is a l28K x 8. Dynamic RAMs, on the other hand, &lt;br /&gt;are available in much lager sizes: up to 16M x 1. In all other respects, DRAM is essentially the &lt;br /&gt;same as SRAM, except that it retains data for only 2 or 4 ms on an integrated capacitor. After 2 &lt;br /&gt;or 4 ms, the contents of the DRAM must be completely rewritten (refreshed) because the capac-&lt;br /&gt;itors, which store a logic 1 or logic 0, lose their charges. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instead of requiring the almost impossible task of reading the contents of each memory &lt;br /&gt;location with a program and then rewriting them, the manufacturer has internally constructed &lt;br /&gt;the DRAM so that, in the 64K x 1 version, the entire contents of the memory is refreshed with &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;318 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;electrical characteristics ov&amp;amp;r recommended operating free-air temperature range (unless otherwise noted) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PARAMETER TEST CONDITIONS MIN TYPt MAX UNIT &lt;br /&gt;VOH High level voltage IOH--1mA, Vcc =4.5V 2.4 V &lt;br /&gt;VOL Low level voltage IOL =2.1 rnA, Vcc -4.5V 0.4 V &lt;br /&gt;I, Input current V, - 0 V to 5.5 V 10 ~A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;loz OffÂ·state output current &lt;br /&gt;S or G at 2 V or W at 0.8 V, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 J.IA Vo =OVt05.5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Icc Supply current from V cc &lt;br /&gt;lo=OmA, Vcc = 5.5 V, 40 70 rnA T A = OÂ°C (worst case) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C, Input capacitance V,=OV, 1= 1 MHz 8 pF &lt;br /&gt;Co Output capacitance Vo=OV, 1= 1 MHz 12 pF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tAli typical values are at V cc = 5 V, T A = 25Â°C. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;timing requirements over recommended supply voltage range and operating free-air temperature range &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMS4016-12 TMS4016-15 TMS4016-20 TMS4016-25 &lt;br /&gt;UNIT PARAMETER MIN MAX MIN MAX MIN MAX MIN MAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tc(rd) Read cycle time 120 150 200 250 ns &lt;br /&gt;Ic(W') Write cycle time 120 150 200 250 ns &lt;br /&gt;tw(W) Write pulse width 60 80 100 120 ns &lt;br /&gt;tsU(A) Address setup time 20 20 20 20 ns &lt;br /&gt;tSU(S) Chip select setup time 60 80 100 120 ns &lt;br /&gt;tSU(O) Data setup time 50 60 80 100 ns &lt;br /&gt;th(A) Address hold time 0 0 0 0 ns &lt;br /&gt;th(O) Data hold time 5 10 10 10 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;switching characteristics over recommended voltage range, T A = ooe to 70 0 e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMS4016-12 TMS4016-15 TMS4016-20 TMS4016-25 UNIT PARAMETER MIN MAX MIN MAX MIN MAX MIN MAX &lt;br /&gt;la(A) Access time Irom address 120 150 200 250 ns &lt;br /&gt;tarS) Access time Irom chip select low 60 75 100 120 ns &lt;br /&gt;ta(G) Access time Irom output enable low 50 60 80 100 ns &lt;br /&gt;tv(A) Output data valid alter address change 10 15 15 15 ns &lt;br /&gt;Idls(S) Output disable time after chip select high 40 50 60 80 ns &lt;br /&gt;tdlS(G) Output disable time alter output enable high 40 50 60 80 ns &lt;br /&gt;tdls(W) Output disable time alter write enable low 50 60 60 80 ns &lt;br /&gt;tentS) Output enable time alter chip select low 5 5 10 10 ns &lt;br /&gt;ten(G) Output enable time alter output enable low 5 5 10 10 ns &lt;br /&gt;ten(W) Output enable time after write enable high 5 5 10 10 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOTES: 3. CL = 100pF for all measurements except tdIS(W) and ten (W). &lt;br /&gt;CL = 5 pF for tdIS(W) and ten(w)' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. tdls and len parameters are sampled and not 100% lested. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-5 (a) The AC characteristics of the TMS4016 SRAM. (b) The timing diagrams of the TMS4016 &lt;br /&gt;SRAM. (Courtesy of Texas Instruments Incorporated) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;256 reads in a 4 ms intervaL Refreshing also occurs during a write, a read, or during a special re-&lt;br /&gt;fresh cycle. Much more information on refreshing DRAMs is provided in Section 9-6. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another disadvantage of DRAM memory is that it requires so many address pins that the &lt;br /&gt;manufacturers have multiplexed the address inputs. Figure 9-7 illustrates a 64K x 4 DRAM, the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-1 MEMORY DEVICES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;timing waveform of read cycle (see note 5) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDRESS ====&amp;gt;q~ ____________________ ~~~ ______ __ &lt;br /&gt;1&amp;quot;+--- la(A) )0 I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rj 0(0(------ tc(rd) -------))0 .... 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;____________ -, â¢ 1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NI/]l &lt;br /&gt;1 j t 1 ~II(A)~, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 r&amp;quot;I- 'aiG) ---+-1 &lt;br /&gt;S ~'I--, ____ -,t+ __ I_en...;.(G...;.)_~-,; ____ lr~ : 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;! ~I-'I 0Â«(----,--- ta(S) 1 )0 I 1 f+-ttdla(G~--:-; &lt;br /&gt;l .... o(_--ten(S) )0 1 1 ~ dla(S) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_____ I __________________ ~~~~--~!~~e~&amp;quot;~~.~&amp;quot;~&amp;quot;~!~~~ DO(out) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;timing waveform of write cycle no. 1 (see note 6) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1&amp;quot;&amp;quot;&amp;quot;1 tc(wr) )0 I &lt;br /&gt;ADDRESS ~ :x~-:----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 -+j r+- th(A) &lt;br /&gt;G --./! 1 &amp;quot; (see note 8) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 4- Isu(S) -+i L &lt;br /&gt;S ~ (see note 10) Vl:-f7Z'7Z-rZ7Z'7Z-r; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;=tJ 4- tsu(A) ill &lt;br /&gt;(~nO,eS9'13)1 ~ ~A-I----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tdos(G) ~ ~ tW(W) ----+I 1 &lt;br /&gt;1-(seenOle7)-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO(out) ~ ;;:::;;? 1 th(D) &lt;br /&gt;~ts~U(~D~)I~I~' ___ '~1 ~~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO(in) -------&amp;lt;~ po&amp;lt;&amp;gt;&amp;lt;&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;timing waveform of write cycle no. 2 (see notes 6 and 11) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. 0( tc(wr) )0 , &lt;br /&gt;ADDRESS:::X: :x~---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 th(A)I-? ~ (see no'e 8) &lt;br /&gt;S ~:S~~~14i('(T/7227/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r 1 1 &lt;br /&gt;- I I t+-;:: tw(W) :c+-i &lt;br /&gt;W i I'\\SSS\\J (see nole 7) ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.-. t+- tsu(A) -../ (see noles 9, 13)1 ~ : t ~ ! &lt;br /&gt;'IT-:?&amp;quot;'o:7&amp;quot;o . 'o:;i-&amp;lt;:;oo&amp;quot;&amp;quot;\\,...;;7-t::&amp;quot;&amp;quot;&amp;quot;&amp;quot;~~&amp;quot;4-- tdlS(W) I~ en(W) ~ DO(Out)~ I t ......-..J th(D) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SU(01' -I ~(seenole12) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO(in) ~ ~&lt;br /&gt;NOTES. 5. W IS high Read Cycle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. W must be h'gh during all address transitions. &lt;br /&gt;7. A write occurs during the overlap of a low 5 and a low W. &lt;br /&gt;8. th(A) is measured from the earlier of 5 or W going high to the end of the wrote cycle. &lt;br /&gt;g, During this period, 110 pins are in the output state so that the input signals of opposite phase to the outputs must not be applied. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 If the Slow transition occurs simultaneously with the Vii low transitions or after the W transition, output remains In a high impedance state &lt;br /&gt;11. G IS continuously low (G = V ,L). &lt;br /&gt;12. If 5 is low durong thiS period, 110 pins are in the output state. Data input signals of opposite phase to the outputs must not be applied. &lt;br /&gt;13. Transition is measured Â± 200 mV from steadyÂ·state voltage. &lt;br /&gt;14 If the 5 low transition occurs before the W low transition, then the data Input signals of opposite phase to the outputs must not be applied &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;for the duration of tdls(W) after the W low transition. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-5 (continued) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;319 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;320 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-6 Pin diagram &lt;br /&gt;of the 62256, 32K x 8 static &lt;br /&gt;RAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-7 The pin-out &lt;br /&gt;of the TMS4464, 64K x 4 &lt;br /&gt;dynamic RAM (DRAM). &lt;br /&gt;(Courtesy of Texas Instru-&lt;br /&gt;ments Incorportated) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI4 1 28 &lt;br /&gt;AI2 2 27 &lt;br /&gt;A7 3 26 &lt;br /&gt;A6 4 25 &lt;br /&gt;As 5 24 &lt;br /&gt;A4 6 23 &lt;br /&gt;A3 7 22 &lt;br /&gt;A2 8 21 &lt;br /&gt;AI 9 20 &lt;br /&gt;Ao 10 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100 II 18 &lt;br /&gt;10 1 12 17 &lt;br /&gt;102 13 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND 14 IS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN FUNcrlON &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ao â¢ AI4 &lt;br /&gt;100 .107 &lt;br /&gt;CS &lt;br /&gt;OE &lt;br /&gt;WE &lt;br /&gt;Vcc &lt;br /&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMS4464 â¢.. JL OR NL PACKAGE &lt;br /&gt;(TOP VIEW) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOÂ·A7 &lt;br /&gt;CAS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G Vss &lt;br /&gt;OQl OQ4 &lt;br /&gt;DQ2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAS &lt;br /&gt;A6 &lt;br /&gt;A5 &lt;br /&gt;A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CAs &lt;br /&gt;DQ3 &lt;br /&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;&amp;quot;'-_--'-'-.... A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN NOMENCLATURE &lt;br /&gt;Address Inputs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OQ1-0Q4 &lt;br /&gt;Column Address Strobe &lt;br /&gt;OataÂ·ln/Data-Out &lt;br /&gt;Output Enable &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAS &lt;br /&gt;VDD &lt;br /&gt;VSS &lt;br /&gt;iN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Row Address Strobe &lt;br /&gt;+5-V Supply &lt;br /&gt;Ground &lt;br /&gt;Write Enable &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vcc &lt;br /&gt;WE &lt;br /&gt;An &lt;br /&gt;As &lt;br /&gt;A9 &lt;br /&gt;All &lt;br /&gt;OE &lt;br /&gt;AIO &lt;br /&gt;CS &lt;br /&gt;107 &lt;br /&gt;106 &lt;br /&gt;lOs &lt;br /&gt;104 &lt;br /&gt;103 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addresses &lt;br /&gt;Data connections &lt;br /&gt;Chip select &lt;br /&gt;Output enable &lt;br /&gt;Write enable &lt;br /&gt;+5V Supply &lt;br /&gt;Ground &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-1 MEMORY DEVICES 321 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOÂ· A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-8 RAS, CAS, and address input timing for the TMS4464 DRAM (Courtesy of Texas &lt;br /&gt;Instruments Incorporated) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMS4464, which stores 256K bits of data. Notice that it contains only 8 address inputs where it &lt;br /&gt;should contain 16-the number required to address 64K memory locations. The only way that &lt;br /&gt;16 address bits can be forced into 8 address pins is in two 8-bit increments. This operation re-&lt;br /&gt;quires two special pins called column address strobe (CAS) and row address strobe (RAS). &lt;br /&gt;First, Ao-A7 are placed on the address pins and strobed into an internal row latch by RAS as the &lt;br /&gt;row address. Next, the address bits AS-AI'i are placed on the same eight address inputs and &lt;br /&gt;strobed into an internal column latch by CAS as the column address (see Figure 9-8 for this &lt;br /&gt;timing). The 16-bit address held in these internal latches addresses the contents of one of the 4-&lt;br /&gt;bit memory locations. Note that CAS also performs the function of the chip selection input to &lt;br /&gt;the DRAM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-9 illustrates a set of multiplexers used to strobe the column and row addresses &lt;br /&gt;into the eight address inputs of a pair of TMS4464 DRAMs. Here the RAS not only strobes the &lt;br /&gt;row address into the DRAMs, but it also changes the address applied to the address inputs. This &lt;br /&gt;is possible due to the long propagation delay time of the multiplexers. When RAS is a logic 1, &lt;br /&gt;the B inputs are connected to the Y outputs of the multiplexers; when the RAS input goes to a &lt;br /&gt;logic 0, the A inputs connect to the Y outputs. Because the internal row address latch is edge-&lt;br /&gt;triggered, it captures the row address before the address at the inputs change to the column ad-&lt;br /&gt;dress. More detail on DRAM and DRAM interfacing is provided in Section 9-6. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with the SRAM, the R/W pin writes data to the DRAM when a logic 0, but there is no &lt;br /&gt;pin labeled G or enable. There also is no S (select) input to the DRAM. As mentioned, the CAS &lt;br /&gt;input selects the DRAM. If selected, the DRAM is written if R/W = 0 and read if R/W = 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-10 shows the pinout of the 41256 dynamic RAM. This device is organized as a &lt;br /&gt;256K x 1 memory requiring as little as 70 ns to access data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;More recently, larger DRAMs have become available that are organized as a 1M x I &lt;br /&gt;memory,4M x 1, and 16M x 1. On the horizon is the 256M x I memory, which is in the plan-&lt;br /&gt;ning stages. Because DRAM memory is usually placed on small circuit boards called SIMMs, &lt;br /&gt;Figure 9-11 shows the pin-outs of the two most common SIMMs (Single In-line Memory Mod-&lt;br /&gt;ules). The 30-pin SIMM is organized most often as 1M x 8 or 1M x 9 and 4M x 8 or 4M x 9. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;322 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-9 Address multi-&lt;br /&gt;plexer for the TMS4464 Ao &lt;br /&gt;DRAM As &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI &lt;br /&gt;A9 &lt;br /&gt;A2 &lt;br /&gt;Aw &lt;br /&gt;A3 &lt;br /&gt;All &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IA &lt;br /&gt;18 &lt;br /&gt;2A &lt;br /&gt;28 &lt;br /&gt;3A &lt;br /&gt;38 &lt;br /&gt;4A &lt;br /&gt;48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IA &lt;br /&gt;18 &lt;br /&gt;2A &lt;br /&gt;28 &lt;br /&gt;3A &lt;br /&gt;38 &lt;br /&gt;4A &lt;br /&gt;48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IY Ao &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 2Y 4 &lt;br /&gt;I &lt;br /&gt;5 3Y 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4Y &lt;br /&gt;S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;IY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 2Y 4 A~ &lt;br /&gt;I &lt;br /&gt;5 3Y 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4Y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Illustrated in Figure 9-11 is a 4M x 9.) The ninth bit is the parity bit. Also shown is the newer &lt;br /&gt;72-pin SIMM. The 72-pin SIMMs are often organized as 1M x 32 or 1M x 36 (with parity). &lt;br /&gt;Other sizes are 2M x 32, 4M x 32 or 8M x 32. These are also available with parity. Illustrated in &lt;br /&gt;Figure 9-11 is a 4M x 36 SIMM, which has 16M bytes of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-10 The 41256 &lt;br /&gt;dynamic RAM organized as &lt;br /&gt;a 256K x 1 memory device &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ao -As &lt;br /&gt;Din &lt;br /&gt;Doul &lt;br /&gt;CAS &lt;br /&gt;RAS &lt;br /&gt;WR &lt;br /&gt;Vee &lt;br /&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As &lt;br /&gt;Din &lt;br /&gt;WR &lt;br /&gt;RAS &lt;br /&gt;Ao &lt;br /&gt;A2 &lt;br /&gt;AI &lt;br /&gt;Vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 GND &lt;br /&gt;2 15 CAS &lt;br /&gt;3 14 Dout &lt;br /&gt;4 13 A6 &lt;br /&gt;5 12 A3 &lt;br /&gt;6 II A4 &lt;br /&gt;7 \\0 As &lt;br /&gt;8 9 A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN FUNcrIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Addresses &lt;br /&gt;Dalain &lt;br /&gt;Dalaout &lt;br /&gt;Column Address Strobe &lt;br /&gt;Row Address Sirobe &lt;br /&gt;Wrileenable &lt;br /&gt;+5V Supply &lt;br /&gt;Ground &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-1 MEMORY DEVICES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;(TDPVlEW) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;Vee 1 &lt;br /&gt;CAS 2 CJ 001 3 AO 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1 5 CJ 002 6 A2 7 &lt;br /&gt;A3 8 CJ VSS 9 003 10 &lt;br /&gt;A4 11 CJ A5 12 004 13 A6 14 CJ A7 15 005 16 A8 17 CJ A9 18 A10 19 006 20 &lt;br /&gt;Vii 21 CJ Vss 22 DO? 23 &lt;br /&gt;NC 24 CJ 008 25 09 26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAS 27 CJ CAS9 28 09 29 &lt;br /&gt;Vee 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vss &lt;br /&gt;DOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D016 &lt;br /&gt;DOl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DQ17 &lt;br /&gt;D02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D018 &lt;br /&gt;D03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D019 &lt;br /&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NC &lt;br /&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al0 &lt;br /&gt;D04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D020 &lt;br /&gt;DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D021 &lt;br /&gt;D06 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D022 &lt;br /&gt;D07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D023 &lt;br /&gt;A7 &lt;br /&gt;NC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;NC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAS2 &lt;br /&gt;NC &lt;br /&gt;NC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NC &lt;br /&gt;NC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Y.M... &lt;br /&gt;CASO &lt;br /&gt;CAS2 &lt;br /&gt;CAS3 &lt;br /&gt;CASl &lt;br /&gt;RASO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NC &lt;br /&gt;NC &lt;br /&gt;W &lt;br /&gt;NC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D08 &lt;br /&gt;D024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D09 &lt;br /&gt;0025 &lt;br /&gt;DOlO &lt;br /&gt;D026 &lt;br /&gt;DOll &lt;br /&gt;D027 &lt;br /&gt;D012 &lt;br /&gt;D028 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vee &lt;br /&gt;D029 &lt;br /&gt;D013 &lt;br /&gt;D030 &lt;br /&gt;D014 &lt;br /&gt;D031 &lt;br /&gt;D015 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NC &lt;br /&gt;PDl &lt;br /&gt;PD2 &lt;br /&gt;PD3 &lt;br /&gt;PD4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NC &lt;br /&gt;Vss &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L:::) 1 &lt;br /&gt;L:::) 2 &lt;br /&gt;L:::) 3 &lt;br /&gt;L:::) 4 &lt;br /&gt;L:::) 5 &lt;br /&gt;L:::) 6 &lt;br /&gt;L:::) 7 &lt;br /&gt;L:::) 8 &lt;br /&gt;L:::) 9 &lt;br /&gt;L:::) 10 &lt;br /&gt;L:::) 11 &lt;br /&gt;L:::) 12 &lt;br /&gt;L:::) 13 &lt;br /&gt;L:::) 14 &lt;br /&gt;L:::) 15 &lt;br /&gt;L:::) 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- L:::) 17 &lt;br /&gt;L:::) 18 &lt;br /&gt;L:::) 19 &lt;br /&gt;L:::) 20 &lt;br /&gt;L:::) 21 &lt;br /&gt;L:::) 22 &lt;br /&gt;L:::) 23 &lt;br /&gt;L:::) 24 &lt;br /&gt;L:::) 25 &lt;br /&gt;L:::) 26 &lt;br /&gt;L:::)27 &lt;br /&gt;L:::)28 &lt;br /&gt;L:::) 29 &lt;br /&gt;L:::)30 &lt;br /&gt;L:::)31 &lt;br /&gt;L:::) 32 &lt;br /&gt;L:::) 33 &lt;br /&gt;L:::)34 &lt;br /&gt;L:::) 35 &lt;br /&gt;L:::) 36 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L:::) 37 &lt;br /&gt;L:::) 38 &lt;br /&gt;L:::) 39 &lt;br /&gt;L:::)40 &lt;br /&gt;L:::)41 &lt;br /&gt;L:::)42 &lt;br /&gt;L:::)43 &lt;br /&gt;L:::)44 &lt;br /&gt;L:::)45 &lt;br /&gt;L:::) 46 &lt;br /&gt;L:::) 47 &lt;br /&gt;L:::)48 &lt;br /&gt;L:::) 49 &lt;br /&gt;L:::)so &lt;br /&gt;L:::) 51 &lt;br /&gt;L:::) 52 &lt;br /&gt;L:::) 53 &lt;br /&gt;L:::) 54 &lt;br /&gt;L:::) 55 &lt;br /&gt;L:::) 56 &lt;br /&gt;L:::) 57 &lt;br /&gt;L:::) 58 &lt;br /&gt;L:::) 59 &lt;br /&gt;L:::)60 &lt;br /&gt;L:::) 61 &lt;br /&gt;L:::) 62 &lt;br /&gt;L:::)63 &lt;br /&gt;L:::)64 &lt;br /&gt;L:::)65 &lt;br /&gt;L:::) 66 &lt;br /&gt;L:::) 67 &lt;br /&gt;L:::) 68 &lt;br /&gt;L:::) 69 &lt;br /&gt;L:::) 70 &lt;br /&gt;L:::) 71 &lt;br /&gt;L:::) 72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;(TOP VIEW) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-11 The pin-outs of the 30-pin and 72-pin SIMM. (a) A 30-pin SIMM organized as 4M x 9 and (b) a &lt;br /&gt;72-pin SIMM organized as 4M x 36. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;323 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;324 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDRESS DECODING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to attach a memory device to the microprocessor, it is necessary to decode the address &lt;br /&gt;from the microprocessor to make the memory function at a unique section or partition of the &lt;br /&gt;memory map. Without an address decoder, only one memory device can be connected to a micro-&lt;br /&gt;processor, which would make it virtually useless. In this section, we describe a few of the more &lt;br /&gt;common address-decoding techniques, as weIl as the decoders that are found in many systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Why Decode Memory? &lt;br /&gt;When the 8088 microprocessor is compared to the 2716 EPROM, a difference in the number of &lt;br /&gt;address connections surfaces-the EPROM has 11 address connections and the microprocessor &lt;br /&gt;has 20. This means that the microprocessor sends out a 20-bit memory address whenever it reads &lt;br /&gt;or writes data. Since the EPROM has only 11 address inputs, there is a mismatch that must &lt;br /&gt;somehow be corrected. If only 11 of the 8088's address pins are connected to the memory, then &lt;br /&gt;the 8088 will see only 2K bytes of memory instead of the 1 M byte that it &amp;quot;expects&amp;quot; the memory &lt;br /&gt;to contain. The decoder corrects the mismatch by decoding the address pins that do not connect &lt;br /&gt;to the memory component. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Simple Nand Gate Decoder &lt;br /&gt;When the 2K x 8 EPROM is used, address connections AIO-AO of the 8088 are connected to ad-&lt;br /&gt;dress inputs AIO-AO of the EPROM, and the remaining nine address pins (AI9-AIl ) are con-&lt;br /&gt;nected to the inputs of a NAND gate decoder (see Figure 9-12). The decoder selects the EPROM &lt;br /&gt;from one of the many 2K byte sections of the entire 1M byte address range of the 8088 micro-&lt;br /&gt;processor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this circuit, a single NAND gate decodes the memory address. The output of the NAND &lt;br /&gt;gate is a logic 0 whenever the 8088 address pins attached to its inputs (A'9-A,,) are all logic 1 's. &lt;br /&gt;The active low, logic 0 output of the NAND gate decoder is connected to the CE input, which &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A,. -----1 &lt;br /&gt;A,. -----1 &lt;br /&gt;A,7 -----1 &lt;br /&gt;A,.-----I &lt;br /&gt;A,,----...., &lt;br /&gt;A,. -----I &lt;br /&gt;A,,---&lt;br /&gt;A,~-----I &lt;br /&gt;All -----I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J(&amp;gt;M~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 Addre&amp;quot; &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;AliI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2716 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;0 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80tHl &lt;br /&gt;Data &lt;br /&gt;bl&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-12 A simple NAND gate decoder used to select a 2716 EPROM memory compo-&lt;br /&gt;nent for memory locations FF800H-FFFFFH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-2 ADDRESS DECDDING 325 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;selects (enables) the EPROM. Recall that whenever CE is a logic 0, data will be read from the &lt;br /&gt;EPROM only if OE is also a logic O. The OE pin is activated by the 8088 RD signal or the &lt;br /&gt;MRDC (memory read control) signal of other family members. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the 20-bit binary address, decoded by the NAND gate, is written so the leftmost 9 bits &lt;br /&gt;are I's and the rightmo~t II bits are don't cares (X), the actual address range of the EPROM can &lt;br /&gt;be determined. (A don't care is a logic I or a logic 0, whichever is appropriate.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 9-1 illustrates how the address range for this EPROM is determined by writing &lt;br /&gt;down the externally decoded address bits (A'9-A,,) and the address bits decided by rhe EPROM &lt;br /&gt;(Aw-Ao) as don't cares. As the example illustrates, the don't cares are first written as O's to lo-&lt;br /&gt;cate the lowest address and then as l's to find the highest address. Example 9-1 also shows these &lt;br /&gt;binary boundaries as hexadecimal addresses. Here the 2K EPROM is decoded at memory ad-&lt;br /&gt;dress locations FF800H-FFFFFH. Notice that this is a 2K-byte section of the memory and is also &lt;br /&gt;located at the reset location for the 8086/8088, the most likely place for an EPROM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-1 &lt;br /&gt;1111 1111 1XXX XXXX XXXX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 1111 1000 0000 0000 FF800H &lt;br /&gt;to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 1111 1111 1111 1111 FFFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Although this example serves to illustrate decoding, NAND gates are rarely used to decode &lt;br /&gt;memory because each memory device requires its own NAND gate decoder. Because of the ex-&lt;br /&gt;cessive cost of the NAND gate decoder and of the inverters that are often required, this option re-&lt;br /&gt;quires that an alternate be found. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 3-to-8 Line Decoder (74LS138) &lt;br /&gt;One of the more common, although not only, integrated circuit decoders found in many micro-&lt;br /&gt;processor-based systems is the 74LS 138 3-to-8 line decoder. Figure 9-13 illustrates this decoder &lt;br /&gt;and its truth table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The truth table shows that only one of the eight outputs ever goes low at any time. For any &lt;br /&gt;of the decoder's outputs to go low, the three enable inputs (G2A, G2B, and G1) must all be ac-&lt;br /&gt;tive. To be active, the G2A and G2B inputs must both be low (logic 0), and G I must be high &lt;br /&gt;(logic I). Once the 74LS138 is enabled, the address inputs (C, B, and A) select which output pin &lt;br /&gt;goes low. Imagine eight EPROM CE inputs connected to the eight outputs of the decoder! This &lt;br /&gt;is a very powerful device because it selects eight different memory devices at the same time. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sample Decoder Circuit. Notice that the outputs of the decoder illustrated in Figure 9-14 are &lt;br /&gt;connected to eight different 2764 EPROM memory devices. Here the decoder selects eight 8K-&lt;br /&gt;byte blocks of memory for a total of 64K bytes of memory. This figure also illustrates the ad-&lt;br /&gt;dress range of each memory device and the common connections to the memory devices. Notice &lt;br /&gt;that all of the address connections from the 8088 are connected to this circuit. Also notice that &lt;br /&gt;the decoder's outputs are connected to the CE inputs of the EPROMs, and the RD signal from &lt;br /&gt;the 8088 is connected to the OE inputs of the EPROMs. This allows only the selected EPROM &lt;br /&gt;to be enabled and to send its data to the microprocessor through the data bus whenever RD be-&lt;br /&gt;comes a logic O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this circuit, a 3-input NAND gate is connected to address bits A'9-A'7' When all three &lt;br /&gt;address inputs are high, the output of this NAND gate goes low and enables input G2B of the &lt;br /&gt;74LS 138. Input G I is connected directly to AI6' In other words, in order to enable this decoder, &lt;br /&gt;the first four address connections (A'9-A'6) must all be high. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;326 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-13 The &lt;br /&gt;74LS138, 3-to-8Iine decoder &lt;br /&gt;and function table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;B &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'I3X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ G2A &lt;br /&gt;r&amp;lt; G2B GI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;...--~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selection { &lt;br /&gt;Input~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Enable { &lt;br /&gt;Inpuh &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AJdre&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;B &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'G2A &lt;br /&gt;G2B &lt;br /&gt;GI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Input~ &lt;br /&gt;Enable Select &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OY G~~ G{C B A &lt;br /&gt;I X X X X X &lt;br /&gt;X I X X X X &lt;br /&gt;X X 0 X X X &lt;br /&gt;0 0 I () () () &lt;br /&gt;() 0 I 0 () I &lt;br /&gt;() 0 I 0 I 0 &lt;br /&gt;0 0 I () I I &lt;br /&gt;0 () I I 0 0 &lt;br /&gt;n 0 I I 0 I &lt;br /&gt;() () I I I 0 &lt;br /&gt;n 0 I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;... A&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;I &lt;br /&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LSI38 3 &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;6 &lt;br /&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Outputs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;() I 2 3 4 5 6 7 &lt;br /&gt;I I I I I I I I &lt;br /&gt;I I I I I I I I &lt;br /&gt;I I I I I I I I &lt;br /&gt;() I I I I I I I &lt;br /&gt;I 0 I I I I I I &lt;br /&gt;I I () I I I I I &lt;br /&gt;I I I 0 I I I I &lt;br /&gt;I I I I () I I I &lt;br /&gt;I I I I I 0 I I &lt;br /&gt;I I I I I I 0 I &lt;br /&gt;I I I I I I I 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&amp;gt; V A,~ '-&lt;br /&gt;A 0&amp;quot; 2764 I--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dalll t -&lt;br /&gt;0 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD---c OE &lt;br /&gt;() FOOOOÂ· FIFFF CE &lt;br /&gt;I F2()OO() . F3FFF CE &lt;br /&gt;2 F40()O - F5FFF CE &lt;br /&gt;3 F6()()() - F7FFF CE &lt;br /&gt;4 F80()O - F9FFF CE &lt;br /&gt;5 FAOOO - FRFFF CE &lt;br /&gt;6 FeOOO â¢ FDFFF ..J CE &lt;br /&gt;7 FEnnOÂ· FFFFF CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Outputs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-14 A circuit that uses eight 2764 EPROMs for a 64K x 8 section of memory in an &lt;br /&gt;8088 microprocessor-based system. The addresses selected in this circuit are &lt;br /&gt;FOOOOH-FFFFFH. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-2 ADDRESS DECODING 327 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address inputs C, B, and A connect to microprocessor address pins A I5-A I3. These &lt;br /&gt;three address inputs determine which output pin goes low and which EPROM is selected when-&lt;br /&gt;ever the 8088 outputs a memory address within this range to the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 9-2 shows how the address range of the entire decoder is determined. Notice that &lt;br /&gt;the range is location FOOOOH-FFFFFH. This is a 64K-byte span of the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-2 &lt;br /&gt;1111 XXXX XXXX XXXX XXXX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 0000 0000 0000 0000 FOOOOH &lt;br /&gt;to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 1111 1111 1111 1111 FFFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;How is it possible to determine the address range of each memory device attached to the &lt;br /&gt;decoder's outputs? Again, the binary bit pattern is written down, and this time the C, B, and A &lt;br /&gt;address inputs are not don't cares. Example 9-3 shows how output 0 of the decoder is made to go &lt;br /&gt;low to select the EPROM attached to that pin. Here C, B, and A are shown as logic O's. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-3 &lt;br /&gt;CBA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 OOOX XXXX XXXX XXXX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 0000 0000 0000 0000 FOOOOH &lt;br /&gt;to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 0001 1111 1111 1111 F1FFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the address range of the EPROM connected to output 1 of the decoder is required, it is de-&lt;br /&gt;termined in exactly the same way as that of output O. The only difference is that now the C, B, and A &lt;br /&gt;inputs contain a 001 instead of a 000 (see Example 9-4). The remaining output address ranges are &lt;br /&gt;determined in the same manner by substituting the binary address of the output pin into C, B, and A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-4 &lt;br /&gt;CBA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 001X XXXX XXXX XXXX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 0010 0000 0000 0000 F2000H &lt;br /&gt;to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111 0011 1111 1111 1111 F3FFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The DuaI2-to-4 Line Decoder (74LS139) &lt;br /&gt;Another decoder that finds some application is the 74LS 139 dual 2-to-41ine decoder. Figure 9-15 &lt;br /&gt;illustrates both the pin-out and the truth table for this decoder. The 74LS139 contains two sepa-&lt;br /&gt;rate 2-to-4 line decoders-each with its own address, enable, and output connections. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROM Address Decoder &lt;br /&gt;Another once-common address decoder is the bipolar PROM, used because of its larger number &lt;br /&gt;of input connections, which reduces the number of other circuits required in a system memory &lt;br /&gt;address decoder. The 74LS138 decoder has six inputs used for address connections. The PROM &lt;br /&gt;decoder may have many more inputs for address decoding. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;328 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-15 The pin-out &lt;br /&gt;and truth table of the 74LS139, &lt;br /&gt;dual 2-to-4 line decoder Scicl:lion J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mpUI' 1 &lt;br /&gt;IA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LSI39 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IYo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EnaoJc &lt;br /&gt;input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selectiun I &lt;br /&gt;tnpUb &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Enable &lt;br /&gt;input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IE &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;() &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;() &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;() &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IB IY, &lt;br /&gt;IY, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dutput, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IE IY, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2A 2Yo &lt;br /&gt;2B 2Y, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2Y, &lt;br /&gt;Dutput, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2E 2Y, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Input' Dutputs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A B Yo V. Y2 Y3 &lt;br /&gt;0 0 0 I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;() I I (J I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I 0 I I 0 I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I () &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;X X I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, the 82S147 (512 x 8) PROM used as an address decoder has 10 input con-&lt;br /&gt;nections and 8 output connections. It can replace the circuit in Figure 9-14 without the extra 3-&lt;br /&gt;input NAND gate. This saves space on the printed circuit board and reduces the cost of a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-16 illustrates this address decoder with the PROM in place. The PROM is a &lt;br /&gt;memory device that must be programmed with the correct binary bit pattern to select the eight &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ Ao '-Address / t '-&lt;br /&gt;A&amp;quot; r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; 2764 0.(1 -&lt;br /&gt;Data t f- f-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;0., &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f-Rb--c DE &lt;br /&gt;~, Do FOOOO - FIFFF CE &lt;br /&gt;A, F2000 - F3FFF 0., CE A, &lt;br /&gt;A., 0., F4000 - F5FFF CE &lt;br /&gt;A4 0, F6000 - F7FFF CE &lt;br /&gt;A5 0.4 FHOOO - F9FFF CE &lt;br /&gt;A&amp;quot; FAOOO - FBFFF 0., CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- A7 FCOOO - FDFFF &lt;br /&gt;t-- A, 0.&amp;quot; CE &lt;br /&gt;I-(l G 0., FEOOO - FFFFF CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-16 A memory system using the TPB28L42, 512 x 8 PROM as an address &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;TABLE 9-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE A8 &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;all other &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-2 ADDRESS DECODING 329 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 828147 PROM programming pattern for the circuit of Figure 9-16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Inputs Outputs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A7 A6 A5 A4 A3 A2 Ai AO 00 01 02 03 04 05 06 07 &lt;br /&gt;0 1 0 0 0 0 1 &lt;br /&gt;0 0 0 1 0 1 &lt;br /&gt;0 0 0 0 1 &lt;br /&gt;0 0 1 1 0 1 &lt;br /&gt;0 0 0 0 &lt;br /&gt;0 0 0 1 &lt;br /&gt;0 0 0 1 &lt;br /&gt;0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;combinations &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EPROM memory devices. The PROM itself has nine address inputs that select one of the 512 in-&lt;br /&gt;ternal 8-bit memory locations. The remaining input (CE) must be grounded because if this &lt;br /&gt;PROM's outputs float to their high-impedance state, then one or more of the EPROMs might be &lt;br /&gt;selected by noise impulses in the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 9-1 illustrates the binary bit pattern programmed into each PROM location in order to &lt;br /&gt;select the eight different EPROMs. The main advantage to using a PROM is that the address map is &lt;br /&gt;easily changed in the field. Because the PROM comes with all the locations programmed as logic &lt;br /&gt;1 's, only 8 of the 512 locations must be programmed. This saves valuable time for the manufacturer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PLD Programmable Decoders &lt;br /&gt;This section of the text explains the use of the programmable logic device or PLD as a decoder. &lt;br /&gt;Recently, the PAL has replaced PROM address decoders in the latest memory interfaces. There &lt;br /&gt;are three PLD devices that function in basically the same manner, but have different names: PLA &lt;br /&gt;(programmable logic array), PAL (programmable array logic), and GAL (gated array &lt;br /&gt;logic). Although these devices have been in existence since the mid-1970s, they have only re-&lt;br /&gt;cently appeared in memory systems and digital designs. The PAL and the PLA are fuse pro-&lt;br /&gt;grammed, as is the PROM, and some PLD devices are erasable, as are EPROMs. In essence, all &lt;br /&gt;three devices are arrays of logic elements that are programmable. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Combinatorial Programmable Logic Arrays. One of the two basic types of PALs is the combina-&lt;br /&gt;torial programmable logic array. This device is internally structured as a programmable array of &lt;br /&gt;combinational logic circuits. Figure 9-17 illustrates the internal structure of the PAL 16L8 that is &lt;br /&gt;constructed with AND/OR gate logic. This device, which is very common, has 10 fixed inputs, &lt;br /&gt;2 fixed outputs, and 6 pins that are programmable as inputs or outputs. Each output pin is gener-&lt;br /&gt;ated from a 7-input OR gate that has an AND gate attached to each input. The outputs of the OR &lt;br /&gt;gates pass through a three-state inverter that defines each out as an AND/NOR function. Ini-&lt;br /&gt;tially, all of the fuses connect all of the vertical/horizontal connections illustrated in Figure 9-17. &lt;br /&gt;Programming is accomplished by blowing fuses to connect various inputs to the OR gate array. &lt;br /&gt;The wired-AND function is performed at each input connection that allows a product term of up &lt;br /&gt;to 16 inputs. A logic expression using the P AL16L8 can have 7 product terms with 16 inputs &lt;br /&gt;NORed together to generate the output expression. This device is ideal as a memory address de-&lt;br /&gt;coder because of its structure. It is also ideal because the outputs are active low. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fortunately, we don't have to choose the fuses by number for programming, as was cus-&lt;br /&gt;tomary when this device was first introduced. Today we program the PAL using a software &lt;br /&gt;package such as PALASM, the PAL assembler program. The PALASM program and its syntax &lt;br /&gt;are an industry standard for programming PAL devices. Example 9-5 shows a program that de-&lt;br /&gt;codes the same areas of memory as decoded in Figure 9-16. Note that this program was developed &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;330 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOllie Diagram 16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o I ::! , 4 ~ (:0 7 K 910 II 12 I:&amp;quot; 14 15 16171H 19 20212:!2J 24252627 28293031 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;gt;---d I 2 3 19 4 5 &lt;br /&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 1--&lt;br /&gt;..... .... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 ~ 9 10 II Ik 12 13 &amp;gt;---' I. &amp;quot; J.t &lt;br /&gt;..... .... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 q~ 17 18 ~8 17 21 22 if' 23 &lt;br /&gt;..... .... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. ~ 25 2. 27 16 ~ rI ~ ~ &lt;br /&gt;..... .... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32 ~ 33 34 35 15 36 ~~ 39 ~ &lt;br /&gt;..... ..... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40 ~ 41 42 43 ~ :=1 14 44 45 4. e.47 &lt;br /&gt;--4. &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.... .... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48 ~ 49 50 51 ='1:=1 13 52 53 54 ~ 55 &lt;br /&gt;8 &amp;quot;&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.... .... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;56 ~ 57 58 59 ~ 12 60 t~  &lt;br /&gt;63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---; &amp;quot;&amp;quot; &lt;br /&gt;4 II .... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0123 4567 891011 12131415 16171819 20212223 24252627 28293031 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-17 The PAL 16L8 (Copyright Advanced Micro Devices, Inc., 1988. Reprinted with &lt;br /&gt;permission of copyright owner. All rights reserved.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;using a text editor such as EDIT, available with Microsoft DOS version 7.0 or Notepad. in Win-&lt;br /&gt;dows 95. The program can also be developed using an editor than comes with the PALASM &lt;br /&gt;package or any other PAL assembler program. Various editors attempt to ease the task of &lt;br /&gt;defining the pins, but we believe it is easier to use EDIT and the listing as shown. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-5 &lt;br /&gt;TITLE &lt;br /&gt;PATTERN &lt;br /&gt;REVISION &lt;br /&gt;AUTHOR &lt;br /&gt;COMPA..'ilY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address Decoder &lt;br /&gt;Test 1 &lt;br /&gt;A &lt;br /&gt;Barry B. Brey &lt;br /&gt;BreyCo &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-2 ADDRESS DECODING 331 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATE 6/6/96 &lt;br /&gt;CHIP DECODER1 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;A19 A18 A17 A16 A15 A14 A13 NC NC GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;NC 08 07 06 05 04 03 02 01 VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101 A19 * A18 * A17 * A16 * IA15 * IA14 * IA13 &lt;br /&gt;102 A19 A18 * A17 * A16 * IA15 * IA14 * AD &lt;br /&gt;103 A19 * A18 * A17 * A16 * IA15 * A14 * IA13 &lt;br /&gt;104 A19 * A18 * A17 * A16 * IA15 * IA14 * A13 &lt;br /&gt;105 A19 * A18 * A17 * A16 * A15 * IA14 * lAD &lt;br /&gt;106 A19 * A18 * A17 * A16 * A15 * A14 * A13 &lt;br /&gt;107 A19 * A18 * A17 * A16 * A15 * IA14 * IA13 &lt;br /&gt;108 A19 * A18 * A17 * A16 * A15 * IA14 * Al3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first eight lines of the program illustrated in Example 9-5 identify the program title, &lt;br /&gt;pattern, revision, author, company, date, and chip type with the program name. Although it is &lt;br /&gt;normal to find entries in each heading, the only entry that is absolutely necessary is the CHIP &lt;br /&gt;statement. In this example, the chip type is a PAL16L8 and the program is called DECODERl. &lt;br /&gt;After the program is identified, a comment statement (;pins) identifies the pin numbers. Below &lt;br /&gt;this comment statement appears the pins as defined for this application. Once all the pins are de-&lt;br /&gt;fined, we use the EQUATIONS statement to indicate that the equations for this application &lt;br /&gt;follow. In this example, the equations define the eight chip enable outputs for the eight EPROM &lt;br /&gt;memory devices. Refer to Figure 9-18 for the complete schematic diagram of this PAL decoder. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FQOOOH - F1 FFFH F2000H - F3FFFH F4000H - FSFFFH F6000H - F7FFFH &lt;br /&gt;A12-M-------------r-----------------,-----------------,-----------------, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D7-DO-------------t---------------,-+---------------,-;----------------r-r---~--------__, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~----------~~~ &lt;br /&gt;A19 1 &lt;br /&gt;AlB &lt;br /&gt;A17 &lt;br /&gt;A16 &lt;br /&gt;A1S &lt;br /&gt;A14 &lt;br /&gt;A13 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-18 A PAL 16L8 that decodes 8 2764 (8K x 8) memory devices &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lK &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;332 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note that each equation specifies one of the active low output pins as defined by the I in &lt;br /&gt;front of the pin name-e.g .â¢ IO I is used in place of 01. We normally place an over-bar on top of &lt;br /&gt;an active low output. but that is not possible when typing. so the slash in front of a pin name is &lt;br /&gt;used to indicate active low outputs. In this example. all outputs are active low because of the &lt;br /&gt;PAL 16L8. which has only active low outputs. Other PAL devices are available with active high &lt;br /&gt;outputs. if needed. Normally. all pins are defined before the equation statement as active high. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Logic symbols used in PAL equations include the * for the AND operation and the + for &lt;br /&gt;the OR operation. This example only illustrates AND operations. If a single input is inverted, the &lt;br /&gt;I is placed in front of the pin name. If a group must be inverted. a slash is placed in front of the &lt;br /&gt;group that is surrounded by parentheses-e.g .â¢ /(A + B) is the same as A+B. the NOR function. &lt;br /&gt;A NAND function would then be I(A * B) which is the same as A*B. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Let us examine the very first equation in Example 9-5. The output pin 101 is active low, &lt;br /&gt;which means that it becomes a logic O. enabling the EPROM in Figure 9-18 when the equation, &lt;br /&gt;on the other side of the equal sign. is true. The equation for this output contains a number of in-&lt;br /&gt;puts that are ANDed together. In this example. when A19â¢ Als' A17â¢ and AI6 are all ones while &lt;br /&gt;A 15â¢ A I.p and AI3 are all low. the output pin 101 becomes a logic O. This binary number corre-&lt;br /&gt;sponds to memory locations FOOOOH-FIFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 AND 80188 (8-BIT) MEMORY INTERFACE &lt;br /&gt;This text contains separate sections on memory interfacing for the 8088 and 80188 with their &lt;br /&gt;8-bit data buses; the 8086. 80186. 80286. and 80386SX with their 16-bit data buses; the &lt;br /&gt;80386DX and 80486 with their 32-bit data buses; and the Pentium and Pentium Pro with their &lt;br /&gt;64-bit data buses. Separate sections are provided because the methods used to address the &lt;br /&gt;memory are slightly different in microprocessors that contain different data bus widths. Hard-&lt;br /&gt;ware engineers or technicians who wish to broaden their expertise in interfacing 16-bit, 32-bit, &lt;br /&gt;and 64-bit memory interface should cover all sections. This section is much more complete than &lt;br /&gt;the section on the 16- and 32-bit memory interface. which covers only material not covered in &lt;br /&gt;the 8088/80188 section. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this section. we examine the memory interface to both RAM and ROM and explain &lt;br /&gt;parity checking. which is still commonplace in many microprocessor-based computer sys-&lt;br /&gt;tems. We also briefly mention error correction schemes currently available to memory system &lt;br /&gt;designers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Basic 8088/80188 Memory Interface &lt;br /&gt;Both the 8088 and 80188 microprocessors have an 8-bit data bus, which makes it ideal to con-&lt;br /&gt;nect to the common 8-bit memory devices available today. The 8-bit memory size makes the &lt;br /&gt;8088 and especially the 80188 ideal as a simple controller. For the 8088/80188 to function cor-&lt;br /&gt;rectly with the memory. however, the memory system must decode the address to select a &lt;br /&gt;memory component. and it must use the RD. WR. and 101M control signals provided by the &lt;br /&gt;8088/80188 to control the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The minimum mode configuration is used in this section and is essentially the same as the &lt;br /&gt;maximum mode system for memory interface. The main difference is that. in maximum mode. &lt;br /&gt;101M is combined with RD to generate an MRDC signal. and 101M is combined with WR to &lt;br /&gt;generate an MWTC signal. These maximum mode control signals are developed inside the 8288 &lt;br /&gt;bus controller. In the minimum mode. the memory sees the 8088 or the 80188 as a device with &lt;br /&gt;20 address connections (A I9-Ao)' 8 data bus connections( AD7-ADo) and the control signals &lt;br /&gt;101M. RD. and WR. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-3 8088 AND 80188 (8-BIT) MEMORY INTERFACE 333 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ All r-Addre&amp;quot; t r-/ &lt;br /&gt;WAIT All &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Oil 2732 ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data t r- r-0 7 &lt;br /&gt;r-RD ---(l OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ale A 0 FSOOO-F8FFF CE &lt;br /&gt;A&amp;quot; B F9000-F9FFF &lt;br /&gt;A, .. C I CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 FAOOO-FAFFF CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M &lt;br /&gt;---Y ~ FBOOO-FBFFF CE , 138 FCOOO-FCFFF A,&amp;lt;- 4 CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A,(,- ~ G2A 5 FDOOO-FDFFF CE &lt;br /&gt;A'7-~ G2B 6 FEOOO-FEFFF CE A,x- -.:.J. FFOOO-FFFFF &lt;br /&gt;A&amp;quot;,- GI 7 CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F ~IK &lt;br /&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-19 Eight 2732 EPROMs interfaced to the 8088 microprocessor. Note that the output of the NAND &lt;br /&gt;gate is used to cause a wait state whenever this section of the memory is selected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interfacing EPROM to the 8088. You will find this section very similar to Section 9-2 on de-&lt;br /&gt;coders. The only difference is that, in this section, we discuss wait states and the use of the 101M &lt;br /&gt;signal to enable the decoder. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-i9 illustrates an 8088 microprocessor connected to eight 2732 EPROMs, 4K x 8 &lt;br /&gt;memory devices that are in very common use today. The 2732 has one more address input (All) &lt;br /&gt;than the 2716, and twice the memory. The device in this illustration decodes eight 4K x 8 blocks &lt;br /&gt;of memory, for a total of 32K x 8 bits of the physical address space for the 8088. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The decoder (74LS138) is connected a little differently than might be expected because the &lt;br /&gt;slower version of this type of EPROM has a memory access time of 450 ns. Recall from Chapter &lt;br /&gt;8 that when the 8088 is operated with a 5 MHz clock, it allows 460 ns for the memory to access &lt;br /&gt;data. Because of the decoder's added time delay (12 ns), it is impossible for this memory to func-&lt;br /&gt;tion within 460 ns. In order to correct this problem, we must add a NAND gate to generate a &lt;br /&gt;signal to enable the decoder and a signal for the wait state generator, covered in Chapter 8. (Note &lt;br /&gt;that the 80188 can internally insert ,from 0-15 wait states without any additional external hard-&lt;br /&gt;ware, so it does not require this NAND gate.) With a wait state inserted every time this section of &lt;br /&gt;the memory is accessed, the 8088 will allow 660 ns for the EPROM to access data. Recall that an &lt;br /&gt;extra wait state adds 200 ns (1 clock) to the access time. The 660 ns is ample time for a 450 ns &lt;br /&gt;memory component to access data, even with the delays introduced by the decoder and any &lt;br /&gt;buffers added to the data bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that the decoder is selected for a memory address range that begins at location &lt;br /&gt;F8000H and continues through location FFFFFH-the upper 32K bytes of memory. This section &lt;br /&gt;of memory is an EPROM because FFFFOH is where the 8088 starts to execute instructions after &lt;br /&gt;a hardware reset. We often call location FFFFOH the cold-start location. The software stored in &lt;br /&gt;this section of memory would contain a JMP instruction at location FFFFOH that jumps to loca-&lt;br /&gt;tion F8000H so that the remainder of the program can execute. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;334 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interfacing RAM to the 8088. RAM is a little easier to interface than EPROM because most &lt;br /&gt;RAM memory components do not require wait states. An ideal section of the memory for the &lt;br /&gt;RAM is the very bottom, which contains vectors for interrupts. Interrupt vectors (discussed in &lt;br /&gt;more detail in Chapter 11) are often modified by software packages, so it is rather important to &lt;br /&gt;encode this section of the memory with RAM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In Figure 9-20, sixteen 62256 32K x 8 static RAMS are interfaced to the 8088, beginning &lt;br /&gt;at memory location OOOOOH. This circuit board uses two decoders to select the sixteen different &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;AS &lt;br /&gt;A9 &lt;br /&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;Dl &lt;br /&gt;D2 &lt;br /&gt;D3 &lt;br /&gt;D4 &lt;br /&gt;DS &lt;br /&gt;D6 &lt;br /&gt;D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;if=========~===ttl~WE DE CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BankO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;AS &lt;br /&gt;A9 &lt;br /&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;Dl &lt;br /&gt;D2 &lt;br /&gt;D3 &lt;br /&gt;D4 &lt;br /&gt;DS &lt;br /&gt;D6 &lt;br /&gt;D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WE &lt;br /&gt;DE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.-----.qcs &lt;br /&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-20 A 512K byte static memory system using 1662255 SRAMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-3 8088 AND 80188 (8-BIT) MEMORY INTERFACE 335 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAM memory components and a third to select the other decoders for tre appropriate memory &lt;br /&gt;sections. Sixteen 32K RAMs fill memory from location OOOOOH through location 7FFFFH, for &lt;br /&gt;Sl2K bytes of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first decoder (U4) in this circuit selects the other two decoders. An address beginning with &lt;br /&gt;00 ~clects decoder U3, and an address that begins with 01 selects decoder U9. Notice that extra pins &lt;br /&gt;remain at the output of decoder U4 for future expansion. These allow more 2S6K x 8 blocks of &lt;br /&gt;RAM, for a total of 1M x 8, simply by adding the RAM and the additional secondary decoders. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also notice from the circuit in Figure 9-20 that all the address inputs to this section of &lt;br /&gt;memory are buffered, as are the data bus connections and control signals RD and WR. Buffering &lt;br /&gt;is important when many devices appear on a single board or in a single system. Suppose that &lt;br /&gt;three other boards like this are plugged into a system. Without the buffers on each board, the load &lt;br /&gt;on the system address, data, and control buses would be enough to prevent proper operation. &lt;br /&gt;(Excessive loading causes the logic 0 output to rise above the 0.8 V maximum allowed in a &lt;br /&gt;system.) Buffers are normally used if the memory will contain additions at some future date. If &lt;br /&gt;the memory will never grow, then buffers may not be needed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interfacing Flash Memory &lt;br /&gt;Flash memory (EEPROM) is becoming commonplace for storing setup information on video &lt;br /&gt;cards as well as for storing the system BIOS in the personal computer. Flash memory is also &lt;br /&gt;found in many other applications to store information that is only changed occasionally. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The only difference between a flash memory device and SRAM is that the flash memory &lt;br /&gt;device requires a 12 V programming voltage to erase and write new data. The 12 V can either be &lt;br /&gt;available at the power supply, or a S V-to-12 V converter designed for use with flash memory &lt;br /&gt;can be obtained. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-21 illustrates a 28F400 Intel flash memory device interfaced to the 8088 micro-&lt;br /&gt;processor. The 28F400 can be used as either a Sl2K x 8 memory device or as a 2S6K x 16 &lt;br /&gt;memory device. Because it is interfaced to the 8088, its configuration is Sl2K x 8. Notice that &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1 &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;A10 &lt;br /&gt;A11 &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;A16 &lt;br /&gt;A17 &lt;br /&gt;A18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;loiM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PWRON &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vPP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;qA 3 B &lt;br /&gt;_ 1 G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33. &lt;br /&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;4 &lt;br /&gt;41 &lt;br /&gt;40 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34 &lt;br /&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;?A &lt;br /&gt;Y~ RD---lt Y1 Y~~ wFi---W 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,..1-&lt;br /&gt;74LS139 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U? &lt;br /&gt;BYTE 000 &lt;br /&gt;AO 001 &lt;br /&gt;A1 002 &lt;br /&gt;A2 003 &lt;br /&gt;A3 004 &lt;br /&gt;A4 005 &lt;br /&gt;A5 006 &lt;br /&gt;A6 007 &lt;br /&gt;A7 008 -&lt;br /&gt;A8 009 -&lt;br /&gt;A9 0010 -&lt;br /&gt;A10 0011 .--&lt;br /&gt;A11 0012 f-&lt;br /&gt;A12 0013 ;--&lt;br /&gt;A13 0014 '--&lt;br /&gt;A14 0015 &lt;br /&gt;A15 &lt;br /&gt;A16 &lt;br /&gt;A17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE &lt;br /&gt;CE &lt;br /&gt;WE &lt;br /&gt;PWO &lt;br /&gt;VPP &lt;br /&gt;28F400 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-21 The 28F400 flash memory device interfaced to the 8088 microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;336 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the control connections on this device are identical to that of an SRAM-CE, OE, and WE. The &lt;br /&gt;only new pins are V PP' which is connected to 12 V for erase and programming; PWD, which se-&lt;br /&gt;lects the power down mode when a logic 0 and is also used for programming; and BYTE, which &lt;br /&gt;selects byte (0) or word (1) operation. Note that the pin DQI5 functions as the least-significant &lt;br /&gt;address input when operated in the byte mode. Another difference is the amount of time required &lt;br /&gt;to accomplish a write operation. The SRAM can perform a write operation in as little as IOns, &lt;br /&gt;but the flash memory requires approximately 0.4 seconds to erase a byte. The topic of program-&lt;br /&gt;ming the flash memory device is covered in Chapter 10, along with I/O devices. The flash &lt;br /&gt;memory device has some internal register and is programmed using I/O techniques not yet ex-&lt;br /&gt;plained. This chapter concentrates on its interface to the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice in Figure 9-21 that the decoder chosen is the 74LS139, because only a simple de-&lt;br /&gt;coder is needed for a flash memory device this large. The decoder uses address connection A19 &lt;br /&gt;and 101M as inputs. The A15 signal selects the flash memory for locations 80000H through &lt;br /&gt;FFFFFH, and 101M enables the decoder. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Parity for Memory Error Detection &lt;br /&gt;Because such large memories are available in today's systems, and because circuit costs are min-&lt;br /&gt;imal, many memory board manufacturers have added parity checking to their RAM memory &lt;br /&gt;boards, although recently there seems to be a trend away from parity. Parity checking counts the &lt;br /&gt;number of l's in data and indicates whether there is an even or odd number. If all data are stored &lt;br /&gt;with even parity (with an even number of I-bits), a I-bit error can be detected. Memory that con-&lt;br /&gt;tains parity is 9-bits wide or 36-bits wide, for the newer 72-pin SIMM (single-in-line memory &lt;br /&gt;module) components found in computer systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-22 illustrates the 74AS2S0 parity generator/detector integrated circuit. This cir-&lt;br /&gt;cuit has nine inputs and generates even or odd parity for the 9-bit number placed on its inputs. It &lt;br /&gt;also checks the parity of a 9-bit number connected to its inputs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-23 illustrates a 64K x 8 static RAM system using two 62556 32K x 8 SRAM de-&lt;br /&gt;vices for data storage that has parity generation and detection. Notice that a 74AS2S0 generates &lt;br /&gt;a parity bit stored in a 6287 64K x I SRAM. This circuit decodes the memory at locations &lt;br /&gt;80000H-SFFFFH using a 74LS138 decoder. Here the eight data bus connections are attached to &lt;br /&gt;the parity generator's (U6) inputs A-H. Input I is grounded, so if an even number of l's appear &lt;br /&gt;on the data bus, a I (at the even output) is stored in the parity RAM. If an odd number of l's &lt;br /&gt;appears, a 0 is stored in the parity RAM. Here odd parity is stored for each byte of data, including &lt;br /&gt;the parity bit written to the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-22 The pin-out &lt;br /&gt;and function table of the &lt;br /&gt;74AS280 9-bit parity gener-&lt;br /&gt;ator/detector (Courtesy &lt;br /&gt;of Texas Instruments &lt;br /&gt;Incorporated) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SN54AS280 â¢â¢. J PACKAGE &lt;br /&gt;SN74AS280 â¢â¢. N PACKAGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(TOP VIEW' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vcc &lt;br /&gt;F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 E &lt;br /&gt;11 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IEVEN 10 C &lt;br /&gt;IODD 6 9 B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;FUNCTION TABLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NUMBER OF INPUTS A OUTPUTS &lt;br /&gt;THRU I THAT ARE HIGH :rEVEN :rOOD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0.2.4.6.8 H L &lt;br /&gt;1.3.5.7.9 L H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-3 8088 AND 80188 (8-BIT) MEMORY INTERFACE 337 &lt;br /&gt;00-07 ______________________ -, ________ ---, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO-A15 ---------------,--------t---, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R15 &lt;br /&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1S &lt;br /&gt;A16 &lt;br /&gt;A17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A19 &lt;br /&gt;A1B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10/t'! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 &lt;br /&gt;AO DO &lt;br /&gt;A1 01 &lt;br /&gt;A2 02 &lt;br /&gt;A3 03 &lt;br /&gt;A4 04 &lt;br /&gt;AS OS &lt;br /&gt;A6 06 &lt;br /&gt;A7 07 &lt;br /&gt;AB &lt;br /&gt;A9 &lt;br /&gt;Al0 &lt;br /&gt;Al1 &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-IH~WE &lt;br /&gt;g~ 62256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WE &lt;br /&gt;g~ 62256 U7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A EVEN &lt;br /&gt;8 &lt;br /&gt;e ODD &lt;br /&gt;o &lt;br /&gt;E &lt;br /&gt;F &lt;br /&gt;~ G ~_r~~------_+----_=~----~~~ ~? DO U6 &lt;br /&gt;~~ 01 ~13L..---+-~__[EiEVIEENN-~BH---j 74LS2BO &lt;br /&gt;A4 ODD e &lt;br /&gt;M 0 &lt;br /&gt;M E &lt;br /&gt;~ F &lt;br /&gt;M G &lt;br /&gt;~ro vee ~ &lt;br /&gt;~g 74LS2BO &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A1S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 ce: &lt;br /&gt;WE &lt;br /&gt;NMI---------------=62~B7-----~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U9A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET ------------'-1 &lt;br /&gt;74LS04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-23 A 64K memory system that contains a parity error detection circuit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When data are read from the memory, each datum is connected to another 74AS280 (U7) &lt;br /&gt;to check its parity. In this case, all the inputs to the checker are connected. Inputs A-H are con-&lt;br /&gt;nected to the data RAM's outputs, and input I is connected to the parity RAM. Note that the &lt;br /&gt;parity RAM control pins are different. This SRAM reads data from its output pin when selected &lt;br /&gt;and writes data if selected with WE = O. It does not have an OE connection for RD. If parity is &lt;br /&gt;odd, as it is if everything is correct, the even parity output of the 74AS280 (U7) is a logic O. If a &lt;br /&gt;bit of the information read from the memory changes for any reason, then the even output pin of &lt;br /&gt;the 74AS280 will become a logic 1. The parity output pin is connected to a special input of the &lt;br /&gt;8088 called the nonmaskable interrupt (NMI) input. The NMI input can never be turned off. If it &lt;br /&gt;is placed at its logic 1 level, the program being executed is interrupted, and a special subroutine &lt;br /&gt;indicates that a parity error has been detected by the memory system. (More detail on interrupts &lt;br /&gt;is provided in Chapter 11.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The application of the parity error is timed so that the data read from the memory are set-&lt;br /&gt;tled to their final state before an NMI input occurs. The operation is timed by a D-type flip-flop &lt;br /&gt;that latches the output of the parity checker at the end of an RD cycle from this section of the &lt;br /&gt;memory. In this way, the memory has enough time to read the information and pass it through &lt;br /&gt;the generator before the output of the generator is sampled by the NMI input. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Error Correction &lt;br /&gt;Error correction schemes have been around for a long time, but integrated circuit manufacturers &lt;br /&gt;have only recently started to produce error-correcting circuits. One such circuit is the 74LS636, &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;338 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;an 8-bit error correction and detection circuit that corrects any single-bit memory read error and &lt;br /&gt;flags any 2-bit error. This device is found in very high-end computer systems because of the cost &lt;br /&gt;of implementing a system that uses error correction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 74LS636 corrects errors by storing five parity bits with each byte of memory data. &lt;br /&gt;This does increase the amount of memory required, but it also provides automatic error correc-&lt;br /&gt;tion for single-bit errors. If more than two bits are in error, this circuit may not detect it. Fortu-&lt;br /&gt;nately, this is rare, and the extra effort required to correct more than a single-bit error is very &lt;br /&gt;expensive and not worth the effort. Whenever a memory component fails completely, its bits are &lt;br /&gt;all high or all low . In this case, the circuit flags the processor with a multiple-bit error indication. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-24 depicts the pin-out of the 74LS636. Notice that it has eight data IJO pins, five &lt;br /&gt;check bit IJO pins, two control inputs (SO and S1), and two error outputs: single error flag (SEF) &lt;br /&gt;and double-error flag (DEF). The control inputs select the type of operation to be performed and &lt;br /&gt;are listed in the truth table of Table 9-2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;functional block diagram &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SO FUNCTION &lt;br /&gt;S1 SELECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-- +- LATCH &lt;br /&gt;.... C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,~ CHECK BIT 110 &lt;br /&gt;CBO THRU CB4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;i+ !--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUFFER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LATCH &lt;br /&gt;+-C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA BIT 110 &lt;br /&gt;DBO THRU DB? ;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-+---j BUFFER &lt;br /&gt;OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;pin .slignments &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J. N PACKAGES &lt;br /&gt;1 DEF 11 CB4 &lt;br /&gt;2 DBD 12 nc &lt;br /&gt;3 DBl 13 CB3 &lt;br /&gt;4 DB2 14 CB2 &lt;br /&gt;5 DB3 15 CBl &lt;br /&gt;S DB4 1S CBO &lt;br /&gt;7 DB5 17 SO &lt;br /&gt;B DBS 18 S1 &lt;br /&gt;9 087 19 SEF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 GND 20 VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I Iii &lt;br /&gt;SOÂ·S1 &lt;br /&gt;SOÂ·S1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 5 PARITY &lt;br /&gt;GENERATOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~10 &lt;br /&gt;5 10I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;( I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 ~ &lt;br /&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B ERROR ~ ERROR ( CORRECTOR DECODER &lt;br /&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE &lt;br /&gt;ERROR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DETECTOR &lt;br /&gt;f--+ &lt;br /&gt;r-+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEF &lt;br /&gt;DEF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-24 (a) The pin connections of the 74LS636. (b) The block diagram of the 74LS636. &lt;br /&gt;(Courtesy of Texas Instruments Incorportated) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-3 8088 AND 80188 (8-BIT) MEMORY INTERFACE 339 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 9-2 Control bits SO &lt;br /&gt;and S1 SO S1 Function SEF DEF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 Write check word o o &lt;br /&gt;0 1 Correct data word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\) Read data o o &lt;br /&gt;1 Latch data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* 'vote: These levels are determined by the type of error. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When a single error is detected, the 74LS636 goes through an error correction cycle: it &lt;br /&gt;places a 01 on So and SI by causing a wait and then a read following error correction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-25 illustrates a circuit used to correct single-bit errors with the 74LS636 and to &lt;br /&gt;interrupt the processor through the NMI pin for double-bit errors. To simplify the illustration, we &lt;br /&gt;depict only one 2K x 8 RAM and a second 2K x 8 RAM to store the 5-bit check code. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The connection of this memory component is different from that of the previous example. &lt;br /&gt;Notice that the S or CS pin is grounded, and data bus buffers control the flow to the system bus. &lt;br /&gt;This is necessary if the data are to be accessed from the memory before the RD strobe goes low. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;On the next negative edge of the clock after an RD, the 74LS636 checks the single-error &lt;br /&gt;flag (SEF) to determine whether an error has occurred. If so, then a correction cycle causes the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-25 An error de-&lt;br /&gt;tection and correction circuit &lt;br /&gt;using the 74LS636 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMI ~----------~ DEF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS636 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;*RD and WR &lt;br /&gt;are conditioned &lt;br /&gt;by the memory &lt;br /&gt;addreÂ». &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CB .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;CBo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;DBo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cheek &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4016 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Do &lt;br /&gt;W 4016 G &lt;br /&gt;S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--i------------- WR * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-+------------- RD* &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;340 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;single-error defect to be corrected. If a double error occurs, then an interrupt request is generated &lt;br /&gt;by the double-error flag (DEF) output. which is connected to the NMI pin of the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086,80186,80286, AND 80386SX (16-BIT) MEMORY INTERFACE &lt;br /&gt;The 8086, 80186, 80286, and 80386SX microprocessors differ from the 8088/80188 in three &lt;br /&gt;ways: (1) the data bus is 16-bits wide instead of 8-bits wide as on the 8088/80188, (2) the 101M &lt;br /&gt;pin of the 8088/80188 replaced with an MIlO pin, and (3) there is a new control signal called bus &lt;br /&gt;high enable (BHE). The address bit Ao or BLE is also used differently. Because this section is &lt;br /&gt;based on information provided in Section 9-3, it is extremely important that you read the pre-&lt;br /&gt;vious section fIrst. A few other differences exist between the 8086/80186 and the 80286/ &lt;br /&gt;80386SX. The 80286/80386SX microprocessors contain a 24-bit address bus (~3-A!!l. instead &lt;br /&gt;of the 20-bit address bus (A19-AO) of the 8086/80186. The 8086/80186 contain an MIlO signal &lt;br /&gt;while the 80286 system and 80386SX microprocessor contain control signals MRDC and &lt;br /&gt;MWTC instead of RD and WR. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-Bit Bus Control &lt;br /&gt;The data bus of the 8086, 80186, 80286, and 80386SX is twice as wide as the bus for the &lt;br /&gt;8088/80188. This wider data bus presents us with a unique set of problems that have not been en-&lt;br /&gt;countered before. The 8086, 80186, 80286, and 80386SX must be able to write data to any 16-&lt;br /&gt;bit location--or any 8-bit location. This meaps that the 16-bit data bus must be divided into two &lt;br /&gt;separate sections (banks) that are 8-bits wide so the microprocessor can write to either half (8-&lt;br /&gt;bit) or both halves (16-bit). Figure 9-26 illustrates the two banks of the memory. One bank (low &lt;br /&gt;bank) holds all the even-numbered memory locations, and the other bank (high bank) holds all &lt;br /&gt;the odd-numbered memory locations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8086, 80186, 80286, and 80386SX use the BHE signal (high bank) and the Ao address &lt;br /&gt;bit or BLE (bus low enable) to select one or both banks of memory used for the data transfer. &lt;br /&gt;Table 9-3 depicts the logic levels on these two pins and the bank or banks selected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank selection is accomplished in two ways: (1) a separate write signal is developed to se-&lt;br /&gt;lect a write to each bank of the memory or (2) separate decoders are used for each bank. As a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-26 The high &lt;br /&gt;(odd) and low (even) e-bit &lt;br /&gt;memory bank~ of the &lt;br /&gt;8086/8028J6/83865X &lt;br /&gt;microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFF &lt;br /&gt;FFFFD I-------f &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFB 1--------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFE 1-------1 &lt;br /&gt;FFFFC 1-____ --1 &lt;br /&gt;FFFFA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(I(lOOS 1-------\\ &lt;br /&gt;()(Klm 1-------\\ &lt;br /&gt;00(0) '--_____ ..... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;High hank &lt;br /&gt;(Odd b'lOk) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OO(Xl4 1------.; &lt;br /&gt;()(lOO~ &lt;br /&gt;00000 I---------l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Low hank &lt;br /&gt;(Even h'lI1kl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: Ao is labeled BLE (Bus low &lt;br /&gt;enable) on the 80386SX. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-4 8086,80186,80286, AND 80386SX (16-BIT) MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 9-3 Memory bank &lt;br /&gt;selection using BHE and &lt;br /&gt;BLE (Ao) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BLE (AJ &lt;br /&gt;o &lt;br /&gt;1 &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Both banks enabled for a 16-bit transfer &lt;br /&gt;High bank enabled for an 8-bit transfer &lt;br /&gt;Low bank enabled f'lr an 8-bit transfer &lt;br /&gt;No banks enabled &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;341 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;careful comparison reveals, the first technique is by far the least costly approach to memory in-&lt;br /&gt;terface for the 8086, 80186, 80286, and 80386SX microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Separate Bank Decoders. The use of separate bank decoders is often the least-effective way to &lt;br /&gt;decode memory addresses for the 8086, 80186, 80286, and 80386SX. This method is sometimes &lt;br /&gt;used, but it is difficult to understand why in most cases. One reason may be to conserve energy, &lt;br /&gt;because only the bank or banks selected are enabled. This is not always the case with separate &lt;br /&gt;bank read and write signals, which are discussed later. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-27 illustrates two 74LS138 decoders used to select 64K RAM memory compo-&lt;br /&gt;nents for the 80386SX microprocessor (24-bit address). Here decoder U2 has the BLE pin (Ao) &lt;br /&gt;attached to G2A, and decoder U3 has the BHE signal attached to its G2A input. Because the de-&lt;br /&gt;coder will not activate until all its enable inputs are active, decoder U2 only activates for a l6-bit &lt;br /&gt;operation or an 8-bit operation from the low bank, and decoder U3 activates for a 16-bit opera-&lt;br /&gt;tion or an 8-bit operation to the high bank. These two decoders and the sixteen 64K RAMs they &lt;br /&gt;control represent a 1M range of the 80386SX memory system. Decoder Ul enables U2 and U3 &lt;br /&gt;for memory address range OOOOOOH-OFFFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice from Figure 9-7 that the Ao address pin does not connect to the memory; in fact, it &lt;br /&gt;does not even exist on the 80386SX microprocessor. Also notice that address bus bit position Al &lt;br /&gt;is connected to memory address input Ao' A2 is connected to A I' and so forth. The reason is that &lt;br /&gt;Ao from the 8086/80186 (or BLE from the 80286/80386SX) is already connected to decoder U2 &lt;br /&gt;and does not need to be connected again to the memory. If Ao or BLE is attached to the Ao ad-&lt;br /&gt;dress pin of memory, every other memory location in each bank of memory would be used. This &lt;br /&gt;means that half of the memory is wasted if Ao or BLE is connected to Ao. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Separate Bank Write Strobes. The most effective way to handle bank selection is to develop a &lt;br /&gt;separate write strobe for each memory bank. This technique requires only one decoder to select a &lt;br /&gt;16-bit wide memory. This often saves money and reduces the number of components in a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Why not also generate separate read strobes for each memory bank? This is usually unnec-&lt;br /&gt;essary, because the 8086, 80186, 80286, and 80386SX microprocessors read only the byte of &lt;br /&gt;data that they need at any given time from half of the data bus. If 16-bit sections of data are al-&lt;br /&gt;ways presented to the data bus during a read, the microprocessor ignores the 8-bit section it &lt;br /&gt;doesn't need without any conflicts or special problems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-28 depicts the generation of separate 8086 write strobes for the memory. Here a &lt;br /&gt;74LS32 OR gate combines Ao with WR for the low bank selection signal (LWR) and BHE com-&lt;br /&gt;bines with WR for the high bank selection signal (HWR). Write strobes for the 80286/80386SX &lt;br /&gt;are generated using the MWTC signal instead of WR. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A memory system that uses separate write strobes is constructed differently from either the &lt;br /&gt;8-bit system (8088) or the system using separate memory banks. Memory in a system that uses &lt;br /&gt;separate write strobes is decoded as 16-bit wide memory. For example, suppose that a memory &lt;br /&gt;system will contain 64K bytes of SRAM memory. This memory requires two 32K byte memory &lt;br /&gt;devices (62256) so that a 16-bit wide memory can be constructed. Because the memory is 16-bits &lt;br /&gt;wide, and another circuit generates the bank write signals, address bit Ao becomes a don't care. &lt;br /&gt;In fact, Ao is not even a pin on the 80386SX microprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;342 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;09-015 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00-07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1-A16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2 &lt;br /&gt;A2 &lt;br /&gt;A22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;lt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 &lt;br /&gt;1 A YO~ 2 B Y1~ 3 e Y2~ Y3~ Y4~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;High bank &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- 64Kx 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;00-07 I-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO-A1S &lt;br /&gt;I-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r--&lt;br /&gt;--..LG1 Y5 ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-oS 3 4G2A Y6sr+-~G2B Y7 o-Z-&lt;br /&gt;-ds &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1 &lt;br /&gt;A1 &lt;br /&gt;A1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 &lt;br /&gt;8 &lt;br /&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mil 0&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-:: 74LS138 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BHE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;1 A YO 2 B Y1 3 e Y2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Y3 &lt;br /&gt;6 Y4 G1 Y5 4 G2A Y6 R G2B Y7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS138 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 &lt;br /&gt;+A YO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 B Y1 &lt;br /&gt;3 e Y2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Y3 &lt;br /&gt;Y4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ G1 Y5 4 G2A Y6 &lt;br /&gt;.2c G2B Y7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS138 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~s &lt;br /&gt;I ~s 15 14 I ~s 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 I rls 10 r-eJs 9 &lt;br /&gt;7 Js &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Low bank &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64K x 8 &lt;br /&gt;r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00-07 l-&lt;br /&gt;t--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO-A15 t--&lt;br /&gt;r--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,c s &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rdS &lt;br /&gt;~s &lt;br /&gt;I rds 15 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-els 13 &lt;br /&gt;12 I ~s 11 &lt;br /&gt;1 r-eJs 9 &lt;br /&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-dS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-27 Separate bank decoders &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 9-6 shows how a 16-bit wide memory stored at locations 060000H-06FFFFH is &lt;br /&gt;decoded for the 80286 or 80386 microprocessors. Memory in this example is decoded so bit Ao &lt;br /&gt;is a don't care for the decoder. Bit positions A,-A'5 are connected to memory component ad-&lt;br /&gt;dress pins Ao-A'4. The decoder (PALl6L8) enables both memory devices by using address con-&lt;br /&gt;nection A23-A'5 to select memory whenever address 06XXXXH appears on the address bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-6 &lt;br /&gt;0000 0110 0000 0000 0000 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to &lt;br /&gt;0000 0110 1111 1111 1111 1111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0110 XXXX XXXX XXXX XXXX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;060000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06FFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06XXXXH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-4 8086,80186,80286, AND 80386SX (16-8IT) MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-28 The memory &lt;br /&gt;bank write selection inputs &lt;br /&gt;signals: HWR (high bank &lt;br /&gt;write) and LWR (low bank &lt;br /&gt;write). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B:: ____ -+rD ____ ::: AO-----~-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;343 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-29 illustrates this simple circuit using a PALl6L8 both to decode memory and &lt;br /&gt;generate tl&amp;quot;!e separate write strobe. The program for the PALl6L8 decoder is illustrated in Ex-&lt;br /&gt;ample 9-7. Notice that not only is the memory selected, but both the lower and upper write &lt;br /&gt;strobes are also generated by the PAL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-7 &lt;br /&gt;TITLE Address Decoder &lt;br /&gt;PATTERN Test 2 &lt;br /&gt;REVISION A &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 6/7 196 &lt;br /&gt;CHIP DECODER2 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;A23 A22 A21 A20 A19 A18 A17 A16 AD GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;BHE SEL LWR HWR NC NC MWTC NC NC VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ISEL IA23 * I A22 * IA21 * IA20 * IA19 * A18 * A17 * IA16 &lt;br /&gt;ILWR = IMWTC * lAO &lt;br /&gt;IHWR = IMWTC * IBHE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-30 depicts a small memory system for the 8086 microprocessor that contains an &lt;br /&gt;EPROM section and a RAM section. Here there are four 27128 EPROMs (16K x 8) that compose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-29 A 16-bit &lt;br /&gt;memory decoder that places &lt;br /&gt;memory at locations &lt;br /&gt;060000H-06FFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015-0B ---------------------------, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07-00-----------------, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A15-Al --------r---------+---, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~--------.+-~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MWTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul &lt;br /&gt;A23 1 &lt;br /&gt;A22 &lt;br /&gt;A21 &lt;br /&gt;A20 &lt;br /&gt;A19 &lt;br /&gt;AlB &lt;br /&gt;A17 &lt;br /&gt;A16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note. AO IS labeled BlE on the 803865X &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;A &lt;br /&gt;A &lt;br /&gt;A &lt;br /&gt;A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;08 - 015 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00-07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;!~ M/iO 1 A18 2 12 A19 3 &lt;br /&gt;74LS10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ill &lt;br /&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;iWR &lt;br /&gt;U7A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al~_~A YO~ 17 _ 3 B Yl &lt;br /&gt;1 G Y2 Y3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS139 &lt;br /&gt;U7B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ali~A YO 12 15 13 B 11 Yl~ &lt;br /&gt;15 G Y2 Y3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS139 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U12 &lt;br /&gt;r--h &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&amp;lt; -r!1 6 '~~ &lt;br /&gt;U13A + Al Yl 18 + A2 Y2 14 ::::::t: A3 Y3~ A4 Y4 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r G 74LS240 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ AO ~ Al A2 &lt;br /&gt;~ A3 A4 S A5 A6 A7 25 AS -~t- A9 &lt;br /&gt;.---4- Al0 All ~ A12 &lt;br /&gt;--L A13 A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ WE 22 OE 20 &lt;br /&gt;es &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U8 &lt;br /&gt;10 AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ ~ Al A2 ~ A3 ~ f+ A4 A5 &lt;br /&gt;r--t- A6 &lt;br /&gt;~ ~ A7 AS 24 A9 ~ ~ vee Al0 ~ All 2 A12 &lt;br /&gt;'--~ A13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lK 20 eE ~OE &lt;br /&gt;7 PGM r vpp 27128 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 U4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOE ~ AO 00 &lt;br /&gt;I ii ~ 10 AO 01 2 ~ Al 01 ~ Al 02~ A2 02 A2 03 ~ A3 03 .~ A3 04~ A4 D4 ~ A4 05~ A5 05 .'---4 A5 g~ ...lL/ A6 06 ~ A6 A7 07 ,~ A7 ~ AS AS 24 A9 ~ A9 ~ Al0 Al0 All ,---4- All &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A12 2 A12 ~ f'--L A13 A13 A14 A14 &lt;br /&gt;~ WE ~ WE OE OE 20 es es &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62256 62256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U9 Ul0 &lt;br /&gt;00 I 10 AO 001 ~ :f: AO 01 '~H- Al 01 1 Al 02 ~f-t- A2 g~ 1 ,- --r- A2 03 A3 A3 04 ~~ A4 ~~ .-=+ A4 05 ~ ~r-t- A5 ,- AS 06 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--1JL.I r--'3 A6 07 f-1JL/ A6 07 ~r&amp;amp;- A7 ,-r-g- A7 A8 t'--&lt;br /&gt;'*-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A8 &lt;br /&gt;A9 A9 ~21 ~~ Al0 + Al0 All ~ All A12 A12 Cf]L A13 '--~ A13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 eE ~~ ~ OE r= PGM 7 PGM 1 vpp vpp &lt;br /&gt;27128 27128 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-30 A memory system for the BOB6 that contains a 64K-byte EPROM and a 12BK-byte SRAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOE ~ AO 01 ~ Al &lt;br /&gt;021 A2 03 A3 ~ 7 A4 .'---4 AS 06 1 ,---a- A6 &lt;br /&gt;07...lL/ ,~ A7 A8 t--~1 A9 Al0 .~ All A12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,:::::::t: A13 A14 &lt;br /&gt;-Â¥-&amp;lt; WE ~ OE es &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ull &lt;br /&gt;00 I ,- + AO 01 Al 02 ,- --r- A2 03 6 A3 04 -+ A4 05 ,- A5 06 A6 07 ,-r-g- A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r#-&lt;br /&gt;AS ,- A9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t'--~ Al0 All A12 ~ ~ A13 &lt;br /&gt;20 _. ~ g~ F PGM vpp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27128 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 It 01 3 g~ 1 &lt;br /&gt;04~ 05~ ~p:L/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OO~ 01 2 02~ 03 1 &lt;br /&gt;04~ 05~ ~pL-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;c..:I &lt;br /&gt;.IÂ» &lt;br /&gt;.IÂ» &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;n &lt;br /&gt;::I: &lt;br /&gt;Â» &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;m &lt;br /&gt;:D &lt;br /&gt;CD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s:: &lt;br /&gt;m &lt;br /&gt;s:: &lt;br /&gt;o &lt;br /&gt;:D &lt;br /&gt;-&amp;lt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;:D );! &lt;br /&gt;n &lt;br /&gt;m &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-4 8086,80186,80286, AND 80386SX (16-BIT) MEMORY INTERFACE 345 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a 32K x 16-bit memory at location FOOOO-FFFFFH and four 62256 (32K x 8) RAMs that &lt;br /&gt;compose a 64K x 16-bit memory at location OOOOOH-IFFFFH. (Remember that even though &lt;br /&gt;the memory is 16-bits wide, it is still numbered in bytes.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This circuit uses a 74LS139 duaI2-to-4Iine decoder that selects EPROM with one half &lt;br /&gt;and RAM with the other half. It decodes memory that is 16-bits wide, not 8-bits as before. &lt;br /&gt;Notice that the RD strobe is connected to all the EPROM OE inputs and all the RAM G input &lt;br /&gt;pins. This is done because even if the 8086 is only reading 8-bits of data, the application of &lt;br /&gt;the remaining 8-bits to the data bus has no effect on the operation of the 8086. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The LWR and HWR strobes are connected to different banks of the RAM memory. &lt;br /&gt;Here it does matter if the microprocessor is doing a 16-bit or an 8-bit write. If the 8086 writes &lt;br /&gt;a 16-bit number to memory, both LWR and HWR go low and enable the W pins in both &lt;br /&gt;memory banks. But if the 8086 does an 8-bit write, then only one of the write strobes goes &lt;br /&gt;low, writing to only one memory bank. Again, the only time that the banks make a difference &lt;br /&gt;is for a memory write operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that an EPROM decoder signal is sent to the 8086 wait state generator be-&lt;br /&gt;cause EPROM memory usually requires a wait state. The signal comes from the NAND &lt;br /&gt;gate used to select the EPROM decoder section so that if EPROM is selected, a wait state &lt;br /&gt;is requested. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-31 illustrates a memory system connected to the 80386SX microprocessor &lt;br /&gt;using a PAL16L8 as a decoder. This interface contains 256K bytes of EPROM in the form &lt;br /&gt;of four 27512 (64K x 8) EPROMs and 128K bytes of SRAM memory found in four 62256 &lt;br /&gt;(32K x 8) SRAMs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice from Figure 9-31 that the PAL also generates the memory bank write signals &lt;br /&gt;L WR and HWR. As can be gleaned from this circuit, the number of components required to &lt;br /&gt;interface memory has been reduced to just one in most cases (the PAL). The program listing &lt;br /&gt;for the PAL is located in Example 9-8. The PAL decodes the 16-bit wide memory addresses &lt;br /&gt;at locations OOOOOOH-OIFFFFH for the SRAM and locations FCOOOOH-FFFFFFH for the &lt;br /&gt;EPROM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-8 &lt;br /&gt;TITLE Address Decoder &lt;br /&gt;PATTERN Test 3 &lt;br /&gt;REVISION A &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 6/8/96 &lt;br /&gt;CHIP DECODER3 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;MWTC AO A16 A17 A18 A19 A20 A21 A22 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;NC HWR A23 BHE LWR RBO RB1 EBO EB1 VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/LWR = /MWTC â¢ /AO &lt;br /&gt;/HWR = /MWTC â¢ /BRE &lt;br /&gt;/RBO /A23' /A22 â¢ /A21 â¢ /A20 â¢ /A19 â¢ /A18 â¢ /A17 â¢ /A16 &lt;br /&gt;/RB1 /A23 * /A22 * /A21 * /A20 â¢ /A19 â¢ /A18 * /A17 â¢ A16 &lt;br /&gt;/EBO = A23 â¢ A22 â¢ A21 â¢ A20 â¢ A19 â¢ A18 â¢ /A17 &lt;br /&gt;/EBl = A23 â¢ A22 â¢ A21 â¢ A20 â¢ A19 â¢ A18 â¢ A17 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;07-00 &lt;br /&gt;015-08 _______________ 1--_.--______ +-________ ....-________ .., &lt;br /&gt;A16-Al _______ ----.r--______ +-_+-______ +-_...--______ +_~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MRoe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MWTC &lt;br /&gt;AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A15 &lt;br /&gt;A16 &lt;br /&gt;A17 &lt;br /&gt;A18 &lt;br /&gt;A19 U6 &lt;br /&gt;A20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO A21 00 &lt;br /&gt;A22 Al 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2 02 &lt;br /&gt;16L8 A3 03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BHE A4 D4 &lt;br /&gt;A23 A5 05 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A6 06 &lt;br /&gt;A7 07 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WE &lt;br /&gt;OE &lt;br /&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62256 62256 62256 62256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-31 An 803865SX memory system containing 256K of EPROM and 128K of SRAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;c..:I &lt;br /&gt;.IÂ» &lt;br /&gt;Cl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;n &lt;br /&gt;::I: &lt;br /&gt;&amp;gt; ~ &lt;br /&gt;:0 &lt;br /&gt;&amp;lt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s: &lt;br /&gt;m &lt;br /&gt;s: &lt;br /&gt;o &lt;br /&gt;:0 &lt;br /&gt;-&amp;lt; &lt;br /&gt;z &lt;br /&gt;rrl &lt;br /&gt;:0 &lt;br /&gt;~ &lt;br /&gt;n &lt;br /&gt;m &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-5 80386DX AND 80486 (32-8IT) MEMORY INTERFACE 347 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386DX AND 80486 (32-BIT) MEMORY INTERFACE &lt;br /&gt;A~ with 8- and 16-bit memory systems, the microprocessor interfaces to memory through its data &lt;br /&gt;bus and control signals that select separate memory banks. The only difference with a 32-bit &lt;br /&gt;memory system is that the microprocessor has a 32-bit data bus and four banks of memory in-&lt;br /&gt;stead of one or two. Another difference is that both the 80386DX and 80486 (both SX and DX) &lt;br /&gt;contain a 32-bit address bus that usually requires PLD decoders instead of integrated decoders, &lt;br /&gt;because of the sizable number of address bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Banks &lt;br /&gt;The memory banks for both the 80386DX and 80486 microprocessors are illustrated in Figure 9-32. &lt;br /&gt;Notice that these large memory systems contain four 8-bit wide banks that each contain up to 10 &lt;br /&gt;byte of memory. Bank selection is accomplished by the bank selection signals BE3, BE2, BEl, and &lt;br /&gt;BEO. If a 32-bit number is transferred, all four banks are selected; if a 16-bit number is transferred, &lt;br /&gt;two banks (usually BE3 and BE2 or BEl and BEO) are selected; and if 8-bits are transferred, a single &lt;br /&gt;bank is selected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with the 8086/80286/80386SX, the 80386DX and 80486 require separate write strobe &lt;br /&gt;signals for each memory bank. These separate write strobes are developed as illustrated in Figure &lt;br /&gt;9-33 using a simple OR gate or other logic component. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32-Bit Memory Interface &lt;br /&gt;As can be gathered from the prior discussion, a memory interface for the 80386DX or 80486 re-&lt;br /&gt;quires that we generate four bank write strobes and also decode a 32-bit address. There are no &lt;br /&gt;integrated decoders, such as the 74LS 138, that can easily accommodate a memory interface for &lt;br /&gt;the 80386DX or 80486 microprocessors. Note that address bits Ao and Al are don't cares when &lt;br /&gt;32-bit wide memory is decoded. These address bits are used within the microprocessor to gen-&lt;br /&gt;erate the bank enable signals. Also notice that address bus connected Az connects to memory &lt;br /&gt;address pin Ao' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank3 Bank 2 BankO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOOOB 1-------1 &lt;br /&gt;00000007~-----l &lt;br /&gt;00000003 ~:--_--;:~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;031 024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOOOAI--___ --1 &lt;br /&gt;00000006~-----l &lt;br /&gt;00000002 ~:--_--;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;023 016 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000091--___ --1 &lt;br /&gt;000000051--___ --1 &lt;br /&gt;00000001 ~:--_~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015 08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOOOB I-------j &lt;br /&gt;00000004~-----l &lt;br /&gt;00000000 '='=:--__ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-32 The memory organization for the 80386DX and 80486 microprocessors &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;348 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-33 Bank write &lt;br /&gt;signals for the 80386DX and &lt;br /&gt;80486 microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MMC ______ ~r---~ &lt;br /&gt;BEO ________ ~~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE' ________ ~~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE3 __________ ~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-34 shows an 256K x 8 memory system for the 80486 microprocessor. This inter-&lt;br /&gt;face uses eight 32K x 8 SRAM memory devices and two PALl6L8 devices. Two devices are re-&lt;br /&gt;quirecJ because of the number of address connections found on the microprocessor. This system &lt;br /&gt;places the SRAM memory at locations 02000000H-0203FFFFH. The programs for the PAL de-&lt;br /&gt;vices are found in Example 9-9. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-9 &lt;br /&gt;TITLE Address Decoder &lt;br /&gt;PATTERN Test 4 (PAL U1) &lt;br /&gt;REVISION A &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 6/9/96 &lt;br /&gt;CHIP DECODER4 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;MWTC BEO BEl BE2 BE3 A17 A28 A29 A30 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;A31 RB1 U2 NC WRO WR1 WR2 WR3 RBO VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/WRO /MWTC * /BEO &lt;br /&gt;/WR1 /MWTC â¢ /BE1 &lt;br /&gt;/WR2 /MWTC â¢ /BE2 &lt;br /&gt;/WR3 /MWTC â¢ /BE3 &lt;br /&gt;/RBO /A31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ /A30 â¢ /A29 â¢ /A28 â¢ /A17 â¢ /U2 &lt;br /&gt;/RB1 /A31 * /A30 â¢ /A29 * /A28 â¢ A17 â¢ /U2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TITLE Address Decoder &lt;br /&gt;PATTERN Test 5 (PAL U2) &lt;br /&gt;REVISION A &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 6/10/96 &lt;br /&gt;CHIP DECODER5 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 '7 8 9 10 &lt;br /&gt;A18 A19 A20 A21 A22 A23 A24 A25 A26 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;A27 U2 NC NC NC NC NC NC NC VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/U2 = /A27 * /A26 â¢ A25 â¢ /A24 â¢ /A23 â¢ /A22 â¢ /A21 * /A20 * /A19 â¢ /A18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Although not mentioned in this section of the text, the 80386DX and 80486 microproces-&lt;br /&gt;sors operate with very high clock rates that usually require wait states for memory access. Access &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;07-00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015-0B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;023 - 016 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;031 -024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI6-A2 &amp;lt;D I &lt;br /&gt;U1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 U4 US U6 &lt;br /&gt;AO 00 AD 00 AD 00 AD 00 CO 0 &lt;br /&gt;Al 01 AI 01 Al 01 Al 01 w CO A2 02 A2 02 A2 02 A2 02 a&amp;gt; &lt;br /&gt;A3 03 A3 03 A3 03 A3 03 &amp;lt;::) &lt;br /&gt;A4 04 A4 04 A4 04 A4 04 X &lt;br /&gt;AS 05 A5 05 AS 05 AS 05 ~ &lt;br /&gt;A6 06 A6 06 A6 06 A6 06 Z &lt;br /&gt;A7 07 A7 07 A7 07 A7 07 &amp;lt;::) &lt;br /&gt;AB AB AB AB 00 &lt;br /&gt;A9 A9 A9 A9 0 ..,. &lt;br /&gt;Al0 AlO AID AID 00 &lt;br /&gt;All All All All a&amp;gt; &lt;br /&gt;A12 A12 A12 A12 W &lt;br /&gt;A13 A13 A13 A13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot; A14 A14 A14 A14 cD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~WE .3 Â°MROC WE WE WE s: &lt;br /&gt;- 22 OE OE OE OE 20 CS m CS CS CS s: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62256 62256 62256 62256 0 &lt;br /&gt;:D &lt;br /&gt;-&amp;lt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul Z &lt;br /&gt;Â°MWTC -t &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â°BEO 11 01 m 12 02 :D &lt;br /&gt;Â°BEI &amp;quot;&amp;quot;Tl &lt;br /&gt;Â°BE2 13 03 ~ 14 04 (&amp;quot;&amp;quot;) &lt;br /&gt;Â°BE3 15 05 m All 16 06 A2B &lt;br /&gt;A29 17 07 UB U9 Ul0 &lt;br /&gt;A30 IB OB 19 AO DO AO DO AD 00 A31 110 Al 01 Al 01 Al 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16LB A2 02 A2 02 A2 02 A3 03 A3 03 A3 03 &lt;br /&gt;A4 04 A4 04 A4 04 &lt;br /&gt;A5 05 AS 05 A5 05 &lt;br /&gt;A6 06 A6 06 A6 06 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 A7 07 A7 07 A7 07 A7 07 &lt;br /&gt;AlB 11 01 AB AB AB AB A19 12 02 A9 A9 A9 A9 A20 13 03 Al0 AlO AID AlO A21 14 04 All All All All A22 15 05 A12 A12 A12 A12 A23 16 06 A13 A13 A13 A13 A24 7 17 07 A14 A14 A14 A14 A25 B 18 08 A26 9 &lt;br /&gt;A27 11 19 WE WE WE WE 110 OE OE OE OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16LB CS CS CS CS &lt;br /&gt;62256 62256 62256 62256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: Â° = active low as in MROC (&amp;quot;MROC) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-34 A small 256K SRAM memory system interfaced to the 80486 microprocessor &lt;br /&gt;w &lt;br /&gt;~ &lt;br /&gt;co &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;350 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;time calculations for these microprocessors are discussed in Chapters 16 and 17. The interface &lt;br /&gt;provides a signal used with the wait state generator that is not illustrated in this section of the &lt;br /&gt;text. Other devices found with these higher speed microprocessors are cache memory and inter-&lt;br /&gt;leaved memory systems. These also are presented in Chapters 16 with the 80386DX and 80486 &lt;br /&gt;microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PENTIUM AND PENTIUM PRO (64-BIT) MEMORY INTERFACE &lt;br /&gt;The Pentium and Pentium Pro microprocessors, except for the P24T version, contain a 64-bit &lt;br /&gt;data bus that either requires eight decoders (one per bank) or eight separate write signals. In most &lt;br /&gt;systems, separate write signals are used with these microprocessors when interfacing memory. &lt;br /&gt;Figure 9-35 illustrates the Pentium's memory organization and its eight memory banks. Notice &lt;br /&gt;that this is almost identical to the 80486 except that it contains eight banks instead of four. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with earlier versions of the Intel microprocessor, this organization is required for up-&lt;br /&gt;ward memory compatibility. The separate write strobe signals are obtained by combining the &lt;br /&gt;bank enable signals with the MWTC signal, which is generated by combining the MilO with &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000171-___ -1 &lt;br /&gt;OOOOOOOFI-___ -1 &lt;br /&gt;00000007l=,.--_-..,.,:-:! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;063 056 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000161-___ -1 &lt;br /&gt;OOOOOOOEI-___ -1 &lt;br /&gt;00000006!::-:-:~_-..,.~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;055 048 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000151-___ -1 &lt;br /&gt;000000001-___ -1 &lt;br /&gt;00000005!:-:::~_-...-:-:! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;047 040 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000141-___ -1 &lt;br /&gt;ooooooocl-___ -1 &lt;br /&gt;00000004~;__-_;:;:~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;039 032 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000013 Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·01 &lt;br /&gt;00000008 I &lt;br /&gt;00000003 I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;031 024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000121-___ -1 &lt;br /&gt;OOOOOOOAI-___ -1 &lt;br /&gt;00000002l=,.--_-..,.~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;023 016 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000111-___ -1 &lt;br /&gt;000000091-___ -1 &lt;br /&gt;00000001l::= __ -;:;,,,,J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015 08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000101-___ -1 &lt;br /&gt;000000081-___ -1 &lt;br /&gt;00000000.,..,.. __ --::&amp;quot;&amp;quot;' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-35 The memory organization of the Pentium microprocessor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-6 PENTIUM AND PENTIUM PRO (64-BIT) MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-36 The genera-&lt;br /&gt;tion of the write strobes for &lt;br /&gt;the Pentium microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE? ______ -'----\\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE6 ____ -j-_-&amp;quot;----\\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BES -----t---&amp;quot;----\\ &lt;br /&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE4 ____ -j-__ '~2---\\ &lt;br /&gt;13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8E3---_~-~-4 &lt;br /&gt;MW~ ____ ~-~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8Et ____ ~-~-4 &lt;br /&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8EO ____ -t-__ '~2___\\ &lt;br /&gt;13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;?4F32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;351 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;w fit The circuit employed for bank write signals appears in Figure 9-36. As can be imagined, &lt;br /&gt;we often find a PAL used for bank write signal generation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64-Bit Memory Interface &lt;br /&gt;Figure 9-37 illustrates a small Pentium memory system. This system uses a PALl6LS to decode &lt;br /&gt;the memory address and a second PAL16LS to generate the separate bank write signals. This &lt;br /&gt;system contains sixteen 27512 EPROM memory devices (64K x S) interfaced to the &lt;br /&gt;Pentium/pentium Pro at locations FFFOOOOOH-FFFFFFFFH. This is a total memory size of 1M &lt;br /&gt;bytes organized so each bank contains two memory components. Note that the Pentium Pro can &lt;br /&gt;be configured with 36 address connections, allowing up to 640 of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory decoding, as illustrated in Example 9-10, is similar to the earlier examples except &lt;br /&gt;that with the Pentium/Pentium Pro, the rightmost three address bits (A2-AO) are ignored. In this &lt;br /&gt;case, the decoder selects two sections of memory that are 64-bits wide and contain 512K bytes of &lt;br /&gt;EPROM memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Ao address input of each memory device connects to the A3 address output of the &lt;br /&gt;Pentium. This Al address input of each memory device connects to the A4 address output of the Pen-&lt;br /&gt;tium. This skewed address connection continues until the AI5 address input to the memory is &lt;br /&gt;connected to the AI8 address output of the Pentium. Address positions A18-A28 are decoded by &lt;br /&gt;PALl6L8 U2, and AZ9-A31 are decoded by PALl6L8 UI. The program for both PAL devices is &lt;br /&gt;listed in Example 9-10 for memory locations FSOOOOOOH-FFFFFFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-10 &lt;br /&gt;TITLE Address Decoder &lt;br /&gt;PATTERN Test 6 (PAL U1) &lt;br /&gt;REVISION A &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 6/11/96 &lt;br /&gt;CHIP DECODER6 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;A29 &lt;br /&gt;A30 &lt;br /&gt;A31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A19 &lt;br /&gt;A20 &lt;br /&gt;A21 &lt;br /&gt;A22 &lt;br /&gt;A23 &lt;br /&gt;A24 &lt;br /&gt;A25 &lt;br /&gt;A26 &lt;br /&gt;A27 &lt;br /&gt;A28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;024 - 031 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;016- 023 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;08 - 015 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00-,07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 -A18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 U4 U5 &lt;br /&gt;AO 00 AO 00 AO 00 &lt;br /&gt;Al 01 Al 01 Al 01 &lt;br /&gt;A2 02 A2 02 A2 02 &lt;br /&gt;A3 03 A3 03 A3 03 &lt;br /&gt;A4 04 A4 04 A4 04 &lt;br /&gt;A5 05 A5 05 A5 05 &lt;br /&gt;A6 06 A6 06 A6 06 &lt;br /&gt;A7 07 A7 07 A7 07 &lt;br /&gt;A8 AS A8 &lt;br /&gt;A9 A9 A9 &lt;br /&gt;AlO Al0 Al0 &lt;br /&gt;All All All &lt;br /&gt;A12 A12 A12 &lt;br /&gt;A13 A13 A13 &lt;br /&gt;A14 A14 A14 &lt;br /&gt;A15 A15 A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cr cr cr &lt;br /&gt;OE OE OE &lt;br /&gt;27512 27512 27512 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U7 U8 U9 &lt;br /&gt;AO 00 AO 00 AO 00 &lt;br /&gt;Al 01 Al 01 Al 01 &lt;br /&gt;A2 02 A2 02 A2 02 &lt;br /&gt;A3 03 A3 03 A3 03 &lt;br /&gt;A4 04 A4 04 A4 04 &lt;br /&gt;A5 05 A5 05 A5 05 &lt;br /&gt;A6 06 A6 06 A6 06 &lt;br /&gt;A7 07 A7 07 A7 07 &lt;br /&gt;A8 AS AS &lt;br /&gt;A9 A9 A9 &lt;br /&gt;Al0 Al0 Al0 &lt;br /&gt;All All All &lt;br /&gt;A12 A12 A12 &lt;br /&gt;A13 A13 A13 &lt;br /&gt;A14 A14 A14 &lt;br /&gt;A15 A15 A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~ 20 cr CE 22 OE OE 16LS MRUC .Â«  &lt;br /&gt;27512 27512 27512 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;032-039 __________________________________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;040-047 ________________________________________________________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04S-055 ______________________________________________________________________________________ -J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U6 &lt;br /&gt;AO 00 &lt;br /&gt;Al 01 &lt;br /&gt;A2 02 &lt;br /&gt;A3 03 &lt;br /&gt;A4 04 &lt;br /&gt;A5 05 &lt;br /&gt;A6 06 &lt;br /&gt;A7 07 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cr &lt;br /&gt;OE &lt;br /&gt;27512 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul0 &lt;br /&gt;AO 00 &lt;br /&gt;Al 01 &lt;br /&gt;A2 02 &lt;br /&gt;A3 03 &lt;br /&gt;A4 04 &lt;br /&gt;AS 05 &lt;br /&gt;A6 06 &lt;br /&gt;A7 07 &lt;br /&gt;AS &lt;br /&gt;A9 &lt;br /&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CE &lt;br /&gt;OE &lt;br /&gt;27512 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;056-063 ________________________________________________________________________________________________________________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-37 A small 512K-byte EPROM memory interfaced to the Pentium microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;w &lt;br /&gt;CJ1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(&amp;quot;&amp;quot;) &lt;br /&gt;:::r: &lt;br /&gt;:t-&lt;br /&gt;-U &lt;br /&gt;--t &lt;br /&gt;m &lt;br /&gt;&amp;quot;:D &lt;br /&gt;&amp;lt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s: &lt;br /&gt;m &lt;br /&gt;s: &lt;br /&gt;0 &lt;br /&gt;&amp;quot;:D &lt;br /&gt;-&amp;lt; &lt;br /&gt;Z &lt;br /&gt;--t &lt;br /&gt;m &lt;br /&gt;&amp;quot;:D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; :t-(&amp;quot;&amp;quot;) &lt;br /&gt;m &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-7 DYNAMIC RAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A29 A30 A31 NC NC NC NC NC NC GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;U2 CE NC NC NC NC NC NC NC VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ICE = /U2 * A29 * A30 * A31 &lt;br /&gt;TITLE Address Decoder &lt;br /&gt;PATTERN Test 7 (PAL U2) &lt;br /&gt;REVISION A &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 6/12/96 &lt;br /&gt;CHIP DECODER7 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ipins 1 2 3 4 5 6 7 8 &lt;br /&gt;A19 A20 A21 A22 A23 A24 A25 A26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;A28 U2 NC NC NC NC NC NC U2 VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9 &lt;br /&gt;A27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/U2 = A19 * A20 * A20 * A21 * A22 * A23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DYNAMIC RAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;353 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* A24 * A25 * A26 * A27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because RAM memory is often very large, it requires many SRAM devices at a great cost or just &lt;br /&gt;a few DRAMs (dynamic RAMs) at a much reduced cost. The DRAM memory, as briefly dis-&lt;br /&gt;cussed in Section 9-1, is fairly complex because it requires address multiplexing and refreshing. &lt;br /&gt;Luckily, the integrated circuit manufacturers have provided a dynamic RAM controller that in-&lt;br /&gt;cludes the address multiplexers and all the timing circuitry necessary for refreshing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the text covers the DRAM memory device in much more detail than in Sec-&lt;br /&gt;tion 9-1 and provides information on the use of a dynamic controller in a memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DRAM Revisited &lt;br /&gt;As mentioned in Section 9-1, a DRAM retains data for only 2-4 ms and requires the multi-&lt;br /&gt;plexing of address inputs. We have already covered address multiplexers in Section 9-1, but we &lt;br /&gt;will examine the operation of the DRAM during refresh in detail here. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As previously mentioned, a DRAM must be refreshed periodically because it stores data &lt;br /&gt;internally on capacitors that lose their charge in a short period of time. In order to refresh a &lt;br /&gt;DRAM, the contents of a section of the memory must periodically be read or written. Any read &lt;br /&gt;or write automatically refreshes an entire section of the DRAM. The number of bits refreshed de-&lt;br /&gt;pends on the size of the memory component and its internal organization. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Refresh cycles are accomplished by doing a read, a write, or a special refresh cycle that &lt;br /&gt;doesn't read or write data. The refresh cycle is totally internal to the DRAM and is accomplished &lt;br /&gt;while other memory components in the system operate. This type of refresh is called either &lt;br /&gt;hidden refresh, transparent refresh, or sometimes cycle stealing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to accomplish a hidden refresh while other memory components are functioning, &lt;br /&gt;an RAS-only cycle strobes a row address into the DRAM to select a row of bits to be refreshed. &lt;br /&gt;The RAS input also causes the selected row to be read out internally and rewritten into the se-&lt;br /&gt;lected bits. This recharges the internal capacitors that store the data. This type of refresh is &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;354 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;hidden from the system because it occurs while the microprocessor is reading or writing to other &lt;br /&gt;sections of the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The DRAM's internal organization contains a series of rows and columns. A 256K x 1 &lt;br /&gt;DRAM has 256 columns, each containing 256-bits, or rows organized into four sections of 64K-&lt;br /&gt;bits each. Whenever a memory location is addressed, the column address selects a column (or in-&lt;br /&gt;ternal memory word) of 1,024-bits (one per section of the DRAM). Refer to Figure 9-38 for the &lt;br /&gt;internal structure of a 256K x 1 DRAM. Note that larger memory devices are structured simi-&lt;br /&gt;larly to the 256K x 1 device. The difference usually lies in either the size of each section or the &lt;br /&gt;number of sections in parallel. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-39 illustrates the timing for an RAS-only refresh cycle. The main difference be-&lt;br /&gt;tween the RAS and a read or write is that it applies only a refresh address, which is usually ob-&lt;br /&gt;tained from a 7- or 8-bit binary counter. The size of the counter is detennined by the type of &lt;br /&gt;DRAM being refreshed. The refresh counter is incremented at the end of each refresh cycle, so &lt;br /&gt;all the rows are refreshed in 2 or 4 ms, depending on the type of DRAM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If there are 256 rows to be refreshed within 4 ms, as in a 256K x 1 DRAM, then the refresh &lt;br /&gt;cycle must be activated at least once every 15.6 /ls in order to meet the refresh specification. For &lt;br /&gt;example, it takes the 8086/8088, running at a 5 MHz clock rate, 800 ns to do a read or a write. &lt;br /&gt;Because the DRAM must have a refresh cycle every 15.6 /ls, this means that for every 19 &lt;br /&gt;memory reads or writes, the memory system must run a refresh cycle or memory data will be &lt;br /&gt;lost. This represents a loss of 5 percent of the computer's time, a small price to pay for the sav-&lt;br /&gt;ings represented by using the dynamic RAM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDO Memory &lt;br /&gt;A slight modification to the structure of the DRAM changes the device into an EDO (extended &lt;br /&gt;data output) DRAM device. In the EDO memory, any memory access, including a refresh, &lt;br /&gt;stores the 256 bits selected by RAS into latches. These latches hold the next 256-bits of infor-&lt;br /&gt;mation, so in most programs, which are sequentially executed, the data are available without any &lt;br /&gt;wait states. This slight modification to the internal structure of the DRAM increases system per-&lt;br /&gt;fonnance by about 15 to 25 percent. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DRAM Controllers &lt;br /&gt;In most systems, a DRAM controller integrated circuit perfonns the task of address multiplexing &lt;br /&gt;and the generation of the DRAM control signals. Some newer embedded microprocessors such &lt;br /&gt;as the 80186/80188 include the refresh circuitry as a part of the microprocessor. Because of the &lt;br /&gt;extreme complexity of some of the newer DRAM controllers, this text details the Intel 82C08, &lt;br /&gt;which controls up to two banks of 256 K x 16 DRAM memory. With the 8086 or the &lt;br /&gt;80286/80386SX microprocessors, this can be up to 1M byte of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 82C08 contains an address multiplexer that multiplexes an 18-bit address onto 9 ad-&lt;br /&gt;dress connections for 256K memory devices. Figure 9-40 shows the pin-out of the DRAM con-&lt;br /&gt;troller. The address inputs are labeled ALO-ALg and AHO-AHgâ¢ The address outputs to the &lt;br /&gt;DRAM are labeled AOO-AOg. The 82e08 contains circuitry that generates the CAS and RAS &lt;br /&gt;signals for the DRAM. These signals are developed internally by the CLK, Sf, and SO signals. &lt;br /&gt;Note that Sf and SO provided by the system are used as RD and WR inputs to the 82C08 DRAM &lt;br /&gt;controller. The AACK/XACK signal is an acknowledge output that is used to indicate the ready &lt;br /&gt;condition for the microprocessor. This pin llonnally connects to the READY input of the micro-&lt;br /&gt;processor or the clock generator SRDY input. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 9-41 illustrates this device connected to a series of four 256 K x 8-bit SIMM &lt;br /&gt;memory modules (41256A8) that comprise a 1M byte memory system for the 80286 micro-&lt;br /&gt;processor. Memory circuits U3 and US fonn the high memory bank and U4 and U6 fonn the low &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CAS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WE &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;...::::::. &lt;br /&gt;...=:::: &lt;br /&gt;'---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-- r-- 255 l- t- - r-&lt;br /&gt;R I- 0 1 - 254 - I--0 I- 253 -- ---&lt;br /&gt;W l- e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I- ~ 64K array 64K array ! I- r (256 X 256) (256 X 256) &lt;br /&gt;t ~ d 2 222 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;e - --- ---'~'_I 555~ -h _ 0 0 1 2 345 I-&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L......- L.....- I I , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_ ~ Multiplexor2 Multiplexor H &lt;br /&gt;C &lt;br /&gt;0 &lt;br /&gt;I &lt;br /&gt;u &lt;br /&gt;m &lt;br /&gt;n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;a &lt;br /&gt;t &lt;br /&gt;c &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ Notes: I. Decoder is an 8-line to 256-line decoder. &lt;br /&gt;2. Multiplexor is 256 to I line. &lt;br /&gt;3. Multiplexor is 4 to 1 line. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-&lt;br /&gt;I--&lt;br /&gt;---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64K array 64K array &lt;br /&gt;(256 X 256) (256 X 256) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I--&lt;br /&gt;I--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, , , -ilT &lt;br /&gt;Multiplexor H Multiplexor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Lr-&lt;br /&gt;M3 &lt;br /&gt;U &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--I-- X &lt;br /&gt;~'--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-38 The internal structure of a 256K x 1 DRAM. Note that each of the internal 256 words are 1 ,025-bits wide. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Din &lt;br /&gt;Dou! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'f &lt;br /&gt;....&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CJ &lt;br /&gt;-&amp;lt; &lt;br /&gt;Z &lt;br /&gt;:to&amp;gt; &lt;br /&gt;:s: &lt;br /&gt;o &lt;br /&gt;:JJ &lt;br /&gt;:to&amp;gt; &lt;br /&gt;:s: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;w &lt;br /&gt;()1 &lt;br /&gt;()1 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;356 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-39 The timing diagram of the RAS refresh cycle for the TMS4464 DRAM (Courtesy &lt;br /&gt;of Texas Instruments Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-40 The 82C08 &lt;br /&gt;DRAM controller that controls &lt;br /&gt;two banks of memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82C08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALO AOO &lt;br /&gt;ALl AOl &lt;br /&gt;AL2 A02 &lt;br /&gt;AL3 A03 &lt;br /&gt;AlA A04 &lt;br /&gt;AL5 A05 &lt;br /&gt;AL6 A06 &lt;br /&gt;AL7 A07 &lt;br /&gt;AL8 A08 &lt;br /&gt;AHO &lt;br /&gt;AH! RASO &lt;br /&gt;AH2 RAS! &lt;br /&gt;AH3 CASO &lt;br /&gt;AH4 CAS! &lt;br /&gt;AH5 &lt;br /&gt;AH6 AA/XA &lt;br /&gt;AH7 WE/PCK &lt;br /&gt;AH8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD &lt;br /&gt;WR &lt;br /&gt;RESET &lt;br /&gt;CLK &lt;br /&gt;PCTL &lt;br /&gt;PE &lt;br /&gt;BS &lt;br /&gt;RFRQ &lt;br /&gt;POI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bank. The PAL l6L8 combines the WE signal from the 82C08 with Ao to generate a bank write &lt;br /&gt;signal for U4 and U6, and it combines WE with BHE to generate a bank write signal for U3 and &lt;br /&gt;U5. The PAL also develops the controller selection signal (PE) by combining MilO with address &lt;br /&gt;lines Azo-A23 to decode the memory at locations OOOOOOH-OFFFFFH. The A19 signal selects the &lt;br /&gt;upper bank (U3 and U4) or the lower bank (U5 and U6) through the BS (bank select) input to &lt;br /&gt;the 82C08 DRAM controller. Example 9-11 lists the program for the PAL 16L8 used for bank &lt;br /&gt;and memory selection. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 9-11 &lt;br /&gt;TITLE Address Decoder &lt;br /&gt;PATTERN Test 7 &lt;br /&gt;REVISION A &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 6/14/96 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;AI &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;AID &lt;br /&gt;All &lt;br /&gt;AI2 &lt;br /&gt;AI3 &lt;br /&gt;AI4 &lt;br /&gt;AI5 &lt;br /&gt;AI6 &lt;br /&gt;AI7 &lt;br /&gt;AI8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI &lt;br /&gt;SO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BHE &lt;br /&gt;AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A20 &lt;br /&gt;A21 &lt;br /&gt;A22 &lt;br /&gt;A23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MilO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D8-D15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO-D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bU2 II 01 ~ll 02 03 04 15 05 16 06 &lt;br /&gt;17 07 &lt;br /&gt;18 08 &lt;br /&gt;19 &lt;br /&gt;110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALO AOO &lt;br /&gt;ALI AOI &lt;br /&gt;AL2 A02 &lt;br /&gt;AU Am &lt;br /&gt;AU A04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;46 ~t~ A05 A06 &lt;br /&gt;Al7 AO? &lt;br /&gt;AL8 AOS &lt;br /&gt;AHO &lt;br /&gt;AHI RASO &lt;br /&gt;AH2 RASI &lt;br /&gt;AH3 CASO &lt;br /&gt;AH4 CASI &lt;br /&gt;AH5 &lt;br /&gt;AH6 AA/XA &lt;br /&gt;AH? WE/PCK &lt;br /&gt;AH8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30 RD &lt;br /&gt;?'l WR &lt;br /&gt;!3 RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P PCTL liE &lt;br /&gt;BS ~ RFRQ PDI &lt;br /&gt;~ 82C08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ft-&lt;br /&gt;4t ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;High data bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Low data bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RI U3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1~16 ~AO D&amp;lt;~ ~'-I;~ ~ AI D2 ~A2 3 A3 D4 &lt;br /&gt;5 A~ 33 ~~~ D5~ g~~ 13 .6~~ I A6 14 A-'\\.,. 9&amp;quot;&amp;quot;:- A7 D8 15 R A .A A8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f--1L---l - I%~ 21 &lt;br /&gt;,19 2~rtj 2' WE RAS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IR 1 .AA CAS &lt;br /&gt;:?n ~~ 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 iAAA 9 41256A8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &amp;quot;7 R ~ I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~AO gi~ AI A2 D3 &lt;br /&gt;:8Â£ ~~ ~~ ~ ~~ D7 A7 DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A8 &lt;br /&gt;21. WE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAS &lt;br /&gt;CAS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41256A8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 9-41 A 1 M-byte memory system using four 256K SIMM memory devices and the 82C08 DRAM controller, &lt;br /&gt;This section of memory is decoded at locations OOOOOOH-OFFFFFH by the PAL 16L8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~AO AI&lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~!E ~~ N4= A5 ~A6 A7 &lt;br /&gt;AS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ WE RAS CAS &lt;br /&gt;41256A8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U6 &lt;br /&gt;~Â±AO ~fAI A2 &lt;br /&gt;~fE A3 ~~~ A6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21 WE L-~ RAS &lt;br /&gt;CAS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41256A8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DI~ &lt;br /&gt;D2~~ D3 b &lt;br /&gt;g;fMS &lt;br /&gt;D6 ~ g~ b &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~ D5~ g~~ &lt;br /&gt;D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'f' &lt;br /&gt;-.j &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CJ &lt;br /&gt;-&amp;lt; &lt;br /&gt;z &lt;br /&gt;J&amp;gt; &lt;br /&gt;S &lt;br /&gt;co &lt;br /&gt;:rJ &lt;br /&gt;J&amp;gt; &lt;br /&gt;S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;w &lt;br /&gt;(J1 &lt;br /&gt;--..J &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;358 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHIP DECODER7 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;WE BHE AO A20 A21 A22 A23 NC NC GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;MIO NC NC NC NC NC HWR LWR PE VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/HWR = /BHE * /WE &lt;br /&gt;/LWR = /AO * /WE &lt;br /&gt;/PE = /A20 * /A21 * /A22 * /A23 * MIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. All memory devices have address inputs; data inputs and outputs, or just outputs; a pin for &lt;br /&gt;selection; and one or more pins that control the operation of the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Address connections on a memory component are used to select one of the memory loca-&lt;br /&gt;tions within the device. Ten address pins have 1,024 combinations and therefore are able to &lt;br /&gt;address 1,024 different memory locations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Data connections on a memory are used to enter information to be stored in a memory loca-&lt;br /&gt;tion and also to retrieve information read from a memory location. Manufacturers list their &lt;br /&gt;memory as, for example, 4K x 4, which means that the device has 4K memory locations &lt;br /&gt;(4,096) and 4-bits are stored in each location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. Memory selection is accomplished via a chip selection pin (CS) on many RAMs or a chip &lt;br /&gt;enable pin (CE) on many EPROM or ROM memories. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Memory function is selected by an output enable pin (OE), for reading data, which normally &lt;br /&gt;connects to the system read signal (RD or MRDC). The write enable pin (WE), for writing &lt;br /&gt;data, normally connects to the system write signal (WR or MWTC). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. An EPROM memory is programmed by an EPROM programmer and can be erased if ex-&lt;br /&gt;posed to ultraviolet light. Today, EPROMs are available in sizes from IK x 8 all the way up &lt;br /&gt;to 128K x 8 and larger. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. The flash memory (EEPROM) is programmed in the system by using a 12 V programming &lt;br /&gt;pulse. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Static (SRAM) retains data for as long as the system power supply is attached. These &lt;br /&gt;memory types are available in sizes up to 128K x 8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. Dynamic RAM (DRAM) retains data for only a short period, usualIy 2-4 ms. This creates &lt;br /&gt;problems for the memory system designer, because the DRAM must be refreshed periodi-&lt;br /&gt;calIy. DRAMs also have mUltiplexed address inputs that require an external multiplexer to &lt;br /&gt;provide each half of the address at the appropriate time. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Memory address decoders select an EPROM or RAM at a particular area of the memory. &lt;br /&gt;Commonly found address decoders include the 74LS138 3-to-8Iine decoder, the 74LSI39 &lt;br /&gt;2-to-4 line decoder, and programmed selection logic in the form of a PROM or PLD. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II. The PROM and PLD address decoders for microprocessors such as the 8088 through the &lt;br /&gt;Pentium Pro reduce the number of integrated circuits required to complete a functioning &lt;br /&gt;memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The 8088 minimum mode memory interface contains 20 address lines, 8 data lines, and 3 &lt;br /&gt;control lines: RD, WR, and 101M. The 8088 memory functions correctly only when alI of &lt;br /&gt;these lines are used for memory interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. The access speed of the EPROM must be compatible with the microprocessor to which it is &lt;br /&gt;interfaced. Many EPROMs available today have an access time of 450 ns, which is too slow &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9-9 QUESTIONS AND PROBLEMS 359 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;for the S MHz 8088. In order to circumvent this problem, a wait state is inserted to increase &lt;br /&gt;memory access time to 660 ns. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Parity checkers are becoming commonplace today in many microprocessor-based micro-&lt;br /&gt;computer systems. An extra bit is stored with each byte of memory, making the memory &lt;br /&gt;9-bits wide instead of 8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IS. Error correction features are also available for memory systems, but these require the &lt;br /&gt;storage of many more bits. If an 8-bit number is stored with an error correction circuit, it ac-&lt;br /&gt;tually takes 13-bits of memory: S for an error checking code and 8 for the data. Most error &lt;br /&gt;correction integrated circuits are able to correct only a single-bit error. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. The 8086/80286/80386SX memory interface has a 16-bit data bus and contains an M/IO &lt;br /&gt;control pin, whereas the 8088 has an 8-bit data bus and contains an IO/M pin. In addition to &lt;br /&gt;these changes, there is an extra control signal, bus high enable (BHE). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. The 8086/80386/80386SX memory is organized in two 8-bit banks: high bank and low &lt;br /&gt;bank. The high bank of memory is enabled by the BHE control signal, and the low bank by &lt;br /&gt;the Ao address signal or by the BLE control signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. Two common schemes for selecting the banks in an 8086/80286/80386SX-based system in-&lt;br /&gt;clude (1) a separate decoder for each bank and (2) separate WR control signals for each bank &lt;br /&gt;with a common decoder. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. Memory interfaced to the 80386DX and 80486 is 32-bits wide as selected by a 32-bit ad-&lt;br /&gt;dress bus. Because of the width of this memory, it is organized in four memory banks that &lt;br /&gt;are each 8-bits wide. Bank selection signals are provided by the microprocessor as BE3, &lt;br /&gt;BE2, BEl, and BEO. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. Memory interfaced to the Pentium and Pentium Pro is 64-bits wide as selected by a 32-bit &lt;br /&gt;address bus. Because of the width of the memory, it is organized in eight banks that are each &lt;br /&gt;8-bits in width. Bank selection signals are provided by the microprocessor as BE7-BEO. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21. Dynamic RAM controllers are designed to control DRAM memory components. Many &lt;br /&gt;DRAM controllers today contain address multiplexers, refresh counters, and the circuitry re-&lt;br /&gt;quired to do a periodic DRAM memory refresh. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. What types of connections are common to all memory devices? &lt;br /&gt;2. List the number of words found in each memory device for the following numbers of ad-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;dress connections: &lt;br /&gt;(a) 8 &lt;br /&gt;(b) 11 &lt;br /&gt;(c) 12 &lt;br /&gt;(d) 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. List the number of data items stored in each of the following memory devices and the &lt;br /&gt;number of bits in each datum: &lt;br /&gt;(a) 2K x 4 &lt;br /&gt;(b) IK x 1 &lt;br /&gt;(c) 4K x 8 &lt;br /&gt;(d) 16Kx 1 &lt;br /&gt;(e) 64K x 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. What is the purpose of the CS or CE pin on a memory component? &lt;br /&gt;S. What is the purpose of the OE pin on a memory device? &lt;br /&gt;6. What is the purpose of the WE pin on a RAM? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;360 CHAPTER 9 MEMORY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. How many bytes of storage do the following EPROM memory devices contain? &lt;br /&gt;(a) 2708 &lt;br /&gt;(b) 2716 &lt;br /&gt;(c) 2732 &lt;br /&gt;(d) 2764 &lt;br /&gt;(e) 27128 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Why won't a 450 ns EPROM work directly with a 5 MHz 8088? &lt;br /&gt;9. What can be stated about the amount of time to erase and write a location in a flash memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;device? &lt;br /&gt;10. SRAM is an acronym for what type of device? &lt;br /&gt;11. The 4016 memory has a G pin, an S pin, and a W pin. What are these pins used for in this &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAM? &lt;br /&gt;12. How much memory access time is required by the slowest 4016? &lt;br /&gt;13. DRAM is an acronym for what type of device? &lt;br /&gt;14. The TMS4464 has eight address inputs, yet it is a 64K DRAM. Explain how a 16-bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory address is forced into eight address inputs. &lt;br /&gt;15. What are the purposes of the CAS and RAS inputs of a DRAM? &lt;br /&gt;16. How much time is required to refresh the typical DRAM? &lt;br /&gt;17. Why are memory address decoders important? &lt;br /&gt;18. Modify the NAND gate decoder in Figure 9-12 so that it selects the memory for address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;range DF800H-DFFFFH. &lt;br /&gt;19. Modify the NAND gate decoder in Figure 9-12 so that it selects the memory for address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;range 40000H-407FFH. &lt;br /&gt;20. When the Gl input is high and G2A and G2B are both low, what happens to the outputs of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the 74LS 138 3-to-8 line decoder? &lt;br /&gt;21. Modify the circuit in Figure 9-14 so that it addresses memory range 70000H-7FFFFH. &lt;br /&gt;22. Modify the circuit in Figure 9-14 so that it addresses memory range 40000H-4FFFFH. &lt;br /&gt;23. Describe the 74LSI39 decoder. &lt;br /&gt;24. Why is a PROM address decoder often found in a memory system? &lt;br /&gt;25. Reprogram the PROM in Table 9-1 so that it decodes memory address range 80000H-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8FFFFH. &lt;br /&gt;26. Reprogram the PROM in Table 9-1 so that it decodes memory address range 30000H-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3FFFFH. &lt;br /&gt;27. Modify the circuit in Figure 9-18 by rewriting the PAL program so that it addresses memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;at locations 40000H-4FFFFH. &lt;br /&gt;28. Modify the circuit of Figure 9-18 by rewriting the PAL program so it addresses memory at &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;locations BOOOOH-BFFFFH. &lt;br /&gt;29. The RD and WR minimum mode control signals are replaced by what two control signals in &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the 8086 maximum mode? &lt;br /&gt;30. Modify the circuit in Figure 9-19 so that it selects memory at location 68000-6FFFFH. &lt;br /&gt;31. Modify the circuit in Figure 9-19 so that it selects eight 2764 8K x 8 EPROMs at memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;location 1 OOOOH-l FFFFH. &lt;br /&gt;32. Add another decoder to the circuit in Figure 9-20 so that an additional eight 62256 SRAMs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;are added at location COOOOH-FFFFFH. &lt;br /&gt;33. Explain how odd parity is stored in a memory system and how it is checked. &lt;br /&gt;34. The 74LS636 error correction and detection circuit stores a check code with each byte of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data. How many bits are stored for the check code? &lt;br /&gt;35. What is the purpose of the SEF pin on the 74LS636? &lt;br /&gt;36. The 74LS636 will correct bits that are in error. &lt;br /&gt;37. Outline the major difference between the buses of the 8086 and 8088 microprocessors. &lt;br /&gt;38. What is the purpose of the BHE and Ao pins Oil the 8086 microprocessor? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;9-9 QUESTIONS AND PROBLEMS 361 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;39. What is the BLE pin and what other pin has it replaced? &lt;br /&gt;40. What two methods are used to select the memory in the 8086 microprocessor? &lt;br /&gt;41. If BHE is a logic 0, then the memory bank is selected. &lt;br /&gt;42. If Ao is a logic O. then the memory bank is selected. &lt;br /&gt;43. Why don't separate bank read (RD) strobes need to be developed when interfacing memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to the 8086? &lt;br /&gt;44. Modify the circuit in Figure 9-30 so that the EPROM is located at memory range &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COOOOH-CFFFFH and the RAM is located at memory range 30000H-4FFFFH. &lt;br /&gt;45. Develop a 16-bit wide memory interface that contains SRAM memory at locations &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;200000H-21FFFFH for the 80386SX microprocessor. &lt;br /&gt;46. Develop a 32-bit wide memory interface that contains EPROM memory at locations &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFOOOOH-FFFFFFFFH . &lt;br /&gt;47. Develop a 64-bit wide memory for the Pentium/pentium Pro that contains EPROM at loca-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tions FFFOOOOOH-FFFFFFFFH and SRAM at locations 00000000H-003FFFFFH. &lt;br /&gt;48. What is an RAS-only cycle? &lt;br /&gt;49. When DRAM is refreshed, can it be done while other sections of the memory operate? &lt;br /&gt;50. If a 1M x 1 DRAM requires 4 ms for a refresh and has 256 rows to be refreshed, no more &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;than of time must pass before another row is refreshed. &lt;br /&gt;51. Where is the memory address applied to the 82C08 DRAM controller? &lt;br /&gt;52. What is the purpose of the BS pin on the 82C08? &lt;br /&gt;53. What is normally connected to the WR pin of the 82C08? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;362 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 10 &lt;br /&gt;Basic lID I nteriace &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;A microprocessor is great at solving problems, but if it can't communicate with the outside &lt;br /&gt;world, it is of little worth. This chapter outlines some of the basic methods of communications, &lt;br /&gt;both serial and parallel, between humans or machines and the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this chapter, we first introduce the basic I/O interface and discuss decoding for I/O &lt;br /&gt;devices. Then we provide detail on parallel and serial interfacing, both of which have a wide &lt;br /&gt;variety of applications. As applications, we connect analog-to-digital and digital-to-analog &lt;br /&gt;converters as well as both DC and stepper motors to the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Explain the operation of the basic input and output interfaces. &lt;br /&gt;2. Decode an 8-, 16-, and 32-bit I/O device so that it can be used at any I/O port address. &lt;br /&gt;3. Define handshaking and explain how to use it with I/O devices. &lt;br /&gt;4. Interface and program the 82C55 programmable parallel interface. &lt;br /&gt;5. Interface and program the 8279 programmable keyboard/display controller. &lt;br /&gt;6. Interface and program the 16550 serial communications interface adapter. &lt;br /&gt;7. Interface and program the 8254 programmable interval timer. &lt;br /&gt;8. Interface an analog-to-digital converter and a digital-to-analog converter to the microprocessor. &lt;br /&gt;9. Interface both DC and stepper motors to the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION TO 1/0 INTERFACE &lt;br /&gt;In this section of the text, we explain the operation of the I/O instructions (IN, INS, OUT, and &lt;br /&gt;OUTS). We also explain the concept of isolated (sometimes caIled direct or I/O-mapped I/O) &lt;br /&gt;and memory-mapped I/O, the basic input and output interfaces, and handshaking. A working &lt;br /&gt;knowledge of these topics will make it easier to understand the connection and operation of the &lt;br /&gt;programmable interface components and I/O techniques presented in the remainder of this &lt;br /&gt;chapter and text. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-1 INTRODUCTION TO 1/0 INTERFACE 363 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;liD Instructions &lt;br /&gt;The instruction set contains one type of instruction that transfers information to an VO device &lt;br /&gt;(OUT) and another to read information from an VO device (IN). Instructions (INS and OUTS &lt;br /&gt;found on all versions exce::&amp;gt;t the 8086/8088) are also provided to transfer strings of data between &lt;br /&gt;the memory and an VO device. Table 10-1 lists all versions of each instruction found in the mi-&lt;br /&gt;croprocessor's instruction set. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Both the IN and OUT instructions transfer data between an I/O device and the microproces-&lt;br /&gt;sor's accumulator (AL, AX, or EAX). The VO address is stored in register DX as a 16-bit VO ad-&lt;br /&gt;dress or in the byte (p8) immediately following the opcode as an 8-bit VO address. Intel calls the &lt;br /&gt;8-bit form (p8) afixed address because it is stored with the instruction, usually in a ROM. The 16-&lt;br /&gt;bit VO address in DX is called a variable address because it is stored in a DX then used to address &lt;br /&gt;the VO device. Other instructions that use DX to address VO are INS and OUTS instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever data are transferred using the IN or OUT instruction, the VO address, often called a &lt;br /&gt;port number, appears on the address bus. The external VO interface decodes it in the same manner &lt;br /&gt;that it decodes a memory address. The 8-bit fixed port number (p8) appears on address bus connec-&lt;br /&gt;tions ~-Ao with bits A15-AS equal to 000000002' The address connections above A15 are undefined &lt;br /&gt;for an VO instruction. The 16-bit variable port number (DX) appears on address connection A'5-Ao-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. This means that the first 256 I/O port addresses (OOH-FFH) are accessed by both the fixed and vari-&lt;br /&gt;able VO instructions, but any VO address from OlOOH-FFFFH is accessed only by the variable VO &lt;br /&gt;address. In many dedicated task systems, only the rightmost 8-bits of the address are decoded, thus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 10-1 Input/output instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,p8 &lt;br /&gt;IN AX,p8 &lt;br /&gt;IN EAX, p8 &lt;br /&gt;IN AL,OX &lt;br /&gt;IN AX,OX &lt;br /&gt;IN EAX,OX &lt;br /&gt;INSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INSW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INSO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT p8,AL &lt;br /&gt;OUTp8,AX &lt;br /&gt;OUTp8,EAX &lt;br /&gt;OUTOX,AL &lt;br /&gt;OUTOX,AX &lt;br /&gt;OUT OX,EAX &lt;br /&gt;OUTSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTSW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTSO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Width &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 &lt;br /&gt;16 &lt;br /&gt;32 &lt;br /&gt;8 &lt;br /&gt;16 &lt;br /&gt;32 &lt;br /&gt;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 &lt;br /&gt;16 &lt;br /&gt;32 &lt;br /&gt;8 &lt;br /&gt;16 &lt;br /&gt;32 &lt;br /&gt;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A byte is input from port p8 into AL &lt;br /&gt;A word is input from port p8 into AX &lt;br /&gt;A doubleword is input from port p8 into EAX &lt;br /&gt;A byte is input from the port addressed by OX into AL &lt;br /&gt;A word is input from the port addressed by OX into AX &lt;br /&gt;A word is input from the port addressed by OX into EAX &lt;br /&gt;A byte is input from the port addressed by OX into the extra segment &lt;br /&gt;memory location addressed by 01, then 01 = 01 Â± 1 &lt;br /&gt;A word is input from the port addressed by OX into the extra segment &lt;br /&gt;memory location addressed by 01, then 01 = 01 Â± 2 &lt;br /&gt;A doubleword is input from the port addressed by OX into the extra segment &lt;br /&gt;memory location addressed by 01, then 01 Â± 4 &lt;br /&gt;A byte is output from AL to port p8 &lt;br /&gt;A word is output from AX to port p8 &lt;br /&gt;A doubleword is output from EAX to port p8 &lt;br /&gt;A byte is output from AL to the port addressed by OX &lt;br /&gt;A word is output from AX to the port addressed by OX &lt;br /&gt;A doubleword is output from EAX to the port addressed by OX &lt;br /&gt;A byte is output from the data segment memory location addressed by SI to &lt;br /&gt;the port addressed by OX, then SI = SI Â± 1 &lt;br /&gt;A word is output from the data segment memory locations addressed by SI to &lt;br /&gt;the port addressed by OX, then SI = SI Â± 2 &lt;br /&gt;A doubleword is output from the data segment memory locations addressed &lt;br /&gt;by SI to the port addressed by OX, then SI = SI Â± 4 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;364 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;reducing the amount of circuitry required for decoding. In a PC computer, all 16 address bus bits are &lt;br /&gt;decoded with locations OOXXH-03XXH, which are the I/O addresses used for I/O inside the Pc. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The INS and OUTS instructions address the I/O device using the DX register, but do not &lt;br /&gt;transfer data between the accumulator and the I/O device as IN and OUT. Instead, these instruc-&lt;br /&gt;tions transfer data between memory and the I/O device. The memory address is located by ES:DI &lt;br /&gt;for the INS instruction and DS:SI for the OUTS instruction. As with other string instructions, the &lt;br /&gt;contents of the pointers are incremented or decremented as dictated by the state of the direction &lt;br /&gt;flag (DF). Both INS and OUTS can also be prefixed with the REP prefix, allowing more than &lt;br /&gt;one byte or word to be transferred between I/O and memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Isolated and Memory-Mapped lID &lt;br /&gt;There are two completely different methods of interfacing I/O to the microprocessor: isolated &lt;br /&gt;JlO and memory-mapped JlO. In isolated I/O, the IN, INS, OUT, and OUTS instructions &lt;br /&gt;transfer data between the microprocessor accumulator or memory and the JlO device. In &lt;br /&gt;memory-mapped I/O, any instruction that references memory can accomplish the transfer. Both &lt;br /&gt;isolated and memory-mapped I/O are in use, so both are discussed in this text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Isolated liD. The most common I/O transfer technique used in the Intel microprocessor-based &lt;br /&gt;system is isolated I/O. The term isolated describes how the I/O locations are isolated from the &lt;br /&gt;memory system in a separate I/O address space. (Figure 10-1 illustrates both the isolated and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-1 The memory &lt;br /&gt;and 1/0 maps for the 80861 &lt;br /&gt;8088 microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;~FF~--------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) Isolated 110 (b) Memory-&lt;br /&gt;mapped 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1M x 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000 ~--------~ &lt;br /&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory + 110 &lt;br /&gt;FFFFF ~--------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000 ~--------~ &lt;br /&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 &lt;br /&gt;FFFF ~--------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MK x 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 '-------------' &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-1 INTRODUCTION TO I/O INTERFACE 365 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory-mapped address spaces for any Intel 80X86 or Pentium microprocessor.) The addresses &lt;br /&gt;for isolated I/O deyices, called ports, are separate from the memory. As a result, the user can ex-&lt;br /&gt;pand the memory to its full size without using any of this space for I/O devices. A disadvantage &lt;br /&gt;of isolated I/O is that the data transferred between I/O and the microprocessor must be accessed &lt;br /&gt;by the IN, INS, OUT, and OUTS instructions. Separate control signals for the I/O space are de-&lt;br /&gt;veloped (using M/IO and w/R) that indicate an I/O read (IORC) or an I/O write (IOWC) opera-&lt;br /&gt;tion. These signals indicate that an I/O port address appears on the address bus that is used to &lt;br /&gt;select the I/O device. In the pcrsonal computer, isolated I/O ports are used for controlling pe-&lt;br /&gt;ripheral devices. As a rule, an 8-bit port address is used to access devices located on the system &lt;br /&gt;board. such as the timer and keyboard interface. while a 16-bit port is used to access serial and &lt;br /&gt;parallel ports as well as video and disk drive systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory-Mapped liD. Unlike isolated I/O, memory-mapped I/O does not use the IN, INS, &lt;br /&gt;OUT, or OUTS instructions. Instead, it uses any instruction that transfers data between the mi-&lt;br /&gt;croprocessor and memory. A memory-mapped I/O device is treated as a memory location in the &lt;br /&gt;memory map. The main advantage of memory-mapped I/O is that any memory transfer instruc-&lt;br /&gt;tion can be used to access the I/O device. The main disadvantage is that a portion of the memory &lt;br /&gt;system is used as the I/O map. This reduces the amount of memory available to applications. An-&lt;br /&gt;other advantage is that the 10RC and 10WC signals have no function in a memory-mapped I/O &lt;br /&gt;system and may reduce the amount of circuitry required for decoding. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Personal Computer lID Map &lt;br /&gt;The personal computer uses part of the I/O map for dedicated functions. Figure 10-2 shows &lt;br /&gt;the I/O map for the Pc. Note that I/O space between ports OOOOH and 03FFH is normally re-&lt;br /&gt;served for the computer system. The I/O ports located at 0400H-FFFFH are generally avail-&lt;br /&gt;able for user applications. Note that the 80287 arithmetic coprocessor uses I/O address &lt;br /&gt;OOF8H-OOFFH for communications: For this reason, Intel reserves I/O ports OOFOH-OOFFH. &lt;br /&gt;The 80386-Pentium Pro use i/o ports 800000F8-800000FFH for communications to their &lt;br /&gt;coprocessors. The I/O ports located between OOOOH and OOFFH are accessed via the fixed &lt;br /&gt;port I/O instructions; the ports located above OOFFH are accessed via the variable I/O port &lt;br /&gt;instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Basic Input and Output Interfaces &lt;br /&gt;The basic input device is a set of three-state buffers. The basic output device is a set of data &lt;br /&gt;latches. The term IN refers to moving data from the I/O device into the microprocessor, and the &lt;br /&gt;term OUT refers to moving data out of the microprocessor to the I/O device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Basic Input Interface. Three-state buffers are used to construct the 8-bit input port depicted &lt;br /&gt;in Figure 10-3. Notice that the external TTL data (simple toggle switches in this example) are &lt;br /&gt;connected to the inputs ot the buffers. The outputs of the buffers connect to the data bus. The &lt;br /&gt;exact data bus connections depend on the version of the microprocessor. For example, the 8088 &lt;br /&gt;has data bus connections D7-DO' while the 80486 has D31-DO and the Pentium and Pentium Pro &lt;br /&gt;have D63-DO' The circuit of Figure 10-3 allows the microprocessor to read the contents of the &lt;br /&gt;eight switches that connect to any 8-bit section of the data bus when the select signal SEL be-&lt;br /&gt;comes a logic O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When the microprocessor executes an IN instruction, the I/O port address is decoded to &lt;br /&gt;generate the logic 0 on SEL. A logic 0 placed on the output control inputs (10 and 20) of the &lt;br /&gt;74ALS244 buffer causes the data input connections (A) to be connected to the data output (Y) &lt;br /&gt;connections. If a logic I is placed on the output control inputs of the 74ALS244 buffer. the de-&lt;br /&gt;vice enters the three-state high-impedance mode that effectively disconnects the switches from &lt;br /&gt;the data bus. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;366 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-2 The I/O map &lt;br /&gt;of a personal computer illus-&lt;br /&gt;trating many of the fixed I/O &lt;br /&gt;areas &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0400 &lt;br /&gt;03FF &lt;br /&gt;03F8 &lt;br /&gt;0357 &lt;br /&gt;03FO &lt;br /&gt;03EF &lt;br /&gt;03EO &lt;br /&gt;03DF &lt;br /&gt;03DO &lt;br /&gt;03CF &lt;br /&gt;0380 &lt;br /&gt;037F &lt;br /&gt;0378 &lt;br /&gt;0377 &lt;br /&gt;0330 &lt;br /&gt;032F &lt;br /&gt;0320 &lt;br /&gt;031F &lt;br /&gt;0300 &lt;br /&gt;02FF &lt;br /&gt;02F8 &lt;br /&gt;02F7 &lt;br /&gt;0064 &lt;br /&gt;0063 &lt;br /&gt;0060 &lt;br /&gt;005F &lt;br /&gt;0044 &lt;br /&gt;0043 &lt;br /&gt;0040 &lt;br /&gt;003F &lt;br /&gt;0024 &lt;br /&gt;0023 &lt;br /&gt;0020 &lt;br /&gt;001F &lt;br /&gt;0010 &lt;br /&gt;OOOF &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I/O Expansion area &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;c-----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COM 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Floppy disk &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CGA adapter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LPT 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hard disk &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COM 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8255 (PPI) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This basic input circuit is not optional and must appear any time that input data are interfaced &lt;br /&gt;to the microprocessor. Sometimes it appears as a discrete part of the circuit, as in Figure 10-3, and &lt;br /&gt;sometimes it is built into a programmable I/O device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sixteen- or 32-bit data can also be interfaced to various versions of the microprocessor, but &lt;br /&gt;this is not nearly as common as 8-bit data. To interface 16-bits of data, the circuit in Figure 10-3 &lt;br /&gt;is doubled to include two 74ALS244 buffers that connect 16-bits of input data to the 16-bit data &lt;br /&gt;bus. To interface 32-bits of data, the circuit is expanded by a factor of 4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Basic Output Interface. The basic output interface receives data from the microprocessor &lt;br /&gt;and must usually hold it for some external device. Its latches, like the buffers found in the input &lt;br /&gt;device, are often built ir'-&amp;lt;1 the I/O device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-4 shows how eight simple light-emitting diodes (LEOs) connect to the micropro-&lt;br /&gt;cessor through a set of eight data latches. The latch stores the number output by the micro-&lt;br /&gt;processor from the data bus so that the LEOs can be lit with any 8-bit binary number. Latches are &lt;br /&gt;needed to hold the data because when the microprocessor executes an OUT instruction, the data &lt;br /&gt;are only present on the data bus for less than 1.0 )ls. Without a latch, the viewer would never see &lt;br /&gt;the LEOs illuminate. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-1 INTRODUCTION TO I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-3 The basic &lt;br /&gt;input interface illustrating the &lt;br /&gt;connection of eight switches. &lt;br /&gt;Note that the 74ALS244 is a &lt;br /&gt;three-state that controls the &lt;br /&gt;application of the switch data &lt;br /&gt;to the data bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;2 &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-=::J &lt;br /&gt;-=::J &lt;br /&gt;-=::J &lt;br /&gt;-=::J &lt;br /&gt;-=::J &lt;br /&gt;-=::J &lt;br /&gt;-=::J &lt;br /&gt;-=::J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12345678 U1 &lt;br /&gt;16 &lt;br /&gt;5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13 &lt;br /&gt;12 &lt;br /&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~--il--H+-H++------lil2 1 A 1. &lt;br /&gt;~----~~~~~----~ 1A2 ~------~~~+---~ 1Aq &lt;br /&gt;~-------4~~~--~1~1 1A4 &lt;br /&gt;r.rr---------tl-~~------:l-.,:.j 2A 1 &lt;br /&gt;m----------+-I~--~1Â¥15 2A2 &lt;br /&gt;f-7&amp;lt;------....... +----!-l!a17 2A3 &lt;br /&gt;!--'!---------------Jl-.-----L.!..i 2A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;19 1G 2G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1Y1 18 &lt;br /&gt;1Y2 16 &lt;br /&gt;1Y3 12 &lt;br /&gt;1Y4 9 &lt;br /&gt;2Y1 7 &lt;br /&gt;2Y2 5 &lt;br /&gt;2Y3 3 2Y4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;367 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When the OUT instruction executes, the data from AL, AX, or EAX are transferred to the &lt;br /&gt;latch via the data bus. Here the D inputs of a 74ALS374 octal latch are connected to the data bus &lt;br /&gt;to capture the output data, and the Q outputs of the latch are attached to the LEDs. When a Q &lt;br /&gt;output becomes a logic 0, the LED lights. Each time that the OUT instruction executes, the SEL &lt;br /&gt;signal to the latch activates, capturing the data output to the latch from any 8-bit section of the &lt;br /&gt;data bus. The data are held until the next OUT instruction executes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-4 The basic &lt;br /&gt;output interface connected to &lt;br /&gt;a set of LED displays &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 QO &lt;br /&gt;01 01 &lt;br /&gt;02 02 &lt;br /&gt;03 03 &lt;br /&gt;04 04 &lt;br /&gt;05 05 &lt;br /&gt;06 06 &lt;br /&gt;07 07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;oe &lt;br /&gt;elK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74AlS374 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;330 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;9 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;368 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Handshaking &lt;br /&gt;Many VO devices accept or release infonnation at a much slower rate than the microprocessor. &lt;br /&gt;Another method of VO control, called handshaking or polling, synchronizes the VO device with &lt;br /&gt;the microprocessor. An example device that requires handshaking is a parallel printer that prints &lt;br /&gt;100 characters per second (CPS). It is obvious that the microprocessor can definitely send more &lt;br /&gt;than 100 CPS to the printer, so a way to slow the microprocessor down to match speeds with the &lt;br /&gt;printer must be developed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-5 illustrates the typical input and output connections found on a p!inter. Here &lt;br /&gt;data are transferred through a series of data connections (D7-Do)' BUSY indicates that the &lt;br /&gt;printer is busy, and STB is a clock pulse used to send data into the printer for printing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Connector CENT36 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Connector DB25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB25 CENT36 DB25 CENT36 &lt;br /&gt;Pin number Pin number Function Pin number Pin number Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Strobe 12 12 Paper empty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 2 Data 0 (DO) 13 13 Select &lt;br /&gt;3 3 Data 1 (D1) 14 14 Afd &lt;br /&gt;4 4 Data 2 (D2) 15 32 Error &lt;br /&gt;5 5 Data 3 (D3) 16 RESET &lt;br /&gt;6 6 Dala 4 (D4) 17 31 Select in &lt;br /&gt;7 7 Data 5 (D5) 18-25 19-30 Ground &lt;br /&gt;8 8 Data 6 (D6) 17 Frame ground &lt;br /&gt;9 9 Data 7 (D7) 16 Ground &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\0 \\0 Ack 33 Ground &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 II Busy &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-5 The D825 connector found on computers and the Centronics 36-pin connector &lt;br /&gt;found on printers for the Centronics parallel printer interface &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-2 lID PORT ADDRESS DECODING 369 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ASCII data to be printed by the printer are placed on 07-00 and a pulse is applied to &lt;br /&gt;the STB connection. The strobe signals send the data into the printer so it can be printed. As soon &lt;br /&gt;as the printer receives the data, it places a logic 1 on the BUSY pin, indicating that it is busy &lt;br /&gt;printing data. The microprocessor polls or tests the BUSY pin to decide if the printer is busy. It &lt;br /&gt;the printer is busy, the microprocessor waits; if it is not busy, the microprocessor sends another &lt;br /&gt;ASCII character to the printer. The process of interrogating the printer is called handshakillc, or &lt;br /&gt;polling. Example 10-1 illustrates a simple procedure that tests the printer BUSY flag and sends &lt;br /&gt;data to the printer if it is not busy. The PRINT procedure prints the ASCII-coded contents of BL &lt;br /&gt;only if the BUSY flag is a logic 0, indicating that the printer is not busy. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-1 &lt;br /&gt;;A procedure that prints the ASCII contents of BL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 PRINT PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E4 4B IN AL,BUSY ; get BUSY flag &lt;br /&gt;0002 A8 04 TEST AL,BUSY_BIT ;test BUSY bit &lt;br /&gt;0004 75 FA JNE PRINT ;if printer busy &lt;br /&gt;0006 8A C3 MOV AL,BL ;get data from BL &lt;br /&gt;0008 E6 4A OUT PRINTER,AL ;send data to printer &lt;br /&gt;OOOA CB RET ;return from procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB PRINT ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I/O PORT ADDRESS DECODING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I/O port address decoding is very similar to memory address decoding, especially for memory-&lt;br /&gt;mapped I/O devices. In fact, we do not discuss memory-mapped I/O decoding because it is &lt;br /&gt;treated exactly the same as memory, except that the 10RC and 10WC are not used, since there is &lt;br /&gt;no IN or OUT instruction. The decision to use memory-mapped I/O is often determined by the &lt;br /&gt;size of the memory system and the placement of the I/O devices in the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The main difference between memory decoding and isolated I/O decoding is the number of &lt;br /&gt;address pins connected to the decoder. We decode A32-Ao' AZ3-Ao' or A'9-AO for memory and &lt;br /&gt;A'5-AO for isolated I/O. Sometimes, if the I/O devices use only fixed I/O addressing, we decode &lt;br /&gt;only A7-AO' Another difference is that we use the 10RC and 10WC to activate I/O devices for a &lt;br /&gt;read or a write operation. On earlier versions of the microprocessor, 101M = 1 and RD or WR are &lt;br /&gt;used to activate I/O devices. On the newest versions of the microprocessor, the MIlO = 0 and W iff. &lt;br /&gt;are used to activate I/O devices. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Decoding 8-Bit I/O Addresses &lt;br /&gt;As mentioned, the fixed I/O instruction uses an 8-bit I/O port address that appears on AI5-AO as &lt;br /&gt;OOOOH-OOFFH. If a system will never contain more than 256 I/O devices, we often decode only ad-&lt;br /&gt;dress connections ~-Aa for an 8-bit I/O port address. Thus, we ignore address connections A I5-As' &lt;br /&gt;(You carmot ignore these address connections in a personal computer-all 16 bits must be used.) &lt;br /&gt;Please note that the OX register can also address I/O ports OOH-FFH. Also note that if the address is &lt;br /&gt;decoded as an 8-bit address, then we can never include I/O devices that use a 16-bit I/O address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-6 illustrates a 74ALS138 decoder that decodes 8-bit I/O ports FOH-F7H. (We &lt;br /&gt;assume that the system will only use I/O ports OOH-FFH for this decoder.) This decoder is iden-&lt;br /&gt;tical to a memory address decoder except we only connect address bits A7-AO to the inputs of the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;370 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-6 A port de-&lt;br /&gt;coder that decodes 8-bit 1/0 &lt;br /&gt;ports. This decoder generates &lt;br /&gt;active low outputs for ports &lt;br /&gt;FOH-F7H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;AI &lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A4 &lt;br /&gt;A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V2A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LSIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A YO FOH FIH B YI F2H C Y2 F3H Y3 F4H Y4 F5H 01 YS F6H 02A Y6 F7H 02B Y7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALSI38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;decoder. Figure 10-7 shows the PAL version of this decoder. Notice that this is a better decoder &lt;br /&gt;circuit because the number of integrated circuits has been reduced to one device, the PAL. The &lt;br /&gt;program for the PAL appears in Example 10-2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-2 &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/1/96 &lt;br /&gt;CHIP DECODER8 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;AO A1 A2 A3 A4 AS A6 A7 NC GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;NC F7 F6 FS F4 F3 F2 F1 FO VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IFO = A7 * A6 * AS * A4 * A3 * IA2 * IA1 * lAO &lt;br /&gt;IF1 = A7 * A6 * AS * A4 * A3 * IA2 * IA1 * AO &lt;br /&gt;IF2 = A7 * A6 * AS * A4 * A3 * IA2 * A1 * lAO &lt;br /&gt;IF3 = A7 * A6 * AS * A4 * A3 * IA2 * A1 * AD &lt;br /&gt;IF4 = A7 * A6 * AS * A4 * A3 * A2 * IA1 * lAO &lt;br /&gt;IFS = A7 * A6 * AS * A4 * A3 * A2 * IA1 * AD &lt;br /&gt;IF6 = A7 * A6 * AS * A4 * A3 * A2 * A1 * lAO &lt;br /&gt;IF7 = A7 * A6 * AS * A4 * A3 * A2 * A1 * AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Decoding 16-Bit lID Addresses &lt;br /&gt;We also decode 16-bit 110 addresses, especially in a personal computer system. The main dif-&lt;br /&gt;ference between decoding an 8-bit 110 address and a 16-bit 110 address is that eight additional &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-7 A PAL16L8 &lt;br /&gt;decoder that generates 1/0 &lt;br /&gt;port signals for port FOH-F7H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;AI &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-2 lID PORT ADDRESS DECODING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-8 A PAL16L8 &lt;br /&gt;decoder that decodes 16-bit &lt;br /&gt;address EFF8H-EFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A15 ______________ ~ &lt;br /&gt;A14 ______________ ~~----~ A13 ______________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:~J--------------~ &lt;br /&gt;A9 ______________ ~ &lt;br /&gt;A8 ______________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;371 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;address lines (AIS-Ag) must be decoded. Figure 10-8 illustrates a circuit that contains a &lt;br /&gt;PAL16L8 and an 8-input NAND gate used to decode I/O ports EFF8H-EFFFH. These are &lt;br /&gt;common I/O port assignments in a PC used for the serial communications port. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The NAND gate decodes the first 8-bits of the I/O port address (AIS-As) so that it gener-&lt;br /&gt;ates a signal to enable the PAL16L8 for any I/O address between EFOOH and EFFFH. The &lt;br /&gt;PAL16L8 further decodes the I/O address to produce eight active low output strobes EFF8H-&lt;br /&gt;EFFFH. The program for the PAL16L8 appears in Example 10-3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-3 &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/2/96 &lt;br /&gt;CHIP DECODER9 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;AD A1 A2 A3 A4 A5 A6 A7 NAND GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;NC EFFFH EFFEH EFFDH EFFCH EFFBH EFFAH EFF9H EFF8H VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/EFF8H A7 * A6 * A5 * A4 * A3 * /A2 * /A1 * /AO * /NAND &lt;br /&gt;/EFF9H = A7 * A6 * A5 * A4 * A3 * /A2 * /A1 * AD * /NAND &lt;br /&gt;/EFFAH = A7 * A6 * A5 * A4 * A3 * /A2 * A1 * /AO * /NAND &lt;br /&gt;/EFFBH = A7 * A6 * A5 * A4 * A3 * /A2 * A1 * AD * /NAND &lt;br /&gt;/EFFCH = A7 * A6 * A5 * A4 * A3 * A2 * /A1 * /AO * /NAND &lt;br /&gt;/EFFDH = A7 * A6 * A5 * A4 * A3 * A2 * /A1 * AD * /NAND &lt;br /&gt;/EFFEH A7 * A6 * A5 * A4 * A3 * A2 * A1 * /AO * /NAND &lt;br /&gt;/EFFF7 = A7 * A6 * A5 * A4 * A3 * A2 * A1 * AD * /NAND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8- and 16-Bit liD Ports &lt;br /&gt;Now that we understand that decoding the I/O port address is probably simpler than decoding a &lt;br /&gt;memory address (because of the number of bits), we explain how data are transferred between &lt;br /&gt;the microprocessor and 8- or 16-bit I/O devices. Data transferred to an 8-bit I/O device exist in &lt;br /&gt;one of the I/O banks in a 16-bit microprocessor such as the 8086, 80286, 80186, or 80386SX. &lt;br /&gt;The I/O system contains two 8-bit memory banks, just as memory does. This is illustrated in &lt;br /&gt;Figure 10-9, which shows the separate I/O banks for a 16-bit system such as the 80386SX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because two I/O banks exist, any 8-bit I/O write requires a separate write strobe to func-&lt;br /&gt;tion correctly. I/O reads do not require separate read strobes because, as with memory, the mi-&lt;br /&gt;croprocessor reads only the byte it expects and ignores the other byte. The only time that a read &lt;br /&gt;can cause problems is when the I/O device responds incorrectly to a read operation. In the case &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;372 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-9 The I/O BHE AO &lt;br /&gt;banks found in the 8086, FFFF FFFE 80186, 80286, and 80386SX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFD FFFC &lt;br /&gt;FFFB FFFA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;------------------ ------------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;High bank Low bank &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;------------------&lt;br /&gt;-----------_ ...... ---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOS 0004 &lt;br /&gt;0003 0002 &lt;br /&gt;0001 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIS_OS D7-oo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;of an I/O device that responds to a read from the wrong bank, we may need to include separate &lt;br /&gt;read signals. This is discussed if the case arises later in this chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10--10 illustrates a system that contains two different 8-bit output devices located at &lt;br /&gt;8-bit I/O address 40H and 41H. Because these are 8-bit devices and because they appear in dif-&lt;br /&gt;ferent I/O banks, we generate separate I/O write signals. The program for the PAL16L8 decoder &lt;br /&gt;used in Figure 10-10 is illustrated in Example 10--4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-4 &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/3/96 &lt;br /&gt;CHIP DECODERA PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;BHE IOWC AO A1 A2 A3 A4 A5 A6 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;A7 NC NC NC NC NC NC 40 41 VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;140 IBLE * IIOWC * fA7 * A6 * IA5 * IA4 * IA3 * IA2 * IA1 &lt;br /&gt;141 = IBHE * IIOWC * IA7 * A6 * IA5 * IA4 * IA3 * 1A2 * IA1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When selecting 16-bit wide I/O devices, the BLE (AO) and BHE pins have no function be-&lt;br /&gt;cause both I/O banks are selected together. Although 16-bit I/O devices are relatively rare, a few &lt;br /&gt;do exist for analog-to-digital and digital-to-analog converters, as well as for some video and disk &lt;br /&gt;memory interfaces. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10--11 illustrates a 16-bit input device connected to function at 8-bit I/O addresses &lt;br /&gt;64H and 65H. Notice that the PAL16L8 decoder does not have a connection for address bit BLE &lt;br /&gt;(AO) and BHE because these signals do not apply to 16-bit wide I/O devices. The program for &lt;br /&gt;the PAL 16L8 is illustrated in Example 10--5 to show how the enable signals are generated for the &lt;br /&gt;three-state buffers (74ALS244) used as input devices. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-5 &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/5/96 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-2 1/0 PORT ADDRESS DECODING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-10 An I/O port &lt;br /&gt;decoder that selects ports &lt;br /&gt;40H and 41 H for output data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015-08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BHE &lt;br /&gt;lowe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D7-DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHIP DECODERB PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;IORC Al A2 A3 A4 A5 A6 A7 NC GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;NC NC NC NC NC NC NC NC 06X VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/06X = /IORC * /A7 * A6 * A5 * /A4 * /A3 * /A2 â¢ /Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32-Bit Wide I/O Ports &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;373 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port 41H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port40H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS374 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Although 32-bit wide 110 ports are not common, they may eventually become commonplace be-&lt;br /&gt;cause of new buses found in computer systems. The once-promising EISA system bus supports &lt;br /&gt;32-bit VO as well as the VESA local and current PCI bus, but these are only found in some com-&lt;br /&gt;puter systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The circuit of Figure 10-12 illustrates a 32-bit input port for the 80386DX or 80486 mi-&lt;br /&gt;croprocessors. As with prior interfaces, this circuit uses a single PAL to decode the 110 ports and &lt;br /&gt;four 74LS244 buffers to connect the 110 data to the data bus. The 110 ports decoded by this in-&lt;br /&gt;terface are 8-bit ports 70H-73H, as illustrated by the PAL program in Example 10-6. Also no-&lt;br /&gt;tice again that we decode only an 8-bit 110 port address. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;374 CHAPTER 10 BASIC liD INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-11 A 16-bit &lt;br /&gt;lID port decoded at lID &lt;br /&gt;addresses 64H and 65H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015-08 &lt;br /&gt;'JL &lt;br /&gt;'-.!L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V2 &lt;br /&gt;IYI IAI 2 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lORe &lt;br /&gt;AI &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;2 &lt;br /&gt;3 &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;6 &lt;br /&gt;7 &lt;br /&gt;8 &lt;br /&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07-00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-6 &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/6/96 &lt;br /&gt;CHIP DECODERC PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VI &lt;br /&gt;11 01 19 &lt;br /&gt;12 02 o+!-&lt;br /&gt;I3 03 ~ &lt;br /&gt;14 04 ~ &lt;br /&gt;15 05 ~ &lt;br /&gt;16 06 ~ &lt;br /&gt;17 07 :&amp;gt;#-&lt;br /&gt;18 08 plL &lt;br /&gt;19 &lt;br /&gt;110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;IORC A7 A6 A5 A4 A3 A2 NC NC GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;NC NC NC NC NC NC NC NC SEL VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'\\.J.L &lt;br /&gt;'-l.L &lt;br /&gt;&amp;quot;--.2.. &lt;br /&gt;~ t:Â± &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ ~ ~ A-r+ ~ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/SEL = /IORC * /A7 * A6 â¢ A5 â¢ A4 * /A3 * /A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IY2 IA2 &lt;br /&gt;IY3 IA3 6 &lt;br /&gt;IY4 IA4 8 &lt;br /&gt;2YI 2AI II Pon65H &lt;br /&gt;2Y2 2A2 13 &lt;br /&gt;2Y3 2A3 15 &lt;br /&gt;2Y4 2A4 J7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 I &lt;br /&gt;20 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V3 &lt;br /&gt;2 IYI IAI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IY2 IA2 4 &lt;br /&gt;IY3 IA3 6 &lt;br /&gt;IY4 IA4 8 &lt;br /&gt;2YI 2AI II Pon64H &lt;br /&gt;2Y2 2A2 13 15 2Y3 2A3 &lt;br /&gt;2Y4 2A4 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 1 &lt;br /&gt;20 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;With the Pentium/Pentium Pro microprocessors and their 64-bit data bus, liD ports appear &lt;br /&gt;in various banks as detennined by the liD port address. For example, 8-bit liD port 0034H ap-&lt;br /&gt;pears in Pentium liD bank 5, while the 16-bit liD port 0034H-0035H appears in Pentium banks &lt;br /&gt;5 and 6. A 32-bit liD access in the Pentium system can appear in any four consecutive liD banks. &lt;br /&gt;For example, 32-bit liD port OlOOH-OI03H appears in banks 0-3. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-3 THE PROGRAMMABLE PERIPHERAL INTERFACE 375 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-12 A 32-bit &lt;br /&gt;input port decoded at bytes &lt;br /&gt;70H-73H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Input data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lORe &lt;br /&gt;A7 &lt;br /&gt;A6 &lt;br /&gt;A5 &lt;br /&gt;A4 U4 A3 &lt;br /&gt;A2 IAI IYI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lA2 IY2 &lt;br /&gt;lA3 IY3 Input data IA4 IY4 &lt;br /&gt;2AI 2YI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L6 2A2 2Y2 &lt;br /&gt;2A3 2Y3 &lt;br /&gt;2M 2Y4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IG &lt;br /&gt;2G &lt;br /&gt;74LS244 &lt;br /&gt;U5 &lt;br /&gt;IAI IYI &lt;br /&gt;IA2 IY2 &lt;br /&gt;IA3 IY3 Input data 1M IY4 &lt;br /&gt;2AI 2YI &lt;br /&gt;2A2 2Y2 &lt;br /&gt;~A3 2Y3 &lt;br /&gt;2A4 2Y4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lG &lt;br /&gt;2G &lt;br /&gt;74LS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE PROGRAMMABLE PERIPHERAL INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;16 &lt;br /&gt;14 &lt;br /&gt;12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;16 &lt;br /&gt;14 &lt;br /&gt;12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data bus 031 - 024 &lt;br /&gt;(73H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data bus 023 - 016 &lt;br /&gt;(72H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data bus 015 - 08 &lt;br /&gt;(7IH) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data bus 07 - DO &lt;br /&gt;(70H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 82C55 programmable peripheral interface (PPI) is a very popular low-cost interfacing &lt;br /&gt;component found in many applications. The PPI has 24 pins for I/O, programmable in groups of &lt;br /&gt;12 pins, that are used in three separate modes of operation. The 82C55A can interface any TTL-&lt;br /&gt;compatible I/O device to the microprocessor. The 82C55A (CMOS version) requires the inser-&lt;br /&gt;tion wait states if operated with a microprocessor using higher than an 8 MHz clock. It also &lt;br /&gt;provides at least 2.5 rnA of sink (logic 0) current at each output with a maximum of 4.0 rnA. Be-&lt;br /&gt;cause I/O devices are inherently slow, wait states used during I/O transfers do not impact signif-&lt;br /&gt;icantly upon the speed of the system. The 82C55 still finds application (compatible for &lt;br /&gt;programming, although it may not appear In the system as a discrete 82C55) even in the latest &lt;br /&gt;80486- or Pentium Pro-based computer system. The 82C55 is used for interface to the keyboard &lt;br /&gt;and the parallel printer port in many of these personal computers. It also controls the timer and &lt;br /&gt;reads data from the keyboard interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Basic Description of the 8255 &lt;br /&gt;Figure 10-13 illustrates the pin-out diagram of the 82C55. Its three I/O ports (labeled A, B, and &lt;br /&gt;C) are programmed in groups of 12 pins. Group A connections consist of port A (P~-PAo) and &lt;br /&gt;the upper half of port C (PC7-PC 4)' and group B consists of port B (PB7-PBo) and the lower half &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;376 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-13 The pin-out &lt;br /&gt;of the 82C55 peripheral inter-&lt;br /&gt;face adapter (PPI) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82C55 &lt;br /&gt;00 &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;RO &lt;br /&gt;WR &lt;br /&gt;AO &lt;br /&gt;AI &lt;br /&gt;RESET &lt;br /&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PAO &lt;br /&gt;PAl &lt;br /&gt;PA2 &lt;br /&gt;PA3 &lt;br /&gt;PA4 &lt;br /&gt;PA5 &lt;br /&gt;PA6 &lt;br /&gt;PA7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PBO &lt;br /&gt;PBI &lt;br /&gt;PB2 &lt;br /&gt;PB3 &lt;br /&gt;PB4 &lt;br /&gt;PB5 &lt;br /&gt;PB6 &lt;br /&gt;PB7 &lt;br /&gt;PCO &lt;br /&gt;Pel &lt;br /&gt;PC2 &lt;br /&gt;PC3 &lt;br /&gt;PC4 &lt;br /&gt;Pe5 &lt;br /&gt;PC6 &lt;br /&gt;PC7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;of port C (PC3-PCO)' The 82C55 is selected by its CS pin for programming and for reading or &lt;br /&gt;writing to a port. Register selection is accomplished through the AI and Ao input pins, which se-&lt;br /&gt;lect an internal register for programming or operation. Table 10-2 shows the I/O port assign-&lt;br /&gt;ments used for programming and access to the I/O ports. In the personal computer, an 82C55 or &lt;br /&gt;its equivalent is decoded at I/O ports 60H-63H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 82C55 is a fairly simple device to interface to the microprocessor and program. For &lt;br /&gt;the 82C55 to be read or written, the CS input must be a logic 0 and the correct I/O address must &lt;br /&gt;be applied to the AI and Ao pins. The remaining port address pins are don't cares as far as the &lt;br /&gt;82C55 is concerned, and are externally decoded to select the 82C55. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-14 shows an 82C55 connected to the 80386SX so that it functions at 8-bit I/O &lt;br /&gt;port addresses COH (port A), C2H (port B), C4H (port C), and C6H (command register). This in-&lt;br /&gt;terface uses the low bank of the 80386SX I/O map. Notice from this interface that all of the &lt;br /&gt;82C55 pins are direct connections to the 80386SX, except for the CS pin. The CS pin is decoded &lt;br /&gt;and selected by a 74ALS138 decoder. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The RESET input to the 82C55 initializes the device whenever the microprocessor is reset. &lt;br /&gt;A RESET input to the 82C55 causes all ports to be set up as simple input ports using mode 0 op-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. eration. Because the port pins are internally programmed as input pins on a reset, damage is pre-&lt;br /&gt;vented when the power is first applied to the system. After a RESET, no other commands are &lt;br /&gt;needed to program the 82C55 as long as it is used as an input device at all three ports. Note that &lt;br /&gt;an 82C55 is interfaced to the personal computer at port addresses 6QH-63H for keyboard control &lt;br /&gt;and also for controlling the speaker, timer, and other internal devices such as memory expansion. &lt;br /&gt;This is true for any AT or earlier style of personal computer systerp. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 10-2 I/O port &lt;br /&gt;a~');gnments for the 8255 AI Ao Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 Port A &lt;br /&gt;0 1 Port B &lt;br /&gt;1 0 Port C &lt;br /&gt;1 Command Register &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-3 THE PROGRAMMABLE PERIPHERAL INTERFACE 377 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07-00 &lt;br /&gt;U2 &lt;br /&gt;~ DO PAO 4 &lt;br /&gt;I'JL 01 PAl 3 ~ 02 PA2 2 ['-J.L 03 PA3 I ~ 04 PA4 40 Port A &lt;br /&gt;~ D5 PA5 39 ~ 06 PA6 38 &lt;br /&gt;'-...1L 07 PA7 37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IORC 5 - PBO 18 RO OWC 36 - PBI 19 WR Al 9 AO PB2 20 A2 8 Al PB3 21 ESET 35 RESET PB4 22 &lt;br /&gt;~ CS PB5 23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PB6 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UI PB7 25 &lt;br /&gt;A7 -L A YO ~ PCO 14 A3 .-L YI 14 &lt;br /&gt;A4-L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B ~ PCI 15 C Y2 PC2 16 Y3 ~ PC3 17 A6 -L GI Y4 13 &lt;br /&gt;AS &amp;quot;* G2A YS ~ PC4 PCS 12 AO 2c G2B Y6 4- PC6 II Y7 ~ 10 PC7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALSI38 82C55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-14 The 82C55 interfaced to the low bank of the 80386SX microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the 82C55 &lt;br /&gt;The 82C55 is easy to program because it contains only two internal command registers, as illus-&lt;br /&gt;trated in Figure 10-15. Notice that bit position 7 selects either command byte A or command &lt;br /&gt;byte B. Command byte A programs the function of group A and B, while command byte B sets &lt;br /&gt;(1) or resets (0) bits of port C only if the 82C55 is programmed in mode 1 or 2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Group B pins (port B and the lower part of port C) are programmed as either input or &lt;br /&gt;output pins. Group B can operate in either mode 0 or mode 1. Mode 0 is the basic input/output &lt;br /&gt;mode that allows the pins of group B to be programmed as simple input and latched output con-&lt;br /&gt;nections. Mode 1 operation is the strobed operation for group B connections, where data are &lt;br /&gt;transferred through port B and handshaking signals are provided by port C. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Group A pins (port A and the upper part of port C) are also programmed as either input or &lt;br /&gt;output pins. The difference is that group A can operate in modes 0, 1, and 2. Mode 2 operation is &lt;br /&gt;a bi-directional mode of operation for port A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If a 0 is placed in bit position 7 of the command byte, command byte B is selected. This &lt;br /&gt;command allows any bit of port C to be set (1) or reset (0) if the 82C55 is operated in either mode &lt;br /&gt;lor 2. Otherwise, this command byte is not used for programming. We often use the bit set/reset &lt;br /&gt;function in control system to set or clear a control bit at port C. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 0 Operation &lt;br /&gt;Mode 0 operation causes the 82C55 to function as either a buffered input device or as a latched &lt;br /&gt;output device. These are the same as the basic input and output circuits discussed in the first sec-&lt;br /&gt;tion of this chapter. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;378 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-15 The com-&lt;br /&gt;mand byte of the command &lt;br /&gt;register in the 82C55. (a) Pro-&lt;br /&gt;grams ports A, B, and C &lt;br /&gt;(b) Sets or resets the bit indi-&lt;br /&gt;cated in the select a bit field &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Command byte A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;765 4 3 2 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II I I I I I I &lt;br /&gt;'--,.....-l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Command byte B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;765 4 3 2 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Group B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port C (PC3 PCO) I = input &lt;br /&gt;O=output &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PortB I = input &lt;br /&gt;0= output &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode &lt;br /&gt;00 = mode 0 &lt;br /&gt;01 = mode I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Group A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port C (PC7 -- PC4) I = input &lt;br /&gt;O=output &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PonA &lt;br /&gt;I = input &lt;br /&gt;o = output &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode &lt;br /&gt;00 = mode 0 &lt;br /&gt;01 = mode I &lt;br /&gt;lX=mode 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit set/reset &lt;br /&gt;I = set &lt;br /&gt;0= reset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selects a bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-16 shows the 82C55 connected to a set of eight 7-segment LED displays. In this &lt;br /&gt;circuit, both ports A and B are programmed as (mode 0) simple latched output ports. Port A pro-&lt;br /&gt;vides the segment data inputs to the display and port B provides a means of selecting a display po-&lt;br /&gt;sition at a time for mUltiplexing the displays. The 82C55 is interfaced to an 8088 microprocessor &lt;br /&gt;through a PAL16L8 so that it functions at JlO port numbers 0700H-0703H. The program for the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;37 DO D1 D2 D3 D4 os D6 D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;nrr~~~Â§1 I I I I I I I I I I I I I I-I I-I I-I I-I I-I 1--1 I-I &lt;br /&gt;'-----' IJ B I_I 2N2907 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vcc o---+--~&amp;gt;----+--+--I---&amp;amp;--+-----'----I--~---j----&amp;lt;I---t~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 2.2K 'JIII &amp;quot;l DO 34 DO PAO 4 1 ~ 14 &lt;br /&gt;rn rn ~ ~ &lt;br /&gt;02 2 02 PA2 g~ 0 g~ ~~~ 0 2N2222 &lt;br /&gt;05 05 PAS ~ &lt;br /&gt;06 28 06 PA6 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 2:;:: -!- 1 ~ 16 I I I LJ I I ~ WR PBl ~ 2 5 &lt;br /&gt;A1 ~~ ~~.-1..[ 4 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET 5 BESET PB4 ~ &lt;br /&gt;.-!?-- CS PBS 24 7 1 I PB6 2 a 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PB7 ~ &lt;br /&gt;pca 1~4 1K &lt;br /&gt;PC1 &lt;br /&gt;PC2 &lt;br /&gt;PC3 ~ PC4 &lt;br /&gt;pes 1 &lt;br /&gt;~g~ It &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2 U2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;AS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8255 A9 A10 &lt;br /&gt;A11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M ~l~ 1III &lt;br /&gt;FIGURE 10-16 An 8-digit LED display interfaced to the 8088 microporcessor through an 82C55 PIA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;0 &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;w &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-t &lt;br /&gt;:c &lt;br /&gt;m &lt;br /&gt;-u &lt;br /&gt;::lJ &lt;br /&gt;0 &lt;br /&gt;G) &lt;br /&gt;::lJ &lt;br /&gt;:t&amp;gt; &lt;br /&gt;s: &lt;br /&gt;s: &lt;br /&gt;:t&amp;gt; &lt;br /&gt;OJ &lt;br /&gt;r &lt;br /&gt;m &lt;br /&gt;-u &lt;br /&gt;m &lt;br /&gt;::lJ &lt;br /&gt;-u &lt;br /&gt;:c &lt;br /&gt;m &lt;br /&gt;::lJ &lt;br /&gt;:t&amp;gt; &lt;br /&gt;r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:z &lt;br /&gt;-t &lt;br /&gt;m &lt;br /&gt;::lJ &lt;br /&gt;&amp;quot; :t&amp;gt; &lt;br /&gt;0 &lt;br /&gt;m &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W &lt;br /&gt;--J &lt;br /&gt;co &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;380 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PALl6L8 is listed in Example 10--7. The PAL decodes the I/O address and also develops the &lt;br /&gt;lower write strobe for the WR pin of the 82C55. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-7 &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/6/96 &lt;br /&gt;CHIP DECODERD PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;A2 A3 A4 AS A6 A7 AS A9 Al0 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;All CS IOM A12 A13 A14 A1S NC NC VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/CS /A1S * /A14 * /A13 * /A12 * )All * Al0 * A9 * A8 * /A6 * /AS * /A4 * /A3 * &lt;br /&gt;/A2 * /IOM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The resistor values are chosen in Figure 10--16 so that the segment current is 80 rnA. This &lt;br /&gt;current is required to produce an average current of 10 rnA per segment as the displays are mul-&lt;br /&gt;tiplexed. A 6-digit display would use a segment current of 60 rnA for an average of 10 rnA per &lt;br /&gt;segment. In this type of display system, only one of the eight display positions is on at any given &lt;br /&gt;instant. The peak anode current in an 8-digit display is 560 rnA ( 7 segments x 80 rnA), but the &lt;br /&gt;average anode current is 80 rnA. In a 6-digit display, the peak current would be 420 rnA (7 seg-&lt;br /&gt;ments x 60 rnA). Whenever displays are multiplexed, we increase the segment current from 10 &lt;br /&gt;rnA (for a display that uses lOrnA per segment as the nominal current) to a value equal to the &lt;br /&gt;number of display positions times lOrnA. This means that a 4-digit display uses 40 rnA per seg-&lt;br /&gt;ment, a 5-digit display uses 50 rnA, and so on. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this display, the segment load resistor passes 80 rnA of current and has a voltage of ap-&lt;br /&gt;proximately 3.0V across it. The LED is 1.65V nominally and a few tenths are dropped across the &lt;br /&gt;anode switch and the segment switch, hence a voltage of 3.0V across the segment load resistor. &lt;br /&gt;The value ofthe resistor is 3.0V/80mA = 37.5 Q. The closest standard resistor value of 37 Q is used &lt;br /&gt;in Figure 10--16 for the segment load. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The resistor in series with the base of the segment switch assumes that the minimum gain &lt;br /&gt;of the transistor is 100. The base current is therefore 80mA/100 = 0.8 rnA. The voltage across the &lt;br /&gt;base resistor is approximately 3.0V (the minimum logic 1 voltage level of the 82C55) minus the &lt;br /&gt;drop across the emitter-base junction (0.7V), or 2.3V. The value of the base resistor is then &lt;br /&gt;2.3V/O.8mA = 2.875 KQ. The closest standard resistor value is 2.7 KQ, but a 2.2 KQ is chosen for &lt;br /&gt;this circuit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The anode switch has a single resistor on its base. The current through the resistor is &lt;br /&gt;560mA/100 = 5.6 rnA because the minimum gain of the transistor is 100. This exceeds the max-&lt;br /&gt;imum current of 4.0 rnA from the 82C55, but this is small enough that it will work without &lt;br /&gt;problem. The maximum current assumes that you are using the port pin as a TTL input to an-&lt;br /&gt;other circuit. If the amount of current was over 8.0-10.0 rnA, then appropriate circuitry in the &lt;br /&gt;form of either a Darlington pair or another transistor switch would be required. Here the &lt;br /&gt;voltage across the base resistor is 5.0V minus the drop across the emitter-base junction &lt;br /&gt;(0.7V) minus the voltage at the pet! pin (O.4V) for a logic 0 level. The value of the resistor is &lt;br /&gt;3Â·9V/5.6mA = 696 Q. The closest standard resistor value is 690 Q, but a 1 KQ is chosen in this &lt;br /&gt;example. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before software to operate the display is examined, we must first program the 82C55. This &lt;br /&gt;is accomplished with the short sequence of instructions listed in Example 10-8. Here port A and &lt;br /&gt;B are both programmed as outputs. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-3 THE PROGRAMMABLE PERIPHERAL INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BO 80 &lt;br /&gt;0002 BA 0703 &lt;br /&gt;0005 EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;programming the 82C55 PIA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOV &lt;br /&gt;HOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,10000000B &lt;br /&gt;DX,703H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address command &lt;br /&gt;;program 82C55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;381 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure to drive these displays is listed in Example 10-9. For this display system to &lt;br /&gt;function correctly, we must call this procedure often. Notice that the procedure calls another pro-&lt;br /&gt;cedure (DELAY) that causes alms time delay. This time delay is not illustrated in this example, &lt;br /&gt;but is used to allow time for each display position to tum on. It is recommended by the manu-&lt;br /&gt;facturers of LED displays that the display flash be between 100 Hz and 1,500 Hz. Using alms &lt;br /&gt;time delay, we light each digit for 1 ms for a total display flash rate of 1000 Hz / 8 display, or a &lt;br /&gt;flash rate of 125. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-9 &lt;br /&gt;;A procedure that scans the 8-digit LED display. &lt;br /&gt;;This procedure must be called from a program &lt;br /&gt;;whenever possible to display 7-segment &lt;br /&gt;;coded data from memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0006 DISP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0006 9C PUSHF ;save registers &lt;br /&gt;0007 50 &lt;br /&gt;0008 53 &lt;br /&gt;0009 52 &lt;br /&gt;OOOA 56 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB &lt;br /&gt;OOOE &lt;br /&gt;0010 &lt;br /&gt;0013 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0016 &lt;br /&gt;0016 &lt;br /&gt;0018 &lt;br /&gt;0919 &lt;br /&gt;001A &lt;br /&gt;001C &lt;br /&gt;001D &lt;br /&gt;0020 &lt;br /&gt;0022 &lt;br /&gt;0023 &lt;br /&gt;0024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE 0008 &lt;br /&gt;B4 7F &lt;br /&gt;BE DOFF R &lt;br /&gt;BA 0701 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8A C4 &lt;br /&gt;EE &lt;br /&gt;4A &lt;br /&gt;8A 00 &lt;br /&gt;EE &lt;br /&gt;E8 029A R &lt;br /&gt;DO CC &lt;br /&gt;42 &lt;br /&gt;4B &lt;br /&gt;75 FO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0026 5E &lt;br /&gt;0027 SA &lt;br /&gt;0028 5B &lt;br /&gt;0029 58 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;PUSH BX &lt;br /&gt;PUSH OX &lt;br /&gt;PUSH S1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;setup registers for display &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX,8 &lt;br /&gt;AH,7FH &lt;br /&gt;SI,OFFSET MEM-1 &lt;br /&gt;DX,701H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display 8 digits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D1SP1: &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;DEC &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;CALL &lt;br /&gt;ROR &lt;br /&gt;INC &lt;br /&gt;DEC &lt;br /&gt;JNZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP &lt;br /&gt;pOP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,AH &lt;br /&gt;DX,AL &lt;br /&gt;DX &lt;br /&gt;AL, [BX+S1j &lt;br /&gt;DX,AL &lt;br /&gt;DELAY &lt;br /&gt;AH,l &lt;br /&gt;DX &lt;br /&gt;BX &lt;br /&gt;DISP1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S1 &lt;br /&gt;DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP BX &lt;br /&gt;POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002A 9D POPF &lt;br /&gt;002B C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002C D1SP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load count &lt;br /&gt;;load selection pattern &lt;br /&gt;;address data &lt;br /&gt;;address Port B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select a digit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address Port A &lt;br /&gt;;get 7-segment data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;wait one millisecond &lt;br /&gt;;address next digit &lt;br /&gt;;address Port B &lt;br /&gt;;adjust count &lt;br /&gt;;repeat 8 times &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;restore registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The display procedure (DISP) addresses an area of memory where the data, in 7-seg-&lt;br /&gt;ment code, is stored for the eight display digits. The AH register is loaded with a code (7FH) &lt;br /&gt;that initially addresses the most-significant display position. Once this position is selected, the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;382 CHAPTER 10 BASIC lID INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;contents of memory location MEM +7 is addressed and sent to the most-significant digit. The &lt;br /&gt;selection code is then adjusted to select the next display digit, as is the address. This process &lt;br /&gt;repeats eight times to display the contents of location MEM through MEM +7 on the eight dis-&lt;br /&gt;play digits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A Stepper Motor Interfaced to the 82C55. Another device often interfaced to a computer system &lt;br /&gt;is the stepper motor. A stepper motor is a digital motor because it is moved in discrete steps as it &lt;br /&gt;traverses through 360Â°. A common stepper motor is geared to move perhaps 15Â° per step in an &lt;br /&gt;inexpensive stepper motor to 1Â° per step in a more costly high-precision stepper motor. In all &lt;br /&gt;cases, these steps are gained through many magnetic poles and/or gearing. Notice that two coils &lt;br /&gt;are energized in Figure 10-17. If less power is required, one coil may be energized at a time, &lt;br /&gt;causing the motor to step at 45Â°, 135Â°,225Â°, and 315Â°. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-17 shows a four-coil stepper motor that uses an armature with a single pole. No-&lt;br /&gt;tice that the illustration shows the stepper motor four times with the armature (permanent mag-&lt;br /&gt;netic) rotated to four discrete places. This is accomplished by energizing the coils as shown. This &lt;br /&gt;is an illustration of full stepping. The stepper motor is driven using NPN Darlington amplifier &lt;br /&gt;pairs to provide a large current to each coil. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A circuit that can drive this stepper motor is illustrated in Figure 10-1S with the four coils &lt;br /&gt;shown in place. This circuit uses the S2C55 to provide it with the drive signals used to rotate the &lt;br /&gt;armature of the motor in either the right-hand or left-hand direction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A simple procedure that drives the motor (assuming port A is programmed in mode 0 as an &lt;br /&gt;output device) is listed in Example 10-10. This subroutine is called with CX holding the number &lt;br /&gt;of steps and direction of the rotation. If ~X &amp;gt; 8000H, the motor spins in the right-hand direction; &lt;br /&gt;if CX &amp;lt; SOOOH, it spins in the left-hand direction. The leftmost bit of CX is removed, and the re-&lt;br /&gt;maining 15-bi~s contain the number of steps. Notice that the procedure uses a time delay (not &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-17 The stepper ~II~~ ~II~~ motor showing full-step operation. (a) 450 (b) 1350 &lt;br /&gt;(c) 2250 (d) 3150 ~ ~ \\ ~ &amp;lt;P -JLQQ;- ~ -.sJ'fJJ-~ ~ &lt;br /&gt;II~ II~ &lt;br /&gt;(a) (b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II~ II~ &lt;br /&gt;~ &amp;amp;9 -,JJ;!lr ~ '% ~ ~ ~ &lt;br /&gt;~II~~ ~II~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(c) (d) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-3 THE PROGRAMMABLE PERIPHERAL INTERFACE 383 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul &lt;br /&gt;00 00 PAO &lt;br /&gt;01 01 PAl &lt;br /&gt;02 02 PA2 &lt;br /&gt;03 03 PA3 &lt;br /&gt;04 04 PA4 &lt;br /&gt;05 05 PA5 &lt;br /&gt;06 06 PA6 &lt;br /&gt;07 07 PA7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-IOWC 5 RO PBO 36 &lt;br /&gt;Â·IORC 9 WR PBl AO 8 AO PB2 Al 35 Al PB3 RESET RESET PB4 6 CS PB5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PB6 &lt;br /&gt;PB7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCO &lt;br /&gt;PCl &lt;br /&gt;PC2 &lt;br /&gt;PC3 &lt;br /&gt;PC4 &lt;br /&gt;PC5 &lt;br /&gt;PC6 &lt;br /&gt;PC7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82C55 Note: .. = active low &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-18 A stepper motor interfaced to the 82C55. This illustration does not show the &lt;br /&gt;decoder. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;illustrated) that causes alms time delay. This time delay is required to allow the stepper motor &lt;br /&gt;armature time to move to its next position. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 0040 PORT EQU 40H ;assign Port A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure to control stepper motor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 STEP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 AO 0000 R MOV AL,POS ;get position &lt;br /&gt;0003 81 F9 8000 CMP CX,8000H &lt;br /&gt;0007 77 10 JA RH ;if right-hand direction &lt;br /&gt;0009 83 F9 00 CMP CX,O &lt;br /&gt;OOOC 74 14 JE STEP_OUT ;if no steps &lt;br /&gt;OOOE STEP1: &lt;br /&gt;OOOE DO CO ROL AL,l ;step left &lt;br /&gt;0010 E6 40 OUT PORT,AL &lt;br /&gt;0012 E8 0011 CALL DELAY ;wait one millisecond &lt;br /&gt;0015 E2 F7 LOOP STEP1 ;repeat until CX = 0 &lt;br /&gt;0017 EB 09 JMP STEP_OUT &lt;br /&gt;0019 RH: &lt;br /&gt;0019 81 E1 7FFF AND CX,7FFFH ;clear bit 15 &lt;br /&gt;0010 RH1: &lt;br /&gt;0010 DO C8 ROR AL,l ;step right &lt;br /&gt;001F E6 40 OUT PORT,AL &lt;br /&gt;0021 E8 0006 CALL DELAY ;wait one millisecond &lt;br /&gt;0024 E2 F7 LOOP RH1 ;repeat until CX = 0 &lt;br /&gt;0026 STEP_OUT: &lt;br /&gt;0026 A2 0000 MOV POS,AL ;save position &lt;br /&gt;0029 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0029 STEP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The current position is stored in memory location POS, which must be initialized with &lt;br /&gt;33H, 66H, OCCH, or 99H. This allows a simple ROR (step right) or ROL (step left) instruction &lt;br /&gt;to rotate the binary bit pattern for the next step. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;384 CHAPTER 10 BASIC liD INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stepper motors can also be operated in the half-step mode, which allows eight steps per se-&lt;br /&gt;quence. This is accomplished by using the full-step sequence describe4 with a half step obtained &lt;br /&gt;by energizing one coil interspersed between the full steps. Half stepping allows the armature to be &lt;br /&gt;positioned at 0,Â° 90Â°, 180Â°, and 270Â°. The half-step position codes are 11H, 22H, 44H, and 88H. &lt;br /&gt;A complete sequence of eight steps would follow as: I1H, 33H, 22H, 66H, 44H, OCCH, 88H, and &lt;br /&gt;99H. This sequence could either be output from a lookup table or generated with software. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Key Matrix Interface. Keyboards come in a vast variety of sizes, from the standard 101-key &lt;br /&gt;QWERTY keyboards interfaced to the microprocessor to small, specialized keyboards that may &lt;br /&gt;contain only 4 to 16 keys. This section of the text concentrates on the smaller keyboards that may &lt;br /&gt;be purchased, pre-assembled, or constructed out of individual key switches. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-19 illustrates a small-key matrix that contains 16 switches interfaced to ports A &lt;br /&gt;and B of an 82C55. In this example, the switches are formed into a 4 X 4 matrix, but any matrix &lt;br /&gt;could be used, such as a 2 x 8. Notice how the keys are organized into four rows &lt;br /&gt;(ROWO-ROW3) and four columns (COLO-COL3). Also notice that each row is connected to &lt;br /&gt;5.0V through a 10 KQ pull-up resistor to ensure th~t the row is pulled high when no push-button &lt;br /&gt;switch is closed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 82C55 is decoded (PAL program not shown) at 110 ports 50H-53H for an 8088 mi-&lt;br /&gt;croprocessor. Port A is programmed as an input port to read the rows, and port B is programmed &lt;br /&gt;as an output port to select a column. For example, if 1110 is output to port B pins PB3-PBO, &lt;br /&gt;column zero has a logic 1, so the four keys in column zero are selected. Notice that with a logic &lt;br /&gt;o on PBO, the only switches that can place a logic 0 onto port A are switches 0-3. If switches 4-F &lt;br /&gt;are closed, the corresponding port A pins rerrain a logic 1. Likewise, if a 1101 is output to port &lt;br /&gt;B, switches 4-7 are selected and so forth. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A flowchart of the software required to read a key from the keyboard matrix and de-&lt;br /&gt;bounce the key is illustrated in Figure 10-20. De-bouncing is normally accomplished with a &lt;br /&gt;short time delay of from 10-20 ms. The flowchart contains three main sections. The first waits &lt;br /&gt;for the release of a key. This seems awkward, but software executes very quickly in a micro-&lt;br /&gt;processor and there is a possibility that the program will return to the top of this program before &lt;br /&gt;the key is released, so we must wait for a release first. Next the flowchart shows that we wait for &lt;br /&gt;a keystroke. Once the keystroke is detected, the position of the key is calculated in the final part &lt;br /&gt;of the flowchart. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The software uses a procedure called SCAN to scan the keys, and another called DELAY &lt;br /&gt;to waste 10 ms of time for de-bouncing. The main keyboard procedure is called KEY, and it ap-&lt;br /&gt;pears with the others in Example 10-11. Note that the SCAN procedure is generic, so it can &lt;br /&gt;handle any configuration of keyboard from a 2 x 2 matrix to an 8 x 8. Changing the two equates &lt;br /&gt;at the start of the program (ROWand COL) will change the configuration of the software for any &lt;br /&gt;size keyboard. Also note that the example does not show the steps required to initialize the &lt;br /&gt;82C55 so that port A is an input port and port B is an output port. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 &lt;br /&gt;0004 &lt;br /&gt;0050 &lt;br /&gt;0051 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 EB 002F &lt;br /&gt;0004 75 FA &lt;br /&gt;0006 EB 0048 &lt;br /&gt;0009 E8 0027 &lt;br /&gt;OOOC 75 F2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A keyboard procedure that scans the keyboard and &lt;br /&gt;;returns with the numeric code of the key in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROI,S EQU 4 ;number of rows &lt;br /&gt;COLS EQU 4 ;number of columns &lt;br /&gt;PORTA EQU 50H ;port A address &lt;br /&gt;PORTB EQU 51H ;port B address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR USES CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL SCAN ;test all keys &lt;br /&gt;JNZ KEY ; if key closed &lt;br /&gt;CALL DELAY ;wait for about 10 ms &lt;br /&gt;CALL SCAN ; test all keys &lt;br /&gt;JNZ KEY ;if key closed &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 RowO PAO 3 PAl &lt;br /&gt;~ 02 PA2 1 I 03 PA3 40 Row1 04 PA4 &lt;br /&gt;n g~ PA5 39 PA6 38 37 07 PA7 Row2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r PBO , WR PBl AO PB2 , Al PB3 Row3 , RESET PB4 u CS PBS &lt;br /&gt;ColO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADO 34~ ADl 33 DO &lt;br /&gt;AD2 3? 01 &lt;br /&gt;AD3 3' &lt;br /&gt;AD4 31 &lt;br /&gt;AD5 291 &lt;br /&gt;AD6 21 A~ 271 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR RD 3f &lt;br /&gt;AO 0 &lt;br /&gt;Al 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET 3: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ports 50H-53H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82C55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~I A3 2 11 01 A4 12 02 A5 13 03 A6 5 14 04 A7 15 05 &lt;br /&gt;A8 7 16 06 &lt;br /&gt;A9 8 17 07 &lt;br /&gt;Al0 18 08 &lt;br /&gt;All 11 19 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;10iM &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-19 A 4 x 4 keyboard matrix connected to an 8088 microprocessor through the 82C55 PIA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Coil Col2 Col3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;0 &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--I &lt;br /&gt;:r: &lt;br /&gt;m &lt;br /&gt;&amp;quot;'tl &lt;br /&gt;::rJ &lt;br /&gt;0 &lt;br /&gt;GJ &lt;br /&gt;::rJ &lt;br /&gt;Â» &lt;br /&gt;s: &lt;br /&gt;s: &lt;br /&gt;Â» &lt;br /&gt;OJ &lt;br /&gt;r-&lt;br /&gt;m &lt;br /&gt;&amp;quot;'tl &lt;br /&gt;m &lt;br /&gt;~ &lt;br /&gt;&amp;quot;'tl &lt;br /&gt;:r: &lt;br /&gt;m &lt;br /&gt;::rJ &lt;br /&gt;Â» &lt;br /&gt;r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Z &lt;br /&gt;--I &lt;br /&gt;m &lt;br /&gt;::rJ &lt;br /&gt;&amp;quot;TO &lt;br /&gt;Â» &lt;br /&gt;C&amp;quot;&amp;gt; &lt;br /&gt;m &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;c.v &lt;br /&gt;ex&amp;gt; &lt;br /&gt;CJl &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;386 CHAPTER 10 BASIC liD INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-20 The flow-&lt;br /&gt;chart of a keyboard-scanning &lt;br /&gt;procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE KEY1: &lt;br /&gt;OOOE E8 0022 CALL &lt;br /&gt;0011 74 FB JZ &lt;br /&gt;0013 E8 003B CALL &lt;br /&gt;0016 E8 001A CALL &lt;br /&gt;0019 74 F3 JZ &lt;br /&gt;OOlB 50 PUSH &lt;br /&gt;OOlC BO 04 MOV &lt;br /&gt;OOlE 2A Cl SUB &lt;br /&gt;0020 B5 04 MOV &lt;br /&gt;0022 F6 E5 MUL &lt;br /&gt;0024 8A C8 MOV &lt;br /&gt;0026 FE C9 DEC &lt;br /&gt;0028 58 POP &lt;br /&gt;0029 KEY2: &lt;br /&gt;0029 DO C8 ROR &lt;br /&gt;002B FE Cl INC &lt;br /&gt;002D 72 FA JC &lt;br /&gt;002F 8A Cl MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Wait for release &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Wait for keystroke &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Return &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCAN ; test all keys &lt;br /&gt;KEY1 ;if no key closed &lt;br /&gt;DELAY ;wait for about 10 ms &lt;br /&gt;SCAN ; test all keys &lt;br /&gt;KEY1 ;if no key closed &lt;br /&gt;AX ;save row codes &lt;br /&gt;AL,COLS ;calculate starting row key &lt;br /&gt;AL,CL &lt;br /&gt;CH,ROWS &lt;br /&gt;CH &lt;br /&gt;CL,AL &lt;br /&gt;CL &lt;br /&gt;AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,l ;find row position &lt;br /&gt;CL &lt;br /&gt;KEY2 &lt;br /&gt;AL,CL ;mode code to AL &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-3 THE PROGRAMMABLE PERIPHERAL INTERFACE 387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0033 KEY ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0033 SCAN PROC NEAR USES BX &lt;br /&gt;0034 B1 04 MOV :L,ROvIS ; form row mask &lt;br /&gt;0036 B7 FF MOV BH,OFFH &lt;br /&gt;0038 D2 E7 SHL BH,CL &lt;br /&gt;003A B9 0004 MOV CX,COLS ;load column count &lt;br /&gt;003D l:l3 F'E MOV BL,OFEH ;get: select:ion code &lt;br /&gt;003F SCAN1: &lt;br /&gt;003F 8A C3 MOV AL,BL ;select column &lt;br /&gt;0041 E6 51 OUT PORTB,AL &lt;br /&gt;0043 DO C3 ROL BL,l &lt;br /&gt;0045 E4 50 IN AL,PORTA ;read rows &lt;br /&gt;0047 OA C7 OR AL,BH &lt;br /&gt;0049 3C FF CMP AL,OFFH ;test for a key &lt;br /&gt;004B 75 02 JNZ SCAN2 &lt;br /&gt;004D E2 FO LOOP SCAN1 &lt;br /&gt;004F SCAN2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0051 SCAN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0051 DELAY PROC NE.&amp;quot;ili USES CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0052 B9 1388 MOV CX,5000 ;10ms (8HHz clock) &lt;br /&gt;0055 DELAY1: &lt;br /&gt;0055 E2 FE LOOP DELAY1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0059 DELAY ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A note about the SCAN procedure. The time between where the keyboard column is se-&lt;br /&gt;lected and where the rows are read is very short. In a very high-speed system, a small time delay &lt;br /&gt;must be placed between these two points for the data at port A to settle to its final state. In most &lt;br /&gt;cases, this is not needed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 1 Strobed Input &lt;br /&gt;Mode 1 operation causes port A and/or port B to function as latching input devices. This allows &lt;br /&gt;external data to be stored into the port until the microprocessor is ready to retrieve it. Port C is &lt;br /&gt;also used in mode 1 operation, not for data, but for control or handshaking signals that help op-&lt;br /&gt;erate either or both port A and port B as strobed input ports. Figure 10-21 shows how both ports &lt;br /&gt;are structured for mode 1 strobed input operation and also the timing diagram. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The strobed input port captures data from the port pins when the strobe (STB) is activated. &lt;br /&gt;Note that strobe captures the port data on the O-to-l transition. The STB signal causes data to be &lt;br /&gt;captured in the port and also activates the IBF (input buffer full) and INTR (interrupt request) &lt;br /&gt;signals. Once the microprocessor, through software (IBF) or hardware (INTR), notices that data are &lt;br /&gt;strobed into the port, it executes an IN instruction to read the port (RD). The act of reading the port &lt;br /&gt;restores both IBF and INTR to their inactive states until the next datum is strobed into the port. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Signal Definitions for Mode 1 Strobed Input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IBF &lt;br /&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The strobe input loads data into the port latch, which holds the information &lt;br /&gt;until it is input to the microprocessor via the IN instruction. &lt;br /&gt;Input buffer full is an output that indicates the input latch contains information. &lt;br /&gt;Interrupt request is an output that requests an interrupt. The INTR pin becomes &lt;br /&gt;a logic 1 when the STB input returns to a logic I and is cleared when the data &lt;br /&gt;are input from the port by the microprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;388 CHAPTER 10 BASIC 1/0 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 1 Por:tA Mode 1 Port B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,------, &lt;br /&gt;lINTEl &lt;br /&gt;o 0 &lt;br /&gt;: A I 1..-- __ j &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC4f4----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC6+ 7 f4----I~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.-----j &lt;br /&gt;lINTEl &lt;br /&gt;o 0 &lt;br /&gt;: B I 1..-- __ ..I &lt;br /&gt;PC2~-- STB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1---_ INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~-----------------------------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~-+--,.,t-----------------------------....... &lt;br /&gt;(Buffer full) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---------------------------.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Interrupt requested) &lt;br /&gt;---------t-------------------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data strobed into port Data read by microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-21 Strobed input operation (mode 1) of the 82C55. (a) Internal structure, and &lt;br /&gt;(b) timing diagram &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTE The interrupt enable signal is neither an input nor an output, but an internal &lt;br /&gt;bit programmed via the port PC4 (port A) or PC2 (port B) bit position. &lt;br /&gt;The port C pins 7 and 6 are general purpose I/O pins that are available for any &lt;br /&gt;purpose. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Strobed Input Example. An excellent example of a strobed input device is a keyboard. The &lt;br /&gt;keyboard encoder de-bounces the key-switches and provides a strobe signal whenever a key is &lt;br /&gt;depressed and the data output contain the ASCII-coded key code. Figure 10-22 illustrates a &lt;br /&gt;keyboard connected to strobed input port A. Here DA V (data available) is activated for 1 ~s &lt;br /&gt;each time that a key is typed on the keyboard. This causes data to be strobed into port A because &lt;br /&gt;DA V is connected to the STB input of port A. Each time a key is typed, therefore, it is stored &lt;br /&gt;into port A of the 82C55. The STB input also activates the IBF signal, indicating that data are &lt;br /&gt;in port A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 10-12 shows a procedure that reads data from the keyboard each time a key is &lt;br /&gt;typed. This procedure reads the key from port A and returns with the ASCII code in AL. To de-&lt;br /&gt;tect a key, port C is read and the IBF bit (bit position PCs) is tested to see if the buffer is full. If &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-3 THE PROGRAMMABLE PERIPHERAL INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-22 Using the &lt;br /&gt;82C55 for strobed input &lt;br /&gt;operation of a keyboard &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82C55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PAil &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t / &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot; &lt;br /&gt;PA 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;389 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Keyboard &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;On &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCII t &lt;br /&gt;0 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STB DAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the buffer is empty (IBF = 0), then the procedure keeps testing this bit, waiting for a character to &lt;br /&gt;be typed on the keyboard. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 &lt;br /&gt;0022 &lt;br /&gt;0020 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E4 22 &lt;br /&gt;0002 A8 20 &lt;br /&gt;0004 74 FA &lt;br /&gt;0006 E4 20 &lt;br /&gt;0008 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that reads the keyboard encoder &lt;br /&gt;;and returns the ASCII character in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIT5 EQU 20H &lt;br /&gt;PORTC EQU 22H &lt;br /&gt;PORTA EQU 20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,PORTC &lt;br /&gt;TEST AL,BIT5 &lt;br /&gt;JZ READ &lt;br /&gt;IN AL,PORTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read Port C &lt;br /&gt;;test IBF &lt;br /&gt;;if IBF = 0 &lt;br /&gt;;read data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 1 Strobed Output &lt;br /&gt;Figure 10-23 illustrates the internal configuration and timing diagram of the 82C55 when it is &lt;br /&gt;operated as a strobed output device under mode 1. Strobed output operation is similar to mode 0 &lt;br /&gt;output, except that control signals are included to provide handshaking. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever data are written to a port programmed as a strobed output port, the OBF (output &lt;br /&gt;buffer full) signal becomes a logic 0 to indicate that data are present in the port latch. This signal &lt;br /&gt;indicates that data are available to an external I/O device that removes the data by strobing the &lt;br /&gt;ACK (acknowledge) input to the port. The ACK signal returns the OBF signal to a logic 1, indi-&lt;br /&gt;cating that the buffer is not full. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Signal Definitions for Mode 1 Strobed Output &lt;br /&gt;OBF Output buffer full is an output that goes low whenever data are output (OUT) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to the port A or port B latch. This signal is set to a logic I whenever the ACK &lt;br /&gt;pulse returns from the external device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ACK The acknowledge signal causes the OBF pin to return to a logic 1 level. The &lt;br /&gt;ACK is a response from an external device that indicates it has received the &lt;br /&gt;data from the 82C55 port. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;390 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode I Port A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC61-+---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC4+5 I.----i~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data sent to port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode I Port B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PortB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--&amp;quot;'---&amp;quot;', &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IINTE: , , &lt;br /&gt;I B I PC21-+--- ACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;....... - ........ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Buffer full) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data removed from port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Interrupt requested) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-23 Strobed output operation (mode 1) of the 82C55. (a) Internal structure, and &lt;br /&gt;(b) timing diagram &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCS, PC4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt request is a signal that often interrupts the microprocessor when the &lt;br /&gt;external device receives the data via the ACK signal. This pin is qualified by &lt;br /&gt;the internal INTE (interrupt enable) bit. &lt;br /&gt;Interrupt enable is neither an input nor an output, but an internal bit &lt;br /&gt;programmed to enable or disable the INTR pin. The INTE A bit is &lt;br /&gt;programmed as PC6â¢ and INTE B is PC2â¢ &lt;br /&gt;Port C bits Sand 4 are general purpose I/O pins. The bit set and reset &lt;br /&gt;command may be used to set or reset these two pins. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Strobed Output Example. The printer interface discussed in Section to-I is used here to &lt;br /&gt;demonstrate how to achieve strobed output synchronization between the printer and the 82C55. &lt;br /&gt;F;gure 10-24 illustrates port B connected to a parallel printer with eight data inputs for receiving &lt;br /&gt;ASCII-coded data, a DS (data strobe) input to strobe data into the printer, and an ACK output to &lt;br /&gt;acknowledge the receipt of the ASCII character. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this circuit, there is no signal to generate the DS signal to the printer, so PC4 is used with &lt;br /&gt;software that generates the DS signal. The ACK signal that is returned from the printer acknowl-&lt;br /&gt;edges the receipt of the data and is connected to the ACK input of the 82C55. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-3 THE PROGRAMMABLE PERIPHERAL INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-24 The 82C55 &lt;br /&gt;connected to a parallel printer &lt;br /&gt;interface that illustrates the &lt;br /&gt;strobed output mode of oper-&lt;br /&gt;ation for the 82C55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82C55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PB&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;PB7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCIl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-ACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;391 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Printer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Do ) t &lt;br /&gt;V D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 10--13 lists the software that sends the ASCII-coded character in AH to the &lt;br /&gt;printer. The procedure first tests OBF to decide if the printer has removed the data from port B. &lt;br /&gt;If not, the procedure waits for the ACK signal to return from the printer. If OBF = 1, then the &lt;br /&gt;procedure sends the contents of AH to the printer through port B and also sends the DS signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 &lt;br /&gt;0062 &lt;br /&gt;0061 &lt;br /&gt;0063 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E4 62 &lt;br /&gt;0002 A8 02 &lt;br /&gt;0004 74 FA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0006 8A C4 &lt;br /&gt;0008 E6 61 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA EO 08 &lt;br /&gt;OOOC E6 63 &lt;br /&gt;OOOE EO 09 &lt;br /&gt;0010 E6 63 &lt;br /&gt;0012 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0013 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that transfers the ASCII character &lt;br /&gt;;from AH to the printer via port B. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIT1 EQU 2 &lt;br /&gt;PORTC EQU 62H &lt;br /&gt;PORTB EQU 61H &lt;br /&gt;CMD EQU 63H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRINT PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;check printer ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,PORTC &lt;br /&gt;TEST AL,BIT1 &lt;br /&gt;JZ PRINT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get OBF &lt;br /&gt;;test OBF &lt;br /&gt;; if OBF = 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;send character to printer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,AH &lt;br /&gt;OUT PORTB,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;send data strobe to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,8 &lt;br /&gt;OUT CMD,AL &lt;br /&gt;MOV AL,9 &lt;br /&gt;OUT CMD,AL &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRINT ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get data &lt;br /&gt;;print data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;printer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 2 Bidirectional Operation &lt;br /&gt;In mode 2, which is allowed with group A only, port A becomes bi-directional, allowing data to &lt;br /&gt;be transmitted and received over the same eight wires. Bi-directional bused data are useful when &lt;br /&gt;interfacing two computers. It is also used for the IEEE-488 parallel high speed GPIB (general &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;392 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PortA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bidirectional mode 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.-----.. _, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lINTEl '----~I 2 ! &lt;br /&gt;'------'&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~--- ACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC4~---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~------~PC5~-~~ IBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data stored in port A &lt;br /&gt;Data output (OUT) to port A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC2 -PCO ~-~~ I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data read from port A &lt;br /&gt;Data input (IN) from port A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-25 Mode 2 operation of the 82C55. (a) Internal structure, and (b) timing diagram &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;purpose instrumentation bus) interface standard. Figure 10-25 shows the internal structure &lt;br /&gt;and timing diagram for mode 2 bi-directional operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Signal Definitions for Bi-directional Mode 2 &lt;br /&gt;INTR Interrupt request is an output used to interrupt the microprocessor for both &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;input and output conditions. &lt;br /&gt;Output buffer full is an output that indicates that the output buffer contains &lt;br /&gt;data for the bi-directional bus. &lt;br /&gt;Acknowledge is an input that enables the three-state buffers so that data can &lt;br /&gt;appear on port A. If ACK is a logic 1, the output buffers of port A are at their &lt;br /&gt;high-impedance state. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-3 THE PROGRAMMABLE PERIPHERAL INTERFACE 393 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PC2, PCI, &lt;br /&gt;and peo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The strobe input loads the port A input latch with external data from the bi-&lt;br /&gt;directional port A bus. &lt;br /&gt;Input buffer full is an output used to signal that the input buffer contains data &lt;br /&gt;for the external bi-directional bus. &lt;br /&gt;Interrupt enable bits are internal (INTEl and INTE2) and enab'e the INTR &lt;br /&gt;pin. The state of the INTR pin is controlled through port C bits PC6 (INTEl) &lt;br /&gt;and PC4 (INTE2). &lt;br /&gt;These bits are general-purpose I/O pins in mode 2 controlled by the bit set and &lt;br /&gt;reset command. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Bi-directional Bus. The bi-directional bus is used by referencing port A with the IN and &lt;br /&gt;OUT instructions. To transmit data through the bi-directional bus, the program first tests the &lt;br /&gt;OBF signal to determine whether the output buffer is empty. If it is, then data are sent to &lt;br /&gt;the output buffer via the OUT instruction. The external circuitry also monitors the OBF signal to &lt;br /&gt;decide if the microprocessor has sent data to the bus. As soon as the output circuitry sees a logic &lt;br /&gt;o on OBF, it sends back the ACK signal to remove it from the output buffer. The ACK sig-&lt;br /&gt;nal sets the OBF bit and also enables the three-state output buffers so that data may be read. &lt;br /&gt;Example 10-14 lists a procedure that transmits the contents of the AH register through bi-&lt;br /&gt;directional port A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-14 &lt;br /&gt;;A procedure that transmits AH through the bi-&lt;br /&gt;;directional bus of port A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0080 BIT7 EQU 80H &lt;br /&gt;0062 PORTC EQU 62H &lt;br /&gt;0060 PORTA EQU 60H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 TRANS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E4 62 IN AL,PORTC ;get OBF &lt;br /&gt;0002 A8 80 TEST AL,BIT7 ;test OBF &lt;br /&gt;0004 74 FA JZ TRANS ; if OBF = 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0006 8A C4 MOV AL,AH ;get data &lt;br /&gt;0008 E6 60 OUT PORTA,AL ;send data &lt;br /&gt;OOOA C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB TRANS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To receive data through the bi-directional port A bus, the IBF bit is tested with software to &lt;br /&gt;decide if data have been strobed into the port. If IBF = 1, then data are input using the IN in-&lt;br /&gt;struction. The external interlace sends data into the port using the STB signal. When STB is ac-&lt;br /&gt;tivated, the IBF signal becomes a logic 1 and the data at port A are held inside the port in a latch. &lt;br /&gt;When the IN instruction executes, the IBF bit is cleared and the data in the port are moved into &lt;br /&gt;AL. Example 10-15 lists a procedure that reads data from the port. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-15 &lt;br /&gt;;A procedure that reads data from the bi-&lt;br /&gt;;directional port A and returns it in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 BIT5 EQU 20H &lt;br /&gt;0062 PORTC EQU 62H &lt;br /&gt;0060 PORTA EQU 60H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 READ PROC NEAR &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;394 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-26 A summary &lt;br /&gt;of the port connections for the &lt;br /&gt;82C55 PIA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E4 62 &lt;br /&gt;0002 A8 20 &lt;br /&gt;0004 74 FA &lt;br /&gt;0006 E4 60 &lt;br /&gt;0008 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 READ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PonB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PortC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN &lt;br /&gt;TEST &lt;br /&gt;JZ &lt;br /&gt;IN &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;I &lt;br /&gt;2 &lt;br /&gt;3 IN OUT &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;6 &lt;br /&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,PORTC &lt;br /&gt;AL,BIT5 &lt;br /&gt;READ &lt;br /&gt;AL,PORTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode I Mode 2 &lt;br /&gt;r--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN OUT I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN OUT ~ &lt;br /&gt;I used &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRB INTRB I/O &lt;br /&gt;-IBFB OBFB I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STBB ACKB I/O &lt;br /&gt;INTRA INTRA INTR &lt;br /&gt;STBA I/O STB &lt;br /&gt;IBFA I/O IBF &lt;br /&gt;I/O ACKA ACK &lt;br /&gt;I/O OBFA OBF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get IBF &lt;br /&gt;;test IBF &lt;br /&gt;; if IBF = 0 &lt;br /&gt;;get data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The INTR (interrupt request) pin can be activated from both directions of data flow &lt;br /&gt;through the bus. If INTR is enabled by both INTE bits, then the output and input buffers both &lt;br /&gt;cause interrupt requests. This occurs when data are strobed into the buffer using STB or when &lt;br /&gt;data are written using OUT. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82C55 Mode Summary &lt;br /&gt;Figure 10-26 shows a graphical summary of the three modes of operation for the 82C55. Mode &lt;br /&gt;o provides simple I/O, mode I provides strobed I/O, and mode 2 provides bi-directional I/O. As &lt;br /&gt;mentioned, these modes are selected through the command register of the 82C55. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE 8279 PROGRAMMABLE KEYBOARD/DISPLAY INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8279 is a programmable keyboard and display interfacing component that scans and en-&lt;br /&gt;codes up to a 64-key keyboard and controls up to a 16-digit numerical display. The keyboard in-&lt;br /&gt;terface has a built-in first-in, first-out (FIFO) buffer that allows it to store up to eight keystrokes &lt;br /&gt;before the microprocessor must retrieve a character. The display section controls up to 16 nu-&lt;br /&gt;meric displays from an internal 16 x 8 RAM that stores the coded display information. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Basic Description of the 8279 &lt;br /&gt;As we shall see, the 8279 is designed to easily interface with any microprocessor. Figure 10-27 &lt;br /&gt;illustrates the pin-out of this device. The definition of each pin connection follows. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Definitions for the 8279 &lt;br /&gt;The AD address input selects data or control for reads and writes &lt;br /&gt;between the microprocessor and the 8279. A logic 0 selects data and a &lt;br /&gt;logic I selects control or status register. &lt;br /&gt;Blank is an output used to blank the displays. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-4 THE 8279 PROGRAMMABLE KEYBOARD/DISPLAY INTERFACE 395 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN CONFIGURATION LOGIC SYMBOL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RlI PIN NAMES &lt;br /&gt;Rlo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NAME &amp;quot;0 FUNCTION &lt;br /&gt;SHIFT DBol &amp;quot;0 DATA BUS 181 DIRECTIONAL' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SlJ eLK I CLOCI( INPUT &lt;br /&gt;RESET , AfSET INPur &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sl, IT I CHIP SELECT &lt;br /&gt;SL. Ail , READ INPUT l'ilI , WRITE INPUT &lt;br /&gt;Sl. A, , SUFFER ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,RO 0 INTERRUPT REQUEST OUTPUT &lt;br /&gt;SltU 0 SCAN LINES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT 8, Alai , RETURN LINES &lt;br /&gt;aUT 82 SHIFT , SHIFT INPur &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT 8] CNll/STB &lt;br /&gt;, CONTROL/STROBE INPUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTAoJ 0 DISPLAV IAI OUTPUTS &lt;br /&gt;OUT Ao OUT 8-;1 0 DISPLA Y 181 OuTPUTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT A, :115 0 8LANI( DISPLAY OUTPUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BO &lt;br /&gt;DB, CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRQ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;'\\ 8 DATA. BUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR &lt;br /&gt;CPU &lt;br /&gt;INTERfACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J. &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TVcc &lt;br /&gt;HLO 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHifT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CNJL/$18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SLOJ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT AOl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT ROl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;amp;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;lt;==1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ S &lt;br /&gt;V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ ) &lt;br /&gt;... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ ) &lt;br /&gt;V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEV DAr.4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CAN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DI~PLAY &lt;br /&gt;DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-27 The pin-out and logic symbol of the 8279 programmable keyboard/display interface (Courtesy of &lt;br /&gt;Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CN/ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRQ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTA3-0UTAO &lt;br /&gt;OUTB3-0UTBO &lt;br /&gt;RD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;RL7-RLO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHIFT &lt;br /&gt;SL3-SLO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Clock is an input that generates the internal timing for the 8279. The &lt;br /&gt;maximum allowable frequency on the CLK pin is 3.125 MHz for the &lt;br /&gt;8279-5 and 2.0 MHz for the 8279. Other timings require wait states in &lt;br /&gt;microprocessors executing at above 5 MHz. &lt;br /&gt;Control/strobe is an input normally connected to the control key on a &lt;br /&gt;keyboard. &lt;br /&gt;Chip select is an input that enables the 8279 for programming, reading &lt;br /&gt;the keyboard and status information, and writing control and display &lt;br /&gt;data. &lt;br /&gt;The data bus consists of bi-directional pins that connect to the data bus &lt;br /&gt;on the microprocessor. &lt;br /&gt;Interrupt request is an output that becomes a logic 1 whenever a key &lt;br /&gt;is pressed on the keyboard. This signal indicates that keyboard data are &lt;br /&gt;available for the microprocessor. &lt;br /&gt;Outputs that send data to the displays (most-significant). &lt;br /&gt;Outputs that send data to the displays (least-significant). &lt;br /&gt;The read input is directly connected to the IOCR or RD signal from &lt;br /&gt;the system. When CS is a logic 0, the RD input causes a read from the &lt;br /&gt;data registers or status register. &lt;br /&gt;The reset input connects to the system RESET signal. &lt;br /&gt;Return lines are inputs used to sense any key depression in the &lt;br /&gt;keyboard matrix. &lt;br /&gt;The shift input normally connects to the shift key on a keyboard. &lt;br /&gt;The scan line outputs scan both the keyboard and the displays. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;396 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Write is an input that connects to the write strobe signal that is &lt;br /&gt;developed with external logic. The WR input causes data to be written &lt;br /&gt;to either the data registers or control registers within the 8279. &lt;br /&gt;A power supply pin connected to the system +5.0V bus. &lt;br /&gt;A ground pin connected to the system ground. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interfacing the 8279 to the Microprocessor &lt;br /&gt;In Figure 10-28, the 8279 is connected to the 8088 microprocessor. The 8279 is decoded to func-&lt;br /&gt;tion at 8-bit I/O address lOH and I1H where port lOH is the data port and IIH is the control port. &lt;br /&gt;This circuit uses a PALl6L8 (see Example 10-16) to decode the I/O address for the 8279. Ad-&lt;br /&gt;dress bus bit Ao selects either the data or control port. Notice that the CS signal selects the 8279 &lt;br /&gt;and also provides a signal called W AIT2 that is used to cause two wait states so that this device &lt;br /&gt;functions with an 8 MHz 8088. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The only signal not connected to the microprocessor is the IRQ output. This is an interrupt &lt;br /&gt;request pin and is beyond the scope of this section of the text. Chapter 11 explains interrupts and &lt;br /&gt;where they operate and function in a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-16 &lt;br /&gt;TITLE Address Decoder &lt;br /&gt;PATTERN Test 14 &lt;br /&gt;REVISION A &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/10/96 &lt;br /&gt;CHIP DECODERE PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;A1 A2 A3 A4 A5 A6 A7 NC IOM GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;NC NC NC NC NC NC NC NC CS VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/CS = /A7 * /A6 * / A5 * A4 * /A3 * /A2 * /A1 * rOM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8279 U2 &lt;br /&gt;interfaced to the 8088 micro- DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 OBO RLO 01 OB1 RL1 &lt;br /&gt;processor to function at 8-bit 02 14 OB2 RL2 03 OB3 RL3 &lt;br /&gt;I/O ports 1 OH and 11 H 04 OB4 RL4 05 OB5 RL5 06 OB6 RL6 07 OB7 RL7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RO 10 RO SHFT &lt;br /&gt;WR 1 WR CN/5T WAIT2 22 CS BO 3.0 MHz 3 CLK RESET RESET SLO AD AD SL1 4 IRQ SL2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SL3 &lt;br /&gt;U1 DAD A1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2 11 (1' OA1 &lt;br /&gt;A3 3 12 02 OA2 &lt;br /&gt;A4 13 03 OA3 &lt;br /&gt;A5 14 04 OBO &lt;br /&gt;A6 15 05 OB1 &lt;br /&gt;A7 16 06 OB2 17 07 OB3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M 18 08 19 8279 &lt;br /&gt;110 &lt;br /&gt;16L8 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT2 &lt;br /&gt;3.0 MHz &lt;br /&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1 &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-4 THE 8279 PROGRAMMABLE KEYBOARD/DISPLAY INTERFACE 397 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Keyboard Interface &lt;br /&gt;Suppose that a 64-key keyboard (with no numeric displays) is connected through the 8279 to the &lt;br /&gt;8088 microprocessor. Figure 10-29 shows this connection as well as the keyboard. With the &lt;br /&gt;8279, tht keyboard matrix is any size from a 2 x 2 matrix (4 keys) to an 8 x 8 matrix (64 keys). &lt;br /&gt;(Note that each crossover point in the matrix contains a normally open push-button switch that &lt;br /&gt;connects one vertical column with one horizontal row when a key is pressed.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 110 port number decoded is the same as that decoded for Figure 10-28. The 110 port &lt;br /&gt;number is lOH for the data port and IIH for the control port in this circuit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 74ALS 138 decoder generates eight active low column strobe signals for the keyboard. &lt;br /&gt;The selection pins SL2-SLO sequentially scan each column of the keyboard, and the internal cir-&lt;br /&gt;cuitry of the 8279 scans the RL pins searching for a key switch closure. Pull-up resistors, nor-&lt;br /&gt;mally found on input lines of a keyboard, are not required because the 8279 contains its own &lt;br /&gt;internal pull-ups on the RL inputs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the Keyboard Interface. Before any keystroke is detected, the 8279 must be pro-&lt;br /&gt;grammed-a more involved procedure than with the 82C55. The 8279 has eight control words to &lt;br /&gt;consider before it is programmed. The first three bits of the number sent to the control port (11 H &lt;br /&gt;in this example) select one of the eight different control words. Table 10-3 lists all eight control &lt;br /&gt;words and briefly describes them. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control Word Descriptions. Following is a list of the control words that program the 8279. Note &lt;br /&gt;that the first three bits are the control register number from Table 10-3, which are followed by &lt;br /&gt;other binary bits of information as they apply to each control. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOODDMMM Mode set is a command with an opcode of 000 and two fields programmed &lt;br /&gt;to select the mode of operation for the 8279. The DD field selects the mode &lt;br /&gt;of operation for the displays (see Table 10-4), and the MMM field selects &lt;br /&gt;the mode of operation for the keyboard (see Table 10-5). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The DD field selects either an 8- or 16-digit display and determines whether new data are &lt;br /&gt;entered to the rightmost or leftmost display position. The MMM field is quite a bit more com-&lt;br /&gt;plex. It provides encoded, decoded, or strobed keyboard operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64-key matrix &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;12 DBO RLO 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14 DB1 RLt 1 DB2 RL2 &lt;br /&gt;DB3 RL3 2 16 DB4 RL4 b &lt;br /&gt;DB5 RL5 6 18 DB6 RL6 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ 19 DB7 RL7 &lt;br /&gt;10 RD SHFT i= 11 WR CN/ST 22 3 CS BD 11 1111 &lt;br /&gt;9 CLK SLO 32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;54 32 1 0 97 &lt;br /&gt;2 RESET 33 U3 AO SL1 YYYYYYYY &lt;br /&gt;-L IRQ SL2 ~ 01234567 74ALS138 SL3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 OAO ~ GG 1 19 G 22 11 01 ~ OA1 ABC 1AB 3 12 02 0A2 &lt;br /&gt;U123 l6~5 4 13 03 ~ OA3 SE 14 04 OBO 5 15 05 OB1 R1 ti 16 06 f?44- OB2 VCC Pt= 17 07 gfi: OB3 10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-+ ~ 18 08 19 8279 &lt;br /&gt;-.lL 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-29 A 64-key keyboard interfaced to the 8088 microprocessor through the 8279 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;398 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 10-3 The 8279 control word summary &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D7 D6 D5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 10-4 Binary bit &lt;br /&gt;assignment for DD of the &lt;br /&gt;mode set control word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function Purpose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode set Selects the number of display positions, left &lt;br /&gt;or right entry, and type of keyboard scan &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Clock Programs the internal clock and sets the &lt;br /&gt;scan and de-bounce times &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Read FIFO Selects the type of FI FO read and the ad-&lt;br /&gt;dress of the read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Read display Selects the type of display read and the ad-&lt;br /&gt;dress of the read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Write display Selects the type of write and the address of &lt;br /&gt;the write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Display write inhibit Allows half-bytes to be blanked &lt;br /&gt;Clear Clears the display or FIFO &lt;br /&gt;End interrupt Clears the IRQ signal to the microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DD Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 8-digit display with left entry &lt;br /&gt;01 16 digit display with left entry &lt;br /&gt;10 8-digit display with right entry &lt;br /&gt;11 16-digit display with right entry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 10-5 Binary bit &lt;br /&gt;assignment for MMM of the &lt;br /&gt;mode set control word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MMM Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 Encoded keyboard with 2-key lockout &lt;br /&gt;001 Decoded keyboard with 2-key lockout &lt;br /&gt;010 Encoded keyboard with N-key rollover &lt;br /&gt;011 Decoded keyboard with N-key rollover &lt;br /&gt;100 Encoded sensor matrix &lt;br /&gt;101 Decoded sensor matrix &lt;br /&gt;110 Strobed keyboard, encoded display scan &lt;br /&gt;111 Strobed keyboard, decoded display scan &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In encoded mode, the SL outputs are active-high and follow the binary bit pattern 0 &lt;br /&gt;through 7 or 0 through 15, depending on whether 8- or 16-digit displays are selected. In decoded &lt;br /&gt;mode, the SL outputs are active-low, and only one of the four outputs is low at any given instant. &lt;br /&gt;The decoded outputs repeat the pattern: 1110, 1101, lOll, and 0111. In strobed mode, an active-&lt;br /&gt;high pulse on the CN/ST input pin strobes data from the RL pins into an internal FIFO, where &lt;br /&gt;they are held for the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It is also possible to select either 2-key lockout or N-key rollover. Two-key lockout pre-&lt;br /&gt;vents two keys from being recognized if pressed simultaneously. N-key rollover will accept all &lt;br /&gt;keys pressed simultaneously, from first to last. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlPPPPP The clock command control word programs the internal clock divider. The &lt;br /&gt;code PPPPP is a prescaler that divides the clock input pin (CLK) to achieve &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-4 THE 8279 PROGRAMMABLE KEYBOARD/DISPLAY INTERFACE 399 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OlOZOAAA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OllZAAAA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOOZAAAA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOlOWWBB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;llOOCCFA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lllEOOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the desired operating frequency of approximately 100 KHz. An input clock &lt;br /&gt;of 1 MHz thus requires a prescaler of 010 I O2 for PPPPP. &lt;br /&gt;The read FIFO control word selects the address of a keystroke from the &lt;br /&gt;internal FIFO buffer. Bit positions AAA select the desired FIFO location &lt;br /&gt;from OOf, to Ill, and Z selects auto-increment for the address. Under &lt;br /&gt;normal operation, this control word is used only with the sensor matrix &lt;br /&gt;operation of the 8279. &lt;br /&gt;The display read control word selects the read address of one of the display &lt;br /&gt;RAM positions for reading through the data port. AAAA is the address of &lt;br /&gt;the position to be read, and Z selects auto-increment mode. This command &lt;br /&gt;is used if the information stored in the display RAM must be read. &lt;br /&gt;The write display control word selects the write address of one of the &lt;br /&gt;displays. AAAA addresses the position to be written to through the data &lt;br /&gt;port, and Z selects auto-increment so that subsequent writes through the &lt;br /&gt;data port are to subsequent display positions. &lt;br /&gt;The display write inhibit control word inhibits writing to either half of &lt;br /&gt;each display RAM location. The leftmost W inhibits writing to the leftmost &lt;br /&gt;four bits of the display RAM location, and the rightmost W inhibits the &lt;br /&gt;rightmost four bits. The BB field functions in a like manner, except that &lt;br /&gt;they blank (tum off) either half of the output pins. &lt;br /&gt;The clear control word clears the display, the FIFO, or both the display &lt;br /&gt;and FIFO. Bit F clears the FIFO and the display RAM status, and sets the &lt;br /&gt;address pointer to 000. If the CC bits are 00 or 0 I, all of the display RAM &lt;br /&gt;locations become 0000000; if CC = 10, all locations become 00100000; and &lt;br /&gt;if CC = 11, all locations become 11111111. &lt;br /&gt;The end of interrupt control word is issued to clear the IRQ pin to zero in &lt;br /&gt;the sensor matrix mode. If E is ai, the special error mode is used. In the &lt;br /&gt;special error mode, the status register indicates if multiple key closures have &lt;br /&gt;occurred. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The large number of control words makes programming the keyboard interface appear &lt;br /&gt;complex. Before anything is programmed, the clock divider rate must be determined. In the cir-&lt;br /&gt;cuit illustrated in Figure 10-29, we use a 3.0 MHz clock input signal. To program the prescaler &lt;br /&gt;to generate a 100 KHz internal rate, we program PPPPP of the clock control word with a 30 or &lt;br /&gt;111102, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The next step involves programming the keyboard type. The example keyboard in &lt;br /&gt;Figure 10-29 is an encoded keyboard. Notice that the circuit includes an external decoder that &lt;br /&gt;converts the encoded data from the SL pins into decoded column selection signals. We are free &lt;br /&gt;in this example to choose either 2-key lockout or N-key rollover, but most applications use &lt;br /&gt;2-key lockout. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Finally, we program the operation of the FIFO. Once the FIFO is programmed, it never &lt;br /&gt;needs to be reprogrammed unless we need to read prior keyboard codes. Each time a key is typed, &lt;br /&gt;the data are stored in the FIFO; if it is read from the FIFO before the FIFO is full (8 characters), &lt;br /&gt;then the data from the FIFO follows the same order as the typed data. Example 10-17 provides the &lt;br /&gt;software required to initialize the 8279 to control the keyboard illustrated in Figure 10-29. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BO 3E &lt;br /&gt;0002 E6 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Initialization dialog for the keyboard interface &lt;br /&gt;;of Figure 10-29. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,00111110B ;program clock &lt;br /&gt;OUT llH, AL &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;400 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 BO 00 MOV AL,O &lt;br /&gt;0006 E6 11 OUT 11H,AL ;program mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 BO 50 MOV AL,01010000B &lt;br /&gt;OOOA E6 11 OUT 11H,AL ;program FIFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once the 8279 is initialized, a procedure is required to read data from the keyboard. We &lt;br /&gt;determine if a character is typed in the keyboard by looking at the FIFO status register. When-&lt;br /&gt;ever the control port is addressed by the IN instruction, the contents of the FIFO status word is &lt;br /&gt;copied into the AL register. Figure 10-30 shows the contents of the FIFO status register and de-&lt;br /&gt;fines the purpose of each status bit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure listed in Example 10-18 first tests the FIFO status register to see if it con-&lt;br /&gt;tains any data. IfNNN = 000, the FIFO is empty. Upon determining that the FIFO is not empty, &lt;br /&gt;the procedure inputs data to AL and returns with the keyboard code in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-18 &lt;br /&gt;;A procedure that reads data from the FIFO and &lt;br /&gt;;returns it in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 0007 MASKS EQU 7 &lt;br /&gt;0000 READ PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E4 11 IN AL,11H ;read status &lt;br /&gt;0002 A8 07 TEST AL,MASKS ;test NNN &lt;br /&gt;0004 74 FA JZ READ ;ifNNN=O &lt;br /&gt;0006 E4 10 IN AL,10H ;read FIFO data &lt;br /&gt;0008 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 READ ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The data found in AL upon returning from the subroutine contains raw data from the key-&lt;br /&gt;board. Figure 10-31 shows the format of this data for both the scanned and strobed modes of op-&lt;br /&gt;eration. The scanned code is returned from our keyboard interface and is converted to ASCII &lt;br /&gt;code by using the XLA T instruction with an ASCII code lookup table. The scanned code is re-&lt;br /&gt;turned with the row and column number occupying the rightmost 6 bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The SH bit shows the state of the shift pin, and the CT bit shows the state of the control &lt;br /&gt;pin. In the strobed mode, the contents of the eight RL inputs appear as they are sampled by &lt;br /&gt;placing a logic 1 on the strobe input pin to the 8279. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Six-Digit Display Interface &lt;br /&gt;Figure 10-32 depicts the 8279 connected to the 8088 microprocessor and a 6-digit numeric dis-&lt;br /&gt;play. This interface uses a PALl6L8 (program not shown) to decode the 8279 at I/O ports 20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-30 The 8279-5 &lt;br /&gt;FIFO status register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;765 432 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I D IS/EI 0 I u I FIN I N I N I &lt;br /&gt;II I I I ... &amp;quot;'&amp;quot; ;oo;&amp;quot;'e th,&amp;quot;&amp;quot;mbe, of &amp;quot;,.&amp;quot;,ctem ;0 the RFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Indicates the FIFO is full &lt;br /&gt;Indicates the FIFO has been read while empty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---------Indicates the FIFO is full and has been overrun &lt;br /&gt;'-----------Indicates multiple key closures &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'------------Display unavailable because of clear command &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-4 THE 8279 PROGRAMMABLE KEYBOARD/DISPLAY INTERFACE 401 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-31 The 7 6 5 4 321 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRL71RL61RL51RL41RL31RL21RL 11 RLOI &lt;br /&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) scanned keyboard code &lt;br /&gt;and (b) strobed keyboard &lt;br /&gt;code for the 8279-5 FIFO (a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;OS &lt;br /&gt;D. &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD &lt;br /&gt;WAIT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\VA &lt;br /&gt;30MHz &lt;br /&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;'7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lSLB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 1 0-32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(data) and 21 H (control/status). The segment data are supplied to the displays through the OUT A &lt;br /&gt;and OUTB pins of the 8279. These bits are buffered by a segment driver (ULN2003A) to drive &lt;br /&gt;the segment inputs to the display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A 74ALS i38 3-to-81ine decoder enables the anode switches of each display position. The &lt;br /&gt;SL2-SLO pins supply the decoder with the encoded display position from the 8279. Notice that &lt;br /&gt;the left-hand display is at position 0101 and the right-hand display is at position 0000. These are &lt;br /&gt;the addresses of the display positions as indicated in control words for the 8279. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It is necessary to choose resistor values that allow 60 rnA of current flow per segment. In &lt;br /&gt;this circuit, we use 47Q resistors. If we allow 60 rnA of segment current, then the average seg-&lt;br /&gt;ment current is 10 rnA, or one-sixth of 60 rnA because current only flows for one-sixth of the &lt;br /&gt;time through a segment. The anode switches must supply the current for all seven segments plus &lt;br /&gt;the decimal point. Here the total anode current is 8 x 60 rnA, or 480 rnA. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 10-19 lists the initialization dialog for programming the 8279 to function with &lt;br /&gt;this 6-digit display. This software programs the display and clears the display RAM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-19 &lt;br /&gt;;Initialization dialog for the 6-digit display of &lt;br /&gt;;Figure 10-32. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BO 3E MOV AL,00111110B ;program clock &lt;br /&gt;0002 E6 21 OUT 21H,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 BO 00 MOV AL,O ;program mode set &lt;br /&gt;0006 E6 21 OUT 21H,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 BO C1 MOV AL,11000001B ;clear display &lt;br /&gt;OOOA E6 21 OUT 21H,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 10-20 lists a procedure for displaying information on the displays. Data are &lt;br /&gt;transferred to the procedure through the AX register. AH contains the seven-segment display &lt;br /&gt;code and AL contains the address of the displayed digit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;12 DBO 15 1. 1 OBI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB2 &lt;br /&gt;I. 083 DB4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DBS &lt;br /&gt;DB. &lt;br /&gt;DB7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 BQ. &lt;br /&gt;11 WA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cs &lt;br /&gt;elK &lt;br /&gt;RESET SlO &lt;br /&gt;AD SL1 &lt;br /&gt;lAO SL2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SL3 03 02 01 00 &lt;br /&gt;OAO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,. &lt;br /&gt;OAI &lt;br /&gt;0A2 &lt;br /&gt;0A3 &lt;br /&gt;OBO &lt;br /&gt;OBI &lt;br /&gt;OB2 &lt;br /&gt;OB3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8279 .7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-_~O--_&amp;quot;&amp;quot;&amp;quot;&amp;quot; __ &amp;quot;&amp;quot;&amp;quot;' __ &amp;quot;&amp;quot;&amp;quot;' __ -+-&amp;lt;o vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A 6-digit numeric display interfaced to the 8279 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;402 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-20 &lt;br /&gt;;A procedure that displays AH on the display &lt;br /&gt;;position addressed by AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 0080 MASKS EQU 80H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 DISP PROe NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 PUSH AX ;save data &lt;br /&gt;0001 DC 80 OR AL,MASKS ;select digit &lt;br /&gt;0003 E6 21 OUT 21H,AL &lt;br /&gt;0005 8A e4 MOV AL,AH ;display data &lt;br /&gt;0007 E6 20 OUT 20H,AL &lt;br /&gt;0009 58 POP AX ;restore data &lt;br /&gt;OOOA e3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB DISP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8254 PROGRAMMABLE INTERVAL TIMER &lt;br /&gt;The 8254 programmable interval timer consists of three independent 16-bit programmable coun-&lt;br /&gt;ters (timers). Each counter is capable of counting in binary or binary-coded decimal (BCD). The &lt;br /&gt;maximum allowable input frequency to any counter is 10 MHz. This device is useful wherever &lt;br /&gt;the microprocessor must control real-time events. Some examples of usage include real time &lt;br /&gt;clock, events counter, and motor speed and direction control. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This timer also appears in the personal computer decoded at ports 40H-43H to (1) gen-&lt;br /&gt;erate a basic timer interrupt that occurs at approximately 18.2 Hz, (2) cause the DRAM memory &lt;br /&gt;system to be refreshed, and (3) provide a timing source to the internal speaker and other devices. &lt;br /&gt;The timer in the personal computer is an 8253 instead of an 8254. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8254 Functional Description &lt;br /&gt;Figure 10-33 shows the pin-out of the 8254, which is a higher-speed version of the 8253, and a di-&lt;br /&gt;agram of one of the three counters. Each timer contains a CLK input, a gate input, and an output &lt;br /&gt;(OUT) connection. The CLK input provides the basic operating frequency to the timer, the gate &lt;br /&gt;pin controls the timer in some modes, and the OUT pin is where we obtain the output of the timer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The signals that connect to the microprocessor are the data bus pins (07-00), RD, WR, CS, &lt;br /&gt;and address inputs Al and Ao. The address inputs are present to select any of the four internal &lt;br /&gt;registers used for programming, reading, or writing to a counter. The personal computer contains &lt;br /&gt;an 8253 timer or its equivalent decoded at I/O ports 40H-43H. Timer zero is programmed to &lt;br /&gt;generate an 18.2 Hz signal that interrupts the microprocessor at interrupt vector 8 for a clock tick. &lt;br /&gt;The tick is often used to time programs and events. Timer 1 is programmed for a 15 J.1s output &lt;br /&gt;that is used on the PCIXT personal computer to request a DMA action used to refresh the dy-&lt;br /&gt;namic RAM. Timer 2 is programmed to generate tone on the personal computer speaker. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Definitions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address inputs select one of four internal registerswithin the 8254. See Tab)( &lt;br /&gt;10-6 for the function of the Al and AD address bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The clock input is the timing source for each of theinternal counters. This input is &lt;br /&gt;often connected to the PCLK signal from the microprocessor system bus controller. &lt;br /&gt;Chip select enables the 8254 for programming and reading or writing a counter. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-5 8254 PROGRAMMABLE INTERVAL TIMER 403 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(:1) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLKO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OATED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eLK 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QATE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;elK 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QATÂ£2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OU12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Do &lt;br /&gt;OJ &lt;br /&gt;~ &lt;br /&gt;Do &lt;br /&gt;U. &lt;br /&gt;0, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Do &lt;br /&gt;eLK 0 &lt;br /&gt;OUTO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OATEO &lt;br /&gt;OND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vee &lt;br /&gt;WR &lt;br /&gt;iiii &lt;br /&gt;Ci &lt;br /&gt;A, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;At! &lt;br /&gt;CLKa &lt;br /&gt;OUT a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ GAlEa &lt;br /&gt;ClK 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 OATEI &lt;br /&gt;OUT 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-33 The 8254 programmable interval timer. (a) Internal structure, and (b) pin-out &lt;br /&gt;(Courtesy of Intel Corporatiori) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G &lt;br /&gt;GND &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The gate input controls the operation of the counter in some modes of operation. &lt;br /&gt;Ground connects to the system ground bus. &lt;br /&gt;A counter output is where the wave-form generated by the timer is available. &lt;br /&gt;Read causes data to be read from the 8254 and often connects to the IORC signal. &lt;br /&gt;Power connects to the +5.0V power supply. &lt;br /&gt;Write causes data to be written to the 8254 and often connects to the write strobe &lt;br /&gt;(IOWC). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the 8254 &lt;br /&gt;Each counter is individually programmed by writing a control word followed by the initial count. &lt;br /&gt;Figure 10-34 lists the program control word structure of the 8254. The control word allows the &lt;br /&gt;programmer to select the counter, mode of operation, and type of operation (read/write). The &lt;br /&gt;control word also selects either a binary or BCD co~t. Each counter may be programmed with &lt;br /&gt;a count of 1 to FFFFH. A count of 0 is equal to FFFFH+ 1 (65,536) or 10,000 in BCD. The min-&lt;br /&gt;imum count of 1 applies to all modes of operation except modes 2 and 3, which have a minimum &lt;br /&gt;count of 2. Timer 0 is used in the personal computer with a divide by count of 64K (FFFFH) to &lt;br /&gt;generate the 18.2 Hz (18.196 Hz) interrupt clock tick. Timer 0 has a clock input frequency of &lt;br /&gt;4.77 MHz + 4, or 1.1925 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 10--6 Address &lt;br /&gt;selection inputs to the 8254 AI Ao Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 Counter 0 &lt;br /&gt;0 1 Counter 1 &lt;br /&gt;1 0 Counter 2 &lt;br /&gt;1 1 Control word &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;404 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-34 The control &lt;br /&gt;word for the 8254-2 timer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;76543210 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I SCI I sco IRWIIRWOI M21 MI I MO IBCDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tL1 Selects a BCD when a logic I Selects the mode (mode 0 --mode 5) &lt;br /&gt;Read/write control &lt;br /&gt;00 = counter latch command &lt;br /&gt;01 = read/write least-significant &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;byte only &lt;br /&gt;10 = read/write most-significant &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;byte only &lt;br /&gt;11 = read/write least-significant &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;byte first, followed by the &lt;br /&gt;most - significant byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selects counter &lt;br /&gt;00 = counter 0 &lt;br /&gt;01 = counter I &lt;br /&gt;10 = counter 2 &lt;br /&gt;II = read-back command &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The control word uses the BCD bit to select a BCD count (BCD = 1) or a binary count &lt;br /&gt;(BCD = 0). The M2, Ml, and MO bits select one of the six different modes of operation &lt;br /&gt;(000-101) for the counter. The RWI and RWO bits determine how the data are read from or &lt;br /&gt;written to the counter. The SCI and SCO bits select a counter or the special read-back mode of &lt;br /&gt;operation discussed later in this section. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each counter has a program control word used to select the way the counter operates. If &lt;br /&gt;two bytes are programmed into a counter, then the first byte (LSB) will stop the count, and the &lt;br /&gt;second byte (MSB) will start the counter with the new count. The order of programming is im-&lt;br /&gt;portant for each counter, but programming of different counters may be interleaved for better &lt;br /&gt;control. For example, the control word may be sent to each counter before the counts for indi-&lt;br /&gt;vidual programming. Example 10-21 shows a few ways to program counter 1 and 2. The first &lt;br /&gt;method programs both control words, then the LSB of the count for each counter, which stops &lt;br /&gt;them from counting. Finally, the MSB portion of the count is programmed, starting both coun-&lt;br /&gt;ters with the new count. The second example shows one counter programmed before the other. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-21 &lt;br /&gt;PROGRAM CONTROL WORD 1 &lt;br /&gt;PROGRAM CONTROL WORD 2 &lt;br /&gt;PROGRAM LSB 1 &lt;br /&gt;PROGRAM LSB 2 &lt;br /&gt;PROGRAM MSB 1 &lt;br /&gt;PROGRAM MSB 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROGRAM CONTROL WORD 1 &lt;br /&gt;PROGRAM LSB 1 &lt;br /&gt;PROGRAM MSB 1 &lt;br /&gt;PROGRAM CONTROL WORD 2 &lt;br /&gt;PROGRAM LSB 2 &lt;br /&gt;PROGRAM MSB 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;setup counter 1 &lt;br /&gt;;setup counter 2 &lt;br /&gt;;stop counter 1 and program LSB &lt;br /&gt;;stop counter 2 and program LSB &lt;br /&gt;;program MSB of counter 1 and start it &lt;br /&gt;;program MSB of counter 2 and start it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;setup counter 1 &lt;br /&gt;;stop counter 1 and program LSB &lt;br /&gt;;program MSB of counter 1 and start it &lt;br /&gt;;setup counter 2 &lt;br /&gt;;stop counter 2 and program LSB &lt;br /&gt;;program MSB of counter 2 and start it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Modes of Operation. Six modes of operation (mode 0 - mode 5) are available to each of the &lt;br /&gt;8254 counters. Figure 10-35 shows how each of these modes functions with the CLK input, the &lt;br /&gt;gate (G) control signal, and the OUT signal. A description of each mode follows. &lt;br /&gt;Mode 0 Allows the 8254 counter to be used as an events counter. In this mode, the output &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;becomes a logic 0 when the control word is written and remains until N plus the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Mode 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-5 8254 PROGRAMMABLE INTERVAL TIMER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Count of 7 loaded &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I 2 I 3 I 4 I 5 I &lt;br /&gt;CLK JuulJLJlflJLJUlJ1SlJLJlJ1J'Lfl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G -fil r---j &lt;br /&gt;! IL--=-~-=--_-_-_-_-_-_-_--'-_~--,-I = ___ = ___= ___ = ___ = __ = ___= ___= ___ = ___ = ___ = __ = ___= ___:;::!========== OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Trigger with count of 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1112131415111213141511121314151 &lt;br /&gt;CLK &lt;br /&gt;--~--------------, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT &lt;br /&gt;* Count of 5 loaded &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I 121 3 I 4 I 5 1 6 1 I I 2 I 3 I 4 I 5 161 &lt;br /&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT &lt;br /&gt;* Count of 6 loaded &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT &lt;br /&gt;*Trigger with count of 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 I 8 I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I 121 3 141 5 I &lt;br /&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT &lt;br /&gt;Trigger with count of 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LJ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;405 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-35 The six modes of operation for the 8254-2 programmable interval timer. Â·The G input stops the &lt;br /&gt;count when 0 in modes 2, 3, and 4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;number of programmed counts. For example, if a count of 5 is programmed, the &lt;br /&gt;output will remain a logic 0 for 6 counts beginning with N. Note that the gate (G) &lt;br /&gt;input must be a logic 1 to allow the counter to count. If G becomes a logic 0 in &lt;br /&gt;the middle of the count, the counter. will stop until G again becomes a logic 1. &lt;br /&gt;Causes the counter to function as a retriggerable monos table multi vibrator (one-&lt;br /&gt;shot). In this mode, the G input triggers the counter so that it develops a pulse at &lt;br /&gt;the OUT connection that becomes a logic 0 for the duration of the count. If the &lt;br /&gt;count is 10, then the OUT connection goes low for 10 clocking periods when &lt;br /&gt;triggered. If the G input occurs within the duration of the output pulse, the &lt;br /&gt;counter is again reloaded with the count and the OUT connection continues for &lt;br /&gt;the total length of the count. &lt;br /&gt;Allows the counter to generate a series of continuous pulses that are one clock &lt;br /&gt;pulse in width. The separation between pulses is determined by the count. For &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;406 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ModeS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;example, for a count of 10, the output is a logic 1 for 9 cIock periods and low for &lt;br /&gt;1 cIock period. This cycle is repeated until the counter is programmed with a new &lt;br /&gt;count or until the G pin is placed at a logic 0 level. The G input must be a logic 1 &lt;br /&gt;for this mode to generate a continuous series of pulses. &lt;br /&gt;Generates a continuous square-wave at the OUT connection, provided the G pin &lt;br /&gt;is a logic 1. If the count is even, the output is high for one-half of the count and &lt;br /&gt;low for one-half of the count. If the count is odd, the output is high for one clock-&lt;br /&gt;ing period longer than it is low. For example, if the counter is programmed for a &lt;br /&gt;count of 5, the output is high for 3 clocks and low for 2. &lt;br /&gt;Allows the counter to produce a single pulse at the output. If the count is pro-&lt;br /&gt;grammed as a 10, the output is high for 10 clocking periods and then low for 1 &lt;br /&gt;clocking period. The cycle does not begin until the counter is loaded with its &lt;br /&gt;complete count. This mode operates as a software triggered one-shot. As with &lt;br /&gt;modes 2 and 3, this mode also uses the G input to enable the counter. The G input &lt;br /&gt;must be a logic 1 for the counter to operate for these three modes. &lt;br /&gt;A hardware triggered one-shot that functions as mode 4 except that it is started by &lt;br /&gt;a trigger pulse on the G pin instead of by software. This mode is also similar to &lt;br /&gt;mode 1 because it is retriggerable. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Generating a Wave-form with the 8254. Figure 10-36 shows an 8254 connected to function at &lt;br /&gt;I/O ports 0700H, 0702H, 0704H, and 0706H of an 80386SX microprocessor. The addresses are &lt;br /&gt;decoded using a PAL16L8 that also generates a write strobe signal for the 8254, which is con-&lt;br /&gt;nected to the low order data bus connections. The PAL also generates a wait signal for the mi-&lt;br /&gt;croprocessor that causes two wait states when the 8254 is accessed. The wait state generator &lt;br /&gt;connected to the microprocessor actually controls the number of wait states inserted into the &lt;br /&gt;timing. The program for the PAL is not illustrated here because it is basically the same as many &lt;br /&gt;of the other prior examples. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(8 MHz) &lt;br /&gt;CLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;D1 &lt;br /&gt;D2 &lt;br /&gt;D3 &lt;br /&gt;D4 &lt;br /&gt;D5 &lt;br /&gt;D6 &lt;br /&gt;D7 &lt;br /&gt;RD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1 &lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/iO &lt;br /&gt;AO &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.\\10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A11 &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;2 &lt;br /&gt;3 &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;7 &lt;br /&gt;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 &lt;br /&gt;11 01 ~ 12 02 13 03 17 &lt;br /&gt;14 04 16 &lt;br /&gt;15 05 10 &lt;br /&gt;16 06 14 13 17 07 p1L 18 08 &lt;br /&gt;19 &lt;br /&gt;110 &lt;br /&gt;1618 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 10K 8 DO &lt;br /&gt;6 D1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* &lt;br /&gt;D2 ClKO 5 03 GO 4 04 OUTO ;j D5 2 06 ClK1 ~ 1 07 G1 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT1 l;j 22 Ro 23 WR ClK2 tl 19 AO G2 2 A1 OUT2 &lt;br /&gt;200 kHz continuous pulses &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100 kHz square wave &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21 cs &lt;br /&gt;8254 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-36 The 8254 interfaced to an 8 MHz 8086 so that it generates a 100 KHz square &lt;br /&gt;wave at OUTO and a 200KHz continous pulse at OUT1 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-5 8254 PROGRAMMABLE INTERVAL TIMER 407 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 10-22 lists the program that generates a 100 KHz square-wave at OUTO and a &lt;br /&gt;200 KHz continuous pulse at OUTI. We use mode 3 for counter 0 and mode 2 for counter I. The &lt;br /&gt;count programmed into counter 0 is 80, and the count for counter I is 40. These counts generate &lt;br /&gt;the desired output frequencies with an 8 MHz input clock. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 &lt;br /&gt;0001 52 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 BA 0706 &lt;br /&gt;0005 BO 36 &lt;br /&gt;0007 EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 BO 74 &lt;br /&gt;OOOA EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB BA 0700 &lt;br /&gt;OOOE BO 50 &lt;br /&gt;0010 EE &lt;br /&gt;0011 32 CO &lt;br /&gt;0013 EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 BA 0702 &lt;br /&gt;0017 BO 28 &lt;br /&gt;0019 EE &lt;br /&gt;001A 32 CO &lt;br /&gt;001C EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlD SA &lt;br /&gt;DOLE 58 &lt;br /&gt;001F C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that programs the 8254 timer to function &lt;br /&gt;;as illustrated in Figure 10-36. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIME PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;PUSH DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,706H &lt;br /&gt;MOV AL,OOllOllOB &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,01l10100B &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,700H &lt;br /&gt;MOV AL,80 &lt;br /&gt;OUT DX,AL &lt;br /&gt;XOR AL,AL &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,702H &lt;br /&gt;MOV AL,40 &lt;br /&gt;OUT DX,AL &lt;br /&gt;XOR AL,AL &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP DX &lt;br /&gt;POP AX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIME ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address control word &lt;br /&gt;;program counter 0 &lt;br /&gt;;for mode 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program counter 1 &lt;br /&gt;;for mode 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address counter 0 &lt;br /&gt;;load count of 80 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address counter 1 &lt;br /&gt;;load count of 40 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;restore registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reading a Counter. Each counter has an intemallatch that is read with the read counter port op-&lt;br /&gt;eration. These latches will normally follow the count. If the contents of the counter are needed at &lt;br /&gt;a particular time, then the latch can remember the count by programming the counter latch con-&lt;br /&gt;trol word (see Figure 10-37), which causes the contents of the counter to be held in a latch until &lt;br /&gt;it is read. Whenever a read from the latch or the counter is programmed, the latch tracks the con-&lt;br /&gt;tents of the counter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When it is necessary for the contents of more than one counter to be read at the same time, &lt;br /&gt;we use the read-back control word illustrated in Figure 10-38. With the read-back control word, &lt;br /&gt;the CNT bit is a logic 0 to cause the counters selected by CNTO, CNT1, and CNT2 to be latched. &lt;br /&gt;If the status register is to be latched, then the ST bit is placed at a logic O. Figure 10-39 shows the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-37 The 8254-2 &lt;br /&gt;counter latch control word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 6 5 4 3 2 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ISCllscol 0 I 0 I X I X I X I X I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L Select counter &lt;br /&gt;00 = counter 0 &lt;br /&gt;01 = counter I &lt;br /&gt;10 =. counter 2 &lt;br /&gt;II = read-back command &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;408 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-38 The 8254-2 &lt;br /&gt;read-back control word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 654 3 2 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.... 1 ____ Select counter bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--------- Latch status of &lt;br /&gt;selected counters &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'----------- Latch count of &lt;br /&gt;selected counters &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;status register, which shows the state of the output pin, whether the counter is at its null state (0), &lt;br /&gt;and how the counter is programmed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DC Motor Speed and Direction Control &lt;br /&gt;One application of the 8254 timer is as a motor speed controller for a DC motor. Figure 10--40 &lt;br /&gt;shows the schematic diagram of the motor and its associated driver circuitry. It also illustrates &lt;br /&gt;the interconnection of the 8254, a flip-flop, and the motor and its driver. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The operation of the motor driver circuitry is fairly straightforward. If the Q output of the &lt;br /&gt;74ALS112 is a logic 1, the base Q2 is pulled up to +12V through the base pull-up resistor and the &lt;br /&gt;base of Q2 is open circuited. This means that Ql is off and Q2 is on, with ground applied to the &lt;br /&gt;positive lead of the motor. The bases of both Q3 and Q4 are pulled low to ground through the in-&lt;br /&gt;verters. This causes Q3 to conduction or turn on and Q4 to turn off, applying ground to the neg-&lt;br /&gt;ative lead of the motor. The logic 1 at the Q output of the flip-flop therefore connects + 12V to the &lt;br /&gt;positive lead of the motor and ground to the negative lead. This connection causes the motor to &lt;br /&gt;spin in its forward direction. If the state of the Q output of the flip-flop becomes a logic 0, then &lt;br /&gt;the conditions of the transistors are reversed and +12V is attached to the negative lead of the &lt;br /&gt;motor, with ground attached to the positive lead. This causes the motor to spin in the reverse &lt;br /&gt;direction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the output of the flip-flop is alternated between a logic I and 0, the motor spins in either &lt;br /&gt;direction at various speeds. If the duty cycle of the Q output is 50 percent, the motor will not spin &lt;br /&gt;at all and exhibits some holding torque because current flows through it. Figure 10--41 shows &lt;br /&gt;some timing diagrams and their effects on the speed and direction of the motor. Notice how each &lt;br /&gt;counter generates pulses at different positions to vary the duty cycle at the Q output of the flip-&lt;br /&gt;flop. This output is also called pulse width modulation. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To generate these wave-forms, counters Â° and 1 are both programmed to divide the input &lt;br /&gt;clock (PCLK) by 30,720. We change the duty cycle of Q by changing the point at which counter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-39 The 8254-2 &lt;br /&gt;status register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 6 5 4 3 2 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--------- Counter mode &lt;br /&gt;'------------- Read/write operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---------------- NULL = I if counter is 0 &lt;br /&gt;'------------------ The level of the OUT pin &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;(BMHz) &lt;br /&gt;CLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;Dl &lt;br /&gt;D2 &lt;br /&gt;D3 &lt;br /&gt;D4 &lt;br /&gt;DS &lt;br /&gt;D6 &lt;br /&gt;D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD &lt;br /&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al &lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/iO &lt;br /&gt;Ul &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO 11 01 &lt;br /&gt;A3 12 02 &lt;br /&gt;A4 13 03 &lt;br /&gt;AS 14 04 &lt;br /&gt;A6 IS OS &lt;br /&gt;A7 16 06 &lt;br /&gt;AB 17 07 &lt;br /&gt;A9 18 DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al0 19 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All 16LB &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A'S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;DO &lt;br /&gt;Dl &lt;br /&gt;D2 &lt;br /&gt;D3 &lt;br /&gt;D4 &lt;br /&gt;DS &lt;br /&gt;D6 &lt;br /&gt;D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~-23 RD 1 WR &lt;br /&gt;20 ~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLKO 9 &lt;br /&gt;GO 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK1a Gl 14 &lt;br /&gt;OUTl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK2 &lt;br /&gt;G2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8254 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tOK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â·open-collector inverters &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3A &lt;br /&gt;C' S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6~ALSl12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-40 Motor speed and direction control using the 8254 timer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+12V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U4A U4C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7406 &lt;br /&gt;C3~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7406 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U4D ~ 7406 7406 U4B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;0 &lt;br /&gt;I (11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;N (11 &lt;br /&gt;... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-0 &lt;br /&gt;:D &lt;br /&gt;0 &lt;br /&gt;G) &lt;br /&gt;:D &lt;br /&gt;~ &lt;br /&gt;s: &lt;br /&gt;s: &lt;br /&gt;~ &lt;br /&gt;OJ &lt;br /&gt;r &lt;br /&gt;m &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Z &lt;br /&gt;--I &lt;br /&gt;m &lt;br /&gt;:D &lt;br /&gt;&amp;lt; ~ &lt;br /&gt;r &lt;br /&gt;--I &lt;br /&gt;~ &lt;br /&gt;m &lt;br /&gt;:D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.p,. &lt;br /&gt;o &lt;br /&gt;co &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;410 CHAPTER 10 BASIC liD INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I_ 30,720--/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLR U U U U &lt;br /&gt;PS U U U U &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Q I &lt;br /&gt;~15,360--l (a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I .. 30,720--/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLR U U U U &lt;br /&gt;PS U U U U &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Q LJ U U U &lt;br /&gt;-13,0721- (b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I_ 30,720 ~I &lt;br /&gt;CLR lJ U U U &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PS U U U lJ &lt;br /&gt;Q I n n n I &lt;br /&gt;~ 27,658---l (c) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-41 Timing for the motor speed and direction control circuit of Figure 10-40. (a) No rotation, &lt;br /&gt;(b) high-speed rotation in the reverse direction, and (c) high-speed rotation in the forward direction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 is started in relationship to counter O. This changes the direction and speed of the motor. But &lt;br /&gt;why divide the 8 MHz clock by 30,720? The divide rate of 30,720 is divisible by 256, so we can &lt;br /&gt;develop a short program that allows 256 different speeds. This also produces a basic operating &lt;br /&gt;frequency for the motor of about 260 Hz, which is low enough in frequency to power the motor. &lt;br /&gt;It is important to keep this operating frequency below 1,000 Hz, but above 60 Hz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 10-23 lists a procedure that controls the speed and direction of the motor. The &lt;br /&gt;speed is controlled by the value of AH when this procedure is called. Because we have an 8-bit &lt;br /&gt;number to represent speed, a 50 percent duty cycle, for a stopped motor, is a count of 128. By &lt;br /&gt;changing the value in AH, when the procedure is called, we can adjust the motor speed. The &lt;br /&gt;speed of the motor will increase in either direction by changing the number in AH when this pro-&lt;br /&gt;cedure is called. As the value in AH approaches OOH, the motor begins to increase its speed in &lt;br /&gt;the reverse direction. As the value of AH approaches FFH, the motor increases its speed in the &lt;br /&gt;forward direction. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-5 8254 PROGRAMMABLE INTERVAL TIMER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0706 &lt;br /&gt;0700 &lt;br /&gt;0702 &lt;br /&gt;7800 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 &lt;br /&gt;0001 51 &lt;br /&gt;0002 53 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003 8A CD &lt;br /&gt;0005 B8 0078 &lt;br /&gt;0008 F6 E3 &lt;br /&gt;OOOA 8B D8 &lt;br /&gt;OOOC B8 7800 &lt;br /&gt;OOOF 2B C3 &lt;br /&gt;0011 8B D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0013 BA 0706 &lt;br /&gt;0016 BO 34 &lt;br /&gt;0018 EE &lt;br /&gt;0019 BO 74 &lt;br /&gt;001B EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001C &lt;br /&gt;OOIF &lt;br /&gt;0022 &lt;br /&gt;0023 &lt;br /&gt;0025 &lt;br /&gt;0026 &lt;br /&gt;0026 &lt;br /&gt;0027 &lt;br /&gt;0029 &lt;br /&gt;002A &lt;br /&gt;002C &lt;br /&gt;002E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA 0702 &lt;br /&gt;B8 7800 &lt;br /&gt;EE &lt;br /&gt;8A C4 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EC &lt;br /&gt;86 C4 &lt;br /&gt;EC &lt;br /&gt;86 C4 &lt;br /&gt;3B C3 &lt;br /&gt;72 F6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0030 BA 0700 &lt;br /&gt;0033 B8 7800 &lt;br /&gt;0036 EE &lt;br /&gt;0037 8A C4 &lt;br /&gt;0039 EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003A &lt;br /&gt;003B &lt;br /&gt;003C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5B &lt;br /&gt;SA &lt;br /&gt;58 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003D C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that controls the speed and direction &lt;br /&gt;;of the motor in Figure 10-40. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;When this procedure is called, the contents of &lt;br /&gt;;AH &amp;lt;.ietermine the speed and direction of the &lt;br /&gt;;motor where AH is between OOH and FFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CNTR EQU &lt;br /&gt;CNTO EQU &lt;br /&gt;CNTO EQU &lt;br /&gt;COUNT EQU &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;706H &lt;br /&gt;700H &lt;br /&gt;702H &lt;br /&gt;30720 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SPEED PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;PUSH DX &lt;br /&gt;PUSH BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL,AL &lt;br /&gt;MOV AX,120 &lt;br /&gt;MUL BL &lt;br /&gt;MOV BX,AX &lt;br /&gt;MOV AX,COUNT &lt;br /&gt;SUB AX,BX &lt;br /&gt;MOV BX,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;calculate count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,CNTR ;program control words &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SPE: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,00110100B &lt;br /&gt;OUT DX,AL &lt;br /&gt;MOV AL,01110100B &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,CNTI &lt;br /&gt;MOV AX, COUNT &lt;br /&gt;OUT DX,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,DX &lt;br /&gt;XCHG AL,AH &lt;br /&gt;IN AL,DX &lt;br /&gt;XCHG AL,AH &lt;br /&gt;CMP AX,BX &lt;br /&gt;JB SPE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,CNTO &lt;br /&gt;MOV AX, COUNT &lt;br /&gt;OUT DX,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP BX &lt;br /&gt;POP DX &lt;br /&gt;POP AX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SPEED ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program counter 1 &lt;br /&gt;;to generate a clear &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;wait for counter 1 &lt;br /&gt;;to reach calculated &lt;br /&gt;; count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program counter 0 &lt;br /&gt;;to generate a set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;restore registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;411 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure adjusts the wave-form at Q by first calculating the count that counter 0 is to &lt;br /&gt;start in relationship to counter 1. This is accomplished by multiplying AH by 120 and then sub-&lt;br /&gt;tracting it from 30,720. This is required because the counters are down-counters that count from &lt;br /&gt;the programmed count to 0, before restarting. Next, counter 1 is programmed with a count of &lt;br /&gt;30,720 and started to generate the clear wave-form for the flip-flop. After counter 1 is started, it &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;412 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 10 BASIC liD INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;is read and compared with the calculated count. Once it reaches this count, counter 0 is started &lt;br /&gt;with a count of 30,720. From this point forward, both counters continue generating the clear and &lt;br /&gt;set wave-forms until the procedure is again called to adjust the speed and direction of the motor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16550 PROGRAMMABLE COMMUNICATIONS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The National Semiconductor Corporation's PC16550D is a programmable communications in-&lt;br /&gt;terface designed to connect to virtually any type of serial interface. The 16550 is a universal &lt;br /&gt;asynchronous receiver/transmitter (UART) that is fully compatible with the Intel microproces-&lt;br /&gt;sors. The 16550 is capable of operating at 0-1.5 M Baud. Baud rate is the number of bits trans-&lt;br /&gt;ferred per second, including start, stop, data, and parity. The 16550 also includes a &lt;br /&gt;programmable Baud rate generator and separate FIFOs for input and output data to ease the load &lt;br /&gt;on the microprocessor. Each FIFO contains 16 bytes of storage. This is the most common com-&lt;br /&gt;munications interface found in modern microprocessor-based equipment, including the personal &lt;br /&gt;computer and many modems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Asynchronous Serial Data &lt;br /&gt;Asynchronous serial data are transmitted and received without a clock or timing signal. Figure &lt;br /&gt;10-42 illustrates two frames of asynchronous serial data. Each frame contains a start bit, seven &lt;br /&gt;data bits, parity, and one stop bit. In this figure, a frame, which contains one ASCII character, &lt;br /&gt;has lO-bits. Most dial-up communications systems, such as CompuServe, Prodigy, and America &lt;br /&gt;Online, use lO-bits for asynchronous serial data with even parity. Most Internet and bulletin &lt;br /&gt;board services also use lO-bits, but they normally do not use parity. Instead, 8-bits are trans-&lt;br /&gt;ferred, replacing parity with a data bit. This makes byte transfers of non-ASCII data much easier &lt;br /&gt;to accomplish. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16550 Functional Description &lt;br /&gt;Figure 10-43 illustrates the pin-out of the 16550 UART. This device is available as a 40-pin DIP &lt;br /&gt;(dual in-line package) or as a 44-pin PLCC (plastic lead-less chip carrier). Two completely &lt;br /&gt;separate sections are responsible for data communications: the receiver and the transmitter. Be-&lt;br /&gt;cause each of these sections is independent of the other, the 16550 is able to function in simplex, &lt;br /&gt;half-duplex, or full-duplex modes. One of the main features of the 16550 is its internal receiver &lt;br /&gt;and transmitter FIFO (first-in, first-out) memories. Because each is 16 bytes deep, the UART &lt;br /&gt;only requires attention from the microprocessor after receiving 16 bytes of data. It also holds 16 &lt;br /&gt;bytes before the microprocessor must wait for the transmitter. The FIFO makes this UART ideal &lt;br /&gt;when interfacing to high-speed systems, because less time is required to service it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An example simplex system is where the transmitter or receiver is used by itself, such as &lt;br /&gt;in an FM (frequency modulation) radio station. An example half-duplex system is a CB (citizens &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I- Frame ~ I &lt;br /&gt;~STID()IDIIDdD,IDÂ·ID~IDhl pi * ISTIDoIDIID~ID,IDÂ·ID~IDhl P IÂ· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* = STOP &lt;br /&gt;ST = START &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-42 Asynchronous serial data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I &lt;br /&gt;* I * I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;TABLE 10-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-6 16550 PROGRAMMABLE COMMUNICATIONS INTERFACE 413 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-43 The pin-out 28 AO DO 1 27 &lt;br /&gt;of the 16550 UART A1 16550 D1 2 26 A2 D2 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 D3 4 CSO 13 D4 5 CS1 6 &lt;br /&gt;CS2 D5 7 D6 &lt;br /&gt;MR D7 8 &lt;br /&gt;RD 10 &lt;br /&gt;RD SIN 11 &lt;br /&gt;WR SOUT &lt;br /&gt;WR BAUDOUT ADS RCLK &lt;br /&gt;XIN RTS XOUT CTS &lt;br /&gt;TXRDY DTR &lt;br /&gt;RXRDY DSR &lt;br /&gt;DDIS DCD &lt;br /&gt;INTR RI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT1 &lt;br /&gt;OUT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;band) radio where we transmit and receive, but not both at the same time. The full-duplex system &lt;br /&gt;allows transmission and reception in both directions simultaneously. An example full-duplex &lt;br /&gt;system is the telephone. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 16550 can control a modem (modulator/demodulator), which is a device that converts &lt;br /&gt;TTL levels of serial data into audio tones that can pass through the telephone system. Six pins on &lt;br /&gt;the 16650 are devoted to modem control: DSR (data set ready), DTR (data terminal ready), &lt;br /&gt;CTS (c1ear-to-send), RTS (request-to-send), RI (ring indicator), and DCD (data carrier de-&lt;br /&gt;tect). The modem is referred to as the data set, and the 16550 is referred to as the data terminal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16550 Pin Functions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BAUDOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address inputs are used to select an internal register for programming &lt;br /&gt;and also for data transfer. Refer to Table 10-7 for a list of each &lt;br /&gt;combination of the address inputs and the registers selected. &lt;br /&gt;The address strobe input is used to latch the address lines and chip select &lt;br /&gt;lines. If not needed (as in the Intel system), connect this pin to ground. &lt;br /&gt;The ADS pin is designed for use with Motorola microprocessors. &lt;br /&gt;The Baud out pin is where the clock signal generated by the Baud rate &lt;br /&gt;generator from the transmitter section is made available. It is most often &lt;br /&gt;connected to the RCLK input to generate a receiver clock that is equal to &lt;br /&gt;the transmitter clock. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;selected by AQ, A1, and A2 A2 AI Ao Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 Receiver buffer (read) and transmitter holding (write) &lt;br /&gt;0 0 1 Interrupt enable &lt;br /&gt;0 1 0 Interrupt identification (read) and FIFO control (write) &lt;br /&gt;0 1 1 Line control &lt;br /&gt;1 0 0 Modem control &lt;br /&gt;1 0 1 Line status &lt;br /&gt;1 0 Modem status &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 Scratch &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;414 CHAPTER 10 BASIC liD INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CSO, CSI, CS2 &lt;br /&gt;CTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D7-DO &lt;br /&gt;DCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DDIS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD,RD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SIN, SOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RXRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TXRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR,WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XIN,XOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The chip select inputs must all be active to enable the 16550 UART. &lt;br /&gt;The clear to send (if low) indicates that the modem or data set is ready to &lt;br /&gt;exchange information. This pin is often used in a half-duplex system to &lt;br /&gt;tum the line around. &lt;br /&gt;The data bus pins are connected to the microprocessor data bus. &lt;br /&gt;The data carrier detect input is used by the modem to signal the 16550 &lt;br /&gt;that a carrier is present. &lt;br /&gt;The disable driver output becomes a logic 0 to indicate that the micro-&lt;br /&gt;processor is reading data from the DART. DDIS can be used to change &lt;br /&gt;the direction of data flow through a buffer. &lt;br /&gt;Data set ready is an input to the 16550 that indicates the modem or data &lt;br /&gt;set is ready to operate. . &lt;br /&gt;Data terminal ready is an output that indicates that the data terminal &lt;br /&gt;(16550) is ready to function. &lt;br /&gt;Interrupt request is an output to the microprocessor used to request an &lt;br /&gt;interrupt (INTR = 1) whenever the 16550 has a receiver error, has &lt;br /&gt;received data, and if the transmitter is empty. &lt;br /&gt;Master reset initializes the 16550 and should be connected to the system &lt;br /&gt;RESET signal. &lt;br /&gt;These are user-defined output pins that can provide signals to a modem &lt;br /&gt;or any other device as needed in a system. &lt;br /&gt;Receiver clock is the clock input to the receiver section of the DART. &lt;br /&gt;This input is always 16 x the desired receiver Baud rate. &lt;br /&gt;Read inputs (either may be used) cause data to be read from the register &lt;br /&gt;specified by the address inputs to the UART. &lt;br /&gt;The ring indicator input is placed at the logic 0 level by the modem to &lt;br /&gt;indicate that the telephone is ringing. &lt;br /&gt;Request-to-send is a signal to the modem indicating that the UART &lt;br /&gt;wishes to send data. &lt;br /&gt;These are the serial data pins. SIN accepts serial data and SOUT transmits &lt;br /&gt;serial data. &lt;br /&gt;Receiver ready is a signal used to transfer received data via DMA tech-&lt;br /&gt;niques (see text). &lt;br /&gt;Transmitter ready is a signal used to transfer transmitter data via DMA &lt;br /&gt;techniques (see text). &lt;br /&gt;Write (either may be used) connects (either) to the microprocessor write &lt;br /&gt;signal to transfer commands and data to the 16550. &lt;br /&gt;These are the main clock connections. A crystal is connected across &lt;br /&gt;these pins to form a crystal oscillator, or XIN is connected to an external &lt;br /&gt;timing source. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the 16550 &lt;br /&gt;Programming the 16550 is fairly simple, although maybe slightly more involved when compared &lt;br /&gt;to some of the other programmable interfaces described in this chapter. Programming is a two-&lt;br /&gt;part process that includes initialization dialog and operational dialog. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Initializing the 16550. Initialization dialog, which occurs after a hardware or software reset, &lt;br /&gt;consists of two parts: programming the line control register and the Baud rate generator. The line &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-6 16550 PROGRAMMABLE COMMUNICATIONS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-44 The con-&lt;br /&gt;tents of the 16550 line control &lt;br /&gt;register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Length &lt;br /&gt;00:. 5 bits &lt;br /&gt;01 ~ 6 bits &lt;br /&gt;10 = 7 bits &lt;br /&gt;11 = 8 bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--____ Stop bits &lt;br /&gt;0=1 stop bit &lt;br /&gt;1 = 1.5 or 2 stop bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L ______ Panty enable &lt;br /&gt;0= no panty &lt;br /&gt;1 = panty enabled &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Parity type &lt;br /&gt;'--------- 0 = odd panty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 = even parity &lt;br /&gt;Stick Sit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'------------ 0 = stick parity off &lt;br /&gt;1 = stick parity on &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-------------Se~d=b~~a~reak sent &lt;br /&gt;1 = send break on SOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'----__________ Enable D,v,sor Latch &lt;br /&gt;o = divisor latch off &lt;br /&gt;1 = enable divisor latch &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;415 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;control register selects the number of data bits, number of stop bits, and parity (whether it is even &lt;br /&gt;or odd or if parity is sent as a one or a zero). The Baud rate generator is programmed with a di-&lt;br /&gt;visor that determines the Baud rate of the transmitter section. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-44 illustrates the line control register. The line control register is programmed &lt;br /&gt;by outputting information to I/O port 011 (Az' A I' Ao)' The rightmost two bits of the line control &lt;br /&gt;register select the number of transmitted data bits (5, 6, 7, or 8). The number of stop bits are se-&lt;br /&gt;lected by S in the line control register. If S == 0, one stop bit is used; if S == 1, 1.5 stop bits are used &lt;br /&gt;for 5 data bits and 2 stop bits are used with 6, 7, or 8 data bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The next three bits are used together to send even or odd parity, to send no parity, or to &lt;br /&gt;send a 1 or a 0 in the parity bit position. To send even or odd parity, the ST (stick) bit must be &lt;br /&gt;placed at a logic 0 level and parity enable must be a logic 1. The value of the parity bit then de-&lt;br /&gt;termines even or odd parity. To send no parity (common in Internet connections), ST == 0 as well &lt;br /&gt;as the parity enable bit. This sends and receives data without parity. Finally, if a lora 0 must be &lt;br /&gt;sent and received in the parity bit position for all data, ST == 1, with a 1 in parity enable. To send &lt;br /&gt;a 1 in the parity bit position, place a 0 in the parity bit; to send a 0, place a 1 in the parity bit. &lt;br /&gt;(Refer to Table 10-8 for the operation of the parity and stick bits.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The remaining bits in the line control register are used to send a break and to select pro-&lt;br /&gt;gramming for the Baud rate divisor. If bit position 6 of the line control register is a logic 1, a &lt;br /&gt;break is transmitted. As long as this bit is a 1, the break is sent from the SOUT pin. A break by &lt;br /&gt;definition is at least two frames of logic 0 data. The software in the system is responsible for &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 10-8 The opera-&lt;br /&gt;tion of the ST and parity bits ST P PE Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 No parity &lt;br /&gt;0 0 1 Odd parity &lt;br /&gt;0 1 0 No parity &lt;br /&gt;0 1 1 Even parity &lt;br /&gt;1 0 0 Undefined &lt;br /&gt;1 0 1 Send/receive 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 Undefined &lt;br /&gt;1 Send/receive 0 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;416 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 10-9 The divisor &lt;br /&gt;used with the Baud rate gen-&lt;br /&gt;erator for an 18.432 MHz &lt;br /&gt;crystal illustrating common &lt;br /&gt;Baud rates &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Baud rate Divisor value &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 &lt;br /&gt;300 &lt;br /&gt;1,200 &lt;br /&gt;2,400 &lt;br /&gt;4,800 &lt;br /&gt;9,600 &lt;br /&gt;19,200 &lt;br /&gt;38,400 &lt;br /&gt;57,600 &lt;br /&gt;115,200 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10,473 &lt;br /&gt;3,840 &lt;br /&gt;920 &lt;br /&gt;480 &lt;br /&gt;240 &lt;br /&gt;120 &lt;br /&gt;60 &lt;br /&gt;30 &lt;br /&gt;20 &lt;br /&gt;1Q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;timing the transmission of the break. To end the break. bit position 6 or the line control regi~ter &lt;br /&gt;is returned to a logic 0 level. The Baud rate divisor is only programmable when bit position '7 of &lt;br /&gt;the line control register is a logic 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the Baud Rate. The Baud rate generator is programmed at I/O addresses 000 &lt;br /&gt;and DOl (A2, AI' Ao). Port 000 is used to hold the least-significant part of the 16-bit divisor, &lt;br /&gt;and port 001 holds the most-significant part. The value used for the divisor depends on the ex-&lt;br /&gt;ternal clock or crystal frequency. Table 10-9 illustrates common Baud rates obtainable if a &lt;br /&gt;18.432 MHz crystal is used as a timing source. It also shows the divisor values programmed &lt;br /&gt;into the Baud rate generator to obtain these Baud rates. The actual number programmed into &lt;br /&gt;the Baud rate generator causes it to produce a clock that is 16 times the desired Baud rate. For &lt;br /&gt;example, if 240 is programmed into the Baud rate divisor, the Baud rate is 18.432MHzh6 x 240 = &lt;br /&gt;4800 Baud. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sample Initialization. Suppose that an asynchronous system requires seven data bits, odd parity, &lt;br /&gt;a Baud rate of 9600, and one stop bit. Example 10-24 lists a procedure that initializes the 16550 &lt;br /&gt;to function in this manner. Figure 10-45 shows the interface to the 8088 microprocessor using a &lt;br /&gt;PALl6L8 to decode the 8-bit port addresses.FOH and F7H. (The PAL program is not shown.) &lt;br /&gt;Here port F3H accesses the line control register and FOH and FIH access the Baud rate divisor &lt;br /&gt;registers. The last part of Example 10-24 is described with the function of the FIFO control reg-&lt;br /&gt;ister in the next few paragraphs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00F3 &lt;br /&gt;OOFO &lt;br /&gt;00F1 &lt;br /&gt;00F2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BO 8A &lt;br /&gt;0002 E6 F3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 BO 78 &lt;br /&gt;0006 E6 FO &lt;br /&gt;0008 BO 00 &lt;br /&gt;DOOA E6 F1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;oooe BO OA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Initia1ization Dialog for Figure 10-45. &lt;br /&gt;;Baud rate 9600, 7 data, odd parity, one stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LINE EQU OF3H &lt;br /&gt;LSB EQU OFOH &lt;br /&gt;MSB EQU OF1H &lt;br /&gt;FIFO EQU OF2H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;START PROe NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,10001010B &lt;br /&gt;OUT LINE,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,120 &lt;br /&gt;OUT LSB,AL &lt;br /&gt;MOV AL,O &lt;br /&gt;OUT MSB,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOV AL,ODOO101DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable Baud divisor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program Baud rate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program 7-data, odd &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-6 16550 PROGRAMMABLE COMMUNICATIONS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-45 The 16550 &lt;br /&gt;interfaced to the 8088 micro-&lt;br /&gt;processor at ports &lt;br /&gt;00FOH-00F7H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE E6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 BO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;?3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;)7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A1S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Bus (00-07) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ --+1!~ ?~ ~ 3 [3 03 17 &lt;br /&gt;4 14 04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 05 0-:':-&amp;gt;;5,-_ &lt;br /&gt;16 06 14 &lt;br /&gt;17 07 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28 &lt;br /&gt;27 &lt;br /&gt;26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO -+_..Â§g_ &lt;br /&gt;Al -+-*-1 &lt;br /&gt;A2 -+_=--{ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18 08 K)-1&amp;quot;'2'-l--l-l-____ .!2...-J &lt;br /&gt;19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RO -+-{;.!;--4 &lt;br /&gt;WR --+--7~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18.432 MHz &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CSO &lt;br /&gt;CSl &lt;br /&gt;CS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MR &lt;br /&gt;RO &lt;br /&gt;RO &lt;br /&gt;WR &lt;br /&gt;WR &lt;br /&gt;ADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XIN &lt;br /&gt;XOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TXROY &lt;br /&gt;RXROY &lt;br /&gt;OOIS &lt;br /&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT LINE,AL ;parity, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,OOOOOlllB ;enable &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SIN &lt;br /&gt;SOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BAUOOUT &lt;br /&gt;RCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RTS &lt;br /&gt;CTS &lt;br /&gt;OTR &lt;br /&gt;OSR &lt;br /&gt;OCO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTl &lt;br /&gt;OUT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16550 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;one stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;transmitter and &lt;br /&gt;0012 E6 0'2 OUT FIFO,AL ireceiver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0015 START ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;417 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Serial &lt;br /&gt;data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After programming the line control register and Baud rate divisor, the 16550 is still not &lt;br /&gt;ready to function-we still must program the FIFO control register, which is at port F2H in the &lt;br /&gt;circuit of Figure 10-45. Figure 10-46 illustrates the FIFO control register for the 16550. This &lt;br /&gt;register enables the transmitter and receiver (bit 0 = 1) and clears the transmitter and receiver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-46 The FIFO &lt;br /&gt;control register of the 16550 &lt;br /&gt;UART &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIFO Enable &lt;br /&gt;a ~ disable the FIFO &lt;br /&gt;1 ~ enable the FIFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-___ Re~e:~~ ~~~~l &lt;br /&gt;1 ~ reset receiver FIFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-_____ Transmitter Reset &lt;br /&gt;o ~ no effect &lt;br /&gt;1 ~ reset transmitter FIFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-------- DMA mode control &lt;br /&gt;o ~ set to function as 16450 UART &lt;br /&gt;1 ~ FIFO mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--_____________ Receiver Tngger level &lt;br /&gt;00 ~ 1 bytes in FIFO &lt;br /&gt;01 ~ 4bytes In FIFO &lt;br /&gt;1 0 ~ 8bytes in FI FO &lt;br /&gt;11 ~ 14bytesln FIFO &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;418 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-47 The con-&lt;br /&gt;tents of the line status reg-&lt;br /&gt;ister of the 16550 UART &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Line Status Register &lt;br /&gt;765432 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I ER I TE I TH I BI I FE I PE I OE IDRI &lt;br /&gt;Data Ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o = no data to read &lt;br /&gt;, = data in FIFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Overrun Error &lt;br /&gt;'----- 0 = no overrun error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 = overrun error &lt;br /&gt;'--____ Parity Error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o = no parity error &lt;br /&gt;, = panty error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Framing Error 1--______ 0 = no framing error &lt;br /&gt;, = framing error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Break Indicator 1--_______ 0 = no break &lt;br /&gt;, = break being received &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--_________ Tra~~~~1: ~~:~!~~~~~~er &lt;br /&gt;, = transmitter ready for data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Transmitter Empty &lt;br /&gt;'------------- 0 = transmitter not empty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, = transmitter empty &lt;br /&gt;'--____________ Error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0= noerror &lt;br /&gt;, = at least one error in FIFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIFOs. It also provides control for the 16550 interrupts, which are discussed in Chapter 11. No-&lt;br /&gt;tice that the last section of Example 10-24 places a 7 into the FIFO control register. This enables &lt;br /&gt;the transmitter and receiver and clears both FIFOs. The 16550 is now ready to operate, but with-&lt;br /&gt;out interrupts. Interrupts are automatically disabled when the MR (master reset) input is placed &lt;br /&gt;at a logic 1 by the system RESET signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sending Serial Data. Before serial data can be sent or received through the 16550, we need to &lt;br /&gt;know the function of the line status register (see Figure 10-47). The line status register contains &lt;br /&gt;infonnation about error conditions and the state of the transmitter and receiver. This register is &lt;br /&gt;tested before a byte is transmitted or can be received. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a procedure (see Example 10-25) is written to transmit the contents of &lt;br /&gt;AH to the 16550 and out through its serial data pin (SOUT). The TH bit is polled by software &lt;br /&gt;to detennine if the transmitter is ready to receive data. This procedure uses the circuit of &lt;br /&gt;Figure 10-43. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-25 &lt;br /&gt;;A Procedure that transmits AH via the 16550 UART. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00F5 LSTAT EQU OF5H ;line status port &lt;br /&gt;OOFO DATA EQU OFOH ;data port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 SEND PROe NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 PUSH AX ;save AX &lt;br /&gt;0001 E4 F5 IN AL,LSTAT ;get line status register &lt;br /&gt;0003 A8 20 TEST AL,20H ;test TH bit &lt;br /&gt;0005 74 FA JZ SEND ;if transmitter not ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 8A e4 MOV AL,AH ;get data &lt;br /&gt;0009 E6 FO OUT DATA,AL ; transmit data &lt;br /&gt;OOOB 58 POP AX ;restore AX &lt;br /&gt;OOoe e3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DODD SEND ENDP &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-7 ANALOG-TO-DIGITAL (ADC) AND DIGITAL-TO-ANALOG (DAC) CONVERTERS 419 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Receiving Serial Data. To read received information from the 16550, we test the DR bit of the &lt;br /&gt;line status register. Example 10-26 lists a procedure that tests the DR bit to decide if the 16550 &lt;br /&gt;has received any data. Upon reception of data, the procedure tests for errors. If an error is de-&lt;br /&gt;tected, the procedure returns with AL equal to an ASCII'?,. If no error has occurred, then the &lt;br /&gt;procedure returns with AL equal to the received character. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 00F5 &lt;br /&gt;= OOFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E4 F5 &lt;br /&gt;0002 A8 01 &lt;br /&gt;0004 74 FA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0006 A8 DE &lt;br /&gt;0008 75 03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA E4 FO &lt;br /&gt;OOOC C3 &lt;br /&gt;DODD ERR: &lt;br /&gt;DODD BO 3F &lt;br /&gt;OOOF C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 REVC ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that receives data from the 16550 UART &lt;br /&gt;;and returns it in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSTAT EQU OF5H ;line status port &lt;br /&gt;DATA EQU OFOH ;data port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RECV PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,LSTAT ;get line status register &lt;br /&gt;TEST AL,l ;test DR bit &lt;br /&gt;JZ RECV ; if no data in receiver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST AL,OEH ;test all 3 error bits &lt;br /&gt;JNZ ERR ;for an error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,DATA ;read data from 16550 &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, '? ' ;get question mark &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UART Errors. The types of errors detected by the 16550 are parity error, framing error, and &lt;br /&gt;overrun error. A parity error indicates that the received data contain the wrong parity. A &lt;br /&gt;framing error indicates that the start and stop bits are not in their proper places. An overrun &lt;br /&gt;error indicates that data have overrun the internal receiver FIFO buffer. These errors should not &lt;br /&gt;occur during normal operation. A parity error indicates that noise was encountered during recep-&lt;br /&gt;tion. A framing error occurs if the receiver is receiving data at an incorrect Baud rate. An overrun &lt;br /&gt;error occurs only if the software fails to read the data from the UART before the receiver FIFO &lt;br /&gt;is full. This example does not test the BI (break indicator bit) for a break condition. Note that a &lt;br /&gt;break is two consecutive frames of logic O's on the SIN pin of the UART. The remaining regis-&lt;br /&gt;ters, which are used for interrupt control and modem control, are developed in Chapter 11. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ANALOG-TO-DIGITAL (ADC) AND DIGITAL-TO-ANALOG (DAC) CONVERTERS &lt;br /&gt;Analog-to-digital (ADC) and digital-to-analog (DAC) converters are used to interface the micro-&lt;br /&gt;processor to the analog world. Many events that are monitored and controlled by the micro-&lt;br /&gt;processor are analog events. These often include monitoring all forms of events, even speech, to &lt;br /&gt;controlling motors and like devices. In order to interface the microprocessor to these events, we &lt;br /&gt;must understand the interlace and control of the ADC and DAC, which convert between analog &lt;br /&gt;and digital data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The DAC0830 Digital-to-Analog Converter &lt;br /&gt;A fairly common and low-cost digital-to-analog converter is the DAC0830 (a product of National &lt;br /&gt;Semiconductor Corporation). This device is an 8-bit converter that transforms an 8-bit binary &lt;br /&gt;number into an analog voltage. Other converters are available that convert from 10-, 12-, or l6-bits &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;420 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-48 The pin-out &lt;br /&gt;of the DAC0830 digital-to-&lt;br /&gt;analog converter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;WRI &lt;br /&gt;WR2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIO &lt;br /&gt;011 RFB &lt;br /&gt;DI2 &lt;br /&gt;DI3 &lt;br /&gt;DI4 IOUT2 &lt;br /&gt;DIS &lt;br /&gt;DI6 IOUTI &lt;br /&gt;DI7 &lt;br /&gt;XFER &lt;br /&gt;ILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DGNO AGNO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAC0830 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;into analog voltages. The number of voltage steps generated by the converter is equal to the &lt;br /&gt;number of binary input combinations. Therefore, an 8-bit converter generates 256 different &lt;br /&gt;voltage levels, a 10-bit converter generates 1,024 levels, and so forth. The DAC0830 is a ~ediumÂ­&lt;br /&gt;speed converter that transforms a digital input to an analog output in approximately 1 Jls. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-48 illustrates the pin-out of the DAC0830. This device has a set of eight data &lt;br /&gt;bus connections for the application of the digital input code and a pair of analog outputs labeled &lt;br /&gt;loutl and lout2 that are designed as inputs to an external operational amplifier. Because this is an &lt;br /&gt;8-bit converter, its output step voltage is defined as -V REF (reference voltage) divided by 255. &lt;br /&gt;For example, if the reference voltage is -5.0V, its output step voltage is +.0196V. Note that the &lt;br /&gt;output voltage is the opposite polarity of the reference voltage. If an input of 1001 00102 is &lt;br /&gt;applied to the device, the output voltage will be the step voltage times 1001 00102, or in this case &lt;br /&gt;+2.862V. By changing the reference voltage to -5.1V, the step voltage becomes +.02V. The step &lt;br /&gt;voltage is also often called the resolution of the converter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Internal Structure of the DAC0830. Figure 10-49 illustrates the internal structure of the &lt;br /&gt;DAC0830. Notice that this device contains two internal registers. The first is a holding register, &lt;br /&gt;while the second connects to the R-2R internal ladder converter. The two latches allow one byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-49 The internal &lt;br /&gt;structure of the DAC0830 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Latch 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-----ill &lt;br /&gt;Latch 2 Converter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1----- Vref &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10ut2 &lt;br /&gt;lout 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Rfb &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-7 ANALOG-TO-DIGITAL (ADC) AND DIGITAL-TO-ANALOG (DAC) CONVERTERS 421 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to be held while another is converted. In many cases, we disable the first latch and use only thc &lt;br /&gt;second for entering data into the converter. This is accomplished by connecting a logic I to ILE &lt;br /&gt;and a logic 0 to CS (chip select). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Both latches within the DAC0830 are transparent. That is, when the G input to thc latch is &lt;br /&gt;a log!' I, data pass through the latch, but when the G input becomes a logic 0, data are latched or &lt;br /&gt;held. The converter has a reference input pin (V REF) that establishes the full scale output voltage. &lt;br /&gt;If -lOY is placed on V REF' the full scale (11111111 2) output voltage is + I OV. The output of the &lt;br /&gt;R-2R ladder within the converter appears at loutl and Iout2. These outputs are designed to be &lt;br /&gt;applied to an operational amplifier such as a 741 or similar device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Connecting the DAC0830 to the Microprocessor. The DAC0830 is connected to the micro-&lt;br /&gt;processor as illustrated in Figure 10-50. Here a PALl6L8 is used to decode the DAC0830 at &lt;br /&gt;8-bit I/O port address 20H. Whenever an OUT 20H,AL instruction is executed, the contents of &lt;br /&gt;data bus connections ADO-AD? are passed to the converter within the DAC0830. The 741 oper-&lt;br /&gt;ational amplifier along with the -12V zener reference voltage causes the full-scale output voltage &lt;br /&gt;to equal + 12V. The output of the operational amplifier feeds a driver that powers a 12V DC &lt;br /&gt;motor. This driver is a Darlington amplifier for large motors. This example shows the converter &lt;br /&gt;driving a motor, but other devices could be used as outputs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ADC0804 Analog-to-Digital Converter &lt;br /&gt;A common low-cost ADC is the ADC0804, which belongs to a family of converters that are all &lt;br /&gt;identical except for accuracy. This device is compatible with a wide range of microprocessors &lt;br /&gt;such as the Intel family. There are faster ADCs available, and some with more resolution than &lt;br /&gt;8-bits, but this device is ideal for many applications that do not require a high degree of accuracy. &lt;br /&gt;The ADC0804 requires up to 100 ).ls to convert an analog input voltage into a digital output code. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-51 shows the pin-out of the ADC0804 converter (a product of National Semi-&lt;br /&gt;conductor Corporation). To operate the converter, the WR pin is pulsed with CS grounded to &lt;br /&gt;start the conversion process. Because this converter requires a considerable amount of time for &lt;br /&gt;the conversion, a pin labeled INTR signals the end of the conversion. Refer to Figure 10-52 for &lt;br /&gt;a timing diagram that shows the interaction of the control signals. As can be seen, we start the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOO~~ AOl A02 03 &lt;br /&gt;A04 &lt;br /&gt;A05 &lt;br /&gt;A06 &lt;br /&gt;A07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14 &lt;br /&gt;13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR 1 &lt;br /&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-$- = digital ground ~ = analog ground &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+12 &lt;br /&gt;010 9 011 RF8 &lt;br /&gt;012 &lt;br /&gt;013 &lt;br /&gt;014 IOUT2 12 &lt;br /&gt;015 11 016 IOUTl &lt;br /&gt;017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XFER &lt;br /&gt;ILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OGNO AGNO &lt;br /&gt;OAC0830 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-50 A DAC0830 interfaced to the 8086 microprocessor at 8-bit I/O location 20H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;422 CHAPTER 10 BASIC I/O INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-51 The pin-out &lt;br /&gt;of the ADC0804 analog-to-&lt;br /&gt;digital converter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DBO &lt;br /&gt;OBI &lt;br /&gt;DB2 &lt;br /&gt;DB3 &lt;br /&gt;DB4 &lt;br /&gt;DB5 &lt;br /&gt;DB6 &lt;br /&gt;DB7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VI+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLKR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eLK &lt;br /&gt;RD VREF &lt;br /&gt;WR &lt;br /&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC0804 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;converter with the WR pulse, we wait for INTR to return to a logic 0 level, and then we read the &lt;br /&gt;data from the converter. If a time delay is used that allows at least 100 Jls of time, then we don't &lt;br /&gt;need to test the INTR pin. Another option is to connect the INTR pin to an interrupt input so an &lt;br /&gt;interrupt occurs when the conversion is complete. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Analog Input Signal. Before the ADC0804 can be connected to the microprocessor, its &lt;br /&gt;analog inputs must be understood. There are two analog inputs to the ADC0804: VIN (+) and V IN &lt;br /&gt;(-). These inputs are connected to an internal operational amplifier and are differential inputs, as &lt;br /&gt;shown in Figure 10-53. The differential inputs are summed by the operational amplifier to pro-&lt;br /&gt;duce a signal for the internal analog-to-digital converter. Figure 10-53 shows a few ways to use &lt;br /&gt;these differential inputs. The first way (Figure 10-53a) uses a single input that can vary between &lt;br /&gt;OV and +5.0V. The second (Figure 10-53b) shows a variable voltage applied to the VIN (-) pin &lt;br /&gt;so the zero reference for V IN (+) can be adjusted. &lt;br /&gt;Generating the Clock Signal. The ADC0804 requires a clock source for operation. The clock can &lt;br /&gt;be an external clock applied to the CLK IN pin, or it can be generated with an RC circuit. The per-&lt;br /&gt;missible range of clock frequencies is between 100 KHz and 1460 KHz. It is desirable to use a fre-&lt;br /&gt;quency that is as close as possible to 1460 KHz so conversion time is kept to a minimum. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the clock is generated with an RC circuit, we use the CLK IN and CLK R pins connected &lt;br /&gt;to an RC circuit, as illustrated in Figure 10-54. When this connection is in use, the clock fre-&lt;br /&gt;quency is calculated by the following equation: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fclk=_l-&lt;br /&gt;1.lRe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Connecting the ADCOB04 to the Microprocessor. The ADC0804 is interfaced to the 8086 mi-&lt;br /&gt;croprocessor as illustrated in Figure 10-55. Note the V REF signal is not attached to anything, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ , &lt;br /&gt;-------~ ~::,: / r------------------------__ , : ~ 'I &lt;br /&gt;____ ~!--/ BUSY &amp;quot;''-_____ --+! ___ _ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 ~ &lt;br /&gt;Start conversion Read data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-52 The timing for the ADC0804 analog-to-digital converter &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-7 ANALOG-TO-DIGITAL (ADC) AND DIGITAL-TO-ANALOG (DAC) CONVERTERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-53 The analog &lt;br /&gt;inputs to the ADC0804 con-&lt;br /&gt;verter. (a) To sense a 0- to &lt;br /&gt;+S.O-V input. (b) To sense an &lt;br /&gt;input offset from ground &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-54 Connecting &lt;br /&gt;the RC circuit to the ClK IN &lt;br /&gt;and ClK R pins on the &lt;br /&gt;ADC0804 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Analog input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Analog input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+SV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK R 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R &lt;br /&gt;CLKIN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vin(+)rt:&amp;gt;-I Vin(-) &lt;br /&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC0804 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 FIGURE 10-55 The &lt;br /&gt;ADC0804 interfaced to the &lt;br /&gt;microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 18 = ~g~ ~7 DB1 &lt;br /&gt;~ 15 = &lt;br /&gt;AD4 14 DB3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD5 ~~~~~~~Â§~~~~~~~~1H3~ DB4 ~ 12 ~~ 11 ~ &lt;br /&gt;U2A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;423 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Analog input &lt;br /&gt;VI+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VI- ,..-2--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClKR J-!.&amp;quot;19'---f---, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L &lt;br /&gt;1K ClK 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VREF -.JL ~' &lt;br /&gt;,..-_--;\\1-j CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;..----f- RD r-+ WR &lt;br /&gt;5 INTR AGND ~. T .001 uF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC0804 ..--I RD~~~1Ef~11--;0~1~M19~==~ J1 __ ~ AO 2 12 02 1187 ~~ 3 13 03 ~~6 &lt;br /&gt;A3 ~~~ci~ :; g; 5 A4 6 16 06 n.1L AS 7 17 07 D-1%-&lt;br /&gt;A6 18 08 ,..J,L &lt;br /&gt;A7 19 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M 11 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I 1618 WR ____________________________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;which is normal. Suppose that the ADC0804 is decoded at 8-bit 1/0 port address 40H for the &lt;br /&gt;data and port address 42H for the INTR signal and a procedure is required to start and read the &lt;br /&gt;data from the ADC. This procedure is listed in Example 10-27. Notice that the INTR bit is &lt;br /&gt;polled; if it becomes a logic 0, the procedure ends with AL containing the converted digital &lt;br /&gt;code. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;424 CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-27 &lt;br /&gt;;A procedure that reads data from the ADC and returns &lt;br /&gt;;it in .&amp;quot;.L. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 ADCX PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 E6 40 OUT 40H,AL ;start conversion &lt;br /&gt;0002 ADCXl: &lt;br /&gt;0002 E4 42 IN AL,42H ;read INTR &lt;br /&gt;0004 A8 80 TEST AL,80H ;test INTR &lt;br /&gt;0006 75 FA JNZ ADCXl ;repeat until INTR 0 &lt;br /&gt;0008 E4 40 IN AL,40H ;get ADC data &lt;br /&gt;OOOA C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB ADCX ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Using the ADC0804 and the DAC0830 &lt;br /&gt;This section of the text illustrates an example using both the ADC0804 and the DAC0830 to cap-&lt;br /&gt;ture and replay audio signals or speech. In the past we often used a speech synthesizer to gen-&lt;br /&gt;erate speech, but the quality of the speech was poor. For quality speech we can use the ADC0804 &lt;br /&gt;to capture an audio signal and store it in memory for later playback through the DAC0830. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 10-56 illustrates the circuitry required to connect the ADC0804 at I/O ports &lt;br /&gt;0700H and 0702H. The DAC0830 is interfaced at 110 port 704H. These 110 ports are in the low &lt;br /&gt;bank of a 16-bit microprocessor such as the 8086 or 80386SX. The software used to run these &lt;br /&gt;converters appears in Example 10--28. This software reads a one-second burst of speech and &lt;br /&gt;then plays it back 10 times. This process repeats until the system is turned off. In this example, &lt;br /&gt;speech is sampled and stored in a section of memory called WORDS. The sample rate is chosen &lt;br /&gt;at 2,048 samples per second which renders acceptable-sounding speech. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 10-28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0500 [ &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0018 &lt;br /&gt;0018 E8 OOOA &lt;br /&gt;OOIB B9 OOOA &lt;br /&gt;ODIE &lt;br /&gt;ODIE E8 0023 &lt;br /&gt;0021 E2 FB &lt;br /&gt;0023 EB EA &lt;br /&gt;0025 &lt;br /&gt;0025 BF 0000 R &lt;br /&gt;0028 B9 0500 &lt;br /&gt;002B Bf. 0700 &lt;br /&gt;002E &lt;br /&gt;002E EE &lt;br /&gt;002F 83 C2 CO &lt;br /&gt;0032 &lt;br /&gt;0032 EC &lt;br /&gt;0033 A8 80 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AG.:UN: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPl: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RE.:&amp;gt;,.D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RE.&amp;quot;.Dl: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RE.;;)2 : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Software that records a I-second passage of speech &lt;br /&gt;;and plays it back 10 times' before recording the &lt;br /&gt;;next I-second passage of speech. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Assumes a clock of 8 MHz (8086) for the time delay . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;WORDS DB 2048 DUP (?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL READ &lt;br /&gt;MOV CX,lO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL WRITE &lt;br /&gt;LOOP LOOPI &lt;br /&gt;JMP AGAIN &lt;br /&gt;PROC NEAR &lt;br /&gt;MOV DI,OFFSET WORDS &lt;br /&gt;MOV CX,2048 &lt;br /&gt;MOV DX,0700H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT DX,AL &lt;br /&gt;ADD DX,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,DX &lt;br /&gt;TEST AL,80H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;space for speech &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;read speech &lt;br /&gt;;set count to 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;playback speech &lt;br /&gt;; repeat 10 times &lt;br /&gt;; repeat forever &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address data area &lt;br /&gt;;load count &lt;br /&gt;;address port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start converter &lt;br /&gt;;address status port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get INTR &lt;br /&gt;;test INTR &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-7 ANALOG-TO-OIGITAL (ADC) AND DIGITAL-TO-ANALOG (DAC) CONVERTERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;Ul &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;es &lt;br /&gt;WR' VREF &lt;br /&gt;W1' &lt;br /&gt;010 &lt;br /&gt;011 RFB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 012 013 ! Dl4 IOUT2 12 &lt;br /&gt;DIS &lt;br /&gt;DIS IDun 11 &lt;br /&gt;Dl7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 XFER 1 ILE &lt;br /&gt;10 DGND AGND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAC0830 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 ADo~lIIr18 ~VI+ ~ AD1 17 ~g~ 1 '--____ -' &lt;br /&gt;AD4 &lt;br /&gt;ADS &lt;br /&gt;ADS &lt;br /&gt;AD7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;AI &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;AS &lt;br /&gt;A7 &lt;br /&gt;AD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A8 A. &lt;br /&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A1S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/iO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l6La &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MICROPHONE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 10-56 A circuit that stores speech and plays it back through the speaker &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0035 75 FB JNZ READ2 iwait for INTR = 0 &lt;br /&gt;0037 83 EA 02 SUB DX,2 ;address data port &lt;br /&gt;003A EC IN AL,DX ;get data from ADC &lt;br /&gt;003B 88 05 MOV [DI] ,AL ;store data in array &lt;br /&gt;003D 47 INC DI ;address next element &lt;br /&gt;003E E8 0018 CALL DELAY iwait for 1/2048 seconds &lt;br /&gt;0041 E2 EB LOOP READ1 ;repeat 2,048 times &lt;br /&gt;0043 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0044 READ ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0044 WRITE PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0044 51 PUSH CX &lt;br /&gt;0045 BF 0000 R MOV DI,OFFSET WORDS ;address data &lt;br /&gt;0048 B9 0500 MOV CX,2048 ;load count &lt;br /&gt;004B BA 0704 MOV DX,0704H ;address DAC &lt;br /&gt;004E WRITE1: &lt;br /&gt;004E 8A 05 MOV AL, [DI] ;get data from array &lt;br /&gt;0050 EE OUT DX,AL ;send data to DAC &lt;br /&gt;0051 47 INC DI ;address next element &lt;br /&gt;0052 E8 0004 CALL DELAY j&amp;quot;,.,ait 1/2048 second &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;425 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;426 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 10 BASIC 110 INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0055 E2 F7 LOOP WRITE1 ;repeat 2,048 times &lt;br /&gt;0057 59 POP ex &lt;br /&gt;0058 e3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0059 WRITE ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0059 DELAY PRoe NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0059 51 PUSH ex &lt;br /&gt;005A B9 00E1 MOV eX,225 ;approximate1y 1/2048 sec. &lt;br /&gt;005D DELAY1: &lt;br /&gt;005D E2 FE LOOP DELAY1 &lt;br /&gt;005F 59 POP ex &lt;br /&gt;0060 e3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0061 DELAY ENDP &lt;br /&gt;. END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;1. The 8086-Pentium Pro microprocessors have two basic types of I/O instructions: IN and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT. The IN instruction inputs data from an external I/O device into either the AL (8-bit) or &lt;br /&gt;AX (l6-bit) register. The IN instruction is available as a fixed port instruction, a variable &lt;br /&gt;port instruction, or a string instruction (80286-Pentium Pro) INSB or INSW. The OUT in-&lt;br /&gt;struction outputs data from AL or AX to an external I/O device and is also available as a &lt;br /&gt;fixed, variable, or string instruction OUTSB or OUTSW. The fixed port instruction uses an &lt;br /&gt;8-bit I/O port address, while the variable and string I/O instructions use a 16-bit port number &lt;br /&gt;found in the DX register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Isolated I/O, sometimes called direct I/O, uses a separate map for the I/O space, freeing the &lt;br /&gt;entire memory for use by the program. Isolated I/O uses the IN and OUT instructions to &lt;br /&gt;transfer data between the I/O device and the microprocessor. The control structure of the I/O &lt;br /&gt;map uses lORe (I/O read control) and lowe (I/O write control) plus the bank selection sig-&lt;br /&gt;nals BHE and BLE (AO on the 8086 and 80286) to effect the I/O transfer. The early &lt;br /&gt;8086/8088 microprocessors use the MilO (101M) signal with RD and WR to generate the &lt;br /&gt;I/O control signals. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Memory-mapped I/O uses a portion of the memory space for I/O transfers. This reduces the &lt;br /&gt;amount of memory available, but it negates the need to use the lORe and lowe signals for &lt;br /&gt;I/O transfers. In addition, any instruction that addresses a memory location using any ad-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. dressing mode can be used to transfer data between the microprocessor and the I/O device &lt;br /&gt;using memory-mapped I/O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. All input devices are buffered so the I/O data are only connected to the data bus during the &lt;br /&gt;execution of the IN instruction. The buffer is either built into a programmable peripheral or &lt;br /&gt;located separately. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. All output devices use a latch to capture output data during the execution of the OUT in-&lt;br /&gt;struction. This is necessary because data appear on the data bus for less than 100 ns for an &lt;br /&gt;OUT instruction, and most output devices require the data for a longer time. In many cases, &lt;br /&gt;the latch is built into the peripheral. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Handshaking or pollinr is the act of two independent devices synchronizing with a few con-&lt;br /&gt;trollines. For example, the computer asks a printer if it is busy by inputting the BUSY signal &lt;br /&gt;from the printer. If it isn't busy, the computer outputs data to the printer and informs the &lt;br /&gt;printer that data are available with a data strobe (DS) signal. This communication between &lt;br /&gt;the computer and the printer is called a handshake or a poll. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10-9 QUESTIONS AND PROBLEMS 427 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. The 1/0 port number appears on address bus connections A7-AO for a fixed port I/O instruc-&lt;br /&gt;tion and on A,s-Ao for a variable port I/O instruction (note that A,s-Ag contain zeros for an &lt;br /&gt;8-bti port). In both cases, address bits above A,s are undefined. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Because the 8086/80286/80386SX contain a 16-bit data bus and the I/O addresses reference &lt;br /&gt;byte-sized I/O locations, the I/O space is also organized' n banks, as is the memory system. &lt;br /&gt;In order to interface an 8-bit I/O device to the 16-bit data bus, we often require separate &lt;br /&gt;write strobes, an upper and a lower, for I/O write operations. Likewise, the 80486 and Pen-&lt;br /&gt;tiumlPentium Pro also have I/O arranged in banks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The I/O port decoder is much like the memory address decoder except that instead of de-&lt;br /&gt;coding the entire address, the I/O pon decoder decodes only a 16-bit address for variable &lt;br /&gt;port instructions and often an 8-bit port number for fixed I/O instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The 82C55 is a programmable peripheral interface (PIA) that has 24 I/O pins that are pro-&lt;br /&gt;grammable in two groups of 12 pins each (group A and group B). The 82C55 operates in &lt;br /&gt;three modes: simple I/O (mode 0), strobed I/O (mode 1), and bi-directional I/O (mode 2). &lt;br /&gt;When the 82C55 is interfaced to the 8086 operating at 8 MHz, we insert two wait states be-&lt;br /&gt;cause the speed of the microprocessor is faster than the 82C55 can handle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. The 8279 is a programmable keyboard/display controller that can control a 64-key keyboard &lt;br /&gt;and a 16-digit numeric display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The 8254 is a programmable interval timer that contains three 16-bit counters that count in &lt;br /&gt;binary or binary-coded decimal (BCD). Each counter is independent of each other, and op-&lt;br /&gt;erates in six different modes. The six modes of the counter are (1) events counter, (2) retrig-&lt;br /&gt;gerable monostable multi vibrator, (3) pulse generator, (4) square-wave generator, (5) software-&lt;br /&gt;triggered pulse generator, and (6) hardware-triggered pulse generator. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. The 16550 is a programmable communications interface capable of receiving and transmit-&lt;br /&gt;ting asynchronous serial data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The DAC0830 is an 8-bit digital-to-analog converter that converts a digital signal to an &lt;br /&gt;analog voltage within Ills. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. The ADC0804 is an 8-bit analog-to-digital converter that converts an analog signal into a &lt;br /&gt;digital signal within 100 Ils. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. Explain which way the data flow for an IN and an OUT instruction. &lt;br /&gt;2. Where is the I/O port number stored for a fixed I/O instruction? &lt;br /&gt;3. Where is the I/O port number stored for a variable I/O instruction? &lt;br /&gt;4. Where is the I/O port number stored for a string I/O instruction? &lt;br /&gt;5. To which register are data input by the 16-bit IN instruction? &lt;br /&gt;6. Describe the operation of the OUTSB instruction. &lt;br /&gt;7. Describe the operation of the INSW instruction. &lt;br /&gt;8. Contrast a memory-mapped I/O system with an isolated I/O system. &lt;br /&gt;9. What is the basic input interface? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. What is the basic output interface? &lt;br /&gt;11. Explain the term handshaking as it applies to computer I/O systems. &lt;br /&gt;12. An even-numbered I/O port address is found in the I/O bank in the 8086 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessor. &lt;br /&gt;13. Show the circuitry required to generate the upper and lower I/O write strobes. &lt;br /&gt;14. Develop an I/O port decoder, using a 74ALS 138. that generates low-bank I/O strobes for the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bit I/O port addresses lOH, 12H, 14H, 16H, 18H, lAH, 1CH, and 1EH. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;428 CHAPTER 10 BASIC liD INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. D.evelop an I/O port decoder. using a 74ALS138, that generates high-bank I/O strobes for &lt;br /&gt;the 8-bit I/O port addresses IlH, 13H, 15H, 17H, 19H, 1 BH, IDH, and I FH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. Develop an I/O port decoder, using a PALl6L8, that generates l6-bit I/O strobes for the 16-&lt;br /&gt;bit I/O port addresses lOOOH-lOOlH, lO02H-1003H, lO04H-1005H, lO06H-1007H, &lt;br /&gt;lO08H-1009H, lOOAH-lOOBH, lOOCH-lOODH, and lOOEH-lOOFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. Develop an I/O port decoder, using the PALl6L8, that generates the following low-bank I/O &lt;br /&gt;strobes: 00A8H, 00B6H, and OOEEH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. Develop an I/O port decoder, using the PALI6L8, that generates the following high-bank &lt;br /&gt;I/O strobes: 300DH, 300BH, lO05H, and lO07H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. Why are both BHE and BLE (AO) ignored in a 16-bit port address decoder? &lt;br /&gt;20. An 8-bit I/O device, located at I/O port address OOlOH, is connected to which data bus con-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;nections? &lt;br /&gt;21. An 8-bit I/O device, located at I/O port address 100DH, is connected to which data bus con-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;nections? &lt;br /&gt;22. The 82C55 has how many programmable I/O pin connections? &lt;br /&gt;23. List the pins that belong to group A and to group B in the 82C55. &lt;br /&gt;24. What two 82C55 pins accomplish internal I/O port address selection? &lt;br /&gt;25. The RD connection on the 82C55 is attached to which 8086 system control bus connection? &lt;br /&gt;26. Using a PAL16L8, interface an 82C55 to the 8086 microprocessor so that it functions at I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;locations 0380H, 0382H, 0384H and 0386H. &lt;br /&gt;27. When the 82C55 is reset, its I/O ports are all initialized as ______ , &lt;br /&gt;28. What three modes of operation are available to the 82C55? &lt;br /&gt;29. What is the purpose of the STB signal in strobed input operation of the 82C55? &lt;br /&gt;30. Explain the operation of a simple four-coil stepper motor. &lt;br /&gt;31. What sets the IBF pin in strobed input operation of the 82C55? &lt;br /&gt;32. Write the software required to place a logic I on the PC7 pin of the 82C55 during strobed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;input operation. &lt;br /&gt;33. How is the interrupt request pin (INTR) enabled in the strobed input mode of operation of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the 82C55? &lt;br /&gt;34. In strobed output operation of the 82C55, what is the purpose of the ACK signal? &lt;br /&gt;35. What clears the OBF signal in strobed output operation of the 82C55? &lt;br /&gt;36. Write the software required to decide if PC4 is a logic I wheI). the 82C55 is operated in the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;strobed output mode. &lt;br /&gt;37. Which group of pins is used during bi-directional operation of the 82C55? &lt;br /&gt;38. What pins are general-purpose I/O pins during mode 2 operation of the 82C55? &lt;br /&gt;39. What changes must be made to Figure 10-19 so it functions with a keyboard matrix that &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;contains three rows and five columns? &lt;br /&gt;40. What time is usually used to de-bounce a keyboard? &lt;br /&gt;41. What is normally connected to the CLK pin of the 8279? &lt;br /&gt;42. How many wait states are required to interface the 8279 to the 8086 microprocessor oper-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ating with an 8 MHz clock? &lt;br /&gt;43. If the 8279 CLK pin is connected to a 3.0 MHz clock, program the internal clock. &lt;br /&gt;44. What is an overrun error in the 8279? &lt;br /&gt;45. What is the difference between encoded and decoded as defined for the 8279? &lt;br /&gt;46. Interface the 8279 so that it functions at 8-bit I/O ports 40H-7FH. Use the 74ALSI38 as a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;decoder and use either the upper or lower data bus. &lt;br /&gt;47. Interface a 16-key keyboard and an 8-digit numeric display to the 8279. &lt;br /&gt;48. The 8254 interval timer functions from DC to Hz. &lt;br /&gt;49. Each counter in the 8254 functions in how many different modes? &lt;br /&gt;50. Interface an 8254 to function at I/O port addresses XXlOH, XXI2H, XXI4H, and XXI6H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Write the software required to cause counter 2 to generate an 80 KHz square-wave if the &lt;br /&gt;CLK input to counter 2 is 8 MHz. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;10-9 QUESTIONS AND PROBLEMS 429 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;51. What number is programmed in an 8254 counter to count 300 events? &lt;br /&gt;52. If a 16-bit count is programmed into the 8254, which byte of the count is programmed first? &lt;br /&gt;53. Explain how the read-back control word functions in the 8254. &lt;br /&gt;54. Program counter 1 of the 8254 so it generates a continuous series of pulses that have a high &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;time of 100 IJ.s and low time of 1 IJ.s. Make sure to indicate the CLK h'quency required to &lt;br /&gt;accomplish this task. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;55. Why does a 50 percent duty cycle cause the motor to stand still in the motor speed and di-&lt;br /&gt;rection control circuit presented in this chapter? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;56. What is asynchronous serial data? &lt;br /&gt;57. What is Baud rate? &lt;br /&gt;58. Program the 16550 for operation using six data bits, even parity, one stop bit, and a Baud &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rate of 19,200 using a 18.432 MHz clock. (Assume that the I/O ports are numbered 20H and &lt;br /&gt;22H.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;59. If the 16550 is to generate a serial signal at a Baud rate of 2400 Baud, and the Baud rate di-&lt;br /&gt;visor is programmed for 16, what is the frequency of the signal? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;60. Describe the following terms: simplex, half-duplex, and lull-duplex. &lt;br /&gt;61. How is the 16550 reset? &lt;br /&gt;62. Write a procedure for the 16550 that transmits 16 bytes from a small buffer in the data seg-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ment (DS is loaded externally) address by SI (SI is loaded externally). &lt;br /&gt;63. The DAC0830 converts an 8-bit digital input to an analog output in approximately &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64. What is the step voltage at the output of the DAC0830 if the reference voltage is -2.55 V? &lt;br /&gt;65. Interface a DAC0830 to the 8086 so it operates at I/O port 400H. &lt;br /&gt;66. Develop a program for the interface of Question 65 so the DAC0830 generates a triangular &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;voltage wave-form. The frequency of this wave-form must be approximately 100 Hz. &lt;br /&gt;67. The ADC0804 requires approximately to convert an analog voltage into a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;digital code. &lt;br /&gt;68. What is the purpose of the INTR pin on the ADC080X? &lt;br /&gt;69. The WR pin on the ADC0804 is used for what purpose? &lt;br /&gt;70. Interface an ADC0804 at I/O port 0260H for data and 0270H to test the INTR pin. &lt;br /&gt;71. Develop a program for the ADC0804 in Question 70 so that it reads an input voltage once &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;per 100 ms and stores the results in a memory array that is lOOH bytes in length. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;430 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 11 &lt;br /&gt;Interrupts &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this chapter, we expand our coverage of basic I/O and programmable peripheral interfaces by &lt;br /&gt;examining a technique called interrupt-processed I/O. An interrupt is a hardware-initialed pro-&lt;br /&gt;cedure that interrupts whatever program is currently executing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This chapter provides examples and a detailed explanation of the interrupt structure of the &lt;br /&gt;entire Intel family of microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Explain the interrupt structure of the Intel family of microprocessors. &lt;br /&gt;2. Explain the operation of software interrupt instructions INT, INTO, INT 3, and BOUND. &lt;br /&gt;3. Explain how the interrupt enable flag bit (IF) modifies the interrupt structure. &lt;br /&gt;4. Describe the function of the trap interrupt flag bit (TF) and the operation of trap-generated &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tracing. &lt;br /&gt;5. Develop interrupt service procedures that control lower speed external peripheral devices. &lt;br /&gt;6. Expand the interrupt structure of the microprocessor using the 8259A programmable inter-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. rupt controller and other techniques. &lt;br /&gt;7. Explain the purpose and operation of a real-time clock. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BASIC INTERRUPT PROCESSING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this section, we discuss the function of an interrupt in a microprocessor-based system and the &lt;br /&gt;structure and features of interrupts available to the Intel family of microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Purpose of Interrupts &lt;br /&gt;Interrupts are particularly useful when interfacing I/O devices that provide or require data at rel-&lt;br /&gt;atively low data transfer rates. In Chapter 10, for instance, we saw a keyboard example using &lt;br /&gt;strobed input operation of the 82C55. In that example, software polled the 82C55 and its IBF bit &lt;br /&gt;to decide if data were available from the keyboard. If the person using the keyboard typed one &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-1 BASIC INTERRUPT PROCESSING 431 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-1 A time line &lt;br /&gt;that indicates interrupt usage &lt;br /&gt;in a typical system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Keyboard interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;Printer interrupt Keyboard interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;Mo'&amp;quot; progmm ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;Printer interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;character per second, the software for the 82C55 waited an entire second between each keystroke &lt;br /&gt;for the person to type another key. This process is such a tremendous waste of time that de-&lt;br /&gt;signers have developed another process called interrupt processing to handle this situation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unlike the polling technique, interrupt processing allows the microprocessor to execute &lt;br /&gt;other software while the keyboard operator is thinking about what key to type next. As SOOI1 as a &lt;br /&gt;key is pressed, the keyboard encoder de-bounces the switch and puts out one pulse that interrupts &lt;br /&gt;the microprocessor. In this way, the microprocessor executes other software until the key is ac-&lt;br /&gt;tually pressed when it reads a key and returns to the program that was interrupted. As a result, the &lt;br /&gt;microprocessor can print reports or complete any other task while the operator is typing a docu-&lt;br /&gt;ment and thinking about what to type next. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 11-1 shows a time line that indicates a typist typing data on a keyboard, a printer &lt;br /&gt;removing data from the memory, and a program executing. The program is the main program &lt;br /&gt;that is interrupted for each keystroke and each character that is to print on the printer. Note that &lt;br /&gt;the keyboard interrupt service procedure, called by the keyboard interrupt, and the printer inter-&lt;br /&gt;rupt service procedure each take little time to execute. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupts &lt;br /&gt;The interrupts of the entire Intel family of microprocessors include two hardware pins that re-&lt;br /&gt;quest interrupts (INTR and NMI) and one hardware pin (INT A) that acknowledges the interrupt &lt;br /&gt;requested through INTR. In addition to the pins, the microprocessor also has software interrupts &lt;br /&gt;INT, INTO, INT 3, and BOUND. Two flag bits, IF (interrupt flag) and TF (trap flag), are also &lt;br /&gt;used with the interrupt structure and a special return instruction IRET (or IRETD in the 80386, &lt;br /&gt;80486, or Pentium/pentium Pro). &lt;br /&gt;Interrupt Vectors. The interrupt vectors and vector table are crucial to an understanding of hard-&lt;br /&gt;ware and software interrupts. The interrupt vector table is located in the first 1,024 bytes of &lt;br /&gt;memory at addresses 000000H-0003FFH. It contains 256 different 4-byte interrupt vectors. An &lt;br /&gt;interrupt vector contains the address (segment and offset) of the interrupt service procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 11-2 illustrates the interrupt vector table for the microprocessor. The first five in-&lt;br /&gt;terrupt vectors are identical in all Intel microprocessor family members from the 8086 to the &lt;br /&gt;Pentium. Other interrupt vectors exist for the 80286 that are upward compatible to the 80386, &lt;br /&gt;80486 and Pentium/pentium Pro, but not downward compatible to the 8086 or 8088. Intel re-&lt;br /&gt;serves the first 32 interrupt vectors for their use in various microprocessor family members. The &lt;br /&gt;last 224 vectors are available as user interrupt vectors. Each vector is four bytes long and con-&lt;br /&gt;tains the starting address of the interrupt service procedure. The first two bytes of the vector &lt;br /&gt;contain the offset address, and the last two bytes contain the segment address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The following list describes the function of each dedicated interrupt in the microprocessor: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Divide Error-Occurs whenever the result of a division overflows or whenever &lt;br /&gt;an attempt is made to divide by zero. &lt;br /&gt;Single-Step or Trap-Occurs after the execution of each instruction if the trap &lt;br /&gt;(TF) flag bit is set. Upon accepting this interrupt, the TF-bit is cleared'so that the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;432 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-2 (a) The &lt;br /&gt;interrupt vector table for the &lt;br /&gt;microprocessor, and (b) the &lt;br /&gt;contents of an interrupt vector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 32 - 255 &lt;br /&gt;User interrupt vectors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;080H 1---------1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;040H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;038H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;034H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;030H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;028H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;024H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;020H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;018H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;014H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;008H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 14 - 31 &lt;br /&gt;Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 16 &lt;br /&gt;Coprocessor error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 15 &lt;br /&gt;Unassigned &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 14 &lt;br /&gt;Page fault &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 13 &lt;br /&gt;General protection &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 12 &lt;br /&gt;Stack segment overrun &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 11 &lt;br /&gt;Segment not present &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Invalid task state segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 9 &lt;br /&gt;Coprocessor segment overrun &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 8 &lt;br /&gt;Double fault &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type? &lt;br /&gt;Coprocessor not available &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 6 &lt;br /&gt;Undefined opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 5 &lt;br /&gt;BOUND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 4 &lt;br /&gt;Overflow (INTO) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 3 &lt;br /&gt;1-byte breakpoint &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 2 &lt;br /&gt;NMI pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 1 &lt;br /&gt;Single-step &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 0 &lt;br /&gt;Divide error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Any interrupt vector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 Segment (high) &lt;br /&gt;2 Segment (low) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset (high) &lt;br /&gt;0 Offset (low) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;inteITupt service procedure executes at full speed. More detail is provided about &lt;br /&gt;this interrupt later in this section of the chapter. &lt;br /&gt;Non-maskable Hardware Interrupt-A result of placing a logic 1 on the NMI &lt;br /&gt;input pin to the microprocessor. This input is non-maskable, which means that it &lt;br /&gt;cannot be disabled. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-1 BASIC INTERRUPT PROCESSING 433 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TypeS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TypeS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;One-Byte Interrupt-A special I-byte instruction (INT 3) that uses this vector to &lt;br /&gt;access its interrupt service procedure. The INT 3 instruction is often used to store &lt;br /&gt;a breakpoint in a program for debugging. &lt;br /&gt;Overflow-A special vector used with the INTO instruction. The INTO instruc-&lt;br /&gt;tion interrupts the program if an overflow condition exists, as reflected by the &lt;br /&gt;overflow flag (OF). &lt;br /&gt;BOUND-An instruction that compares a register with boundaries stored in the &lt;br /&gt;memory. If the contents of the register is greater than or equal to the first word in &lt;br /&gt;memory and less than or equal to the second word, no interrupt occurs because &lt;br /&gt;the contents of the register is within bounds. If [he contents of the register is out &lt;br /&gt;of bounds, a type 5 interrupt ensues. &lt;br /&gt;Invalid Opcode-Occurs whenever an undefined opcode is encountered in a &lt;br /&gt;program. &lt;br /&gt;Coprocessor Not Available-Occurs when a coprocessor is not found in the &lt;br /&gt;system, as dictated by the machine status word (MSW) coprocessor control bits. &lt;br /&gt;If an ESC or WAIT instruction executes and the coprocessor is not found, a type &lt;br /&gt;7 exception or interrupt occurs. &lt;br /&gt;Double Fault-Activated whenever two separate interrupts occur during the &lt;br /&gt;same instruction. &lt;br /&gt;Coprocessor Segment Overrun-Occurs if the ESC instruction (coprocessor &lt;br /&gt;opcode) memory operand extends beyond offset address FFFFH. &lt;br /&gt;Invalid Task State Segment-Occurs if the TSS is invalid because the segment &lt;br /&gt;limit field is not 002BH or higher. In most cases this is caused because the TSS &lt;br /&gt;is not initialized. &lt;br /&gt;Segment Not Present-Occurs when the P-bit (P = 0) in a descriptor indicates &lt;br /&gt;that the segment is not present or not valid. &lt;br /&gt;Stack Segment Overrun-Occurs if the stack segment is not present (P = 0) or if &lt;br /&gt;the limit of the stack segment is exceeded. &lt;br /&gt;General Protection-Occurs for most protection violation in the 80286-Pentium &lt;br /&gt;Pro protected mode system. (These errors occur in Windows as general protec-&lt;br /&gt;tion/aults). A list of these protection violations follows: &lt;br /&gt;a. Descriptor table limit exceeded &lt;br /&gt;b. Privilege rules violated &lt;br /&gt;c. Invalid descriptor segment type loaded &lt;br /&gt;d. Write to code segment that is protected &lt;br /&gt;e. Read from execute-only code segment &lt;br /&gt;f. Write to read-only data segment &lt;br /&gt;g. Segment limit exceeded &lt;br /&gt;h. CPL = IOPL when executing CTS, HLT, LGDT, LIDT, LLDT, LMSW, or LTR &lt;br /&gt;i. CPL&amp;gt; IOPL when executing CLI, IN, INS, LOCK, OUT, OUTS, and STI .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page Fault-Occurs for any page fault memory or code access in the 80386, &lt;br /&gt;80486, and Pentium/pentium Pro microprocessors. &lt;br /&gt;Coprocessor Error-Takes effect whenever a coprocessor error (ERROR = 0) &lt;br /&gt;occurs for the ESCape or WAIT instructions for the 80386, 80486, and &lt;br /&gt;Pentium/pentium Pro microprocessors only. &lt;br /&gt;Alignment Check-Indicates that word, doubleword data are addressed at an odd &lt;br /&gt;memory location, or incorrect location in the case of a double word. This &lt;br /&gt;inten'upt is active in the 80486 and Pentium/pentium Pro microprocessors. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;434 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type 18 Machine Check-Activates a system memory management mode interrupt in the &lt;br /&gt;Pentium and Pentium Pro microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Instructions: BOUND, INTO, INT, INT 3, and IRET &lt;br /&gt;Of the five software interrupt instructions available to the microprocessor, INT and INT 3 are very &lt;br /&gt;similar, BOUND and INTO are conditional, and IRET is a special interrupt return instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The BOUND instruction, which has two operands, compares a register with two words of &lt;br /&gt;memory data. For example, if the instruction BOUND AX,DAT A is executed, AX is compared &lt;br /&gt;with the contents of DATA and DATA+I and also with DATA+2 and DATA+3. If AX is less &lt;br /&gt;than the contents of DATA and DATA+I, a type 5 interrupt occurs. If AX is greater than &lt;br /&gt;DATA+2 and DATA+3, a type 5 interrupt occurs. If AX is within the bounds of these two &lt;br /&gt;memory words, no interrupt occurs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The INTO instruction checks the overflow flag (OF). If OF = 1, the INTO instruction calls &lt;br /&gt;the procedure whose address is stored in interrupt vector type number 4. If OF = 0, then the INTO &lt;br /&gt;instruction performs no operation and the next sequential instruction in the program executes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The INT n instruction calls the interrupt service procedure that begins at the address repre-&lt;br /&gt;sented in vector number n. For example, an INT 80H or INT 128 call the interrupt service proce-&lt;br /&gt;dure whose address is stored in vector type number 80H (000200H-00203H). To determine the &lt;br /&gt;vector address, just multiply the vector type number (n) by 4. This gi ves the beginning address of &lt;br /&gt;the 4-byte long interrupt vector. For example, an INT 5 = 4 x 5 or 20 (l4H). The vector for INT &lt;br /&gt;5 begins at address 0000I4H and continues to 0000l7H. Each INT instruction is stored in two &lt;br /&gt;bytes of memory with the first byte containing the opcode and the second the interrupt type &lt;br /&gt;number. The only exception to this is the INT 3 instruction, a I-byte instruction. The INT 3 in-&lt;br /&gt;struction is often used as a breakpoint interrupt because it is easy to insert a I-byte instruction &lt;br /&gt;into a program. Breakpoints are often used to debug faulty software. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The IRET instruction is a special return instruction used to return for both software and &lt;br /&gt;hardware interrupts. The IRET instruction is much like a normal far RET, because it retrieves the &lt;br /&gt;return address from the stack. It is unlike the normal return because it also retrieves a copy of the &lt;br /&gt;flag register from the stack. An IRET instruction removes six bytes from the stack: two for the &lt;br /&gt;IP, two for the CS, and two for the flags. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80386-Pentium Pro, there is also an IRETD instruction because these microproces-&lt;br /&gt;sors can push the EFLAG register (32-bits) on the stack as well as the 32-bit EIP in the protected &lt;br /&gt;mode. If operated in the real mode, we use the lRET instruction with the 80386-Pentium Prof &lt;br /&gt;80486 microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Operation of a Real Mode Interrupt &lt;br /&gt;When the microprocessor completes executing the current instruction, it determines whether an &lt;br /&gt;interrupt is active by checking (1) instruction executions, (2) single-step, (3) NMI, (4) co-&lt;br /&gt;processor segment overrun, (5) INTR, and (6) INT instruction in the order presented. If one or &lt;br /&gt;more of these interrupt conditions are present, the following sequence of events occurs: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The contents of the flag register are pushed onto the stack. &lt;br /&gt;2. Both the interrupt (IF) and trap (TF) flags are cleared. This disables the INTR pin and also the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;trap or single-step feature. &lt;br /&gt;3. The contents of the code segment register (CS) are pushed onto the stack. &lt;br /&gt;4. The contents of the instruction pointer (IP) are pushed onto the stack. &lt;br /&gt;5. The interrupt vector contents are fetched and placed into both IP and CS so that the next in-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;struction executes at the interrupt service procedure addressed by the vector. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever an interrupt is accepted, the microprocessor stacks the contents of the flag reg-&lt;br /&gt;ister, CS and IP; clears both IF and TF; and jumps to the procedure addressed by the interrupt &lt;br /&gt;vector. After the flags are pushed onto the stack, IF and TF are cleared. These flags are returned &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-1 BASIC INTERRUPT PROCESSING 435 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to the state prior to the interrupt when the IRET instruction is encountered at the end of the in-&lt;br /&gt;terrupt service procedure. Therefore, if interrupts were enabled prior to the interrupt service pro-&lt;br /&gt;cedure, they are automatically re-enabled by the IRET instruction at the end of the procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The return address (in CS and IP) is pushed onto the stack during the interrupt. Sometimes &lt;br /&gt;the r'.turn address points to the next instruction in the program, and sometimes it points to the in-&lt;br /&gt;struction or point in the program where the interrupt occurred. Interrupt type numbers 0, 5, 6, 7, &lt;br /&gt;8, 10, 11, 12, and 13 push a return address that points to the offending instruction, instead of the &lt;br /&gt;next instruction in the program. This allows the interrupt service procedurc to possibly retry the &lt;br /&gt;instruction in certain error cases. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Some of the protected mode interrupts (types 8, 10, 11, 12, and 13) place an error code on &lt;br /&gt;the stack following the return address. The error code identifies the selector that caused the in-&lt;br /&gt;terrupt. In cases where no selector is involved, the error code is a O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation of a Protected Mode Interrupt &lt;br /&gt;In the protected mode, interrupts have exactly the same assignments as in real mode, but the in-&lt;br /&gt;terrupt vector table is different. In place of interrupt vectors, protected mode uses a set of 256 in-&lt;br /&gt;terrupt descriptors stored in an interrupt descriptor table (IDT). The interrupt descriptor table is &lt;br /&gt;256 x 8 (2K) bytes long with each descriptor containing eight bytes. The interrupt descriptor &lt;br /&gt;table is located at any memory location in the system by the interrupt descriptor table address &lt;br /&gt;register (IDTR). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each entry in the IDT contains the address of the interrupt service procedure in the form of &lt;br /&gt;a segment selector and a 32-bit offset address. It also contains the P-bit (present) and DPL-bits &lt;br /&gt;to describe the privilege level of the interrupt. Figure 11-3 shows the contents of the interrupt &lt;br /&gt;descriptor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Real mode interrupt vectors can be converted into protected mode interrupts by copying &lt;br /&gt;the intemlpt procedure addresses from the interrupt vector table and converting them to 32-bit &lt;br /&gt;offset addresses that are stored in the interrupt descriptors. A single selector and segment de-&lt;br /&gt;scriptor can be placed in the global descriptor table that identifies the first 1M byte of memory as &lt;br /&gt;the interrupt segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Other than the IDT and interrupt descriptors, the protected mode interrupt functions like &lt;br /&gt;the real mode intemlpt. We return from both interrupts using the IRET or IRETD instruction. &lt;br /&gt;The only difference is that in protected mode the microprocessor accesses the IDT instead of the &lt;br /&gt;interrupt vector table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Flag Bits &lt;br /&gt;The interrupt flag (IF) and the trap flag (TF) are both cleared after the contents of the flag reg-&lt;br /&gt;ister are stacked during an interrupt. Figure 11-4 illustrates the contents of the flag register and &lt;br /&gt;the location of IF and TF. When the IF-bit is set, it allows the INTR pin to cause an interrupt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-3 The pro-&lt;br /&gt;tected mode interrupt &lt;br /&gt;descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P &lt;br /&gt;Â· &lt;br /&gt;Â· &lt;br /&gt;Â· DtL o 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset (A31-A16) ( 6 &lt;br /&gt;110 o 0 H \\ 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment selector 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset (A 1S-AO) o &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;436 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-4 The 80286 &lt;br /&gt;flag register (Courtesy of Intel &lt;br /&gt;Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;when the IF-bit is cleared, it prevents the INTR pin from causing an interrupt. When TF = 1, it &lt;br /&gt;causes a trap interrupt (type number 1) to occur after each instruction executes. This is why we &lt;br /&gt;often call trap a si1lgle-step. When TF = 0, normal program execution occurs. This flag bit allows &lt;br /&gt;debugging, as explained in later chapters that detail the 808386-Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt flag is set and cleared by the STI and CLI instructions respectively. There are &lt;br /&gt;no special instructions that set or clear the trap flag. Example 11-1 shows an interrupt service &lt;br /&gt;procedure that turns tracing on by setting the trap flag bit on the stack from inside the procedure. &lt;br /&gt;Example 11-2 shows an interrupt service procedure that turns tracing off by clearing the trap &lt;br /&gt;flag on the stack from within the procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-1 &lt;br /&gt;;A procedure that sets TF to enable trap. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 TRON PROe NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 PUSH AX ;save registers &lt;br /&gt;0001 55 PUSH BP &lt;br /&gt;0002 8B EC MOV BP,SP ;get SP &lt;br /&gt;0004 8B 46 08 MOV AX, [BP+8] ;get flags from stack &lt;br /&gt;0007 80 CC 01 OR AH,l ;set TF &lt;br /&gt;OOOA 89 46 08 MOV [BP+8] ,AX ;save flags &lt;br /&gt;OOOD 5D POP BP ;restore registers &lt;br /&gt;OOOE 58 POP AX &lt;br /&gt;OOOF CF IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 TRON ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-2 &lt;br /&gt;;A procedure that clears TF to disable trap. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 TROFF PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 PUSH AX isave registers &lt;br /&gt;0001 55 PUSH BP &lt;br /&gt;0002 8B EC MOV BP,SP ;get SP &lt;br /&gt;0004 8B 46 08 MOV AX, [BP+8] ;get TF &lt;br /&gt;0007 80 E4 FE AND AH,OFEH ;clear TF &lt;br /&gt;OOOA 89 46 08 MOV [BP+8] ,AX ;save flags &lt;br /&gt;OOOD 5D POP BP ;restore registers &lt;br /&gt;OOOE 58 POP AX &lt;br /&gt;OOOF CF IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 TROFF ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In both examples, the flag register is retrieved from the stack by using the BP register, &lt;br /&gt;which by default addresses the stack segment. After the flags are retrieved, the TF-bit is either &lt;br /&gt;set (TRON) or clears (TROFF) before returning from the interrupt service procedure. The IRET &lt;br /&gt;instruction restores the flag register with the new state of the trap flag. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Trace Procedure. Assuming that TRON is accessed by an INT 40H instruction and TROFF is &lt;br /&gt;accessed by an INT 41H instruction, Example 11-3 traces through a program immediately fol-&lt;br /&gt;lowing the INT 40H instruction. The interrupt service procedure illustrated in Example 11-3 re-&lt;br /&gt;sponds to interrupt type number 1 or a trap interrupt. Each time that this occurs-after each &lt;br /&gt;instruction executes folJowing INT 40H-the TRACE procedure displays the contents of all the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-1 BASIC INTERRUPT PROCESSING 437 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-bit microprocessor registers on the CRT screen. This provides a register trace of all the in-&lt;br /&gt;structions between the INT 40H (TRON) and INT 41H (TROFF). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-3 &lt;br /&gt;.MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 .CODE &lt;br /&gt;0000 41 58 20 3D 20 42 RNAME DB 'AX , 'BX , 'cx &amp;quot; 'DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;58 20 3D 20 43 58 &lt;br /&gt;20 3D 20 44 58 20 &lt;br /&gt;3D 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 53 50 20 3D 20 42 DB 'SP &amp;quot; 'BP , 'SI &amp;quot; 'D1 &lt;br /&gt;50 20 3D 20 53 49 &lt;br /&gt;0 3D 20 44 49 20 &lt;br /&gt;3D 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0028 49 50 20 3D 20 46 DB 'IP , 'FL , 'CS &amp;quot; 'DS &lt;br /&gt;4C 20 3D 20 43 53 &lt;br /&gt;20 3D 20 44 53 20 &lt;br /&gt;3D 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003C 45 53 20 3D 20 53 DB 'ES , 'SS &lt;br /&gt;53 20 3D 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP M.A.CRO PARi &lt;br /&gt;PUSH AX &lt;br /&gt;PUSH DX &lt;br /&gt;MOV DL,PARl &lt;br /&gt;NOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;POP DX &lt;br /&gt;POP AX &lt;br /&gt;ENDN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CRLF l1ACRO &lt;br /&gt;D1SP 13 &lt;br /&gt;DISP 10 &lt;br /&gt;ENDN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0046 TRACE PROC FAR USES AX BP BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0049 BB 0000 R NOV BX,OFFSET RNAME ;address names &lt;br /&gt;CRLF &lt;br /&gt;0060 E8 004D CALL DREG ;display AX &lt;br /&gt;0063 58 POP AX ;get BX &lt;br /&gt;0064 50 PUSH AX &lt;br /&gt;0065 E8 0048 CALL DREG ;display BX &lt;br /&gt;0068 8B Cl MOV AX,CX &lt;br /&gt;006A E8 0043 CALL DREG ;display CX &lt;br /&gt;006D 8B C2 NOV AX,DX &lt;br /&gt;006F E8 003E CALL DREG ; display DX &lt;br /&gt;0072 8B C4 NOV AX,SP &lt;br /&gt;0074 83 CO OC ADD AX,12 &lt;br /&gt;0077 E8 0036 CALL DREG ;display SP &lt;br /&gt;007A 8B C5 NOV AX,BP &lt;br /&gt;007C E8 0031 CALL DREG ;display BP &lt;br /&gt;007F 8B C6 NOV AX,SI &lt;br /&gt;0081 E8 002C CALL DREG ;display S1 &lt;br /&gt;0084 8B C7 HOV AX,DI &lt;br /&gt;0086 E8 0027 CALL DREG ;display DI &lt;br /&gt;0089 8B EC t-!OV BP,SP &lt;br /&gt;008B 8B 46 06 NOV AX, [BP+6] &lt;br /&gt;008E E8 001F CALL DREG ;display IP &lt;br /&gt;0091 8B 46 OA NOV AX, [BP+10] &lt;br /&gt;0094 E8 0019 c.:'.LL DREG ;display Flags &lt;br /&gt;0097 8B 46 08 EOV AX, [BP+8] &lt;br /&gt;G09A E8 0013 c.:'.LL DREG ;display CX &lt;br /&gt;009D 8C D8 NOV AX,DS &lt;br /&gt;009F E8 OOOE C.o,LL DREG ;display DS &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;438 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00A2 8C CO &lt;br /&gt;OOM E8 0009 &lt;br /&gt;00A7 8C DO &lt;br /&gt;00A9 E8 0004 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOBO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOBO &lt;br /&gt;00B1 B9 0005 &lt;br /&gt;00B4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOBF 43 &lt;br /&gt;OOCO E2 F2 &lt;br /&gt;00C2 B9 0004 &lt;br /&gt;OOCS &lt;br /&gt;OOCS D3 C8 &lt;br /&gt;00C7 D3 C8 &lt;br /&gt;00C9 D3 C8 &lt;br /&gt;OOCB D3 C8 &lt;br /&gt;OOCD 50 &lt;br /&gt;OOCE 24 OF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00D4 04 07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00D6 04 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00E2 58 &lt;br /&gt;00E3 E2 EO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00F1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DREG1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DREG2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DREG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DREG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,ES &lt;br /&gt;CALL DREG &lt;br /&gt;MOV AX,SS &lt;br /&gt;CALL DREG &lt;br /&gt;IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC NEAR USES &lt;br /&gt;MOV CX,S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP CS: [BX] &lt;br /&gt;INC BX &lt;br /&gt;LOOP DREG1 &lt;br /&gt;MOV CX,4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL AX,l &lt;br /&gt;ROL AX,l &lt;br /&gt;ROL AX,l &lt;br /&gt;ROL AX,l &lt;br /&gt;PUSH AX &lt;br /&gt;AND AL,OFH &lt;br /&gt;.IF AL &amp;gt; 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;ADD AL,30H &lt;br /&gt;DISP AL &lt;br /&gt;POP AX &lt;br /&gt;LOOP DREG2 &lt;br /&gt;DISP &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display SS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;load count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display character &lt;br /&gt;;address next &lt;br /&gt;;repeat 5 times &lt;br /&gt;;load count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;position digit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;convert to ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;repeat 4 times &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Storing an Interrupt Vector in the Vector Table &lt;br /&gt;In order to install an interrupt vector-sometimes called a hook-the assembler must address ab-&lt;br /&gt;solute memory. Example 11-4 shows how a new vector is added to the interrupt vector table by &lt;br /&gt;using the assembler and a DOS function call. Here INT 21H function call number 25H initializes &lt;br /&gt;the interrupt vector. Notice that the first thing done in this procedure is to save the old interrupt &lt;br /&gt;vector number using DOS INT 21H function call number 35H to read the current vector. Refer &lt;br /&gt;to Appendix A for more detail on DOS INT 21H function calls. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-4 &lt;br /&gt;.MODEL TINY &lt;br /&gt;. CODE &lt;br /&gt;;A program that installs NEW40 at INT 40H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0100 EB 05 JMP START &lt;br /&gt;0102 00000000 OLD DD ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;new interrupt procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 NEW40 PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 CF IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0107 NEl'i40 EIlDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0107 START: &lt;br /&gt;0107 BC C8 MOV AX,CS ;get data segment &lt;br /&gt;0109 8E D8 MOV DS,AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11-2 HARDWARE INTERRUPTS 439 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010B B4 35 MOV AH,35H ;get old incerrupt vector &lt;br /&gt;010D BO 40 MOV AL,40H &lt;br /&gt;010F CD 21 INT 21H &lt;br /&gt;0111 89 IE 0102 R MOV WORD PTR OLD,BX &lt;br /&gt;0115 8C 06 0104 R MOV WORD PTR OLD+2,ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;install ne&amp;quot; interrupt vector 40H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0119 BA 0106 R MOV DX,OFFSET NEW40 &lt;br /&gt;011C B4 25 MOV AH,25H &lt;br /&gt;011E BO 40 MOV AL,40H &lt;br /&gt;0120 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;leave NEW40 in memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0122 BA 0107 R MOV DX,OFFSET START &lt;br /&gt;0125 D1 EA SHR DX,l &lt;br /&gt;0127 D1 EA SHR DX,l &lt;br /&gt;0129 D1 EA SHR DX,l &lt;br /&gt;012B D1 EA SHR DX,l &lt;br /&gt;012D 42 INC DX &lt;br /&gt;012E B8 3100 MOV AX,3100H &lt;br /&gt;0131 CD 21 INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HARDWARE INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The microprocessor has two hardware interrupt inputs: non-maskable interrupt (NMI) and inter-&lt;br /&gt;rupt request (INTR). Whenever the NMI input is activated, a type 2 interrupt occurs because NMI &lt;br /&gt;is internally decoded. The INTR input must be externally decoded to select a vector. Any interrupt &lt;br /&gt;vector can be chosen for the INTR pin, but we usually use an interrupt type number between 20B &lt;br /&gt;and FFH. The INT A signal is also an interrupt pin on the microprocessor, but it is an output that is &lt;br /&gt;used in response to the INTR input to apply a vector type number to the data bus connections &lt;br /&gt;D7-DO. Figure 11-5 shows the three user interrupt connections on the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The non-maskable interrupt (NMI) is an edge-triggered input that requests an interrupt &lt;br /&gt;on the positive edge (O-to-I transition). After a positive edge, the NMI pin must remain a logic I &lt;br /&gt;until it is recognized by the microprocessor. Note that before the positive edge is recognized, the &lt;br /&gt;NMI pin must be a logic 0 for at least two clocking periods. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The NMI input is often used for parity errors and other major system faults such as power &lt;br /&gt;failures. Power failures are easily detected by monitoring the AC power line and causing an NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-5 The interrupt &lt;br /&gt;pins on ali versions of the &lt;br /&gt;Intel microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMII-+----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR ...... ---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA IO-----~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt inp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt out &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;440 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;CEXT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C &lt;br /&gt;VCC o-..,;;.,R-,.,,--+-,-,'-I REXT/CEXT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1K UlA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lK &lt;br /&gt;74LS122 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;47K r---------, &lt;br /&gt;~!fEC11~ __ r-i_JI--~-:....j 2 Q Q t-&amp;quot;----NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-6 A power failure detection circuit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interrupt whenever AC power drops out. In response to this type of interrupt, the microprocessor &lt;br /&gt;stores all the internal register in a battery-backed-up memory or an EEPROM. Figure 11-6 &lt;br /&gt;shows a power failure detection circuit that provides a logic 1 to the NMI input whenever AC &lt;br /&gt;power is interrupted. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this circuit, an optical isolator provides isolation from the AC power line. The output of &lt;br /&gt;the isolator is shaped by a Schmitt-trigger inverter that provides a 60 Hz pulse to the trigger input &lt;br /&gt;of the 74LSI22 retriggerable monostable multivibrator. The values of Rand C are chosen so that &lt;br /&gt;the 74LSI22 has an active pulse width of 33 ms or 2 AC input periods. Because the 74LSI22 is &lt;br /&gt;retriggerable, as long as AC power is applie4, the Q output remains triggered at a logic 1 and Q &lt;br /&gt;reIl1ains a logic O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the AC power fails, the 74LSI22 no longer receives trigger pulses from the 74ALS14, &lt;br /&gt;which means that Q returns to a logic 0 and Q returns to a logic I, interrupting the micro-&lt;br /&gt;processor through the NMI pin. The interrupt service procedure, not shown here, stores the con-&lt;br /&gt;tents of all internal registers and other data into a battery-backed-up memory. This system &lt;br /&gt;assumes that the system power supply has a large enough filter capacitor to provide energy for at &lt;br /&gt;least 75 ms after the AC power ceases. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 11-7 shows a circuit that supplies power to a memory after the DC power fails. &lt;br /&gt;Here diodes are used to switch supply voltages from the DC power supply to the battery. The &lt;br /&gt;diodes used are standard silicon diodes because the power supply to this memory circuit is ele-&lt;br /&gt;vated above +5.0V to +5.7V. Also notice that the resistor is used to trickle-c~arge the battery, &lt;br /&gt;which is either NiCAD, Lithium, or a gel cell. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-7 A battery-&lt;br /&gt;backed-up memory system &lt;br /&gt;using a NiCad, lithium, or gel &lt;br /&gt;cell &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+9.0V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4.7K &lt;br /&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR -------' &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-2 HARDWARE INTERRUPTS 441 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA \\ ~ &lt;br /&gt;LOCK \\ ~ &lt;br /&gt;~,/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07 - DO -------------~-----------~--------&lt;br /&gt;Vector number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-8 The timing of the INTR input and INTA output. 'Note: This portion of the data &lt;br /&gt;bus is ignored and usually contains the vector number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When DC power fails, the battery provides a reduced voltage to the Vee connection on the &lt;br /&gt;memory device. Most memory devices will retain data with Vee voltages as low as 1.5V so the &lt;br /&gt;battery voltage does not need to be +5.0V. The WR pin is pulled to Vee during a power outage &lt;br /&gt;so no data will be written to the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR and INTA &lt;br /&gt;The interrupt request input (INTR) is level-sensitive, which means that it must be held at a &lt;br /&gt;logic 1 level until it is recognized. The INTR pin is set by an external event and cleared inside the &lt;br /&gt;interrupt service procedure. This input is automatically disabled once it is accepted by the mi-&lt;br /&gt;croprocessor and re-enabled by the IRET instruction at the end of the interrupt service proce-&lt;br /&gt;dure. The 80386-Pentium Pro use the IRETD instruction in the protected mode of operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The microprocessor responds to the INTR input by pulsing the INT A output in anticipa-&lt;br /&gt;tion of receiving an interrupt vector type number on data bus connection D7-DO' Figure 11-8 &lt;br /&gt;shows the timing diagram for the INTR and INT A pins of the microprocessor. There are two &lt;br /&gt;INT A pulses generated by the system that are used to insert the vector type number on the data &lt;br /&gt;bus. / &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 11-9 illustrates a simple circuit that applies i errupt vector type number FFH to &lt;br /&gt;the data bus in response to an INTR. Notice that the INT pin is not connected in this circuit. &lt;br /&gt;Because resistors are used to pull the data bus connection (Do-D7) high, the microprocessor au-&lt;br /&gt;tomatically sees vector type number FFH in response t the INTR input. This is possibly the &lt;br /&gt;least expensive way to implement the INTR pin on the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Using a Three-state Buffer for INTA. Figure 11-10 shows how interrupt vector type number &lt;br /&gt;80H is applied to the data bus (Do-D7) in response to an INTR. In response to the INTR, the mi-&lt;br /&gt;croprocessor outputs the INT A that is used to enable a 74ALS244 three-state octal buffer. The &lt;br /&gt;octal buffer applies the interrupt vector type number to the data bus in response to the INT A &lt;br /&gt;pulse. The vector type number is easily changed with the DIP switches that are shown in this &lt;br /&gt;illustration. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Making the INTR Input Edge-triggered. Often we need an edge-triggered input instead of a &lt;br /&gt;level-sensitive input. The INTR input can be converted to an edge-triggered input by using a &lt;br /&gt;D-type flip-flop, as illustrated in Figure 11-11. Here the clock input becomes an edge-triggered &lt;br /&gt;interrupt request input, and the clear input is used to clear the request when the INT A signal is &lt;br /&gt;output by the microprocessor. Also note that the RESET signal initially clears the flip-flop so &lt;br /&gt;that no interrupt is requested when the system is first powered. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;442 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-9 A simple &lt;br /&gt;method for generating inter-&lt;br /&gt;rupt vector type number FFH &lt;br /&gt;in response to INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-10 A circuit &lt;br /&gt;that applies any interrupt &lt;br /&gt;vector type number in re-&lt;br /&gt;sponse to INTA. Here the &lt;br /&gt;circuit is applying type &lt;br /&gt;number80H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 with &lt;br /&gt;the 82288 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;DI &lt;br /&gt;D2 &lt;br /&gt;D3 &lt;br /&gt;D4 &lt;br /&gt;D5 &lt;br /&gt;D6 &lt;br /&gt;D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 with &lt;br /&gt;the 82288 1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;65 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;1 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;D4 &lt;br /&gt;05 &lt;br /&gt;D6 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 1 1 &lt;br /&gt;8 6 4 2 9 7 5 3 &lt;br /&gt;1 1 1 1 2 2 2 2 &lt;br /&gt;YYYYYYYY &lt;br /&gt;1 234 1 234 &lt;br /&gt;1 1 1 1 2 2 2 2 &lt;br /&gt;AAAAAAAA &lt;br /&gt;12341234 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 1 1 &lt;br /&gt;2 4 6 8 1 3 5 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 0 00 00 o 0 &lt;br /&gt;1 1 1 1 1 1 1 &lt;br /&gt;~. $ 4 32 1 09 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f~ ~. ~ ~ ~ ~ ~ ~ I &lt;br /&gt;I 2 3 4 5 6 78 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 1 1 1 1 &lt;br /&gt;43 2 1 09 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 27K &lt;br /&gt;3 4 5 6 7 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Low data bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;No connection &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Lo wdata bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 2 &lt;br /&gt;GG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r1r~ vo &lt;br /&gt;1'-- 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cc &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 15 &lt;br /&gt;3 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IT &lt;br /&gt;12 &lt;br /&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-2 HARDWARE INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-11 Converting &lt;br /&gt;INTR into an edge-triggered &lt;br /&gt;interrupt request input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Edge-triggered &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interrupt request &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 UIA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D P Q 5 INTR &lt;br /&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R &lt;br /&gt;eLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;e Q 6 L &lt;br /&gt;74ALS74 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2A &lt;br /&gt;74ALS08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;gt;o~~ L-----------------i INTA &lt;br /&gt;74ALS04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 82C55 Keyboard Interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;443 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The keyboard example presented in Chapter 10 provides a simple example of the operation of &lt;br /&gt;the INTR input and an interrupt. Figure 11-12 illustrates the interconnection of the 82C55 with &lt;br /&gt;the microprocessor and the keyboard. It also shows how a 74ALS244 octal buffer is used to pro-&lt;br /&gt;vide the microprocessor with interrupt vector type number 40H in response to the keyboard in-&lt;br /&gt;terrupt during the INT A pulse. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 82C55 is decoded at 80386SX I/O port address 0500H, 0502H, 0504H, and 0506H by &lt;br /&gt;a PALl6L8 (the program is not illustrated). The 82C55 is operated in mode 1 (strobed input &lt;br /&gt;mode) so whenever a key is typed, the INTR output (PC3) becomes a logic 1, requesting an in-&lt;br /&gt;terrupt through the INTR pin on the microprocessor. The INTR pin remains high until the ASCII &lt;br /&gt;data are read from port A. In other words, every time a key is typed, the 82C55 requests a type &lt;br /&gt;40H interrupt through the INTR pin. The DA V signal from the keyboard causes data to be &lt;br /&gt;latched into port A and also causes INTR to become a logic 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 11-5 illustrates the interrupt service procedure for the keyboard. It is very impor-&lt;br /&gt;tant that all registers affected by an interrupt be saved before they are used. In the software re-&lt;br /&gt;quired to initialize the 82C55 (not shown here), the FIFO is initialized so that both pointers are &lt;br /&gt;equal, the INTR request pin is enabled through the INTE bit inside the 82C55, and the mode of &lt;br /&gt;operation is programmed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 0500 &lt;br /&gt;= 0506 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0100 [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;0100 0000 &lt;br /&gt;0102 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0104 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;An interrupt service procedure that reads a key &lt;br /&gt;; from the keyboard in Figure 11-12. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PORTA EQU 500H &lt;br /&gt;CNTR EQU 506H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIFO DB 256 DUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INP DW ? &lt;br /&gt;OUTP DW ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(? ) ~e , &lt;br /&gt;;input ~inter &lt;br /&gt;;output pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY PROC FAR USES AX BX DI DX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;444 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V3 &lt;br /&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;D4 &lt;br /&gt;05 &lt;br /&gt;D6 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34 DO PAO 4 DO 3, 01 PAl l 01 l2 02 PA2 2 02 3 03 PA3 03 30 D4 PA4 40 D4 29 05 PA5 39 05 28 D6 PA6 lR D6 &lt;br /&gt;07 PA7 37 07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lORe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI &lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 RO PBO ~ rt WR PBI &lt;br /&gt;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO PB2 ~ 35 AI PB3 &lt;br /&gt;.6-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET PB4 r-- OAV &lt;br /&gt;es PB5 3f PB6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PB7 ....z.s... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lowe &lt;br /&gt;AO &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V2 PCO ~ &lt;br /&gt;I 11 01 ~ PCI ~ 2 12 02 PC2 STB Keyboard 17 13 03 PC3 \\3 4 14 04 ~ PC4 ~ 5 15 05 PC5 6 16 06 PC6 7 17 07 PC7 8 18 08 8255A-5 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 19 110 &lt;br /&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All &lt;br /&gt;AI2 &lt;br /&gt;AI3 &lt;br /&gt;AI4 &lt;br /&gt;AI5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;I I I I &lt;br /&gt;8 6 4 2 97 5 3 &lt;br /&gt;I I I 12222 VI yyyyyyyy 74ALS244 12341234 &lt;br /&gt;I I I I 2 222 &lt;br /&gt;AAAAAAAA I 2 &lt;br /&gt;12341234 GG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2J46 ~ J:I I I 8 I 3 5 7 tin &lt;br /&gt;~ vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-12 An 8255A-5 interfaced to a keyboard from the microprocessor system using interrupt vector 40H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0108 2E: 8B 1E 0100 R MOV BX,CS:INP ;load input pointer &lt;br /&gt;010D 2E: 8B 3E 0102 R MOV OI,CS:OUTP ;load output pointer &lt;br /&gt;0112 FE C3 INC BL ;test for queue = full &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0114 3B DF CMP BX,DI &lt;br /&gt;0116 74 11 JE FULL ;if queue is full &lt;br /&gt;0118 FE CB DEC BL &lt;br /&gt;011A BA 0500 MOV DX,PORTA &lt;br /&gt;011D EC IN AL,DX ;get data from 82C55 &lt;br /&gt;011E 2E: 88 07 MOV CS: [BX] ,AL ;save data in queue &lt;br /&gt;0121 2E: FE 06 0100 R INC BYTE PTR INP &lt;br /&gt;0126 EB 07 90 JMP DONE &lt;br /&gt;0129 FULL: &lt;br /&gt;0129 BO 08 MOV AL,8 ;disable 82C55 interrupt &lt;br /&gt;012B BA 0506 ~IOV DX,CNTR &lt;br /&gt;012E EE OUT DX,AL &lt;br /&gt;012F DONE: &lt;br /&gt;012F IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0134 KEY ENDP &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11-3 EXPANDING THE INTERRUPT STRUCTURE 445 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure is fairly short because the 80386SX already knows that keyboard data are &lt;br /&gt;available when the procedure is called. Data are input from the keyboard and then stored in the &lt;br /&gt;FIFO (first-in, first-out) buffer. Most keyboard interfaces contain a FIFO that is at least 16 bytes &lt;br /&gt;in depth. The FIFO in this example is 256 bytes, which is more than adequate for a keyboard in-&lt;br /&gt;terface. Notice how the INC BYTE PTR INP is used to add one to the input pointer and also &lt;br /&gt;make sure that it always addresses data in the queue. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This procedure first checks to see if the FIFO is full. A full condition is indicated when the &lt;br /&gt;input point (INP) is one byte below the output pointer (OUTP). If the FIFO is full, the interrupt &lt;br /&gt;is disabled with a bit set/reset command to the 82C55, and a return from the interrupt occurs. If &lt;br /&gt;the FIFO is not full, the data are input from port A, and the input pointer is incremented before a &lt;br /&gt;return occurs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 11-6 shows the procedure that removes data from the FIFO. This procedure &lt;br /&gt;first determines whether the FIFO is empty by comparing the two pointers. If the pointers are &lt;br /&gt;equal, the FIFO is empty, and the software waits at the EMPTY loop where it continuously &lt;br /&gt;tests the pointers. The EMPTY loop is interrup~ed by the keyboard interrupt, which stores &lt;br /&gt;data into the FIFO so it is no longer empty. This procedure returns wjth the character in &lt;br /&gt;register AH. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0134 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0137 &lt;br /&gt;0137 2E: 8B 1E 0100 R &lt;br /&gt;013D 2E: 8B 3E 0102 R &lt;br /&gt;0142 3B DF &lt;br /&gt;0144 74 F2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0146 2E: 8A 25 &lt;br /&gt;0149 BO 09 &lt;br /&gt;014B BA 0506 &lt;br /&gt;014E EE &lt;br /&gt;014F 2E: FE 06 0102 R &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0157 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that reads data from the queue of &lt;br /&gt;;Example 11-5 and returns with it in AH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ PROC FAR USES BX DI DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EMPTY: &lt;br /&gt;MOV BX,CS:INP ;load input pointer &lt;br /&gt;MOV DI,CS:OUTP ;~oad output pointer &lt;br /&gt;CMP BX,DI &lt;br /&gt;JE EMPTY ;if queue is empty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,CS: [DI] ,get data &lt;br /&gt;MOV AL,9 ; enable 82C55 interrupt &lt;br /&gt;MOV DX,CNTR &lt;br /&gt;OUT DX,AL &lt;br /&gt;INC BYTE PTR CS:OUTP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXPANDING THE INTERRUPT STRUCTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This text covers three of the more common methods of expanding the interrupt structure of the &lt;br /&gt;microprocessor. In this section, we explain how, with software and some hardware modification &lt;br /&gt;of the circuit in Figure 11-10, it is possible to expand the INTR input so that it accepts seven in-&lt;br /&gt;terrupt inputs. We also explain how to &amp;quot;daisy-chain&amp;quot; interrupts by software polling. In the next &lt;br /&gt;section, we describe a third technique in which up to 63 interrupting inputs can be added by &lt;br /&gt;means of the 8259A programmable interrupt controller. \\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Using the 74ALS244 to Expand &lt;br /&gt;The modification shown in Figure 11-13 allows the circuit in Fig re 11-10 to accommodate up &lt;br /&gt;to seven additional interrupt inputs. The only hardware changei is the addition of an 8-input &lt;br /&gt;NAND gate, which provides the INTR signal to the microprocessor when any of the IR inputs &lt;br /&gt;becomes active. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;446 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 with &lt;br /&gt;the 82288 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;DI &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;U2 2 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR ~ ;4 5 &lt;br /&gt;74ALS30 fi &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I 1 &lt;br /&gt;8 6 4 2 9 7 5 3 &lt;br /&gt;I I 1 1 222 2 &lt;br /&gt;YYYYYYYY &lt;br /&gt;12341234 &lt;br /&gt;11112222 &lt;br /&gt;AAAAAAAA &lt;br /&gt;12341234 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I 1 &lt;br /&gt;2 4 6 8 I 3 5 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UI &lt;br /&gt;74ALS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I 2 &lt;br /&gt;GG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11~ vee ;&amp;gt; &lt;br /&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Low data bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRQ &lt;br /&gt;IRJ &lt;br /&gt;IR2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IR3 &lt;br /&gt;IR4 &lt;br /&gt;IR5 &lt;br /&gt;IR6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-13 Expanding the INTR input from one to seven interrupt request lines &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation. If any of the IR inputs become a logic 0, then the output of the NAND gate goes to &lt;br /&gt;a logic 1 and requests an interrupt through the INTR input. Which interrupt vector is fetched &lt;br /&gt;during the INTA pulse depends on which interrupt request line becomes active. Table 11-1 &lt;br /&gt;shows the interrupt vectors used by a single interrupt request input. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If two or more interrupt request inputs are simultaneously active, a new interrupt vector is &lt;br /&gt;generated. For example, if IR 1 and IRO are both active, the interrupt vector generated is FCH &lt;br /&gt;(252). Priority is resolved at this location. If the IRO input is to have the higher priority, the &lt;br /&gt;vector address for IRO is stored at vector location FCH. The entire top half of the vector table &lt;br /&gt;and its 128 interrupt vectors must be used to accommodate all possible conditions of these &lt;br /&gt;seven interrupt request inputs. This seems wasteful, but in many dedicated applications it is a &lt;br /&gt;cost-effective approach to interrupt expansion. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 11-1 Single inter-&lt;br /&gt;rupt request for Figure 11-13 IR6 IR2 IR1 IRO Vector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--------------------------------------------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;1 &lt;br /&gt;0 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 0 FEH &lt;br /&gt;0 :=DH &lt;br /&gt;1 FBH &lt;br /&gt;1 F7H &lt;br /&gt;1 EFH &lt;br /&gt;1 DFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BFH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-3 EXPANDING THE INTERRUPT STRUCTURE 447 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Daisy-Chained Interrupt &lt;br /&gt;Expansion by mcans of a daisy-chained interrupt is in many ways bctter than using the &lt;br /&gt;74ALS244 interrupt expansion because it requires only one interrupt vector. The task of deter-&lt;br /&gt;mining priOl:lY is left to the interrupt service procedure. Setting priority for a daisy-chain does &lt;br /&gt;require additional software execution time, but in general this is a much better approach to ex-&lt;br /&gt;panding the interrupt structure of the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 11-14 iliustrates a set of two 82eSS peripheral interfaces with their four INTR out-&lt;br /&gt;puts daisy-chained and connected to the single INTR input of the microprocessor. If any inter-&lt;br /&gt;rupt output becomes a logic I, so does the INTR input to the microprocessor, causing an &lt;br /&gt;interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When a daisy-chain is used to request an interrupt, it is better to pull the data bus connec-&lt;br /&gt;tions (00-07) high using pull-up resistors so that interrupt vector FFH is used for the chain. Ac-&lt;br /&gt;tually, any interrupt vector can be used to respond to a daisy-chain. In the circuit, any of the four &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-14 Two &lt;br /&gt;8255A-5 PIAs connected to &lt;br /&gt;the INTR outputs are daisy-&lt;br /&gt;chained to produce an INTR &lt;br /&gt;signal for the 80286. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VI &lt;br /&gt;00 &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;D3 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PAD &lt;br /&gt;PAl &lt;br /&gt;PA2 &lt;br /&gt;PA3 &lt;br /&gt;PA4 &lt;br /&gt;PA5 &lt;br /&gt;PA6 &lt;br /&gt;PA7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8255A-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V2 &lt;br /&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RO &lt;br /&gt;WR &lt;br /&gt;AO &lt;br /&gt;Al &lt;br /&gt;RESET &lt;br /&gt;CS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCO~~----__ ~B ____ ~ &lt;br /&gt;PCI &lt;br /&gt;PC2 &lt;br /&gt;PC3 t-+-;;---------'&amp;quot;.o.J &lt;br /&gt;PC4 &lt;br /&gt;PC5 &lt;br /&gt;PC6 &lt;br /&gt;PC7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8255A-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V3A Daisy~hain &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS32 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;448 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR outputs from the two 82C55s will cause the INTR pin on the microprocessor to go high, &lt;br /&gt;requesting an interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When the INTR pin does go high with a daisy-chain, the hardware gives no direct indica-&lt;br /&gt;tion as to which 8~C55 or which INTR output caused the interrupt. The task of locating which &lt;br /&gt;INTR output became active is up to the interrupt service procedure, which must poll the 82C55s &lt;br /&gt;to determine which output caused the interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 11-7 illustrates the interrupt service procedure that responds to the daisy-chain &lt;br /&gt;interrupt request. This procedure polls each 82C55 and each INTR output to decide which inter-&lt;br /&gt;rupt service procedure to utilize. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-7 &lt;br /&gt;;A procedure that services the daisy-chain interrupt &lt;br /&gt;;of Figure 11-14. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0504 C1 EQU 504H ;first 82C55 &lt;br /&gt;0604 C2 EQU 604H ; second 82C55 &lt;br /&gt;0001 MASK1 EQU 1 ;INTRB &lt;br /&gt;0008 MASK2 EQU 8 ; INTRA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 POLL PROC FAR USES AX DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 BA 0504 MOV DX,C1 ; address first 82C55 &lt;br /&gt;0005 EC IN AL,DX ;get port C &lt;br /&gt;0006 A8 01 TEST AL,MASK1 &lt;br /&gt;0008 75 OF JNZ LEVEL_O ;if INTRB is set &lt;br /&gt;OOOA A8 08 TEST AL,MASK2 &lt;br /&gt;OOOC 75 13 JNZ LEVEL_1 ;if INTRA is set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOE BA 0604 MOV DX,C2 ;address second 82C55 &lt;br /&gt;0011 EC IN AL,DX ;get port C &lt;br /&gt;0012 A8 01 TEST AL,MASK1 &lt;br /&gt;0014 75 1B JNZ LEVEL_2 ;if INTRB is set &lt;br /&gt;0016 EB 29 00 JMP LEVEL_3 ;for INTRA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0019 POLL ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8259A PROGRAMMABLE INTERRUPT CONTROLLER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8259A programmable interrupt control!er (PIC) adds eight vectored priority encoded inter-&lt;br /&gt;rupts to the microprocessor. This controller can be expanded without additional hardware to accept &lt;br /&gt;up to 64 inteJTllpt request inputs. This expansiori requires a master 8259A and eight 8259A slaves. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;General Description of the 8259a &lt;br /&gt;Figure 11-15 shows the pin-out of the 8259A. The 8259A is easy to connect to the micro-&lt;br /&gt;processor because all of its pins are direct connections except the CS pin, which must be de-&lt;br /&gt;coded, and the WR pin, which must have an I/O bank write pulse. Following is a description of &lt;br /&gt;each pin on the 8259A: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The hi-directional data connections are normally connected to either the &lt;br /&gt;upper or lower data bus on the 80386SX microprocessor or the data bus on &lt;br /&gt;the 8088. If an 80486 or Pentium!Pentiu!Tl Pro is used, then they connect to &lt;br /&gt;any 8-bit bank. &lt;br /&gt;Interrupt request inputs are used to request an interrupt and to connect to a &lt;br /&gt;slave in a system with multiple 8259As .. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-4 82S9A PROGRAMMABLE INTERRUPT CONTROLLER 449 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-15 The pin-out &lt;br /&gt;of the 8259A programmable &lt;br /&gt;interrupt controller (PIC) DO 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8259A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RD &lt;br /&gt;INT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;CS &lt;br /&gt;RO &lt;br /&gt;WR &lt;br /&gt;SP/EN CASO &lt;br /&gt;INT CAS I &lt;br /&gt;INTA CAS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The write input connects to either the lower or upper write strobe signal in a &lt;br /&gt;l6-bit system or any other bus write strobe in any size system. &lt;br /&gt;The read input connects to the IORC signal. &lt;br /&gt;The interrupt output connects to the INTR pin on the microprocessor from &lt;br /&gt;the master, and is connected to a master IR pin on a slave. &lt;br /&gt;Interrupt acknowledge is an input that connects to the INT A signal on the &lt;br /&gt;system. In a system with a master and slaves, only the master INT A signal &lt;br /&gt;is connected. &lt;br /&gt;The Ao address input selects different command words within the 8259A. &lt;br /&gt;Chip select enables the 8259A for programming and control. &lt;br /&gt;Slave program/enable buffer is a dual-function pin. When the 8259A is in &lt;br /&gt;buffered mode, this pin is an output that controls the data bus transceivers in &lt;br /&gt;a large microprocessor-based system. When the 8259A is not in buffered &lt;br /&gt;mode, this pin programs the device as a master (1) or a slave (0). &lt;br /&gt;The cascade lines are used as outputs from the master to the slaves for &lt;br /&gt;cascading multiple 8259As in a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Connecting a Single 8259A &lt;br /&gt;Figure 11-16 shows a single 8259A connected to the 8086 microprocessor. Here the SP/EN pin is &lt;br /&gt;pulled high to indicate that it is a master. Also note that the 8259A is decoded at I/O ports 0400H &lt;br /&gt;and 0402H by the PAL16L8 (no program shown). Like other peripherals discussed in Chapter 10, &lt;br /&gt;the 8259A requires four wait states for it to function properly with a l6MHz 80386SX and more for &lt;br /&gt;some other versions of the Intel microprocessor family. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cascading Multiple 8259As &lt;br /&gt;Figure 11-17 shows two 8259As connected to the 80386SX microproceSS~Oin way that is often &lt;br /&gt;found in the AT-style computer, which has two 8259As for interrupts. The XT- or C- style computer &lt;br /&gt;uses one 8259A at interrupt vectors 08H41FH. The AT -style computer uses in rrupt vector OAH as &lt;br /&gt;a cascade input from a second 8259A located at vectors 70H-77H. Appe~ A contains a table that &lt;br /&gt;lists the functions of all the interrupt vectors used in the PC-, XT-, and AT-style computers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This circuit uses vectors 08H-OFH and I/O ports 0300H and 0302H for VI, the master, &lt;br /&gt;and vectors 70H-77H and I/O ports 0304H and 0306H for V2, the slave. Notice that we also in-&lt;br /&gt;clude data bus buffers to illustrate the use of the SP/EN pin on the 8259A. These buffers are used &lt;br /&gt;only in vary large systems that have many devices connected to their data bus connections. In &lt;br /&gt;practice, we seldom find these buffers. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;450 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-16 An 8259A &lt;br /&gt;interfaced to the 8086 micro-&lt;br /&gt;processor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vcc &lt;br /&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;1 &lt;br /&gt;2 &lt;br /&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;5 &lt;br /&gt;6 &lt;br /&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R &lt;br /&gt;A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT &lt;br /&gt;iNT&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/iO &lt;br /&gt;AD &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;AS &lt;br /&gt;A7 &lt;br /&gt;AB &lt;br /&gt;A9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AID &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul &lt;br /&gt;1 11 01~ &lt;br /&gt;3 12 02 1 &lt;br /&gt;4 13 03 1 &lt;br /&gt;5 14 04 :15 &lt;br /&gt;6 15 05 14 &lt;br /&gt;7 16 ~l 8 17 9 18 08 19 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ISlB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;11 DO IRO 18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dl IRI 19 9 D2 1R2 2 &lt;br /&gt;D3 IR3 21 &lt;br /&gt;D4 IR4 2 6 D5 IRS 23 5 D6 IR6 24 &lt;br /&gt;D7 IR7 25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt inpuls &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27 AQ ~ ... ,1. ... ~ &lt;br /&gt;-fr WR_ H!-SP/EN CASO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 INT CASI ~ INTA CAS2 &lt;br /&gt;8259A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the 8259A &lt;br /&gt;The 8259A is programmed by initialization and operation command words. Initialization com-&lt;br /&gt;mand words (ICWs) are programmed before the 8259A is able to function in the system and dic-&lt;br /&gt;tate the basic operation of the 8259A. Operation command words (OCWs) are programmed &lt;br /&gt;during the normal course of operation and allow the 8259A to function properly. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Initialization Command Words. There are four initialization command words (ICWs) for the &lt;br /&gt;8259A that are selected when the Ao pin is a logic 1. When the 8259A is first powered up, it must &lt;br /&gt;be sent ICWl, ICW2, and ICW4. If the 8259A is programmed in cascade mode by ICWl, then we &lt;br /&gt;also must program ICW3. So if a single 8259A is used in a system, ICWl, ICW2, and ICW4 must &lt;br /&gt;be programmed. If cascade mode is used in a system, then all four ICWs must be programmed. &lt;br /&gt;Refer to Figure 11-18 for the format of all four ICW s. The following is a description of each ICW: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;leWl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ICW2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programs the basic operation of the 8259A. To program this ICW for 8086-Pentium &lt;br /&gt;Pro operation, we place a logic 1 in bit IC4. Bits AD!, A7, A6, and A5 are don't &lt;br /&gt;cares for microprocessor operation and only apply to the 8259A when used with &lt;br /&gt;an 8-bit 8085 microprocessor (not covered in this textbook). This ICW selects &lt;br /&gt;single or cascade operation by programming the SNGL bit. If cascade operation &lt;br /&gt;is selected, we must also program ICW3. The LTIM bit determines whether the &lt;br /&gt;interrupt request inputs are positive edge-triggered or level-triggered. &lt;br /&gt;Selects the vector number used with the interrupt request inputs. For example, if &lt;br /&gt;we decide to program the 8259A so that it functions at vector locations 08H-OFH, &lt;br /&gt;we place a 08H into this command word. Likewise, if we decide to program the &lt;br /&gt;8259A for vectors 70H-77H, we place a 70H in this ICW. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA &lt;br /&gt;Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/iO &lt;br /&gt;AO &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;AB &lt;br /&gt;A9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U4A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-{ 1 ~ &lt;br /&gt;74ALSOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 &lt;br /&gt;1 11 01 :&amp;gt;i* ~ 12 02 ~~ 13 03 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-----4- 14 04 16 ~ 15 05 15 &lt;br /&gt;----4 16 06 :rf}-&lt;br /&gt;-----i- 17 07 ~ &lt;br /&gt;---* &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IB OB :,...1Â£f--&lt;br /&gt;----,t 19 110 ~&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16LB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U4B &lt;br /&gt;-&amp;quot; 4 ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, ) &lt;br /&gt;- . --74ALSOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U5 &lt;br /&gt;18 Bl Al &lt;br /&gt;17 B2 A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B3 A3 &lt;br /&gt;B4 A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 B5 A5 &lt;br /&gt;1 B6 A6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B7 A7 &lt;br /&gt;BB AB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G &lt;br /&gt;OIR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS245 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U5 &lt;br /&gt;1 Bl Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B2 A2 &lt;br /&gt;B3 A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 B4 A4 &lt;br /&gt;1 B5 A5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B6 A6 &lt;br /&gt;2 B7 A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 BB AB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G &lt;br /&gt;DIR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS245 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;;&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;gt; 10K Master &lt;br /&gt;Ul &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 11 DO IRO ~ (QBH) 1 01 IRl (o9H) &lt;br /&gt;4 D2 IR2 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03 IR3 2 (OBH &lt;br /&gt;7 04 IR4 (QCHl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 05 IR5 2 OH &lt;br /&gt;5 06 IR6 24 (oEH) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07 IR7 fOFH) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;p1f- Sf- ,--2f- AO 1 2 CS 74ALSO: .3 Fill WR Fft= 16 SP/EN CASO ~ INT CASl INTA CAS2 &lt;br /&gt;B259A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;2 1 DO IRO 1 (70H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 01 IRl (Zll:J) &lt;br /&gt;4 02 IR2 tJL--&lt;br /&gt;5 03 IR3 ---tt~~, 04 IR4 &lt;br /&gt;7 05 IR5 (Z5t1l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06 IR6 4 U6H) &lt;br /&gt;9 4 07 IR7 (77H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;p1f- q- Lzt- AO 1 4 CS &lt;br /&gt;74ALSO: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fill &lt;br /&gt;2 WR Ht-SP/EN CASO INT CASl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.2fi., INTA CAS2 &lt;br /&gt;B259A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K Slave &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-17 Two 8259As interfaced to the 8259A at 1/0 ports 0300H and 0302H for the master and 0304H and 0306H for the slave &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRO &lt;br /&gt;IRl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IR3 &lt;br /&gt;~4 &lt;br /&gt;IR5 &lt;br /&gt;IR6 &lt;br /&gt;IR7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRB &lt;br /&gt;IR9 &lt;br /&gt;IR10 &lt;br /&gt;IR11 &lt;br /&gt;IR12 &lt;br /&gt;IR13 &lt;br /&gt;IR14 &lt;br /&gt;IR15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;~ &lt;br /&gt;~ &lt;br /&gt;W &lt;br /&gt;~ &lt;br /&gt;~ &lt;br /&gt;~ &lt;br /&gt;0 Q &lt;br /&gt;~ &lt;br /&gt;~ &lt;br /&gt;Â£ &lt;br /&gt;Â£ &lt;br /&gt;~ &lt;br /&gt;ill &lt;br /&gt;r &lt;br /&gt;m &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Z &lt;br /&gt;~ &lt;br /&gt;m &lt;br /&gt;~ &lt;br /&gt;~ &lt;br /&gt;C &lt;br /&gt;~ &lt;br /&gt;~ &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;Z &lt;br /&gt;~ &lt;br /&gt;~ &lt;br /&gt;0 &lt;br /&gt;r &lt;br /&gt;r &lt;br /&gt;m &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;U1 &lt;br /&gt;~ &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;452 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-18 The 8259A &lt;br /&gt;initialization command words &lt;br /&gt;(ICWs) (Courtesy of Intel Cor-&lt;br /&gt;poration) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;leW3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.&amp;quot;&amp;quot;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D, o. OJ D. 0&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 Ie'''' N((DlD &lt;br /&gt;o â¢ NO ICW&amp;quot; NHOID &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I â¢ StNGLE &lt;br /&gt;o â¢ CASCADE WooE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CAll. AC'OAUIINTUIVAL &lt;br /&gt;1. *NTUIVAL Of. &lt;br /&gt;O_,NTfJlVALOf. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &amp;amp; lEVEL TAtGGEREO MODE &lt;br /&gt;o â¢ EDGE TRIGGERED MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'7~:~;::=fs1 &lt;br /&gt;(MCS 80'85 MODE ONLY) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.&amp;quot;&amp;quot;. &lt;br /&gt;D, D. D, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:~t~:C:ERS~UPT &lt;br /&gt;(MCSIO/85 MODE) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ICW1, .. A$UIIi DEVICEI ~~c'/c! .~~~~PT (80&amp;amp;818088 MODE) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 â¢ ,,. .,....&amp;quot;&amp;quot; HAS A SLAV( &lt;br /&gt;L-....JL--L_....J.._...L.._..L._..L._'--_-I 0 1111 INll'UT DOU M:Jl HAVE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A SLAVE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ICWlISlAV( OIVIC(1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ ~ 0&amp;quot; ~ 0&amp;quot; ~ ~ ~ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I ' I 0 I 0 I 0 I 0 I 0 I '0, I 'D, I 00,\\ &lt;br /&gt;SL .... E 10. 1, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ 1 &lt;br /&gt;. , . . , , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ 1 â¢ &lt;br /&gt;1 â¢ , â¢ 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ â¢ 1 1 â¢â¢ 1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ â¢ â¢ â¢ 1 1 1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I â¢ 80881 eo88 MODE &lt;br /&gt;0- MCS-8018S MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &amp;quot;'ulOtDI &lt;br /&gt;a - NO&amp;quot; ....... (01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ffiE- ~.U&amp;quot;(RÂ£DMOD( '1 0 . IUfFUlfD MODllSlAVf &lt;br /&gt;1 1Â· IUff(RlOMODlfMASTlR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I â¢ SPECIAL FUlL Y NESTED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'----------t 0 â¢ ::O~PEOAL FULLY &lt;br /&gt;HESTEDMODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Is used only when lCWI indicates that the system is operated in cascade mode. &lt;br /&gt;This ICW indicates where the slave is connected to the master. For example, in &lt;br /&gt;Figure 11-18 we connected a slave to IR2. To program ICW3 for this connection, &lt;br /&gt;in both master and slave, we place a 04H in ICW3. Suppose we have two slaves &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-4 8259A PROGRAMMABLE INTERRUPT CONTROLLER 453 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ICW4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;connected to a master using IRO and IR I. The master is programmed with an &lt;br /&gt;ICW3 of 03H; one slave is programmed with an ICW3 of 0 I H and the other with &lt;br /&gt;an ICW3,of 02H. &lt;br /&gt;Is pr'ogrammed for use with the 8086-Pentium Pro microprocessor. This ICW is &lt;br /&gt;not programmed in a system that functions with the 8(,'85 microprocessors. The &lt;br /&gt;rightmost bit must be a logic 1 to select operation with the 8086-Pentium Pro &lt;br /&gt;microprocessors and the remaining bits are programmed as follows: &lt;br /&gt;SFNM-Selects the special fully nested mode of operation for the 8259A if a logic &lt;br /&gt;1 is placed in this bit. This allows the highest priority interrupt request from a slave &lt;br /&gt;to be recognized by the master while it is processing another interrupt from a slave. &lt;br /&gt;Normally, only one interrupt request is processed at a time and others are ignored &lt;br /&gt;until the ,process is complete. &lt;br /&gt;BUF and MIS-Buffer and master slave are used together to select buffered &lt;br /&gt;operation or nonbuffered operation for the 8259A as a master or a slave &lt;br /&gt;AEOI-Selects automatic or normal end of interrupt (discussed more fully under &lt;br /&gt;operation command words). The EOI commands of OeW2 are used only if the &lt;br /&gt;AEOI mode is not selected by IeW4. If AEOI is selected, the interrupt automati-&lt;br /&gt;cally resets the interrupt request bit and does not modify priority. This is the pre-&lt;br /&gt;ferred mode of operation for the 8259A and reduces the length of the interrupt &lt;br /&gt;service procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operation Command Words. The operation command words (OeWs) are used to direct the op-&lt;br /&gt;eration of the 8259A once it is programmed with the leW. The oews are selected when the Ao &lt;br /&gt;pin is at a logic 0 level, except for oew I, which is selected when Ao is a logic 1. Figure 11-19 &lt;br /&gt;lists the binary bit patterns for all three operation command words of the 8259A. Following is a &lt;br /&gt;list describing the function of each oew: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCWl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCW2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Is used to set and read the interrupt mask register. When a mask bit is set, it will &lt;br /&gt;tum off (mask) the corresponding interrupt input. The mask register is read when &lt;br /&gt;OeWl is read. Because the state of the mask bits is unknown when the 8259A is &lt;br /&gt;first initialized, OeWl must be programmed after programming the leW upon &lt;br /&gt;initialization. &lt;br /&gt;Is programmed only when the AEOI mode is not selected for the 8259A. In this &lt;br /&gt;case, this oew selects how the 8259A responds to an interrupt. The modes are &lt;br /&gt;listed as follows: &lt;br /&gt;Nonspecific End-of-Interrupt-A command sent by the interrupt service procedure &lt;br /&gt;to signal the end of the interrupt. The 8259A a tomatically determines which &lt;br /&gt;interrupt level was active and resets the correct it of the interrupt status register. &lt;br /&gt;Resetting the status bit allows the interrupt to tak ction again or a lower priority &lt;br /&gt;interrupt to take effect. &lt;br /&gt;Specific End-of-Interrupt-A command that allows a specific interrupt request to &lt;br /&gt;be reset. The exact position is determined with bits L2-LO of OeW2. &lt;br /&gt;Rotate-on-Nonspecific EOI-A command that functions exactly like the &lt;br /&gt;nonspecific end-of-interrupt command except that it rotates interrupt priorities &lt;br /&gt;after resetting the interrupt status register bit. The level reset by this command &lt;br /&gt;becomes the lowest priority interrupt. For example, if IR4 was just serviced by this &lt;br /&gt;command, it becomes the lowest priority interrupt input and IR5 becomes the &lt;br /&gt;highest priority. &lt;br /&gt;Rotate-on-Automatic EOI-A command that selects automatic EOI with rotating &lt;br /&gt;priority. This command must be sent to the 8259A only once if this mode is &lt;br /&gt;desired. If this mode must be turned off, use the clear command. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;454 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-19 The 8259A ocw. &lt;br /&gt;operational command words .. D. D â¢ 0, D. 0, 0, 0, 0, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(OCWs) (Courtesy of Intel &lt;br /&gt;Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCW3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ocw, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.. D â¢ D. &amp;quot;-&lt;br /&gt;D. D, D. D, 0, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I 0 â¢ I .. I '0' I 0 I 0 1 L, I L, 1 L, J &lt;br /&gt;I 1I&amp;amp;.nm.'TO â¢ ....... -â¢ I , â¢ â¢ â¢ â¢ , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ â¢ â¢ &lt;br /&gt;Â· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ â¢ â¢ . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ â¢ â¢ â¢ â¢ â¢ â¢ â¢ &lt;br /&gt;â¢ 0 â¢ â¢ â¢ â¢ â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l I &lt;br /&gt;rt orf &lt;br /&gt;-- l blDOPWIIft.....,. r.- -;-. _laI-r, â¢â¢ MJWI DIll ~IOI COIiMAND } r-;- 7, .,... II MnOIIoD1C 101 __ (lIT) AIIYOOIATICOO_ roTa IIID'WlIM A&amp;amp;I'tOIIIUo'nC 101 MODI tQ..IM) r,-7, '1IIOTJIft0fill~1Ot~ l --r-;--;- â¢ .... _-~-;- . &lt;br /&gt;... -'-'--'-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â·1..OU .... wu &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;oew. &lt;br /&gt;'&amp;quot; 0, o. ~ D. 0, D, D, 0., &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I Â· I 0 I'SMMJ SMM I 0 I ' I . 1 &amp;quot;lÂ·&amp;quot;J &lt;br /&gt;L 1llU0 flIOtST! .. COfIIMAIrItD â¢ I , â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· &lt;br /&gt;â¢ J 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· Â· READ READ &lt;br /&gt;NO ACTION IF! Ri.G IS REG 0.. NE'CT ON HEkT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RO,UL.St AO ~UlS( &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1.POU.~ &lt;br /&gt;'Â·NOIi'OU..~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PECIAl ..... SK MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D I , 0 , &lt;br /&gt;0 I â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· Â· &lt;br /&gt;REifT .n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NO ACTtON ~C'AL ,&amp;quot;&amp;quot;C,AL MA. M.,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Rotate-on-Specific EOI-Functions as the specific EOI, except that it selects &lt;br /&gt;rotating priority. &lt;br /&gt;Set Priority-Allows the programmer to set the lowest priority interrupt input &lt;br /&gt;using the L2-LO bits. &lt;br /&gt;Selects the register to be read, the operation of the special mask register, and the &lt;br /&gt;poll command. If polling is selected, the P-bit must be set and then output to the &lt;br /&gt;8259A. Th'_ next read operation will read the poll word. The rightmost three bits of &lt;br /&gt;the poll word indicate the active interrupt request with the highest priority. The &lt;br /&gt;leftmost bit indicates whether there is an interrupt, and must be checked to &lt;br /&gt;determine whether the rightmost three bits contain valid information. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Status Register. Three status registers are readable in the 8259A: interrupt request register &lt;br /&gt;(IRR), in-service register (ISR), and interrupt mask register (IMR). (Refer to Figure 11-20 for all &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11-4 8259A PROGRAMMABLE INTERRUPT CONTROLLER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ISR STATUS &lt;br /&gt;PRIORITY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;157 ISS ISS 154 153 152 151 ISO &lt;br /&gt;~ 0 , 0 , 0 0 0 0 1 BEFORE &lt;br /&gt;, 7 6 5 4 3 2 , 0 COMMAND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOWEST PRIORITY &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HIGHEST PRIORITY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IS7 ISS ISS IS4 153 152 151 ISO &lt;br /&gt;ISR STATUS I 0 , 0 0 0 0 0 I:J AFTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(bl PRIORITY 2 , 0 7 6 5 4 ~ COMMAND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HIGHEST PRIORITY LOWEST PRIOR'TY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;455 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-20 The 8259A in-service register (ISR). (a) Before IR4 is accepted, and (b) after IR4 is accepted. &lt;br /&gt;(Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;three status registers; they all have the same bit configuration.) The IRR is an 8-bit register that &lt;br /&gt;indicates which interrupt request inputs are active. The ISR is an 8-bit register that contains the &lt;br /&gt;level of the interrupt being serviced. The IMR is an 8-bit register that holds the interrupt mask &lt;br /&gt;bits and indicates which interrupts are masked off. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Both the IRR and ISR are read by programming OeW3, and IMR is read through oew 1. &lt;br /&gt;To read the IMR, AO = I; to read either IRR or ISR, AO = O. Bit positions DO and D I of OeW3 &lt;br /&gt;select which register (IRR or ISR) is read when AO = O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8259A Programming Example &lt;br /&gt;Figure 11-21 illustrates the 8259A programmable interrupt controller connected to a 16550 pro-&lt;br /&gt;grammable communications controller. In this circuit, the INTR pin from the 16550 is connected &lt;br /&gt;to the programmable interrupt controller's interrupt request input IRO. An IRO occurs whenever &lt;br /&gt;(I) the transmitter is ready to send another character, (2) the receiver has received a character, &lt;br /&gt;(3) an error is detected while receiving data, and (4) a modem interrupt occurs. Notice that the &lt;br /&gt;16550 is decoded at I/O ports 40H and 47H, and the 8259A is decoded at 8-bit 1/0 ports 48H and &lt;br /&gt;49H. Both devices are interfaced to data bus of an 8088 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Initialization Software. The first portion of the software for this system must program both the &lt;br /&gt;16550 and the 8259A and then enable the INTR pin on the 8088 so that interrupts can take effect. &lt;br /&gt;Example 11-8 lists the software required to program both devices and enable INTR. This soft-&lt;br /&gt;ware uses two memory FlFOs that hold data for the transmitter and for the receiver. Each &lt;br /&gt;memory FIFO is 16K bytes long and is addressed by a pair of pointers (input and output). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0048 &lt;br /&gt;0049 &lt;br /&gt;001B &lt;br /&gt;0080 &lt;br /&gt;0003 &lt;br /&gt;OOFE &lt;br /&gt;0043 &lt;br /&gt;0040 &lt;br /&gt;0041 &lt;br /&gt;0042 &lt;br /&gt;0041 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 BO 8A &lt;br /&gt;0002 E6 43 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C4 BO 78 &lt;br /&gt;0006 E6 40 &lt;br /&gt;0008 BO 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Initialization software for the 16550 and 8259A &lt;br /&gt;;of the circuit in Figure 11-21. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIC1 EQU 48H ;8259A control AD 0 &lt;br /&gt;PIC1 EQU 49H ;8259A control AD 1 &lt;br /&gt;ICW1 EQU 1bH ;8259A ICW1 &lt;br /&gt;ICW2 EQU 80H ;8259A ICW2 &lt;br /&gt;ICW4 EQU 3 ;8259A ICW4 &lt;br /&gt;OCW1 EQU OFEH ;8259A OCW1 &lt;br /&gt;LINE EQU 43H ;16550 line register &lt;br /&gt;LSB EQU 40H ;16550 Baud divisor LSB &lt;br /&gt;MSB EQU 41H ;16550 Baud divisor MSB &lt;br /&gt;FIFO EQU 42H ;16550 FIFO register &lt;br /&gt;ITR EQU 41H ;16550 interrupt register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;START PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Program 16550, but do not enable interrupts yet &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV AL,10001010B ;enable Baud divisor &lt;br /&gt;OUT LINE,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV AL,120 ;program Baud rate &lt;br /&gt;OUT LSB,AL ; 9600 Baud rate &lt;br /&gt;MO'! AL,O &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;456 &lt;br /&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al &lt;br /&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A9 &lt;br /&gt;Al0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Oata Bus (00-07) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Serial Oata &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;U2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111 01 19 40H-47H &lt;br /&gt;2 12 02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13 03 7 &lt;br /&gt;4 14 04 &lt;br /&gt;5 15 05 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 06 ~ 17 07 &lt;br /&gt;9 18 OB p1L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 :~O &lt;br /&gt;lelB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4BH-49H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 00 01 02 ~ 03 04 05 06 07 &lt;br /&gt;10 SIN 11 SOUT &lt;br /&gt;15 BAUOOUT 9 RCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ RTS CTS &lt;br /&gt;~ OTR OSR &lt;br /&gt;=* &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCO &lt;br /&gt;RI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* &lt;br /&gt;OUT 1 &lt;br /&gt;OUT 2 &lt;br /&gt;16550 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 00 01 03 ~ ~ 04 05 U 06 07 &lt;br /&gt;27 AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3~ &lt;br /&gt;r1t WR SPiEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I INTA B259A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;~ &lt;br /&gt;&amp;lt; 10K &lt;br /&gt;;? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO 28 &lt;br /&gt;Al ~ A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CSO 12 &lt;br /&gt;CSl 14 CS2 &lt;br /&gt;MR 35 &lt;br /&gt;RO :*-RO &lt;br /&gt;WR :.:a-WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOS ~ 18.432 MH z &lt;br /&gt;XIN 16 DI XOUT 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TXROY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;m= RXROY OOIS INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRO 1 B &lt;br /&gt;IRl 19 &lt;br /&gt;IR2 &lt;br /&gt;IR3 21 Oth &lt;br /&gt;IR4 22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;er Interrupt Requests &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRS &lt;br /&gt;IR6 &lt;br /&gt;IR7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CASO &lt;br /&gt;-U-CASl Â± CAS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-21 The 16550 UART inteliaced to the 8088 microprocessor through the 8259A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA E6 41 OUT ~lSB,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC BO OA MOV AL,00001010B ;program 7-data, odd &lt;br /&gt;OOOE E6 43 OUT LlNE,AL ;parity, one stop &lt;br /&gt;0010 BO 07 MOV AL,OOOOOl11B ;enable transmitter and &lt;br /&gt;0012 E6 42 OUT FlFO,AL ;and receiver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Program 8259A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 BO 1B MOV AL, lCW1 ; program lCW1 &lt;br /&gt;0016 E6 48 ou'r. PIC1,AL &lt;br /&gt;0018 BO 80 MOV AL, lCW2 ; program lCW2 &lt;br /&gt;001A E6 49 OUT PIC2,AL &lt;br /&gt;001C BO 03 MOV AL,ICW4 ; program lCW4 &lt;br /&gt;001E E6 49 OUT PlC2,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 BO FE MOV AL,OCW1 ;program OCW1 &lt;br /&gt;0022 E6 49 OUT PIC2,AL &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-4 8259A PROGRAMMABLE INTERRUPT CONTROLLER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002'J FE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0025 EO 07 &lt;br /&gt;0027 E6 41 &lt;br /&gt;0029 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable 16550 lnterrupts &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,5 &lt;br /&gt;OUT ITR,AL &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;START ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable system INTR pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable receiver and &lt;br /&gt;;error interrupts &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;457 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first portion of the procedure (START) programs the 16550 UART for operation with &lt;br /&gt;seven data bits, odd parity, one stop bit, and a Baud rate clock of 9600. The FIFO control register &lt;br /&gt;also enables both the transmitter and receiver. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The second part of the procedure programs the 8259A with its three IeWs and its one &lt;br /&gt;oew. The 8259A is set up to function at interrupt vectors 80H-87H and operates with auto-&lt;br /&gt;matic EO!. The leW enables the interrupt for the 16550 UART. Also enabled is the INTR pin of &lt;br /&gt;the microprocessor by using the STI instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The final part of the software enables the receiver and error interrupts of the 16550 UART &lt;br /&gt;through the interrupt control register. The transmitter interrupt is not enabled until data are avail-&lt;br /&gt;able for transmission. Refer to Figure 11-22 for the contents of the interrupt control register of &lt;br /&gt;the 16550 UART. Notice that the control register can enable or disable the receiver, transmitter, &lt;br /&gt;line status (error), and modem interrupts. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Handling the 16550 UART Interrupt Request. Because the 16550 generates only one interrupt &lt;br /&gt;request for various interrupts, the interrupt handler must poll the 16550 to determine what type &lt;br /&gt;of interrupt has occurred. This is accomplished by examining the interrupt identification register &lt;br /&gt;(see Figure 11-23). Note that the interrupt identification register (read-only) shares the same I/O &lt;br /&gt;port as the FIFO control register (write-only). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-22 The 16550 &lt;br /&gt;interrupt control register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-23 The 16550 &lt;br /&gt;interrupt identification register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Enable Receiver Interrupt &lt;br /&gt;0= disabled &lt;br /&gt;1 = enabled &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--___ En~b~e J~~~~~tter Interrupt &lt;br /&gt;1 = enabled &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-------Enable Line Interrupt &lt;br /&gt;0= disabled &lt;br /&gt;1 = enabled &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-------- Enable Modem Interrupt &lt;br /&gt;0= disabled &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Identification Register &lt;br /&gt;76543210 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 = enabled &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Pending &lt;br /&gt;o = interrupt pending &lt;br /&gt;1 = no interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--____ Interrupt Identification Bits &lt;br /&gt;(see Table 11-2) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;458 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt identification register indicates if an interrupt is pending and also the type of in-&lt;br /&gt;terrupt. It also shows if the transmitter and receiver FIFO memories are enabled. Refer to Table 11-2 &lt;br /&gt;for the contents of the interrupt control bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt service procedure must examine the contents of the interrupt identification &lt;br /&gt;register to determine what event caused the interrupt and pass control to the appropriate proce-&lt;br /&gt;dure for the event. Example 11-9 shows the first part of an interrupt handler that passes control &lt;br /&gt;to RECV for a receiver data interrupt, TRANS for a transmitter data interrupt, and ERR for a line &lt;br /&gt;status error interrupt. Note that the modem status is not tested in this example. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-9 &lt;br /&gt;;Interrupt handler for the 16550 UART of &lt;br /&gt;;Figure 11-21. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 INT80 PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 50 PUSH AX &lt;br /&gt;0001 E4 42 IN AL,42H ;input interrupt ID reg &lt;br /&gt;0003 3C 06 CMP AL,6 ;test for error &lt;br /&gt;0005 74 20 JE ERR ;for receiver error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 3C 02 CMP AL,2 ;test for transmitter &lt;br /&gt;0009 74 55 JE TRANS ;for transmitter ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOB 3C 04 CMP AL,4 ;test for receiver &lt;br /&gt;OOOD 74 11 JE RECV ;for receiver ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Receiving Data from the 16550. The data received by the 16550 are stored, not only the FIFO &lt;br /&gt;within the DART, but also in a FIFO memory until the software in the main program can use &lt;br /&gt;them. The FIFO memory used for received data is 16K bytes long, so many characters can easily &lt;br /&gt;be stored and received before any intervention from the microprocessor is required to empty the &lt;br /&gt;receiver's memory FIFO. The receiver memory FIFO is stored in the extra segment so string in-&lt;br /&gt;structions, using the DI register, can be used to access it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Receiving data from the 16550 requires two procedures: one reads the data register of the &lt;br /&gt;16550 each time that the INTR pin requests an interrupt and stores it into the memory FIFO, and &lt;br /&gt;the other reads data from the memory FIFO from the main program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 11-2 The interrupt control bits of the 16550 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bitt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BitO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Priority &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: 1 is the highest priority and 4 the lowest. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;No interrupt &lt;br /&gt;Receiver error (parity, &lt;br /&gt;framing, overrun, or break) &lt;br /&gt;Receiver data available &lt;br /&gt;Character time-out, nothing &lt;br /&gt;has been removed from the &lt;br /&gt;receiver FIFO for at least &lt;br /&gt;four character times &lt;br /&gt;Transmitter empty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Modem status &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reset Control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reset by reading the line &lt;br /&gt;register &lt;br /&gt;Reset by reading the data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reset by reading the data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reset by writing to the &lt;br /&gt;transmitter &lt;br /&gt;Reset by reading the &lt;br /&gt;modem status &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-4 8259A PROGRAMMABLE INTERRUPT CONTROLLER 459 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 11-10 lists the procedure used to read data from the memory FIFO from the main &lt;br /&gt;program. This procedure assumes that the pointers (lIN and lOUT) are initialized in the initialization &lt;br /&gt;dialog for the system (not shown). The READ procedure returns with AL containing a character read &lt;br /&gt;from the memory FIFO. If the memory FIFO is empty, the procedure retUI11S with the carry flag bit &lt;br /&gt;S~~ to a logic I. If AL contains a valid character, the carry flag bit is cleared upon return from READ. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice how the FIFO is reused by changing the address from the top of the FIFO to the &lt;br /&gt;bottom whenever it exceeds the start of the FIFO plus 16K. This is located at the CMP instruc-&lt;br /&gt;tion at offset address 0015. Also nOlice that interrupts are enabled at the end of this procedure in &lt;br /&gt;case they are disabled by a full memory FIFO condition by the RECV interrupt procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0002 26: 8B 3E &lt;br /&gt;0007 26 : 8B lE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC 3B DF &lt;br /&gt;OOOE F9 &lt;br /&gt;OOOF 74 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0011 26: BA 06 &lt;br /&gt;0014 47 &lt;br /&gt;0015 81 FF 4000 &lt;br /&gt;0019 26: 89 3E &lt;br /&gt;001E 76 07 &lt;br /&gt;0020 26: C7 06 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 R &lt;br /&gt;0027 &lt;br /&gt;0027 F8 &lt;br /&gt;0028 &lt;br /&gt;0028 9C &lt;br /&gt;0029 E4 41 &lt;br /&gt;002B 06 05 &lt;br /&gt;002D E6 41 &lt;br /&gt;002F 9D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0033 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that reads one character from the memory &lt;br /&gt;;FIFO and returns with it in AL. &lt;br /&gt;;If the FIFO is empty the return occurs with Carry = 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ PROC NEAR USES BX DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R MOV DI,IOUT ;get output pointer &lt;br /&gt;4000 R Mm' BX, IIN ;get input pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP BX,DI ;compare pointers &lt;br /&gt;S'IC ;set carry flag &lt;br /&gt;JE DONEl ;if empty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV AL,ES: [DI] ;get data from FIFO &lt;br /&gt;INC DI ;address next byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R CHP DI,OFFSET FIFO+16*1024 &lt;br /&gt;4002 R MOV lOUT, DI ;save pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JBE DONE ;if within bounds &lt;br /&gt;4002 R MOV IOUT,OFFSET FIFO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DONE: &lt;br /&gt;CLC ;clear carry flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DONE1 : &lt;br /&gt;PUSHF ;save carry flag &lt;br /&gt;IN AL,41H ;read interrupt control &lt;br /&gt;OR AL,5 ;enable receiver interrupts &lt;br /&gt;OUT 41H,AL &lt;br /&gt;POPF &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READ ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 11-11 lists the RECV interrupt service procedure that is called each time the &lt;br /&gt;16550 receives a character for the microprocessor. In this example, this interrupt uses vector type &lt;br /&gt;number 80H, which must address the interrupt handler of Example 11-9. Each time this interrupt &lt;br /&gt;occurs, the REVC procedure is accessed by the interrupt handler reading a character from the &lt;br /&gt;16550. The RECV procedure stores the character into the memory FIFO. If the memory FIFO is &lt;br /&gt;full, the receiver interrupt is disabled by the interrupt control register within the 16550. This may &lt;br /&gt;result in lost data, but at least it will not cause the interrupt to overrun valid data already stored in &lt;br /&gt;the memory FIFO. Any error conditions detected by the 8251A store a ? (3FH) in the memory &lt;br /&gt;FIFO. Note that errors are detected by the ERR portion of the interrupt handler (not shown). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 &lt;br /&gt;0020 53 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;RECV portion of the :~cerrupt handler in Example &lt;br /&gt;; 11-9. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RECV: &lt;br /&gt;PUSH BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;continues from Exa 11-9 &lt;br /&gt;isave registers &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;460 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0021 57 PUSH DI &lt;br /&gt;0022 56 PUSH SI &lt;br /&gt;0023 26: 8B 1E 4002 R MOV BX,IOUT ;load output pointer &lt;br /&gt;0028 26: 8B 36 4000 R MOV SI, IIN ;load input pointer &lt;br /&gt;002D 8B FE MOV DI,SI &lt;br /&gt;002F 46 INC SI &lt;br /&gt;0030 81 FE 4000 R CMP SI,OFFSET FIFO+16*1024 &lt;br /&gt;0034 76 03 JBE NEXT &lt;br /&gt;0036 BE 0000 R MOV SI,OFFSET FIFO &lt;br /&gt;0039 NEXT: &lt;br /&gt;0039 3B DE CMP BX,SI ;is FIFO full? &lt;br /&gt;003B 74 OB JE FULL ;if it is full &lt;br /&gt;003D E4 40 IN AL,40H ; read 16550 receiver &lt;br /&gt;003F AA STOSB ;save it in FIFO &lt;br /&gt;0040 26: 89 36 4000 R MOV IIN, SI ;save input pointer &lt;br /&gt;0045 EB 06 90 JMP DONE ;end up &lt;br /&gt;0048 FULL &lt;br /&gt;0048 E4 41 IN AL,41H ;read interrupt control &lt;br /&gt;004A 24 FA AND AL,OFAH ;disable receiver &lt;br /&gt;004C E6 41 OUT 41H,AL &lt;br /&gt;004E DOlJE: &lt;br /&gt;004E BO 20 MOV AL,20H ;signal 8259A EOI &lt;br /&gt;0050 E6 49 OUT 49H,AL &lt;br /&gt;0052 5E POP SI ;restore registers &lt;br /&gt;0053 5F POP DI &lt;br /&gt;0054 5B POP BX &lt;br /&gt;0055 58 POP AX &lt;br /&gt;0056 CF IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Transmitting Data to the 16550. Data are transmitted to the 16550 in much the same manner as &lt;br /&gt;they are received, except that the interrupt service procedure removes transmit data from a &lt;br /&gt;second 16K-byte memory FIFO. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 11-12 lists the procedure that fills the output FIFO. It is similar to the procedure &lt;br /&gt;listed in Example 11-10, except that it determines whether the FIFO is full instead .of empty. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-12 &lt;br /&gt;;A procedure that places data into the memory FIFO for &lt;br /&gt;;t~ansmission by the transmitter interrupt. &lt;br /&gt;;.~L = character to be transmitted. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 SAVE PROC NEAR USES BX DI SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003 26: 8B 36 8004 R MOV SI,OIN ;get input pointer &lt;br /&gt;0008 26: 8B 1E 8006 R MOV BX,OOUT ;get output pointer &lt;br /&gt;OOOD 8B FE MOV DI,SI &lt;br /&gt;OOOF 46 INC SI &lt;br /&gt;0010 81 FE 8004 R CMP SI,OFFSET OFIFO+16*1024 &lt;br /&gt;0014 76 03 JBE NEXT &lt;br /&gt;0016 BE 4004 R MOV SI,OFFSET OFIFO &lt;br /&gt;0019 NEXT: &lt;br /&gt;0019 3B DE CMP BX,SI &lt;br /&gt;001B 74 06 JE DONE ;if full &lt;br /&gt;001D AA STOSB isave data in OFIFO &lt;br /&gt;001E 26: 89 36 8004 R MOV OIN,SI &lt;br /&gt;0023 DO!'JE: &lt;br /&gt;0023 E4 41 IN AL,41H ;read interrupt control &lt;br /&gt;0025 06 01 OR AL,l ;enable transmitter &lt;br /&gt;0027 E6 41 OUT 41H,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;002D S.;VE ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 11-131ists the interrupt service subroutine for the 16550 DART transmitter. This pro-&lt;br /&gt;cedure is a continuation of the interrupt handler presented in Example 11-9 and is similar to the &lt;br /&gt;RECV procedure of Example II-II, except that it determines whether the FIFO is empty rather than &lt;br /&gt;full. Note that we do not include an interrupt service procedure for the break interrupt or any errors. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-4 8259A PROGRAMMABLE INTERRUPT CONTROLLER 461 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-13 &lt;br /&gt;; Interrupt service procedure for the 16550 &lt;br /&gt;;transmitter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0060 TEAUS: &lt;br /&gt;0060 5~ PUSH BX ;save registers 0061 7 PUSH DI &lt;br /&gt;0062 2 : 8B 1E 8004 R MOV BX,OIN ;load input pointer &lt;br /&gt;0068 iii: 8B 3E 8006 R MOV DI,OOUT ;load output pointer &lt;br /&gt;006D ,B DF CMP BX, DI &lt;br /&gt;006F 74 17 JE EMPTY ; if empty &lt;br /&gt;0071 26: 8A 05 MOV AL,ES:[DI] ;get character &lt;br /&gt;0074 E6 40 OUT 40H,AL ;send it to UART &lt;br /&gt;0076 47 INC DI &lt;br /&gt;0077 81 FF 8004 R CMP DI,OFFSET OFIFO+16*1024 &lt;br /&gt;007B 76 03 JBE NEXT1 &lt;br /&gt;007D BF 4004 R NOV DI,OFFSET OFIFO &lt;br /&gt;0080 NEXT1 : &lt;br /&gt;0080 26: 89 3E 8006 R MOV OOUT,DI &lt;br /&gt;0085 EB 07 90 JMP DONES &lt;br /&gt;0088 EMPTY: &lt;br /&gt;0088 E4 41 IN AL,41H ;read interrupt control &lt;br /&gt;008A 24 FD AND AL,OFDH ;disable transmitter &lt;br /&gt;008C E6 41 OUT 41H,AL &lt;br /&gt;008E DONES: &lt;br /&gt;008E BO 20 MOV 1'.L,20H ;signal 82591'. EOI &lt;br /&gt;0090 E6 49 OUT 49H,AL &lt;br /&gt;0092 SF POP DI &lt;br /&gt;0093 58 POP BX &lt;br /&gt;0094 58 POP AX &lt;br /&gt;0095 CF IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 16550 also contains a scratch register. This is a general purpose register that can be &lt;br /&gt;used in any way deemed necessary by the programmer. Also contained within the 16550 are a &lt;br /&gt;modem control register and a modem status register. These registers allow the modem to cause &lt;br /&gt;interrupt and also control the operation of the 16550 with a modem. Refer to Figure 11-24 for &lt;br /&gt;the contents of both the modem status register and the modem control register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DTRpin _ &lt;br /&gt;a = 1 on DTR pin &lt;br /&gt;1 = a on DTR pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RTSpin _ &lt;br /&gt;a = 1 on RTS pin &lt;br /&gt;1 = a on RTS pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'----- OUT 1 pin __ &lt;br /&gt;a = 1 on OUT 1 pin &lt;br /&gt;1 = a on OUT 1 pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-_____ OUT 2 pin __ &lt;br /&gt;a = 1 on OUT 2 pin &lt;br /&gt;1 = a on OUT 2 pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-______ Loopback control &lt;br /&gt;a = no operation &lt;br /&gt;1 = selects loopback test &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CTS has changed &lt;br /&gt;a = no change &lt;br /&gt;1 = CTS has changed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DSR has changed &lt;br /&gt;a = no change &lt;br /&gt;1 = DSR has changed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-____ Trailing edge 01 Ai &lt;br /&gt;a = no change &lt;br /&gt;1 = trailing edge olRI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-_____ DCD has changed &lt;br /&gt;a = no change &lt;br /&gt;1 = DCD has changed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--______ CTS pin &lt;br /&gt;a = 1 on CTS pin &lt;br /&gt;1 = a on CTS pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-________ DSR pin _ &lt;br /&gt;a = 1 on DSR pin &lt;br /&gt;1 = a on DSR pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---_________ Ai pin _ &lt;br /&gt;a = 1 on RI pin &lt;br /&gt;1 = a onRI pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-__________ DCD pin _ &lt;br /&gt;a = 1 or, DCD pin &lt;br /&gt;1 = a on DCD pin &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-24 The 16550 modem control and modem status registers &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;462 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul &lt;br /&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CSO &lt;br /&gt;CSl &lt;br /&gt;CS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 ~~ &lt;br /&gt;RO &lt;br /&gt;WR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 !'6's &lt;br /&gt;XIN &lt;br /&gt;XOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TXROY &lt;br /&gt;RXROY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30 ~~~ &lt;br /&gt;16550 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;D3 &lt;br /&gt;D4 &lt;br /&gt;OS &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SIN H'~--++-+..., &lt;br /&gt;SOUT~~--+~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BAUOOUT &lt;br /&gt;RCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTl &lt;br /&gt;OUT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.----..!-.-.i &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1489 Pl &lt;br /&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1488 &lt;br /&gt;1 &lt;br /&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18 &lt;br /&gt;5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;1488 3 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;6 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;1488 RS-232C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1489 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-25 The 16550 interfaced to RS-2332C using 1488 line drivers and 1489 line &lt;br /&gt;receivers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The modem control register uses bit positions 0-3 to control various pins on the 16550. Bit &lt;br /&gt;position 4 enables the internal loop-back test for testing purposes. The modem status register al-&lt;br /&gt;lows the status of the modem pins to be tested; it also allows the modem pins to be checked for a &lt;br /&gt;change or, in the case of RI, a trailing edge. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 11-25 illustrates the 16550 UART connected to an RS-232C interface that is often &lt;br /&gt;used to control a modem. Included in this interface are line driver and receiver circuits used to &lt;br /&gt;convert between TTL levels on the 16550 to RS-232C levels found on the interface. Note that &lt;br /&gt;RS-232C levels are usually +12V for a logic 0 and -12V for a logic 1 level. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to transmit or receive data through the modem, the DTR pin is activated (logic 0) &lt;br /&gt;and the UART then waits for the DSR pin to become a logic 0 from the modem, indicating that &lt;br /&gt;the modem is ready. Once this handshake is complete, the UART sends the modem a logic 0 on &lt;br /&gt;the RTS pin. When the modem is ready, it returns the CTS signal (logic 0) to the UART. Com-&lt;br /&gt;munications can now commence. The DCD signal from the modem is an indication that the &lt;br /&gt;modem has detected a carrier. This signal must also be tested before communications can begin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REAL-TIME CLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the text presents a real-time clock as an example use of an interrupt. A realÂ·timl &lt;br /&gt;clock keeps time in real time-that is, in hours and minutes. The example illustrated here keeps &lt;br /&gt;time in hours, minutes, seconds, and 1/60 seconds using four memory locations to hold the BCD &lt;br /&gt;time of day. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 11-26 illustrates :\\ simple circuit that uses the 60 Hz AC power line to generate a &lt;br /&gt;periodic interrupt request signal for the NMI inh.:rrupt input pin. Although we are using a signal &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-5 REAL-TIME CLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 11-26 Converting &lt;br /&gt;the AC power line to a 60 Hz &lt;br /&gt;TIL signal for the NMI input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;463 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMI &lt;br /&gt;120VAC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;from ihe AC powel line, which varies slightly in frequency [mm timc to time, it is accurate over &lt;br /&gt;a period of time. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The circuit uses a signal from the 120 V AC power line that is conditioned by a Schmitt-&lt;br /&gt;trigger inverter before it is applied to the NMI interrupt input. Note that you must make certain &lt;br /&gt;that the power line ground is connected to the system ground in this schematic. The power line &lt;br /&gt;ground (neutral) connection is the large flat pin on the power line. The narrow flat pin is the hot &lt;br /&gt;side or 120 VAC side of the line. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The software for the real-time clock contains an interrupt service procedure that is called &lt;br /&gt;60 times per second and a procedure that updates the count located in four memory locations. &lt;br /&gt;Example 11-14 lists both procedures along with the four bytes of memory used to hold the BCD &lt;br /&gt;time of day. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 11-14 &lt;br /&gt;. MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 EB 04 JMP TIMES &lt;br /&gt;0102 00 TIME DB ;1/60 second counter &lt;br /&gt;0103 00 DB ;seconds counter &lt;br /&gt;0104 00 DB ;minutes counter &lt;br /&gt;0105 00 DB ;hours counter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; Interrupt handler for NIH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 TIMES PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0106 50 PUSH AX ;save registers &lt;br /&gt;0107 56 PUSH SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0108 B4 60 MOV AH,60H ;load modulus 60 &lt;br /&gt;010A BE 0102 R MOV SI,OFFSET TIME ;address time &lt;br /&gt;010D E8 0014 CALL UP ; increment 1/60 counter &lt;br /&gt;0110 75 OF JNZ DONE &lt;br /&gt;0112 E8 OOOF CALL UP ; increment seconds &lt;br /&gt;0115 75 OA JNZ DONE &lt;br /&gt;0117 E8 OOOA CALL UP ; increment minutes &lt;br /&gt;011A 75 05 JNZ DONE &lt;br /&gt;011C B4 24 MOV AH,24H ;load modulus 24 &lt;br /&gt;011E E8 0003 CALL UP ;increment minutes &lt;br /&gt;0121 DONE: &lt;br /&gt;0121 5E POP 81 ;reload registers &lt;br /&gt;0122 58 POP AX &lt;br /&gt;0123 CF IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0124 TIMES ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0124 UP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0124 2E: 8A 04 MOV AL,C8: lSI] ;get count &lt;br /&gt;0127 46 INC SI ;address next counter &lt;br /&gt;0128 04 01 ADD AL,l iincrement count &lt;br /&gt;012.'\\ 27 DAA imake it BCD &lt;br /&gt;012B 2E: 88 44 FF MOV C8: [SI-1] ,AL isave count &lt;br /&gt;012F 2A C4 SUB AL,AH ;test modulus &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;464 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0131 75 04 JNZ UP1 &lt;br /&gt;0133 2E: 88 44 FF MOV CS: [SI-1],AL ;clear count &lt;br /&gt;0137 UP1: &lt;br /&gt;0137 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0138 UP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;1. An interrupt is a hardware- or software-initiated call that interrupts the currently executing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;program at any point and calls a procedure. The procedure is called by the interrupt handler &lt;br /&gt;or an interrupt service procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Interrupts are useful when an I/O device needs to be serviced only occasionally at low data &lt;br /&gt;transfer rates. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The microprocessor has five instructions that apply to interrupts: BOUND, INT, INT 3, &lt;br /&gt;INTO, and IRET. The INT and INT 3 instructions call procedures with addresses stored in &lt;br /&gt;interrupt vector whose type is indicated by the instruction. The BOUND instruction is a con-&lt;br /&gt;ditional interrupt that uses interrupt vector type number 5. The INTO instruction is a condi-&lt;br /&gt;tional interrupt that interrupts a program only if the overflow flag is set. Finally, the IRET &lt;br /&gt;instruction is used to return from interrupt service procedures. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. The microprocessor has three pins that apply to its hardware interrupt structure: INTR, NMI, &lt;br /&gt;and INT A. The interrupt inputs are INTR and NMI, which are used to request interrupts. &lt;br /&gt;INT A is an output used to acknowledge the INTR interrupt request. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Real mode interrupts are referenced through a vector table that occupies memory locations &lt;br /&gt;OOOOOH-003FFH. Each interrupt vector is four bytes long and contains the offset and seg-&lt;br /&gt;ment addresses of the interrupt service procedure. In protected mode, the interrupts refer-&lt;br /&gt;ence the interrupt descriptor table (IDT) that contains 256 interrupt descriptors. Each &lt;br /&gt;interrupt descriptor contains a segment selector and a 32-bit offset address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Two flag bits are used with the interrupt structure of the microprocessor: trap (TF) and in-&lt;br /&gt;terrupt enable (IF). The IF flag bit enables the INTR interrupt input, and the TF flag bit &lt;br /&gt;causes interrupts to occur after the execution of each instruction as long as TF is active .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. The first 32 interrupt vector locations are reserved for Intel use, with many predefined in the &lt;br /&gt;microprocessor. The last 224 interrupt vectors are for user use and can perform any function &lt;br /&gt;desired. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Â·Whenever an interrupt is detected, the following events occur: (I) the flags are pushed onto &lt;br /&gt;the stack, (2) the IF and TF flag bits are both cleared, (3) the IP and CS registers are both &lt;br /&gt;pushed onto the stack, and (4) the interrupt vector is fetched from the interrupt vector table &lt;br /&gt;and the interrupt service subroutine is accessed through the vector address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. Tracing or single-stepping is accomplished by setting the TF flag bit. This causes an inter-&lt;br /&gt;rupt to occur after the execution of each instruction for debugging. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The non-maskable interrupt input (NMI) calls the procedure whose address is stored at in-&lt;br /&gt;terrupt vector type number 2. This input is positive-edge triggered. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. The INTR pin is not internally decoded as is the NMI pin. Instead, INT A is used to apply the &lt;br /&gt;interrupt vector type number to data bus connections Do-D7 during the INTA pulse. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. Methods of applying the interrupt vector type number to the data bus during INTA vary &lt;br /&gt;widely. One method uses resistors to apply interrupt type number FFH to the data bus, while &lt;br /&gt;another uses a three-state buffer to apply any vector type number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. The 8259A programmable interrupt controller (PIC) adds at least eight interrupt inputs to &lt;br /&gt;the microprocessor. If more interrupts are needed, this device'can be cascaded to provide up &lt;br /&gt;to 64 interrupt inputs. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;11-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11-7 QUtSTIONS AND PROBLEMS &lt;br /&gt;\\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;465 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. Programming the 8259A is a two-step process. First, a series of initialization command &lt;br /&gt;words (lCWs) are sent to the 8259A; then a series of operation command words (OCWs) are &lt;br /&gt;sent. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. The 8259A contains three status registers: IMR (interrupt mask register), ISR (in-service &lt;br /&gt;register), and IRR (interrupt request register). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. A real-time clock is used to keep time in real-time. In most cases, time is stored in either &lt;br /&gt;binary or BCD form in several memory locations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;I. What is interrupted by an interrupt? &lt;br /&gt;2. Define the term interrupt. &lt;br /&gt;3. What is called by an interrupt? &lt;br /&gt;4. Why do interrupts free up time for the microprocessor? &lt;br /&gt;5. List the interrupt pins found on the microprocessor. &lt;br /&gt;6. List the five interrupt instructions for the microprocessor. &lt;br /&gt;7. What is an interrupt vector? &lt;br /&gt;8. Where are the interrupt vectors located in the microprocessor's memory? &lt;br /&gt;9. How many different interrupt vectors are found in the interrupt vector table? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Which interrupt vectors are reserved by Intel? &lt;br /&gt;11. Explain how a type 0 interrupt occurs. &lt;br /&gt;12. Where is the interrupt descriptor table located for protected mode operation? &lt;br /&gt;13. Each protected mode interrupt descriptor contains what information? &lt;br /&gt;14. Describe the differences between a protected and real mode interrupt. &lt;br /&gt;15. Describe the operation of the BOUND instruction. &lt;br /&gt;16. Describe the operation of the INTO instruction. &lt;br /&gt;17. What memory locations contain the vector for an INT 44H instruction? &lt;br /&gt;18. Explain the operation of the IRET instruction. &lt;br /&gt;19. What is the purpose of interrupt vector type number 7? &lt;br /&gt;20. List the events that occur when an interrupt becomes active. &lt;br /&gt;21. Explain the purpose of the interrupt flag (IF). &lt;br /&gt;22. Explain the purpose of the trap flag (TF). &lt;br /&gt;23. How is IF cleared and set? &lt;br /&gt;24. How is TF cleared and set? &lt;br /&gt;25. The NMI interrupt input automatically vectors through which vector type number? &lt;br /&gt;26. Does the INT A signal activate for the NMI pin? &lt;br /&gt;27. The INTR input is -sensitive. &lt;br /&gt;28. The NMI input is -sensItIve. &lt;br /&gt;29. When the INTA signal becomes a logic 0, it indicates that the microprocessor is waiting for &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;an interrupt number to be placed on the data bus (Do-D7). &lt;br /&gt;30. What is a FIFO? &lt;br /&gt;31. Develop a circuit that places interrupt type number 86H on the data bus in response to the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR input. &lt;br /&gt;32. Develop a circuit that places interrupt type number CCH on the data bus in response to the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR input. &lt;br /&gt;33. Explain why pull-up resistors on Do-D7 cause the microprocessor to respond with interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vector type number FFH for the INT A pulse. &lt;br /&gt;34. What is a daisy-chain? &lt;br /&gt;35. Why must interrupting devices be polled in a daisy-chained interrupt system? &lt;br /&gt;36. What is the 8259A? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;466 CHAPTER 11 INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37. How many 8259As are required to have 64 interrupt inputs? &lt;br /&gt;38. What is the purpose of the IRO-IR7 pins on the 8259A? &lt;br /&gt;39. When are the CAS2-CASO pins used on the 8259A? &lt;br /&gt;40. Where is a slave INT pin connected on the master 8259A in a cascaded system? &lt;br /&gt;41. What is an ICW? &lt;br /&gt;42. What is an OCW? &lt;br /&gt;43. How many ICWs are needed to program the 8259A when operated as a single master in a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;system? &lt;br /&gt;44. Where is the vector type number stored in the 8259A? &lt;br /&gt;45. Where is the sensitivity of the IR pins programmed in the 8259A? &lt;br /&gt;46. What is the purpose of ICWl? &lt;br /&gt;47. What is a non-specific EOI? &lt;br /&gt;48. Explain priority rotation in the 8259A. &lt;br /&gt;49. What is the purpose of IRR in the 8259A? &lt;br /&gt;50. At which liD ports is the master 8259A PIC found in the personal computer? &lt;br /&gt;51. At which liD ports is the slave 8259A found in the personal computer? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\CHAPTER 12 &lt;br /&gt;Direct Memory Access and &lt;br /&gt;DMA-Controlled I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In previous chapters, we discussed basic and interrupt-processed liD. Now we tum to the &lt;br /&gt;final form of liD called direct memory access (DMA). The DMA liD technique provides direct &lt;br /&gt;access to the memory while the microprocessor is temporarily disabled. This allows data to be &lt;br /&gt;transferred between memory and the liD device at a rate that is limited only by the speed of &lt;br /&gt;the memory components in the system or the DMA controller. The DMA transfer speed can &lt;br /&gt;approach 15-20 M-byte transfer rates with today's high-speed RAM memory components. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA transfers are used for many purposes, but more common are DRAM refresh, video &lt;br /&gt;displays for refreshing the screen, and disk memory system reads and writes. The DMA &lt;br /&gt;transfer is also used to do high-speed memory-to-memory transfers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This chapter also explains the operation of disk memory systems and video systems that &lt;br /&gt;are often DMA processed. Disk memory includes floppy, fixed, and optical disk storage. Video &lt;br /&gt;systems include digital and analog monitors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Describe a DMA transfer. &lt;br /&gt;2. Explain the operation of the HOLD and HLDA direct memory access control signals. &lt;br /&gt;3. Explain the function of the 8237 DMA controller when used for DMA transfers. &lt;br /&gt;4. Program the 8237 to accomplish DMA transfers. &lt;br /&gt;5. Describe the disk standards found in personal computer systems. &lt;br /&gt;6. Describe the various video interface standards that are found in the personal computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BASIC DMA OPERATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Two control signals are used to request and acknowledge a direct memory access (DMA) &lt;br /&gt;transfer in the microprocessor-based system. The HOLD pin is an input used to request a DMA &lt;br /&gt;action, and the HLDA pin is an output that acknowledges the DMA action. Figure 12-1 shows &lt;br /&gt;the timing that is typically found on these two DMA control pins. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;467 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;468 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-1 HOLD &lt;br /&gt;and HLDA timing for the &lt;br /&gt;8086/8088 microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever the HOLD input is placed at a logic 1 level, a DMA action (hold) is requested. The &lt;br /&gt;microprocessor responds, within a few clocks, by suspending the execution of the program and &lt;br /&gt;by placing its address, data, and control bus at their high-impedance states. The high-impedance &lt;br /&gt;state causes the microprocessor to appear as if it has been removed from its socket. This state &lt;br /&gt;allows external I/O devices or other microprocessors to gain access to the system buses so memory &lt;br /&gt;can be accessed directly. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As the timing diagram indicates, HOLD is sampled in the middle of any clocking cycle. &lt;br /&gt;Thus, the hold can take effect at any time during the operation of any instruction in the micro-&lt;br /&gt;processor. As soon as the microprocessor recognizes the hold, it stops executing software and &lt;br /&gt;enters hold cycles. Note that the HOLD input has a higher priority than the INTR or NMI inter-&lt;br /&gt;rupt inputs. Interrupts take effect at the end of an instruction, while a HOLD takes effect in the &lt;br /&gt;middle of an instruction. The only microprocessor pin that has a higher priority than a HOLD is &lt;br /&gt;the RESET pin. Note that the HOLD input may not be active during a RESET or the reset is not &lt;br /&gt;guaranteed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The HLDA signal becomes active to indicate that the microprocessor has indeed placed its &lt;br /&gt;buses at their high-impedance states, as can be seen in the timing diagram. Note that there are a &lt;br /&gt;few clock cycles between the time that HOLD changes until the time that HLDA changes. The &lt;br /&gt;HLDA output is a signal to the external requesting device that the microprocessor has relin-&lt;br /&gt;quished control of its memory and I/O space. You could call the HOLD input a DMA request &lt;br /&gt;input and the HLDA output a DMA grant signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Basic DMA Definitions &lt;br /&gt;Direct memory accesses normally occur between an I/O device and memory without the use of &lt;br /&gt;the microprocessor. A DMA read transfers data from the memory to the I/O device. A DMA &lt;br /&gt;write transfers data from an I/O device to memory. In both operations, the memory and I/O &lt;br /&gt;are controlled simultaneously, which is why the system contains separate memory and I/O &lt;br /&gt;control signals. This special control bus structure of the microprocessor allows DMA trans-&lt;br /&gt;fers. A DMA read causes the MRDC and 10WC signals both to activate, transferring data &lt;br /&gt;from the memory to the I/O device. A DMA write causes the MWTC and 10RC signals both &lt;br /&gt;to activate. These control bus signals are available to all microprocessors in the Intel family, &lt;br /&gt;except the 8086/8088 system. The 8086/8088 require their generation with either a system &lt;br /&gt;controller or a circuit such as the one illustrated in Figure 12-2. The DMA controller provides &lt;br /&gt;the memory with its address, and a signal from the controller (DACK) selects the I/O device &lt;br /&gt;during the DMA transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The data transfer speed is determined by the speed of the memory device or a DMA con-&lt;br /&gt;troller that often controls DMA transfers. If the memory speed is 100 ns, DMA transfers occur at &lt;br /&gt;rates of up to 1/100 ns or 10 lvI-bytes per second. If the DMA controller in a system functions at &lt;br /&gt;a maximum rate of 5 MHz and we stilI use 100 ns memory, the maximum transfer rate is 5 MHz &lt;br /&gt;because the DMA controller is slower than the memory. In many cases, the DMA controller &lt;br /&gt;slows the speed of the system when DMA transfers occur. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;/ &lt;br /&gt;J 469 12-2 THE 8237 DMA CONTROLLER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-2 A circuit that Vee &lt;br /&gt;generates system control sig-&lt;br /&gt;nals in a DMA environment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W/R ___ y &lt;br /&gt;2 1A 4 IORC 3 1B 1Y 2 5 2A 7 IOWC 6 2Y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 2B 9 3A 3Y MRDC 10 3B 12 &lt;br /&gt;4A 4Y MWTC &lt;br /&gt;4B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 G 1 AlB &lt;br /&gt;HLDA ____________________ ~a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/iO ___________________ --!.....I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F257 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE 8237 DMA CONTROLLER &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8237 DMA controller supplies the memory and 110 with control signals and memory ad-&lt;br /&gt;dress information during the DMA transfer. The 8237 is actually a special purpose micro-&lt;br /&gt;processor whole job is high-speed data transfer between memory and the 110. Figure 12-3 shows &lt;br /&gt;the pin-out and block diagram of the 8237 programmable DMA controller. Although this device &lt;br /&gt;may not appear as a discrete component in modern microprocessor-based systems, it does appear &lt;br /&gt;within system controller chip sets found in most newer systems. Although not described because &lt;br /&gt;of its complexity, the chip set (82357 ISP or integrated peripheral controller), and its integral set &lt;br /&gt;of two DMAcontrollers, are programmed exactly as the 8237. The ISP also provides a pair of &lt;br /&gt;8259A progr~mmable interrupt controllers for the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8237 is a four-channel device that is compatible to the 8086/8088 microprocessors. The &lt;br /&gt;8237 can be expanded to include any number of DMA channel inputs, although four channels &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-3 The 8237A-5 programmable DMA controller. (a) Block diagram, and (b) pin-out (Courtesy of Intel &lt;br /&gt;Corporation) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;470 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;seem to Ill' adequate for many small systems. The 8237 is capable of DMA transfers at rates of &lt;br /&gt;LIp to 1.6M bytes per second. Each channel is capable of addressing a full 64K-byte section of &lt;br /&gt;memory and can transfer up to 64K bytes with a single programming. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Definitions &lt;br /&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HLDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HRQ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADSTB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The clock input is connected to the system clock signal as long as that signal is &lt;br /&gt;5 MHz or less. In the 8086/8088 system, the clock must be inverted for the &lt;br /&gt;proper operation of the 8237. &lt;br /&gt;Chip select enables the 8237 for programming. The CS pin is nonnally con-&lt;br /&gt;nected to the output of a decoder. The decoder does not use the 8086/8088 &lt;br /&gt;control signal 101M (MiIO) because it contains the new memory and I/O &lt;br /&gt;control signals (MEMR, MEMW, lOR, and lOW). &lt;br /&gt;The reset pin clears the command, status, request, and temporary registers. It &lt;br /&gt;also clears the first/last flip-flop and sets the mask register. This input primes &lt;br /&gt;the 8237 so it is disabled until programmed otherwise. &lt;br /&gt;A logic 0 on the ready input causes the 8237 to enter wait states for slower &lt;br /&gt;memory and/or I/O components. &lt;br /&gt;A hold acknowledge signals the 8237 that the microprocessor has relinquished &lt;br /&gt;control of the address, data, and control buses. &lt;br /&gt;The DMA request inputs are used to request a DMA transfer for each of the &lt;br /&gt;four DMA channels. Because the polarity of these inputs is programmable, &lt;br /&gt;they are either active-high or active-low inputs. &lt;br /&gt;The data bus pins are connected to the microprocessor data bus connections &lt;br /&gt;and are used during the programming of the DMA controller. &lt;br /&gt;I/O read is a bi-directional pin used during programming and during a DMA &lt;br /&gt;write cycle. &lt;br /&gt;I/O write is a bi-directional pin used during programming and during a DMA &lt;br /&gt;read cycle. &lt;br /&gt;End-or-process is a bi-directional signal that is used as an input to tenninate a &lt;br /&gt;DMA process or as an output to signal the end of the DMA transfer. This input &lt;br /&gt;is often used to interrupt a DMA transfer at the end of a DMA cycle. &lt;br /&gt;These address pins select an internal register during programming and also &lt;br /&gt;provide part of the DMA transfer address during a DMA action. &lt;br /&gt;These address pins are outputs that provide part of the DMA transfer address &lt;br /&gt;during a DMA action. &lt;br /&gt;Hold request is an output that connects to the HOLD input of the &lt;br /&gt;microprocessor in order to request a DMA transfer. &lt;br /&gt;DMA channel acknowledge outputs acknowledge a channel DMA request. &lt;br /&gt;These outputs are programmable as either active-high or active-low signals. The &lt;br /&gt;DACK outputs are often used to select the DMA-controlled I/O device during &lt;br /&gt;the DMA transfer. &lt;br /&gt;The address enable signal enables the DMA address latch connected to the &lt;br /&gt;DB7-DBo pins on the 8237. It is also used to disable any buffers in the system &lt;br /&gt;connected to the microprocessor. &lt;br /&gt;Address strobe functions as ALE, except that it is used by the DMA controller &lt;br /&gt;to latch address bits AIS-As during the DMA transfer. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-2 THE 8237 DMA CONTROLLER 471 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MEMW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory read is an output that causes memory to ;ead data during a DMA read &lt;br /&gt;cycle. &lt;br /&gt;Memory write is an output that causes memory to write data during a DMA &lt;br /&gt;write cycle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Internal Registers &lt;br /&gt;CAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CWCR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BAand &lt;br /&gt;BWC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The current address register is used to hold the 16-bit memory address used &lt;br /&gt;for the DMA transfer. Each channel has its own current address register for this &lt;br /&gt;purpose. When a byte of data is transferred during a DMA operation, the eAR &lt;br /&gt;is either incremented or decremented, depending on how it is programmed. &lt;br /&gt;The current word count register programs a channel for the number of bytes &lt;br /&gt;(up to 64K) transferred during a DMA action. The number loaded into this &lt;br /&gt;register is one less than the number of bytes transferred. For example, if a 10 is &lt;br /&gt;loaded into the eWeR, then 11 bytes are transferred during the DMA action. &lt;br /&gt;The base address (BA) and base word count (BWC) registers are used when &lt;br /&gt;auto-initialization is selected for a channel. In the auto-initialization mode, these &lt;br /&gt;registers are used to reload both the eAR and eWeR after the DMA action is &lt;br /&gt;completed. This allows the same count and address to be used to transfer data &lt;br /&gt;from the same memory area. &lt;br /&gt;The command register programs the operation of the 8237 DMA controller. &lt;br /&gt;Figure 12-4 depicts the function of the command register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The command register uses bit position 0 to select the memory-to-memory DMA transfer &lt;br /&gt;mode. Memory-to-memory DMA transfers use DMA channel 0 to hold the source address and &lt;br /&gt;DMA channell to hold the destination address. (This is similar to the operation of a MOYSB in-&lt;br /&gt;struction.) A byte is read from the address accessed by channel 0 and saved within the 8237 in a &lt;br /&gt;temporary holding register. Next, the 8237 initiates a memory write cycle where the contents of &lt;br /&gt;the temporary holding register are written into the address selected by DMA channel I. The &lt;br /&gt;number of bytes transferred are determined by the channell count registe:. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-4 8237A-5 &lt;br /&gt;command register (Courtesy &lt;br /&gt;of Intel Corporation) &lt;br /&gt;~r:-.,-:;.....-:--Y-::--Y-:::..,-:....,..O:...,-Bit Number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 Memory-to memory disable &lt;br /&gt;1 Memory-to-memory enable &lt;br /&gt;0 Channel 0 address hold disable &lt;br /&gt;1 Channel 0 address hold enable &lt;br /&gt;X II bit 0 = 0 &lt;br /&gt;0 Controller enable &lt;br /&gt;1 Controller disable &lt;br /&gt;0 Normal timing &lt;br /&gt;1 Compressed timing &lt;br /&gt;X II bit 0 = 1 &lt;br /&gt;0 Fixed priority &lt;br /&gt;1 Rotating priority &lt;br /&gt;0 Late write selection &lt;br /&gt;1 Extended write selection &lt;br /&gt;X II bit 3 = 1 &lt;br /&gt;0 DREQ sense active high &lt;br /&gt;1 DREQ sense active low &lt;br /&gt;0 DACK sense active low &lt;br /&gt;1 DACK sense active high &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;472 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The channel 0 address hold enable bit (bit position I) programs channel 0 for memory-to-&lt;br /&gt;memory transfers. For example, if you must fill an area of memory with data, channel 0 can be &lt;br /&gt;held at the same address while channel I changes for memory-to-memory transfer. This copies &lt;br /&gt;the contents of the address accessed by channel 0 into a block of memory accessed by channel I. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The controller enable/disable bit (bit position 2) turns the entire controller on and off. The &lt;br /&gt;normal and compressed bit (bit position 3) determines whether a DMA cycle contains two (com-&lt;br /&gt;pressed) or four (normal) clocking periods. Bit position 5 is used in normal timing to extend the write &lt;br /&gt;pulse so that it appears one clock earlier in the timing for III devices that require a wider write pulse. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit position 4 selects priority for the four DMA channel DREQ inputs. In the fixed priority &lt;br /&gt;scheme, channel 0 has the highest priority and channel 3 has the lowest. In the rotating priority &lt;br /&gt;scheme, the most recently serviced channel assumes the lowest priority. For example, if channel &lt;br /&gt;2 just had access to a DMA transfer, it assumes the lowest priority and channel 3 assumes the &lt;br /&gt;highest priority position. Rotating priority is an attempt to give all channels equal priority. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The remaining two bits (bit positions 6 and 7) program the polarities of the DREQ inputs &lt;br /&gt;and the DACK outputs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MR The mode register programs the mode of operation for a channel. Note that &lt;br /&gt;each channel has its own mode register (see Figure 12-5) as selected by bit &lt;br /&gt;positions I and O. The remaining bits of the mode register select the operation, &lt;br /&gt;auto-initialization, increment/decrement, and mode for the channeL Verification &lt;br /&gt;operations generate the DMA addresses without generating the DMA memory &lt;br /&gt;and I/O control signals. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The modes of operation include demand mode, single mode, block mode, and &lt;br /&gt;cascade mode. Demand mode transfers data until an external EOP is input or until &lt;br /&gt;the DREQ input becomes inactive. Single mode releases the HOLD after each byte &lt;br /&gt;of data is transferred. If the DREQ pin is held active, the 8237 again requests a &lt;br /&gt;DMA transfer through the DRQ line to the microprocessor's HOLD input. Block &lt;br /&gt;mode automatically transfers the number of bytes indicated by the count register for &lt;br /&gt;the channel. DREQ need not be held active through the block mode transfer. &lt;br /&gt;Cascade mode is used when more than one 8237 is present in a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RR The request register is used to request a DMA transfer via software (see &lt;br /&gt;Figure 12-6). This is very useful in memory-to-memory transfers where an &lt;br /&gt;external signal is not available to begin the DMA transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-5 8237A-5 &lt;br /&gt;mode register (Courtesy of &lt;br /&gt;Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 6 5 4 3 2 1 0 - Bit Number &lt;br /&gt;I I I I I I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--r--' 1-r--'4' 00 Channel 0 select &lt;br /&gt;01 Channel 1 select &lt;br /&gt;10 Channel 2 select &lt;br /&gt;11 Channel 3 select &lt;br /&gt;00 Verify transfer &lt;br /&gt;01 Write transfer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1----1 10 Read transfer &lt;br /&gt;11 Illegal &lt;br /&gt;XX If bits 6 and 7 = 11 &lt;br /&gt;o Autoinitialization disable &lt;br /&gt;1 Autoinitialization enable &lt;br /&gt;o Address increment select &lt;br /&gt;1 Address decrement select &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 Demand mode select &lt;br /&gt;1...-_____ -; 01 Single mode select &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 Block mode select &lt;br /&gt;11 Cascade 'mode select &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-2 THE 8237 DMA CONTROLLER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-6 8237A-5 re-&lt;br /&gt;quest register (Courtesy of &lt;br /&gt;Intel Corporation) ( Don't' Care &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MRSR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MSR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\, Reset request bit &lt;br /&gt;Set request bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The mask register set/reset sets or clears the channel mask, as illustrated in &lt;br /&gt;Figure 12-7. If the mask is set, the channel is disabled. Recall that the RESET &lt;br /&gt;signal sets all channel masks to disable them. &lt;br /&gt;The mask register (see Figure 12-8) clears or sets all of the masks with one &lt;br /&gt;command instead of individual channels as with the MRSR. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;473 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SR The status register shows the status of each DMA channel (see Figure 12-9). &lt;br /&gt;The TC bits indicate if the channel has reached its terminal count (transferred all &lt;br /&gt;of its bytes). Whenever the terminal count is reached, the DMA transfer is &lt;br /&gt;terminated for most modes of operation. The request bits indicate if the DREQ &lt;br /&gt;input for a given channel is active. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-7 8237A-5 &lt;br /&gt;mask register set/reset mode &lt;br /&gt;(Courtesy of Intel Corpora-&lt;br /&gt;tion) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-8 8237A-5 &lt;br /&gt;mask register (Courtesy of &lt;br /&gt;Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-9 8237A-5 &lt;br /&gt;status register (Courtesy of &lt;br /&gt;Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;Don't Care Y 00 Select channel 0 mask bit 01 Select channel 1 mask bit 10 Select channel 2 mask bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 Select channel 3 mask bit &lt;br /&gt;o Clear mask bit &lt;br /&gt;1 Set mask bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 1 O-Bit Number &lt;br /&gt;r-ir-t--'---'-'-r-r-r'o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o Clear channel 0 mask bit &lt;br /&gt;1 Set channel 0 mask bit &lt;br /&gt;o Clear channel 1 mask bit &lt;br /&gt;1 Set channel 1 mask bit &lt;br /&gt;o Clear channel 2 mask bit &lt;br /&gt;1 Set channel 2 mask bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o Clear channel 3 mask bit &lt;br /&gt;1 Set channel 3 mask bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Channel 0 has reached TC &lt;br /&gt;Channel 1 has reached TC &lt;br /&gt;Channel 2 has reached TC &lt;br /&gt;Channel 3 has reached TC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Channel 0 request &lt;br /&gt;Channel 1 request &lt;br /&gt;Channel 2 request &lt;br /&gt;Channel 3 request &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;474 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Software Command &lt;br /&gt;Three software commands are used to control the operation of the 8237. These commands do not &lt;br /&gt;have a binary bit pattern, as do the various control registers within the 8237. A simple output to &lt;br /&gt;the correct port number enables the software command. Figure 12-10 shows the I/O port assign-&lt;br /&gt;ments that access all registers and the software commands. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The function of the software commands are explained in the following list: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Clear the firstJIast flip-flop-Clears the firstllast (FIL) flip-flop within the 8237. The FIL flip-&lt;br /&gt;flop selects which byte (low or high order) is read/written in the current address and current &lt;br /&gt;count registers. If FIL = 0, the low order byte is selected; if FIL = 1, the high-order byte is se-&lt;br /&gt;lected. Any read or write to the address or count register automatically toggles the FIL flip-flop. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Master clear-Acts exactly the same as the RESET signal to the 8237. As with the RESET &lt;br /&gt;signal, this command disables all channels. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Clear mask register-Enables all four DMA channels. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the Address and Count Registers &lt;br /&gt;Figure 12-11 illustrates the I/O port locations for programming the ~t and ~ registers for &lt;br /&gt;each channel. Notice that the state of the FIL flip-flop determines whether the LSB or MSB is pro-&lt;br /&gt;grammed. If the state of the FIL flip-flop is unknown, the count and address could be programmed &lt;br /&gt;incorrectly. It is also important that the DMA channel be disabled before its address and count &lt;br /&gt;are programmed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are four steps required to program the 8237: (1) the FIL flip-flop is cleared using a &lt;br /&gt;clear FIL command, (2) the channel is disabled, (3) the LSB and then MSB of the address are &lt;br /&gt;programmed, and (4) the LSB and MSB of the count are programmed. Once these four opera-&lt;br /&gt;tions are performed, the channel is programmed and ready to use. Additional programming is re-&lt;br /&gt;quired to select the mode of operation before the channel is enabled and started. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8237 Connected to the 80X86 Microprocessor &lt;br /&gt;Figure 12-12 shows an 80X86-based system that contains the 8237 DMA controller. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address enable (AEN) output of the 8237 controls the output pins of the latches and &lt;br /&gt;the outputs of the 74LS257 (E). During normal80X86 operation (AEN = 0), latches A and C and &lt;br /&gt;the multiplexer (E) provide address bus bits A19-A16 and A7-AO' The multiplexer provides the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-10 8237A-5 &lt;br /&gt;command and control port as-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. signments (Courtesy of Intel &lt;br /&gt;Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Signals &lt;br /&gt;Al AO &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;0 1 &lt;br /&gt;0 1 &lt;br /&gt;1 0 &lt;br /&gt;1 0 &lt;br /&gt;1 1 &lt;br /&gt;1 1 &lt;br /&gt;0 0 &lt;br /&gt;0 0 &lt;br /&gt;0 1 &lt;br /&gt;0 1 &lt;br /&gt;1 0 &lt;br /&gt;1 0 &lt;br /&gt;1 1 &lt;br /&gt;1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOR lOW Operation &lt;br /&gt;0 1 Read Status Reaister &lt;br /&gt;1 0 Write Command ReQister &lt;br /&gt;0 1 lIIeQal &lt;br /&gt;1 0 Write Reauest Reaister &lt;br /&gt;0 1 lIIeQal &lt;br /&gt;1 0 Write Single Mask Register Bit &lt;br /&gt;0 1 Illegal &lt;br /&gt;1 0 Write Mode ReQister &lt;br /&gt;0 1 Illegal &lt;br /&gt;1 0 Clear Byte Pointer Flip/Flop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--0 1 Read Temporary Register &lt;br /&gt;1 0 Master Clear &lt;br /&gt;0 1 Illegal &lt;br /&gt;1 0 Clear Mask Register &lt;br /&gt;0 1 Illegal &lt;br /&gt;1 0 Write All Mask Register Bits &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-2 THE 8237 OMA CONTROLLER 475 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Channel Register Operation CS lOR lOW &lt;br /&gt;Signals &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 A2 A1 AO Internal Flip-Flop Data Bus DBO-DB7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 Base and Current Address Write 0 1 0 0 0 0 0 0 AO-A7 &lt;br /&gt;0 1 0 0 0 0 0 1 A8-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current Address Read 0 0 1 0 0 0 0 0 AO-A7 &lt;br /&gt;0 0 1 0 0 0 0 1 A8-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base and Current Word Count Write 0 1 0 0 0 0 1 0 WO-W7 &lt;br /&gt;0 1 0 0 0 0 1 1 W8-W15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current Word Count Read 0 0 1 0 0 0 1 0 WO-W7 &lt;br /&gt;0 0 1 0 0 0 1 1 W8-W15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 Base and Current Address Write 0 1 0 0 0 1 0 0 AO-A7 &lt;br /&gt;0 1 0 0 0 1 0 1 A8-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current Address Read 0 0 1 0 0 1 0 0 AO-A7 &lt;br /&gt;0 0 1 0 0 1 0 1 A8-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base and Current Word Count Write 0 1 0 0 0 1 1 0 WO-W7 &lt;br /&gt;0 1 0 0 0 1 1 1 W8-W15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current Word Count Read 0 0 1 0 0 1 1 0 WO-W7 &lt;br /&gt;0 0 1 0 0 1 1 1 W8-W15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 Base and Current Address Write 0 1 0 0 1 0 0 0 AO-A7 &lt;br /&gt;0 1 0 0 1 0 0 1 A8-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current Address Read 0 0 1 0 1 0 0 0 AO-A7 &lt;br /&gt;0 0 1 0 1 0 0 1 AB-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base and Current Word Count Write 0 1 0 0 1 0 1 0 WO-W7 &lt;br /&gt;0 1 0 0 1 0 1 1 W8-W15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current Word Count Read 0 0 1 0 1 0 1 0 WO-W7 &lt;br /&gt;0 0 1 0 1 0 1 1 W8-W15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 Base and Current Address Write 0 1 0 0 1 1 0 0 AO-A7 &lt;br /&gt;0 1 0 0 1 1 0 1 A8-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current Address Read 0 0 1 0 1 1 0 0 AO-A7 &lt;br /&gt;0 0 1 0 1 1 0 1 A8-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base and Current Word Count Write 0 1 0 0 1 1 1 0 WO-W7 &lt;br /&gt;0 1 0 0 1 1 1 1 W8-W15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Current Word Count Read 0 0 1 0 1 1 1 0 WO-W7 &lt;br /&gt;0 0 1 0 1 1 1 1 W8-W15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-11 8237A-5 DMA channel 1/0 port addresses (Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;system control signals as long as the 80X86 is in control of the system. During a DMA action &lt;br /&gt;(AEN = 1), latches A and C are disabled along with the multiplexer (E). Latches D and B now &lt;br /&gt;provide address bits A19-A16 and A1S-Ag. Address bus bits A7-AO are provided directly by the &lt;br /&gt;8237 and contain a part of the DMA transfer address. The control signals MEMR, MEMW, IOR, &lt;br /&gt;and lOW are also provided by the DMA controller. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address strobe output (ADSTB) of the 8237 clocks the address (AIS-Ag) into latch D &lt;br /&gt;during the DMA action so that the entire DMA transfer address becomes available on the address &lt;br /&gt;bus. Address bus bits A19-A16 are provided by latch B, which must be programmed with these &lt;br /&gt;four address bits before the controller is enabled for the DMA transfer. The DMA operation of &lt;br /&gt;the 8237 is limited to a transfer of not more than 64K bytes within the same 64K-byte section of &lt;br /&gt;the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The decoder (F) selects the 8237 for programming and also the 4-bit latch (B) for the up-&lt;br /&gt;permost four address bits. The decoder in this system enables the 8237 for I/O port addresses &lt;br /&gt;XX60H-XX7FH and the I/O latch (B) for ports XXOOH-XXIFH. Notice that the decoder output &lt;br /&gt;is combined with the lOW signal to generate an active-high clock for the latch (B). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;During normal 80X86 operation, the DMA controller and integrated circuits Band Dare &lt;br /&gt;disabled. During a DMA action, integrated circuits A, C, and E are disabled so that the 8237 can &lt;br /&gt;take control of the system through the address, data, and control buses. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the personal computer, the two DMA controllers are programmed ~tJ/9 ports &lt;br /&gt;OOOOH--DOOFH for DMA channels 0-3 imd ports OOCOH--DODFH for DMA channels 4-7. Note &lt;br /&gt;that-the sec()ll~ cont~ll~r is programmed at even addresses-o~iy, ~o the channel 4 base and current &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;FIGURE 12-12 Complete 8088 minimum mode DMA system (pp. 476-477) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 &lt;br /&gt;A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'373 &lt;br /&gt;A ,IS 07 07 &lt;br /&gt;A'iS' 06 06 &lt;br /&gt;A'iS' Os OS &lt;br /&gt;A'JS' 04 04 , , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G OE &lt;br /&gt;I i' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B &lt;br /&gt;'373 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07 07 I--06 06 &lt;br /&gt;Os Os &lt;br /&gt;04 04 &lt;br /&gt;G OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I L-&lt;br /&gt;A&amp;quot; &lt;br /&gt;A&amp;quot; &lt;br /&gt;A&amp;quot; A12 &lt;br /&gt;Al1 &lt;br /&gt;AIO &lt;br /&gt;A, &lt;br /&gt;A, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C &lt;br /&gt;~ '37307 &lt;br /&gt;06 06 &lt;br /&gt;Os Os &lt;br /&gt;04 04 &lt;br /&gt;03 03 &lt;br /&gt;O2 O2 &lt;br /&gt;0, 0 , &lt;br /&gt;O~ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE I I &lt;br /&gt;A, &lt;br /&gt;~ &lt;br /&gt;A' &lt;br /&gt;A' &lt;br /&gt;A' &lt;br /&gt;A' &lt;br /&gt;A' 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ I I. I I &amp;quot; &lt;br /&gt;Â· Â· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I' â¢â¢ I I I I &lt;br /&gt;â¢ I I I I I I. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· Â· &lt;br /&gt;â¢ I I I â¢â¢â¢â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ I â¢â¢ I â¢â¢ I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· Â· &lt;br /&gt;â¢ I â¢ I â¢ I I. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I â¢ I I I â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· &lt;br /&gt;â¢ I' â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; â¢ I â¢ I â¢â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I &lt;br /&gt;I I I â¢ I â¢ I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· &lt;br /&gt;â¢ I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A19 &lt;br /&gt;A18 &lt;br /&gt;A17 &lt;br /&gt;A16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A&amp;quot; &lt;br /&gt;A&amp;quot; &lt;br /&gt;A&amp;quot; &lt;br /&gt;A&amp;quot; Al1 &lt;br /&gt;AIO &lt;br /&gt;A, &lt;br /&gt;A, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A, &lt;br /&gt;~ &lt;br /&gt;A' &lt;br /&gt;A' &lt;br /&gt;A' A' &lt;br /&gt;.\\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0, &lt;br /&gt;0, &lt;br /&gt;05 &lt;br /&gt;0, &lt;br /&gt;0, &lt;br /&gt;0, &lt;br /&gt;0, &lt;br /&gt;Do &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;-....J &lt;br /&gt;0) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C&amp;quot;&amp;gt; &lt;br /&gt;:J: &lt;br /&gt;l&amp;gt; &lt;br /&gt;-0 &lt;br /&gt;-i &lt;br /&gt;m &lt;br /&gt;::Il &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot; &lt;br /&gt;S! &lt;br /&gt;::Il &lt;br /&gt;m &lt;br /&gt;C&amp;quot;&amp;gt; &lt;br /&gt;-i &lt;br /&gt;s:: &lt;br /&gt;m &lt;br /&gt;s:: &lt;br /&gt;0 &lt;br /&gt;::Il &lt;br /&gt;-&amp;lt; &lt;br /&gt;l&amp;gt; &lt;br /&gt;C&amp;quot;&amp;gt; &lt;br /&gt;C&amp;quot;&amp;gt; &lt;br /&gt;rn &lt;br /&gt;en &lt;br /&gt;l&amp;gt; &lt;br /&gt;Z &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;s:: &lt;br /&gt;~ &lt;br /&gt;C&amp;quot;&amp;gt; &lt;br /&gt;0 &lt;br /&gt;Z &lt;br /&gt;-i &lt;br /&gt;::Il &lt;br /&gt;0 &lt;br /&gt;r-&lt;br /&gt;r-&lt;br /&gt;m &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2i &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;D I '373 D, a, &lt;br /&gt;D, a, &lt;br /&gt;Ds as &lt;br /&gt;D, a, &lt;br /&gt;D, a, &lt;br /&gt;D, a, &lt;br /&gt;D, a, &lt;br /&gt;Do 00 &lt;br /&gt;G DE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;... I &lt;br /&gt;&amp;quot;,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;D. D, D, Do AEN ADSTB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D, Ds D, D, &lt;br /&gt;HlDA HlDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8237A-5 &lt;br /&gt;DMA cDntrolier &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HRQ ClK RESET MEMW MEMR lOW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r--- ! &lt;br /&gt;HOLD - Q 0-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T A &lt;br /&gt;.... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MN/MX -+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M RDWR &lt;br /&gt;elK RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;(from 8284A) E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'257 &lt;br /&gt;r--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ao Vo &lt;br /&gt;Bo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;A, V, &lt;br /&gt;B, &lt;br /&gt;~ A, v, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5V -&amp;quot; &lt;br /&gt;B, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A, v, &lt;br /&gt;1K B, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B DE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ &lt;br /&gt;{O2 ,...~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A A, A A'A A, A Ao &lt;br /&gt;7 5 3 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~O &lt;br /&gt;&amp;lt;: ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS 3 &lt;br /&gt;~ ~ ~ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F &lt;br /&gt;'138 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A I B &lt;br /&gt;c I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E2 i E'flJ  ' , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MEMW &lt;br /&gt;MEMR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOW &lt;br /&gt;lOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;N &lt;br /&gt;rZ, &lt;br /&gt;-l &lt;br /&gt;::J: &lt;br /&gt;m &lt;br /&gt;ex&amp;gt; &lt;br /&gt;N &lt;br /&gt;w &lt;br /&gt;...... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;s: &lt;br /&gt;:l&amp;gt; &lt;br /&gt;C&amp;quot;) &lt;br /&gt;o &lt;br /&gt;Z &lt;br /&gt;-l &lt;br /&gt;::D &lt;br /&gt;o &lt;br /&gt;r-&lt;br /&gt;r-&lt;br /&gt;m &lt;br /&gt;::D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&amp;quot;&amp;quot; &lt;br /&gt;---J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;&amp;quot; &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;478 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;address is programmed at !!.9 gO[t QQ.9LH and the channel ~~S~~~~ __ countjs pro-&lt;br /&gt;grammed at port ~H. The page register, which holds address bits A23-A 16 of the DMA ad-&lt;br /&gt;dress, are located at VO ports 0087H (CH-O), 0083H (CH-I), 0081H (CH-2), 0082H (CH-3), (no &lt;br /&gt;channel 4), 008BH (CH-5), 0089H (CH-6), and 008AH (CH-7). The page register functions as &lt;br /&gt;the address latch described with the examples in this text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory-to-Memory Transfer with the 8237 &lt;br /&gt;The memory-to-memory transfer is much more powerful even than the automatically repeated &lt;br /&gt;MOVSB instruction. While the repeated MOVSB instruction tables the 8088 4.2 ~s per byte, the &lt;br /&gt;8237 requires only 2.0 ~s per byte. This is over twice as fast as a software data transfer. This is &lt;br /&gt;not true if an 80386, 80846, or PentiumlPentium Pro is in use in the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sample Memory-fa-memory DMA Transfer. Suppose that the contents of memory locations &lt;br /&gt;10000H-13FFFH are to be transferred into memory locations 14000H-17FFFH. This is accom-&lt;br /&gt;plished with a repeated string move instruction or, at a much faster rate, with the DMA controller. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 12-1 illustrates the software required to initialize the 8237 and program latch B &lt;br /&gt;in Figure 12-12 for this DMA transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 12-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 &lt;br /&gt;007C &lt;br /&gt;0070 &lt;br /&gt;0072 &lt;br /&gt;0073 &lt;br /&gt;007B &lt;br /&gt;0078 &lt;br /&gt;007F &lt;br /&gt;0079 &lt;br /&gt;0078 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 8C CO &lt;br /&gt;0003 8A C4 &lt;br /&gt;0005 CO E8 04 &lt;br /&gt;0008 E6 10 &lt;br /&gt;OOOA E6 7C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC SC CO &lt;br /&gt;OOOE Cl EO 04 &lt;br /&gt;0011 03 C6 &lt;br /&gt;0013 E6 70 &lt;br /&gt;0015 SA C4 &lt;br /&gt;Q017 E6 70 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0019 BC CO &lt;br /&gt;00lB C1 EO 04 &lt;br /&gt;001E 03 C7 &lt;br /&gt;0020 E6 72 &lt;br /&gt;0022 8A C4 &lt;br /&gt;0024 E6 72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that transfers a block of data using the &lt;br /&gt;;8237A DMA controller in Figure 12-12. This is a &lt;br /&gt;;memory-to-memory block transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Calling parameters: &lt;br /&gt;SI source address &lt;br /&gt;D1 destination address &lt;br /&gt;CX count v &lt;br /&gt;ES segment of source and destination \\/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LATCHB EQU 10H ; latch B &lt;br /&gt;CLEAR_F EQU 7CH ;F/L flip flop &lt;br /&gt;CHO_A EQU 70H ; channel 0 address &lt;br /&gt;CH1_A EQU 72H ; channel 1 address &lt;br /&gt;CH1_C EQU 73H ; channel 1 count &lt;br /&gt;MODE EQU 7BH ;mode &lt;br /&gt;CMMD EQU 78H ; command &lt;br /&gt;M]\\SKS EQU 7FH ;masks &lt;br /&gt;REQ EQU 79H ;request register &lt;br /&gt;STATUS EQU 78H ;status register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRANS PROC FAR USES AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,ES ; program Â¢atch B &lt;br /&gt;MOV AL,AH &lt;br /&gt;SHR AL,4 &lt;br /&gt;OUT LATCHB,AL &lt;br /&gt;OUT CLEAR_F,AL ;clear F/L flip-flop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,ES ;program source address &lt;br /&gt;SHL AX,4 &lt;br /&gt;ADD AX,SI ;form source offset &lt;br /&gt;OUT CHO_A,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;OUT CHO_A,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,ES ;program destination address &lt;br /&gt;SHL AX,4 &lt;br /&gt;ADD AX,D1 ; form destination offset &lt;br /&gt;OUT CHl_A,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;OUT CHl_A,AL &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L'G~ t &lt;br /&gt;007.P &lt;br /&gt;OOLS' &lt;br /&gt;OG21:' &lt;br /&gt;()f -j-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QC~,F &lt;br /&gt;00,1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a033 &lt;br /&gt;00,5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOj7 &lt;br /&gt;0039 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 &lt;br /&gt;003D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003F &lt;br /&gt;0041 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0043 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE 8237 DMA CONTROLLER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;dB Cl &lt;br /&gt;18 &lt;br /&gt;Â£6 :3 &lt;br /&gt;8A C4 &lt;br /&gt;U 7, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BO :ib &lt;br /&gt;Â£6 78 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BO 80 &lt;br /&gt;Â£f 7B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80 01 &lt;br /&gt;E6 78 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BO OE &lt;br /&gt;Â£6 7F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80 04 &lt;br /&gt;Â£6 79 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E4 78 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRANS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOV ,''-X, ex &lt;br /&gt;DEC AX &lt;br /&gt;OUT CHl_C,AL &lt;br /&gt;NOV AL,l-J-i &lt;br /&gt;OUT CH1_C, p.L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NO'! AL,88i-! &lt;br /&gt;OUT NODE,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MO'! AL,65H &lt;br /&gt;OUT MODE,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,l &lt;br /&gt;OUT CMt1D,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,OEH &lt;br /&gt;OUT i'1.lI.SKS,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,4 &lt;br /&gt;OUT REQ,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,REPEAT &lt;br /&gt;IN AL,ST;&amp;quot;TUS &lt;br /&gt;. UNTIL f&amp;gt;..L &amp;amp;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program count &lt;br /&gt;;adjust count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program mOGe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable block transfer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;unmask channel 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start DMA transfer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;wait until DMA complete &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;479 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the DMA controller requires a few steps, as illustrated in Example 12-1. &lt;br /&gt;The leftmost digit of the 5-digit address is sent to latch B. Next, the channels are programmed &lt;br /&gt;after the FIL flip-flop is cleared. Note that we use channel 0 as the source and channel I as the &lt;br /&gt;destination for a memory-to-memory transfer. The count is next programmed with a value that is &lt;br /&gt;one less than the number of bytes to be transferred. Next, the mode register of each channel is &lt;br /&gt;programmed, the command register selects a block move, channel 0 is enabled, and a software &lt;br /&gt;DMA request is initiated, Before return is made from the procedure, the status register is tested &lt;br /&gt;for a terminal count. Recall that the terminal count flag indicates that the DMA transfer is com-&lt;br /&gt;pleted. The TC also disables the channel, preventing additional transfers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sample Memory Fill Using the 8237. In order to fill an area of memory with the same data, the &lt;br /&gt;channel 0 source register is programmed to point to the same address throughout the transfer. &lt;br /&gt;This is accomplished with the channel 0 hold mode. The controller copies the contents of this &lt;br /&gt;single memory location to an entire block of memory addressed by channel I. This has many &lt;br /&gt;useful applications. For example, suppose that a video display must be cleared. This operation &lt;br /&gt;can be performed using the DMA controller with the channel 0 hold mode and a memory-to-&lt;br /&gt;memory transfer. If the video display contains 80 columns and 25 lines, it has 2,000 display po-&lt;br /&gt;sitions that must be set to 20H (an ASCII space) to clear the screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 12-2 shows a procedure that clears an area of memory addressed by ES:DI. The &lt;br /&gt;CX register transfer the number of bytes to be cleared to the CLEAR procedure. Notice that this &lt;br /&gt;procedure is nearly identical to Example 12-1, except that the command register is programmed &lt;br /&gt;so the channel 0 address is held. The source address is programmed as the same address as ES:DI &lt;br /&gt;and then the destination is programmed as one location beyond ES:DI. Also note that this pro-&lt;br /&gt;gram is designed to function with the hardware in Figure 12-12 and will not function in the per-&lt;br /&gt;sonal computer unless you have the same hardware. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 12-2 &lt;br /&gt;;;.. procedure that clears an area of memory using the &lt;br /&gt;; 8237;&amp;quot; DM_'&amp;quot; controller in Figure 12-12. This is a &lt;br /&gt;;memory-to-memory block transfer with a channel 0 hold. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;480 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Calling parameters: &lt;br /&gt;DI offset address of area cleared &lt;br /&gt;ES segment address of area cleared &lt;br /&gt;CX number of bytes cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 LATCHB EQU 10H ;latch B &lt;br /&gt;007C CLEAR_F EQU 7CH ;F/L flip flop &lt;br /&gt;0070 CHO_A EQU 70H ; channel 0 address &lt;br /&gt;0072 CH1_A EQU 72H ; channel 1 address &lt;br /&gt;0073 CH1_C EQU 73H ; channel 1 count &lt;br /&gt;007B MODE EQU 7BH ;mode &lt;br /&gt;0078 CMMD EQU 78H ; command &lt;br /&gt;007F MASKS EQU 7FH ;rnasks &lt;br /&gt;0079 REQ EQU 79H ; request register &lt;br /&gt;0078 STATUS EQU 78H ;status register &lt;br /&gt;0000 ZERO EQU OH ;zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 CLEAR PROC FAR USES AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 8C CO MOV AX,ES ;program latch B &lt;br /&gt;0003 8A C4 MOV AL,AH &lt;br /&gt;0005 CO E8 04 SHR AL,4 &lt;br /&gt;0008 E6 10 OUT LATCHB,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOA E6 7C OUT CLEAR_F,AL ;clear F/L flip-flop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOC 2E: AO 0000 MOV AL,CS:ZERO &lt;br /&gt;0010 26: 88 05 MOV ES: [DI) ,AL isave zero in first byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0013 8C CO MOV AX,ES ;program source address &lt;br /&gt;0015 C1 EO 04 SHL AX,4 &lt;br /&gt;0018 03 C7 ADD AX,DI ;form source offset &lt;br /&gt;001A E6 70 OUT CHO_A,AL &lt;br /&gt;001C 8A C4 MOV AL,AH &lt;br /&gt;001E E6 70 OUT CHO_A,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0020 8C CO MOV AX,ES ;program destination address &lt;br /&gt;0022 C1 EO 04 SHL AX,4 &lt;br /&gt;0025 03 C7 ADD AX,DI ;form destination offset &lt;br /&gt;0027 48 INC AX &lt;br /&gt;0028 E6 72 OUT CH1_A,AL &lt;br /&gt;002A 8A C4 MOV AL,AH &lt;br /&gt;002C E6 72 OUT CH1_A,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002E 8B C1 MOV AX,CX ;program count &lt;br /&gt;0030 48 DEC AX ;adjust count &lt;br /&gt;0031 48 DEC AX &lt;br /&gt;0032 E6 73 OUT CH1_C,AL &lt;br /&gt;0034 8A C4 MOV AL,AH &lt;br /&gt;0036 E6 73 OUT CH1_C,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 BO 88 MOV AL,88H ;program mode &lt;br /&gt;003A E6 7B OUT MODE,AL &lt;br /&gt;003C BO 85 MOV AL,85H &lt;br /&gt;003E E6 7B OUT MODp,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0040 BO 03 MOV AL,3 ;enable block hold transfer &lt;br /&gt;0042 E6 78 OUT CMMD,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0044 BO ( I~ MOV AL,OEH ;unmask channel 0 &lt;br /&gt;0046 E6 7F OUT MASKS,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0048 BO 04 MOV AL,4 ;start D~~ transfer &lt;br /&gt;004A E6 79 OUT REQ,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT ;wait until DMA complete &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-2 THE 8237 DMA CONTROLLER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004C E4 78 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0054 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN AL,STA'l'US &lt;br /&gt;.UNTIL AL &amp;amp;1 &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLEAR ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA-Processed Printer Interface &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;481 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 12-13 illustrates the hardware added to Figure 12-12 for a DMA-controlled prinier inter-&lt;br /&gt;face. Little additional circuitry is added for this interface to a Centronics-type parallel printer. &lt;br /&gt;The latch is used to capture the data as they are sent to the printer during the DMA transfer. The &lt;br /&gt;write pulse passed through to the latch during the DMA action also generates the data strobe &lt;br /&gt;(DS) signal to the printer through the single-shot. The ACK signal returns from the printer each &lt;br /&gt;time it is ready for additional data. In this circuit, ACK is used to request a DMA action through &lt;br /&gt;a flip-flop. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that the I/O device is not selected by decoding the address on the address bus. &lt;br /&gt;During the DMA transfer, the address bus contains the memory address and cannot contain the &lt;br /&gt;I/O port address. In place of the I/O port address, the DACK3 output from the 8237 selects the &lt;br /&gt;latch by gating the write pulse through an OR gate. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Software that controls this interface is simple because only the address of the data and the &lt;br /&gt;number of characters to be printed are programmed. Once programmed, the channel is enabled, &lt;br /&gt;and the DMA action transfers a byte at a time to the printer interface each time that the interface &lt;br /&gt;receives the ACK signal from the printer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-13 DMA-&lt;br /&gt;processed printer interface &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8237A-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DREQ31-----i &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DACK3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SET J &lt;br /&gt;Q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;K &lt;br /&gt;CLEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07 &lt;br /&gt;Os &lt;br /&gt;05 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data 04 &lt;br /&gt;bus 03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;O2 &lt;br /&gt;0 1 &lt;br /&gt;Do &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IORC-------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'373 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'122 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data to &lt;br /&gt;printer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Qt----DS &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;482 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure that prints data from the current data segment is illustrated in Example 12-3. &lt;br /&gt;This procedure programs the 8237, but doesn't actually print anything. Printing is accomplished by &lt;br /&gt;the DMA controller and the printer interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 12-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 &lt;br /&gt;007C &lt;br /&gt;0076 &lt;br /&gt;0077 &lt;br /&gt;007B &lt;br /&gt;0078 &lt;br /&gt;007F &lt;br /&gt;0079 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that prints data via the printer interface &lt;br /&gt;;in Figure 12-13. &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Calling parameters: &lt;br /&gt;BX offset address of printer data &lt;br /&gt;DS segment address of printer data &lt;br /&gt;CX number of bytes to print &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LATCHB EQU 10H ;latch B &lt;br /&gt;CLEAR_F EQU 7CH ;F/L flip flop &lt;br /&gt;CH3_A EQU 76H ;channel 0 address &lt;br /&gt;CH3_C EQU 77H ; channel 1 count &lt;br /&gt;MODE EQU 7BH ;mode &lt;br /&gt;CMMD EQU 78H ; command &lt;br /&gt;MASKS EQU 7FH ;masks &lt;br /&gt;REQ EQU 79H ; request register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRINT PROC FAR USES AX CX BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003 661 B8 00000000 MOV EAX,O &lt;br /&gt;0009 8C D8 MOV AX,DS ;program latch B &lt;br /&gt;OOOB 661 C1 E8 04 SHR EAX,4 &lt;br /&gt;OOOF 50 PUSH AX &lt;br /&gt;0010 661 C1 E8 10 SHR EAX,16 &lt;br /&gt;0014 E6 10 OUT LATCHB,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0016 58 POP AX ;program address &lt;br /&gt;0017 E6 76 OUT CH3_A,AL &lt;br /&gt;0019 8A C4 MOV AL,AH &lt;br /&gt;001B E6 76 OUT CH3_A,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOlD 8B C1 MOV AX,CX ;program count &lt;br /&gt;OOlF 48 DEC AX ;adjust count &lt;br /&gt;0020 E6 77 OUT CH3_C,AL &lt;br /&gt;0022 8A C4 MOV AL,AH &lt;br /&gt;0024 E6 77 OUT CH3_C,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0026 BO DB MOV AL,OBH ;program mode &lt;br /&gt;0028 E6 7B OUT MODE,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002A BO 00 MOV AL,O ;enable block hold transfer &lt;br /&gt;002C E6 78 OUT CMMD,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002E BO 07 MOV AL,7 ; unmask channel 3 &lt;br /&gt;0030 E6 7F OUT MASKS,AL &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0036 PRINT ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A secondary procedure is needed to detennine if the DMA action has been completed. Ex-&lt;br /&gt;ample 12-4 lists the secondary procedure that tests the DMA controller to see if the DMA &lt;br /&gt;transfer is complete. The TEST_P procedure is called before programming the DMA controller &lt;br /&gt;to see if the prior transfer is complete. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 12-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 0078 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that tests for a complete DMA action. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STATUS EQU 78H ;status register &lt;br /&gt;TEST_P PROC NEAR USES AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12-3 SHARED-BUS OPERATION 483 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;0001 E4 78 IN AL,STATUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL AL &amp;amp;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0009 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Printed data can be double-buffered by first loading buffer i with data to be printed. Next, &lt;br /&gt;the PRINT procedure is called to begin printing buffer 1. Because it takes very little time to pro-&lt;br /&gt;gram the DMA controller, a second buffer (buffer 2) can be filled with new printer data while the &lt;br /&gt;first buffer (buffer 1) is printed by the printer interface and DMA controller. This process is re-&lt;br /&gt;peated until all data are printed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHARED-BUS OPERATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Complex present-day computer systems have so many tasks to perform that some systems are &lt;br /&gt;using more than one microprocessor to accomplish the work. This is called a multiprocessing &lt;br /&gt;system. We also sometimes call this a distributed system. A system that performs more than one &lt;br /&gt;task is called a multitasking system. In systems that contain more than one microprocessor, &lt;br /&gt;some method of control must be developed and employed. In a distributed, multiprocessing, &lt;br /&gt;multitasking environment, each microprocessor accesses two buses: (1) the local bus and (2) the &lt;br /&gt;remote or shared bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the text describes shared bus operation for the 8086 and 8088 micro-&lt;br /&gt;processors using the 8289 bus arbiter. The 80286 uses the 82289 bus arbiter and the 80386/80486 &lt;br /&gt;use the 82389. The Pentium and Pentium Pro directly support a multiuser environment, as de-&lt;br /&gt;scribed in Chapters 15 and 16. These systems are much more complex and difficult to illustrate &lt;br /&gt;at this point in the text, but their terminology and operation is essentially the same as for the &lt;br /&gt;8086/8088. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The local bus is connected to memory and I/O devices that are directly accessed by a single &lt;br /&gt;microprocessor without any special protocol or access rules. The remote (shared) bus contains &lt;br /&gt;memory and I/O that are accessed by any microprocessor in the system. Figure 12-14 illustrates &lt;br /&gt;this idea with a few microprocessors. Note that the personal computer is also configured in the &lt;br /&gt;same manner as the system in Figure 12-14. The bus master is the main microprocessor in the &lt;br /&gt;personal computer. What we call the local bus in the personal computer is the shared bus in this &lt;br /&gt;illustration. The ISA bus is operated as a slave to the personal computer's microprocessor as well &lt;br /&gt;as any other devices attached to the shared bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Types Of Buses Defined &lt;br /&gt;The local bus is the bus that is resident to the microprocessor. The local bus contains the resident &lt;br /&gt;or local memory and I/O. All microprocessors studied thus far in this text are considered local &lt;br /&gt;bus systems. The local memory and local I/O are accessed by the microprocessor that is directly &lt;br /&gt;connected to them. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A shared bus is one that is connected to all microprocessors in the system. The shared bus &lt;br /&gt;is used to exchange data between microprocessors in the system. A shared bus may contain &lt;br /&gt;memory and I/O devices that are accessed by all microprocessors in the system. Access to the &lt;br /&gt;shared bus is controlled by some form or arbiter that allows only a single microprocessor to ac-&lt;br /&gt;cess the system's shared bus space. As mentioned, the shared bus in the personal computer is &lt;br /&gt;what we often call the local bus in the personal computer, because it is local to the micro-&lt;br /&gt;processor in the personal computer. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;484 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Local &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Local &lt;br /&gt;1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bus slave &lt;br /&gt;microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Local &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Local &lt;br /&gt;1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Local Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bus slave &lt;br /&gt;microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared &lt;br /&gt;1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Local &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Local &lt;br /&gt;1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bus slave &lt;br /&gt;microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bus master &lt;br /&gt;microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-14 A block diagram illustrating the shared and local buses &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 12-15 shows an 8088 microprocessor that is connected as a remote bus master. &lt;br /&gt;The term bus master applies to any device (microprocessor or otherwise) that can control a bus &lt;br /&gt;containing memory and VO. The 8237 DMA controller presented earlier in the chapter is an ex-&lt;br /&gt;ample of a remote bus master. The DMA controller gained access to the system memory and 110 &lt;br /&gt;space to cause a data transfer. Likewise, a remote bus master gains access to the shared bus for &lt;br /&gt;the same purpose. The difference is that the remote bus master microprocessor can execute vari-&lt;br /&gt;able software, whereas the DMA controller can only transfer data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Access to the shared bus is accomplished using the HOLD pin on the microprocessor for &lt;br /&gt;the DMA controller. Access to the shared bus for the remote bus master is accomplished via a &lt;br /&gt;bus arbiter. The bus arbiter functions to resolve priority between bus masters and allows only &lt;br /&gt;one device at a time to access the shared bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice in Figure 12-15 that the 8088 microprocessor has an interface to both a local, resi-&lt;br /&gt;dent bus and the shared bus. This configuration allows the 8088 to access local memory and 110 &lt;br /&gt;or, through the bus arbiter and buffers, the shared bus. The task assigned to the microprocessor &lt;br /&gt;might be data communications and it may, after collecting a block of data from the communica-&lt;br /&gt;tions interface, pass those data on to the shared bus and shared memory so other microprocessors &lt;br /&gt;attached to the system can access the data. This allows many microprocessors to share common &lt;br /&gt;data. In the same manner, multiple microprocessors can be assigned various tasks in the system, &lt;br /&gt;drastically improving throughput. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Bus Arbiter &lt;br /&gt;Before Figure 12-15 can be fully understood, the operation of the bus arbiter must be grasped. &lt;br /&gt;The 8289 bus arbiter controls the interface of a bus master to a shared bus. Although the 8289 is &lt;br /&gt;not the only bus arbiter, it is designed to function with the 8086/8088 microprocessors, so it is &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-3 SHARED-BUS OPERATION 485 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 MHz &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-F AEN2 AEN, 8284 &lt;br /&gt;Y READY READ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(loca I) â¢ ROY? ROY1 (Shared) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY elK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY elK &lt;br /&gt;8088 STATUS (S2, Sl, SO) r-~ 8289 &amp;lt; Multibus Control RESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f.+5V v &lt;br /&gt;.... t--f- elK ii:l!l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ANY ROST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SYSBI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AEN ROSS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SYSB/RESB ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-~ 1-1-&lt;br /&gt;CEN AEN CEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f-'- ~~ &amp;quot; S &amp;lt; Control 8288 1&amp;lt; 8288 Control local hared &lt;br /&gt;&amp;quot; ClK ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bus bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R !--- DT/R &lt;br /&gt;DEN !--- I-- DEN IOBh ALE ALE _ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Decoder &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G OE G OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;dRESS '373 '373 &amp;quot; X3 X3 ADDRESS v &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rÂ«:}- ~ 6 &lt;br /&gt;DIR OE DIR OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &amp;lt; &amp;gt; DATA ) '245 &amp;quot;- ADDRESS/DATA / '245 DATA &amp;quot; &lt;br /&gt;FIGURE 12-15 The 8088 operated in the remote mode illustrating the local and shared bus connections &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;presented here. Each bus master or microprocessor requires an arbiter for the interface to the &lt;br /&gt;shared bus, which Intel calls the Multibus and IBM calls the Micro Channel. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The shared bus is used only to pass information from one microprocessor to another; oth-&lt;br /&gt;erwise, the bus masters function in their own local bus modes using their own 1000;al programs, &lt;br /&gt;memory, and va space. Microprocessors connected in a system such as this are often called par-&lt;br /&gt;allel or distributed processors because they can execute software and perform tasks in parallel. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;486 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-16 The 8289 &lt;br /&gt;pin-out and block diagram &lt;br /&gt;(Courtesy of Intel Corpora-&lt;br /&gt;tion) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SYSB/RESB &lt;br /&gt;RESB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, Vee &lt;br /&gt;51 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 So &lt;br /&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;{&lt;br /&gt;S, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOB6/BOBB/BOB9 5, &lt;br /&gt;STATUS So &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;{ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOCK &lt;br /&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROCESSOR CROCCK &lt;br /&gt;CONTROL RESB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ANYRQST &lt;br /&gt;lOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BClK lOCK &lt;br /&gt;INIT CROlCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BREO 7 ANYROST &lt;br /&gt;BPRO B AEN &lt;br /&gt;BPRN g CBRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND BUSY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INIT} BClK &lt;br /&gt;BREQ MUlTIBUS'&amp;quot; &lt;br /&gt;Bi5Fm COMMAND &lt;br /&gt;BPRO SIGNALS &lt;br /&gt;BUSY &lt;br /&gt;CIDi'O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AEN } &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L_-!=;===r====::f-- SYSB/RESB ~irfJf~ &lt;br /&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8289 Architecture. Figure 12-16 illustrates the pin-out and block diagram of the 8289 bus ar-&lt;br /&gt;biter. The left side of the block diagram depicts the connections to the microprocessor. The right &lt;br /&gt;side denotes the 8289 connection to the shared (remote) bus or Multibus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8289 controls the shared bus by causing the READY input to the microprocessor to &lt;br /&gt;become a logic 0 (not ready) if access to the shared bus is denied. Blocking occurs whenever an-&lt;br /&gt;other microprocessor is accessing the shared bus. As a result, the microprocessor requesting ac-&lt;br /&gt;cess is blocked by the logic 0 applied to its READY input. When the READY pin is a logic 0, the &lt;br /&gt;microprocessor and its software wait until access to the shared bus is granted by the arbiter. In &lt;br /&gt;this manner, one microprocessor at a time gains access to the shared bus. No special instructions &lt;br /&gt;are required for bus arbitration with the 8289 bus arbiter since arbitration is accomplished &lt;br /&gt;strictly by the hardware. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Definitions &lt;br /&gt;AEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ANYRQST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address enable output causes the bus drivers in a system to switch to &lt;br /&gt;their three-state, high-impedance state. &lt;br /&gt;The any request input is a strapping option that prevents a lower priority &lt;br /&gt;microprocessor from gaining access to the shared bus. If tied to a logic 0, &lt;br /&gt;normal arbitration occurs, and a lower priority microprocessor can gain access &lt;br /&gt;to the shared bus if CBRQ is also a logic O. &lt;br /&gt;The bus clock input synchronizes all sharec -bus masters. &lt;br /&gt;The bus priority input allows the 8289 to acquire the shared bus on the next &lt;br /&gt;falling edge of the BLCK signal. &lt;br /&gt;The bus priority output is a signal that is used to resolve priority in a system &lt;br /&gt;that contains multiple bus masters. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-3 SHARED-BUS OPERATION 487 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CRQLCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S2, SI, &lt;br /&gt;and SO &lt;br /&gt;SYSB/ &lt;br /&gt;RESB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bus request output is used to request access to the shared bus. &lt;br /&gt;The busy input/output indicates, as an output, that an 8289 has acquired the &lt;br /&gt;shared bus. As an input, BUSY is used to detect that another 8289 has &lt;br /&gt;acquired tht' ,hared bus. &lt;br /&gt;The common bus request input/output is used when a lower priority micro-&lt;br /&gt;processor is asking for the use of the shared bus. As an output, CBRQ becomes &lt;br /&gt;a logic 0 whenever the 8289 requests the shared bus, and remains low until the &lt;br /&gt;8289 obtains access to the shared bus. &lt;br /&gt;The dock input is generated by the 8284A clock generator and provides the &lt;br /&gt;internal timing source to the 8289. &lt;br /&gt;The common request lock input prevents the 8289 from surrendering the &lt;br /&gt;shared bus to any of the 8289s in the system. This signal functions in &lt;br /&gt;conjunction with the CBRQ pin. &lt;br /&gt;The initialization input resets the 8289 and is normally connected to the &lt;br /&gt;system RESET signal. &lt;br /&gt;The I/O bus input selects whether the 8289 operates in a shared-bus system &lt;br /&gt;(if selected by RESB) with I/O (lOB = 0) or with memory and I/O (lOB = 1). &lt;br /&gt;The lock input prevents the 8289 from allowing any other microprocessor &lt;br /&gt;from gaining access to the shared bus. An 8086/8088 instruction that contains a &lt;br /&gt;LOCK prefix will prevent other microprocessors from accessing the shared bus. &lt;br /&gt;The resident-bus input is a strapping connection that allows the 8289 to &lt;br /&gt;operate in systems that have either a shared-bus or resident-bus system. If &lt;br /&gt;RESB is a logic 1, the 8289 is configured as a shared-bus master. If RESB is a &lt;br /&gt;logic 0, the 8289 is configured as a local-bus master. When configured as a &lt;br /&gt;shared-bus master, access is requested through the SYSB/RESB input pin. &lt;br /&gt;The status inputs initiate shared-bus requests and surrenders. These pins &lt;br /&gt;connect to the 8288 system bus controller status pins. &lt;br /&gt;The system bus/resident bus input selects the shared-bus system when placed &lt;br /&gt;at a logic 1 or the resident local bus when placed at a logic O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;General 8289 Operation. As the pin descriptions demonstrate, the 8289 can be operated in three &lt;br /&gt;basic modes: (1) I/O peripheral bus mode, (2) resident bus mode, and (3) single-bus mode. Refer &lt;br /&gt;to Table 12-1 for the connections required to operate the 8289 in these modes. In the I/O pe-&lt;br /&gt;ripheral bus mode, all devices on the local bus are treated as I/O, including memory, and are ac-&lt;br /&gt;cessed by III instructions. All memory references access the shared bus and all I/O access the &lt;br /&gt;resident local bus. The resident bus mode allows memory and I/O accesses on both the local and &lt;br /&gt;shared buses. Finally, the single-bus mode interfaces a microprocessor to a shared-bus, but the &lt;br /&gt;microprocessor has no local memory or local I/O. In many systems, one microprocessor is set up &lt;br /&gt;as the shared-bus master (single-bus mode) to control the shared bus and become the shared-bus &lt;br /&gt;master. The shared-bus master controls the system through shared memory and I/O. Additional &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 12-1 8289 modes &lt;br /&gt;of operation Mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Single bus &lt;br /&gt;Resident bus &lt;br /&gt;1/0 bus &lt;br /&gt;1/0 bus and resident bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Connections &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOB = 1 and RESB = 0 &lt;br /&gt;lOB = 1 and RESB = 1 &lt;br /&gt;lOB = 0 and RESB = 0 &lt;br /&gt;lOB = 0 and RESB = 1 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;488 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;u V B S Sia e B &lt;br /&gt;Data Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Telephone Address Bus I Interface Local Memory &lt;br /&gt;Â§li &lt;br /&gt;Sf &lt;br /&gt;S2 8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOcK CLKRDY &lt;br /&gt;4 B 3 I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;! I I 74L~ l I I jJ J I DE DIR DE CLK AEN CLK AEN LOCK AEN1 CLKRDY 74LS244 DEN RDY2 h1. 74LS245 74LS373 DT/R 8288 B2B9 8284 AEN2 i.9 '-:: : &lt;br /&gt;G- ALE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDY1 Vee i &lt;br /&gt;-- -- ---- -- --- --------- ----- --- -------- --- --------------- .................. -_ .. -- .. -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_______ .. ______________ oJ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared Control Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared Address Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared Dala Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;p-- ------ -- -- -- --_ ...... _- -_ .. --_ .. ---- --_ .. ---- ----------- ----&lt;br /&gt;----------------~ .. -- --- -- --_ .. ----- ----- ----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G- ALE RDY1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R AeN2 r---oVcc 74LS245 B2BB 8289 B284 RDY2 h 74LS373 DEN &lt;br /&gt;DE DIR DE AENCLK lOcK AENCLK AEN1 CLK ROY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I II 6 C 5 I I 74LS04 &lt;br /&gt;lOcK CLKRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SO B068 &lt;br /&gt;S1 &lt;br /&gt;S2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Printer Interface &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIsk Meml')ry Address Bus &lt;br /&gt;Local Memory Data Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bus Slave C : &lt;br /&gt;-------------- -- .. -- -_ .... --_ .... --- .. -- -_ .. -_ .......... --- -_ .... ---- -- .... ---- --_ .. -----_ .... -- -- -_ .. -- -_ .. -- -- -------- -- -- --_ .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-17 Three 8088 microprocessors that share a common bus system. Microprocessor A is the bus &lt;br /&gt;master in control of the shared memory and CRT terminal. Microprocessor B is a bus slave controlling its local &lt;br /&gt;telephone interface and memory. Microprocessor C is also a slave that controls a printer, disk memory system, &lt;br /&gt;and local memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessors are connected to the shared bus as resident or 110 peripheral bus masters. These &lt;br /&gt;additional bus masters usually perform independent tasks that are reported to the shared-bus &lt;br /&gt;master through the shared bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System Illustrating Single-bus and Resident-bus Connections. Single-bus operation interfaces a &lt;br /&gt;microprocessor to a shared bus that contains both 110 and memory resources that are shared by &lt;br /&gt;other microprocessors. Figure 12-17 illustrates three 8088 microprocessors, each connected to &lt;br /&gt;with a shared bus. Two of the three microprocessors operate in the resident-bus mode, while the &lt;br /&gt;third operates in the single-bus mode. Microprocessor A, in Figure 12-17, operates in the single-&lt;br /&gt;bus mode and has no local bus. This microprocessor only accesses the shared memory and 110 &lt;br /&gt;space. Microprocessor A is often referred to as the system bus master because it is responsible &lt;br /&gt;for coordinating the main memory and 110 tasks. The remaining two microprocessors (B and C) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-3 SHARED-BUS OPERATION 489 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Bus Bus Master A &lt;br /&gt;Address Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II &lt;br /&gt;SO &lt;br /&gt;31 &lt;br /&gt;52 8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 A 1 &lt;br /&gt;lOCK elK RDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II I 74LS04 I I I &lt;br /&gt;OE DIR OE ClK AEN ClK AEN lOCK AEN1 ClK RDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS244 I~ DEN RDY2 ~ 74LS245 74LS373 DT/A 8288 8289 8284 AEN2 Gr- ALE &lt;br /&gt;RDY1 Vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: &lt;br /&gt;'._------ -------------------- - -------------- ----------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;------- --------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BClK 10Mhz &lt;br /&gt;Oscillator &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CBRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;[ BUSY 10K &lt;br /&gt;Vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 2 1 (BREQ) &lt;br /&gt;Parallel &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared Memory CRT Terminal PriOrity &lt;br /&gt;L..- BPRN Resolver &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-17 (continued) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;are connected in the resident-bus mode, which allows them access to both the shared bus and &lt;br /&gt;their own local buses. These resident-bus microprocessors are used to perform tasks that are in-&lt;br /&gt;dependent from the system bus master. In fact, the only time that the system bus master is inter-&lt;br /&gt;rupted from performing its tasks is when one of the two resident-bus microprocessors needs to &lt;br /&gt;transfer data between itself and the shared bus. This connection allows all three microprocessors &lt;br /&gt;to perform tasks simultaneously, yet data can be shared between microprocessors when needed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In Figure 12-17, the bus master (A) allows the user to operate with a video terminal that &lt;br /&gt;allows the execution of programs and generally controls the system. Microprocessor B handles &lt;br /&gt;all telephone communications and passes this information to the shared memory in blocks. This &lt;br /&gt;means that microprocessor-B waits for each character to be transmitted or received and controls &lt;br /&gt;the protocol used for the transfers. For example, suppose that a lK-byte block of data is trans-&lt;br /&gt;mitted across the telephone interface and this occurs at the rate of 100 characters per second. &lt;br /&gt;This means that the transfer requires 10 seconds. Rather than tie up the bus master for 10 sec-&lt;br /&gt;onds, microprocessor B patiently performs the data transfer from its own local memory and the &lt;br /&gt;local communications interface. This frees the bus master for other tasks. The only time that mi-&lt;br /&gt;croprocessor B interrupts the bus master is to transfer data between the shared memory and its &lt;br /&gt;local memory system. This requires only a few hundred microseconds from the bus master and &lt;br /&gt;the main system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microprocessor C is used as a print spooler. Its only task is to print data on the printer. &lt;br /&gt;Whenever the bus master requires printed output, it transfers the task to microprocessor C. Mi-&lt;br /&gt;croprocessor C then accesses the shared memory and captures the data to be printed and stores it &lt;br /&gt;in its own local memory. Data are then printed from the local memory, freeing the bus master to &lt;br /&gt;perform other tasks. This allows the system to execute a program with the bus master, transfer &lt;br /&gt;data through the communications interface with microprocessor B, and print information on the &lt;br /&gt;printer with microprocessor C. These tasks all execute simultaneously. There is no limit to the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;490 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED liD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;number of microprocessors connected to a system or the number of tasks performed simultane-&lt;br /&gt;ously using this technique. The only limit is that introduced by the system design and the de-&lt;br /&gt;signer's ingenuity. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Priority Logic Using The 8289 &lt;br /&gt;In applications that use the 8289, there is always more than one microprocessor connected to a &lt;br /&gt;shared bus. Because only one can access the shared bus at a time, some method of resolving pri-&lt;br /&gt;ority must be employed. Priority prevents more than one microprocessor from accessing the bus &lt;br /&gt;at a time. There are two methods for resolving priority with the 8289 bus arbiter: the daisy-chain &lt;br /&gt;(serial) and the parallel-priority schemes. &lt;br /&gt;Daisy-Chain Priority. The daisy-chain priority scheme connects the BPRO output to the BPRN &lt;br /&gt;input of the next-lower priority 8289 and is the least expensive to implement. Figure 12-18 il-&lt;br /&gt;lustrates the daisy-chain scheme for connecting several 8289s in a system. Because the BPRN &lt;br /&gt;input of the higher priority 8289 is grounded, it gets an immediate acknowledgment whenever its &lt;br /&gt;microprocessor requests access to the shared bus. The BPRO output is a logic 0 if the 8289 and &lt;br /&gt;its microprocessor are inactive, and a logic I if the 8289 and its microprocessor are actively &lt;br /&gt;using the shared bus. If no requests are active, all BPRN inputs will see a logic O. As soon as the &lt;br /&gt;highest priority 8289 receives a bus acknowledgment, its BPRO output goes high, blocking all &lt;br /&gt;lower priority 82895 from accessing the shared bus. If more than one 8289 receives an acknowl-&lt;br /&gt;edgment, more than one 8289 will function at the same time. This scheme is seldom used because &lt;br /&gt;two microprocessors can access the shared bus at a time. For this reason Intel recommends that &lt;br /&gt;this scheme be limited to no more than three 8289s in a system that use a bus clock of 10 MHz or &lt;br /&gt;less. With this frequency bus clock, no conflict occurs and only one microprocessor accesses the &lt;br /&gt;shared bus at a time. If more arbiters are connected, Intel suggests that the priority be resolved &lt;br /&gt;using the parallel scheme. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Parallel Priority &lt;br /&gt;Figure 12-19 illustrates a parallel-priority scheme where four 8289 bus arbiters are connected &lt;br /&gt;with a parallel circuit. Here a 74LS148, eight-input priority encoder is used to resolve priority &lt;br /&gt;conflicts in parallel. In this example, only four of the inputs are used to resolve priority for the &lt;br /&gt;four 8289s. The four unused encoder inputs are pulled up to a logic 1 to disable these unneeded. &lt;br /&gt;inputs to the encoder. Note that this circuit can be expanded to provide priority for up to eight &lt;br /&gt;8289s with their microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The circuit in Figure 12-19 functions as follows. If all 8289 arbiters are idle (no requests &lt;br /&gt;for the shared bus through the SYSBjRESB input), all BREQ outputs are high and the outputs of &lt;br /&gt;the 74LSI48 are logic Is (A and B are both 1). This means that the highest priority 8289 will &lt;br /&gt;gain access to the shared bus if it is requested by its microprocessor. On the other hand, if a lower &lt;br /&gt;priority request is made, the BREQ output becomes a logic O. This causes the priority encoder to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-18 Daisy-chain &lt;br /&gt;8289 priority resolver &lt;br /&gt;~----------------~------------------~------~BUSY &lt;br /&gt;~------------~--~------------~~--~--~CBRQ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSY CBRQ &lt;br /&gt;8289 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BPRN BPRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Highest &lt;br /&gt;priority &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSY CBRQ &lt;br /&gt;8289 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSY CBRQ &lt;br /&gt;8289 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BPRN BPRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Lowest &lt;br /&gt;priority &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-3 SHARED-BUS OPERATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FiGURE 12-19 Parallel-&lt;br /&gt;priority resolver for the 8289 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Highest &lt;br /&gt;priority &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;BUSY CBRC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8289 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BREO BPR~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ ~ &lt;br /&gt;BUSY CBRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8289 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BREO BPRN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 Ap---A &lt;br /&gt;2 Bp--- B &lt;br /&gt;1 Cp r-- C &lt;br /&gt;0 '148 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r---: 4 Priority encoder &lt;br /&gt;~5 r---&amp;lt; E, &lt;br /&gt;f--&amp;lt;: 6 r E2 f--&amp;lt;: 7 E - E3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* &lt;br /&gt;lK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;), &lt;br /&gt;BUSY CBRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82e9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BREO BPRN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30---&lt;br /&gt;2 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'138 0 &lt;br /&gt;40 &lt;br /&gt;50 &lt;br /&gt;60 &lt;br /&gt;70 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Lowest &lt;br /&gt;priority &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;BUSY CBRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8289 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BREO BPRN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;491 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;place a logic 0 on the corresponding BREQ input pin of the 8289, allowing access to the shared &lt;br /&gt;bus, For example, if the rightmost 8289 places a logic 0 on its BREQ output pin, the priority en-&lt;br /&gt;coder will have a zero on input 3. This causes the 74LS148 to generate a 00 on its output pins. &lt;br /&gt;The 00 causes the 74LS 138 to activate the BPRN input of the rightmost 8289, giving it access to &lt;br /&gt;the shared bus. This also locks out any other request, because the BUSY signal becomes a logic &lt;br /&gt;O. If simultaneous requests occur, they are automatically prioritized by the 74LS148, preventing &lt;br /&gt;conflicts no matter how many 8289s are connected in a system. For this reason, this priority &lt;br /&gt;scheme is desirable. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Print Spooler and Interface &lt;br /&gt;Figure 12-20 shows the block diagram of a printer interface and spooler (print queue) controlled &lt;br /&gt;by an 8088 microprocessor. Here two microprocessors are placed in a system with one, the &lt;br /&gt;system bus master, operated in single-bus mode, and a second operated in the resident-bus mode. &lt;br /&gt;Because two microprocessors exist, one can print data while the other is used to process new in-&lt;br /&gt;formation in the interim. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In this interface, the slave microprocessor transfers data to the printer from its local memory &lt;br /&gt;without intervention from the system bus master. Data are transferred to the local memory of the &lt;br /&gt;slave microprocessor whenever it accesses the shared memory for additional data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Single-mode Bus-master Interface. Figure 12-21 illustrates the 8088 bus master, operated in &lt;br /&gt;single mode, interfaced to the shared bus. The shared bus master has access to every memory lo-&lt;br /&gt;cation and I/O device on the shared bus. The BCLK signal is generated by an 8284A clock gen-&lt;br /&gt;erator used as a 10 MHz oscillator. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;492 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-20 Block dia-&lt;br /&gt;gram of two 8088s used to &lt;br /&gt;control a printer interface and &lt;br /&gt;print spooler &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;h &lt;br /&gt;a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 &lt;br /&gt;liP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interface &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interface &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8289 arbiter is operated with no I/O bus, no resident bus, and ANYRQST pulled high &lt;br /&gt;so that the shared bus can be accessed for all memory and I/O transfers. This system uses the &lt;br /&gt;daisy-chain priority scheme, which means that the BREQ signal is not connected. This interface &lt;br /&gt;allows the slave microprocessor to access shared memory whenever necessary and thus prevents &lt;br /&gt;the slave microprocessor from locking the bus for too long. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In addition to the normal bus signals, this circuit also provides the shared bus with a 2.5 &lt;br /&gt;MHz PCLK signal for any I/O device. The RDY input is shown in case system memory and I/O &lt;br /&gt;require wait states. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Resident-bus Operation of the Slave 8088. Figure 12-22 illustrates the slave 8088 micro-&lt;br /&gt;processor that functions as a print spooler. This microprocessor is connected as a resident-bus &lt;br /&gt;master. This illustration depicts the resident-local-bus interface as well as the shared-bus interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever the slave 8088 microprocessor accesses memory above location 7FFFFH, it &lt;br /&gt;places a logic 1 on the SYS/RESB input to the 8289 and the CEN pin of the shared-bus mas-&lt;br /&gt;ter's 8288. This requests access to the shared bus through the 8289 bus arbiter. If the address &lt;br /&gt;is below 80000H, the SYS/RESB pin on the 8289 is grounded and a logic 1 is placed on the &lt;br /&gt;CEN pin of the local bus 8288. This requests access to the resident-local bus for control of the &lt;br /&gt;printer and resident-local bus memory. Notice that no attempt is made to access the shared-bus &lt;br /&gt;I/O because the purpose of the slave 8088 is to access the printer interface on its local bus as &lt;br /&gt;local I/O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 12-23 shows the memory maps of both the slave 8088 local memory and the shared &lt;br /&gt;memory and the local memory of the 8088 bus master. The bus master has access to all of the &lt;br /&gt;shared memory, while the slave can only access locations 80000H-FFFFFH. Transfers to the &lt;br /&gt;print spooler are made through the upper half of the shared memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The resident-local bus in this system contains EPROM, DRAM, and a printer interface. &lt;br /&gt;The EPROM contains the program that controls the slave 8088, the DRAM contains the data for &lt;br /&gt;the printer, and printer interface controls the printer. Figure 12-24 illustrates these three devices &lt;br /&gt;on the resident-local bus of the slave 8088 microprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-3 SHARED-BUS OPERATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A,iSâ¢ 0, '373 0, &lt;br /&gt;AlBISs D. O. &lt;br /&gt;A&amp;quot;IS. 05 05 &lt;br /&gt;A,,/S3 D. OE G O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;A15 I, '244 0, &lt;br /&gt;A,. I. O. &lt;br /&gt;A'3 15 05 &lt;br /&gt;A'2 I, O. &lt;br /&gt;A&amp;quot; 13 0 3 &lt;br /&gt;A,o 12 O2 &lt;br /&gt;A. I, 0, &lt;br /&gt;As 10 OE OE 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Y't &lt;br /&gt;AD, 0, '373 a, -&lt;br /&gt;AD. D. a. .. &lt;br /&gt;ADs 05 as &lt;br /&gt;AD. D. a, &lt;br /&gt;AD3 0 3 0 3 &lt;br /&gt;AD2 O2 O2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-AD, 0, 0, &lt;br /&gt;ADo Do OE G 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;'-- A, '245 B, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;A. B. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;As Bs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---- A. B. &lt;br /&gt;A3 B3 &lt;br /&gt;A2 B2 &lt;br /&gt;A, B, &lt;br /&gt;Ao OE DIR Bo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L .=Â£ 'OMHZ~ &lt;br /&gt;MNIMX q. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-F 8288 DTIA S2 S2 t&amp;gt;o S, S, DEN So So MRDC &lt;br /&gt;lOCK p-- MWTC 10RC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;!-c AEN 10WC &lt;br /&gt;ClK INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE I--&lt;br /&gt;RESET READY ClK lOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I 1 -Â¥-&lt;br /&gt;READY ClK dJ 8289 RESET PCLK ~ S2 BClK MHZ~ X, ROY, S, BREO P--N1C '---&amp;lt;: So BPRN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;'E. AEN, AEN BPRO t:--NIC X2 ClK CBRO &lt;br /&gt;8284A lOCK BUSY &lt;br /&gt;~RES SIA lOB ANYROST I Fie AEN2 RESB &lt;br /&gt;=~ 1K -:} &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A,. &lt;br /&gt;AlB &lt;br /&gt;A&amp;quot; &lt;br /&gt;A,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A15 &lt;br /&gt;A,. &lt;br /&gt;A'3 &lt;br /&gt;A'2 &lt;br /&gt;A&amp;quot; &lt;br /&gt;A10 &lt;br /&gt;A. &lt;br /&gt;As &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A, &lt;br /&gt;A â¢ &lt;br /&gt;As &lt;br /&gt;A, &lt;br /&gt;A3 &lt;br /&gt;A2 &lt;br /&gt;A, &lt;br /&gt;Ao &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0, &lt;br /&gt;D. &lt;br /&gt;0 5 &lt;br /&gt;D. &lt;br /&gt;0 3 &lt;br /&gt;O2 &lt;br /&gt;0, &lt;br /&gt;Do ~-~ X, 8284A X2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIG r=t--r ClK &lt;br /&gt;~ ~ &lt;br /&gt;10WC &lt;br /&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PClK &lt;br /&gt;ROY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BPRN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CBRO &lt;br /&gt;BUSY _ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;f-s &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;USY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;493 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-21 An 8088 connected for the single-bus mode of operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The decoder in Figure 12-24 selects EPROM for locations OOOOOH-OFFFFH, the printer &lt;br /&gt;for locations 10000H-IFFFFH, and the DRAM for locations 20000H-7FFFFH. This allows the &lt;br /&gt;spooler to hold up to 384K bytes of data (see Figure 12-25). If the printer can produce 1,000 &lt;br /&gt;lines per minute (high-speed printer), then this represents about three minutes of printing and &lt;br /&gt;about 50-75 printed pages of data. If the system is expanded with a fixed memory system, the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;FIGURE 12-22 The 8088 shown with both a shared and a local bus. (pp. 494-495) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A, &lt;br /&gt;A, &lt;br /&gt;A, &lt;br /&gt;A, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;A &lt;br /&gt;A &lt;br /&gt;A &lt;br /&gt;A &lt;br /&gt;A &lt;br /&gt;A &lt;br /&gt;A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,.... D7 '373 0 71-----&lt;br /&gt;~ D. O.~:::::::: ~ DS 0 51-&lt;br /&gt;&amp;gt;- D. OE G 0.1-----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Y &lt;br /&gt;17 '244 07~~~~~f I. O. &lt;br /&gt;Is .' 05 &lt;br /&gt;I. O. &lt;br /&gt;13 0 31-----1-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 02~===:E I, O,~ &lt;br /&gt;: yy &lt;br /&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ '373 07~ D. O. &lt;br /&gt;DS 05 &lt;br /&gt;D. O. &lt;br /&gt;D3 0 3 &lt;br /&gt;D2 O2 &lt;br /&gt;D, 0, &lt;br /&gt;DOOE G 0 01------1-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As B. &lt;br /&gt;As Bs &lt;br /&gt;A. B. _&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_ 7 '245 7~ &lt;br /&gt;A3 B3 &lt;br /&gt;A2 B2 &lt;br /&gt;A, B, &lt;br /&gt;Ao OE DIR Bo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;y &lt;br /&gt;2 528288 DT/R ~ &lt;br /&gt;I 5, DEN!~~~~~ o So MRDC MWTC r~~~~=~:E~:E~~~~~~~tt=:1:t~:jAEN 10RC CLK 10WC CEN INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOB ALE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:~~ â¢â¢â¢ m ~ -3 -= -2 I D &lt;br /&gt;III &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.l&amp;gt;-&lt;br /&gt;cc &lt;br /&gt;.I&amp;gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A,. &lt;br /&gt;A,. &lt;br /&gt;A'7 &lt;br /&gt;A,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;n &lt;br /&gt;A,s ::I: &lt;br /&gt;A,. :Â» &lt;br /&gt;A'3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'U &lt;br /&gt;-I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A'2 m &lt;br /&gt;A&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;::D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A,o &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A. &lt;br /&gt;N &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As &amp;lt;::I &lt;br /&gt;:0 &lt;br /&gt;m &lt;br /&gt;n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDY l,-&lt;br /&gt;-I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A7 &lt;br /&gt;s: &lt;br /&gt;m &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ s: &amp;lt;::I &lt;br /&gt;A! ::D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&amp;lt; &lt;br /&gt;A3 :Â» &lt;br /&gt;A2 n &lt;br /&gt;A, n &lt;br /&gt;Ao m en bus en &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:Â» &lt;br /&gt;z &lt;br /&gt;&amp;lt;::I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D7 &amp;lt;::I &lt;br /&gt;D. s: &lt;br /&gt;Ds ~ &lt;br /&gt;D. n &lt;br /&gt;D3 0 Z &lt;br /&gt;D2 -I &lt;br /&gt;D, :Xl &lt;br /&gt;Do 0 r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-&lt;br /&gt;m &lt;br /&gt;&amp;lt;::I &lt;br /&gt;(Â§ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;~tt% &lt;br /&gt;iCiFiC &lt;br /&gt;10WC &lt;br /&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSY &lt;br /&gt;CBRO &lt;br /&gt;BPRO &lt;br /&gt;BCLK &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.. &lt;br /&gt;. &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--- -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--- -&lt;br /&gt;._-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--- -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--- -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-- -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--- -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-- -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---&lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;j-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A'9 &lt;br /&gt;AlB &lt;br /&gt;A17 &lt;br /&gt;A16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A,S &lt;br /&gt;A14 &lt;br /&gt;A'3 &lt;br /&gt;A12 &lt;br /&gt;A'l &lt;br /&gt;AlO &lt;br /&gt;A9 &lt;br /&gt;AS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A, &lt;br /&gt;A6 &lt;br /&gt;As &lt;br /&gt;A4 &lt;br /&gt;A3 &lt;br /&gt;A2 &lt;br /&gt;A, &lt;br /&gt;Ao &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D, &lt;br /&gt;D6 &lt;br /&gt;Ds &lt;br /&gt;D4 &lt;br /&gt;D3 &lt;br /&gt;D2 &lt;br /&gt;D, &lt;br /&gt;Do &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MRDe &lt;br /&gt;MVVTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ Resident &lt;br /&gt;local &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;N &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;en &lt;br /&gt;:r: &lt;br /&gt;Â» &lt;br /&gt;:Xl &lt;br /&gt;m &lt;br /&gt;0 &lt;br /&gt;Co &lt;br /&gt;c: &lt;br /&gt;en &lt;br /&gt;0 &lt;br /&gt;-0 &lt;br /&gt;m &lt;br /&gt;:Xl &lt;br /&gt;Â» &lt;br /&gt;=! &lt;br /&gt;0 &lt;br /&gt;z &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.j:&amp;gt;. &lt;br /&gt;&amp;lt;.0 &lt;br /&gt;CJ1 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;496 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-23 Memory Memory map &lt;br /&gt;maps for the print spooler. FFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) Shared-bus master, and &lt;br /&gt;(b) bus-slave memory map &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000 &lt;br /&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-24 Resident &lt;br /&gt;local bus for the print spooler &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSY BUSY flip-flop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Q &lt;br /&gt;SET---c SET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C ..---. ~CLEAR &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lORe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_A 0 l~ _B 1 _C 2 '138 3 4 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E, 5 &lt;br /&gt;.,f: E2 ~~ E3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; 1K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;ACK â¢ Q D 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Do &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I--&lt;br /&gt;I--&lt;br /&gt;I--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,.--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A IK/ &lt;br /&gt;'I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ A15 t &lt;br /&gt;--y AD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;... D7 &lt;br /&gt;&amp;quot;\\ t y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Do &lt;br /&gt;RD &lt;br /&gt;WR &lt;br /&gt;SEL, &lt;br /&gt;SEL2 &lt;br /&gt;SEL3 &lt;br /&gt;SEL. &lt;br /&gt;SELs &lt;br /&gt;SEls &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory map &lt;br /&gt;FFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Shared &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80000 &lt;br /&gt;7FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Resident &lt;br /&gt;local &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000 &lt;br /&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D7 2716 t EPROM 2Kx8 Do &lt;br /&gt;AlO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;A, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE CE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l &lt;br /&gt;DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS244 &lt;br /&gt;Buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t 10 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t &lt;br /&gt;00 =&amp;gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Printer &lt;br /&gt;data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Y &lt;br /&gt;...... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DRAM &lt;br /&gt;ARRAY &lt;br /&gt;6 banks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;of &lt;br /&gt;64K x 8 &lt;br /&gt;DRAMs &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-3 SHARED-BUS OPERATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-25 8088 resi-&lt;br /&gt;dent local bus memory map &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;497 &lt;br /&gt;Memory map &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DRAM 384K Bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20000 1------1 &lt;br /&gt;Printer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10000 1-----1 } &lt;br /&gt;EPROM 64K Bytes 00000 '--___ ----' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;capacity of the spooler can become almost boundless because of the huge capacity of a modern &lt;br /&gt;fixed-disk memory system. For simplicity's sake, this is not added to this example. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The printer is interfaced to the slave microprocessor through a 74LS244 that is operated as &lt;br /&gt;a strobed output interrupting device. Whenever the printer completes printing a character, as sig-&lt;br /&gt;naled by the ACK signal, an interrupt is generated, causing the slave microprocessor to retrieve &lt;br /&gt;data from the print queue for the printer. This process continues until the queue is empty, at &lt;br /&gt;which time the slave microprocessor disables interrupt requests until new information is placed &lt;br /&gt;in the queue for printing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Print Spooler Software. The software for the print spooler is fairly straightforward. The entire &lt;br /&gt;software listing is provided in sections, so a study can be made of initialization, data transfer, and &lt;br /&gt;interrupt-controlled printer service procedures. The only software not illustrated is that which is &lt;br /&gt;required to program and initialize the system. When the system is initialized, the input and &lt;br /&gt;output pointers of the queue are both set up with address 20000H. This condition (equal pointers) &lt;br /&gt;indicates that the queue is empty. The segment portion of the pointers contains 2000H, and the &lt;br /&gt;offset portion contains OOOOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 12-5 lists the software that transfers data into the print spooler from the shared &lt;br /&gt;bus. In this software, the bus master loads a block of shared memory with printer data, called a &lt;br /&gt;print buffer (BUFFER beginning at location 80002H), and then signals the slave 8088 that data &lt;br /&gt;are available through a flip-flop, which acts as an indicator to the slave. This flag flip-flop is set by &lt;br /&gt;the master whenever printer data are available and cleared by the slave after the slave has removed &lt;br /&gt;the data from the shared memory. One additional piece of information is also placed in the shared &lt;br /&gt;memory for the slave-the length of the block of data. Location 80000H holds a word that indi-&lt;br /&gt;cates the length of the printed block of data. The maximum size of the buffer is 64K bytes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 12-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 E4 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure found in the master system that tests the &lt;br /&gt;;FLAG to determine if the slave is busy. If the slave &lt;br /&gt;;is not busy, data are transferred to the print buffer &lt;br /&gt;;and the FLAG is set to indicate that data are available &lt;br /&gt;;for printing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Calling parameters: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS:SI = address of printer data &lt;br /&gt;cx = number of bytes to print &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOAD PROC FAR USES ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT ;test FLAG &lt;br /&gt;IN AL, a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL AL==O &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;498 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0007 BF 0002 MOV DI,2 ;offset of buffer &lt;br /&gt;OOOA B8 8000 MOV AX,8000H ;segment of buffer &amp;amp; count &lt;br /&gt;DODD 8E CO MOV ES,AX &lt;br /&gt;OOOF 26: 89 DE 0000 MOV ES: [0) ,CX ; save count &lt;br /&gt;0014 F3/ A4 REP MOVSB ; save data to buffer &lt;br /&gt;0016 BO FF MOV AL,OFFH &lt;br /&gt;0018 E6 00 OUT O,AL ;set FLAG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001C LOAD ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once the slave notices a logic 1 in the flag flip-flop, it begins transferring data from the &lt;br /&gt;shared memory into its own local memory. The data are stored in the local memory organized as &lt;br /&gt;a FIFO (fIrst-in, fIrst out) or queue. In this example, the size of the queue is 384K bytes. Example &lt;br /&gt;12-6 lists the software used by the slave to load the queue from the shared memory buffer. In this &lt;br /&gt;software, the slave tests the flag flip-flop to see if the master has fIlled the buffer in the shared &lt;br /&gt;memory. If the buffer is fIlled, the slave microprocessor transfers its contents form the shared &lt;br /&gt;memory into its queue. Once the transfer is complete, the slave clears the flag flip-flop so the &lt;br /&gt;master may begin fIlling the buffer with additional printer data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 12-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 &lt;br /&gt;OOOB &lt;br /&gt;DODD &lt;br /&gt;0011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;0018 &lt;br /&gt;001A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001C &lt;br /&gt;DOlE &lt;br /&gt;0020 &lt;br /&gt;0022 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 &lt;br /&gt;0025 &lt;br /&gt;0029 &lt;br /&gt;002B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E4 00 &lt;br /&gt;A8 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B8 8000 &lt;br /&gt;8E D8 &lt;br /&gt;8B DE 0000 &lt;br /&gt;BE 0002 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E8 DODD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FB &lt;br /&gt;E6 00 &lt;br /&gt;EB E4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure found in the slave system that tests the &lt;br /&gt;;FLAG to determine if data are available for printing. &lt;br /&gt;;If data are available, data are transferred into the &lt;br /&gt;;queue for the printer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRANS PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT ;test &lt;br /&gt;IN AL,O &lt;br /&gt;TEST AL,l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL AL == 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,8000H &lt;br /&gt;MOV DS,AX &lt;br /&gt;MOV CX, DS: [0) &lt;br /&gt;MOV SI,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL FILL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STI &lt;br /&gt;OUT O,AL &lt;br /&gt;JMP TRANS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRANS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Data used with FILL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN_PS DW ? &lt;br /&gt;IN_PO DW ? &lt;br /&gt;OUT_PS DW ? &lt;br /&gt;OUT_PO DW ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLAG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; if not finished &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;segment of buffer &amp;amp; count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get count &lt;br /&gt;;address buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; fill queue &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear FLAG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;input pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;output pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Procedure that fills the printer queue. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FILL PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD ;clear direction &lt;br /&gt;2E: Al 001C R MOV AX, CS: IN_PS &lt;br /&gt;8E CO MOV ES,AX &lt;br /&gt;2E: 8B 3E DOlE R MOV DI, CS: IN_PO ; load input address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;. REPEAT &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-3 SHARED-BUS OPERATION 499 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:){} 3 ~,I E8 0014 CALL TESTF ;test for full queu',::, &lt;br /&gt;.UNTIL !ZERO? ;while full &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;u03S FA MOVSB ;store byte &lt;br /&gt;0036 E8 0024 CALL INCP iincrement pointer &lt;br /&gt;003? 8e CO MOV AX,ES &lt;br /&gt;003B 2EÂ· A3 OOlC R MOV CS:IN _PS,AX &lt;br /&gt;003F 2E: 89 3E OOlE R MOV CS:IN_PO,DI isave input pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;0046 C3 RET &lt;br /&gt;::;0Â·47 FILL ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0047 TESTF PROC NEAR USES DI DS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0047 E8 0011 CALL INCP iincrement pointer &lt;br /&gt;004C 8C D8 MOV AX,DS &lt;br /&gt;004E 2E: 3B 06 0020 R CMP AX,CS:OUT_PS &lt;br /&gt;0053 75 05 JNE TESTFI &lt;br /&gt;0055 2E: 3B 3E 0022 R CMP DI, CS: OUT_PO &lt;br /&gt;005A TESTFl: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOsD TESTF ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOsD INCP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOsD 47 INC DI &lt;br /&gt;.IF DI 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0062 8C CO MOV AX,ES &lt;br /&gt;0064 05 1000 ADD AX,lOOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF AX -- BOOOH &lt;br /&gt;006C B8 2000 MOV AX,2000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;006F BE CO MOV ES,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;0071 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0072 INCP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 12-7 lists the software that prints data from the queue. This software is interrupt &lt;br /&gt;driven, and therefore runs as a background program virtually hidden from the software listed in &lt;br /&gt;Example 12-6, except for the interrupt enable instruction. Whenever the printer interface, &lt;br /&gt;through a flip-flop, indicates that it is ready to accept additional data, an interrupt occurs, calling &lt;br /&gt;this interrupt service procedure. The procedure extracts data from the queue and sends them to &lt;br /&gt;the printer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 12-7 &lt;br /&gt;0072 PRINT PROC FAR USES AX BP DS Dr ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0077 E8 0023 CALL TESTE &lt;br /&gt;.IF ZERO? ;if empty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007C 8B EC MOV BP,SP ; interrupt off &lt;br /&gt;007E 8B 46 OC MOV AX, [BP+12] &lt;br /&gt;0081 80 E4 FD AND AH,OFDH &lt;br /&gt;0084 89 46 OC MOV [BP+12] ,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ELSE &lt;br /&gt;0089 B8 1000 MOV AX,lOOOH &lt;br /&gt;008C 8E CO MOV ES,AX &lt;br /&gt;008E 8A 05 MOV AL, [DI] &lt;br /&gt;0090 26: A2 0000 MOV ES: [0] ,AL ;print data &lt;br /&gt;0094 E8 OOlE CALL INCO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;009D PRINT ENDP &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;500 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;009D TESTE PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;009D 2E: Al 0020 R MOV AX,CS:OUT_PS &lt;br /&gt;OOAl 8E D8 MOV DS,AX &lt;br /&gt;00A3 2E: 8B 3E 0022 R MOV DI, CS: OUT_PO &lt;br /&gt;00A8 2E: 3B 06 ODIC R CMP AX,CS:IN_PS &lt;br /&gt;OOAD 75 05 JNE TESTEl &lt;br /&gt;OOAF 2E: 3B 3E ODIE R CMP DI,CS:IN_PO &lt;br /&gt;00B4 TESTE1: &lt;br /&gt;00B4 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B5 TESTE ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B5 INCO PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B5 47 INC DI &lt;br /&gt;.IF DI == 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOBA 8C D8 MOV AX,DS &lt;br /&gt;OOBC 05 1000 ADD AX,lOOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF AX == 8000H &lt;br /&gt;00C4 B8 2000 MOV AX,2000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;00C7 8E D8 MOV DS,AX &lt;br /&gt;00C9 2E: A3 0020 R MOV CS:OUT_PS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;OOCD 2E: 89 3E 0022 R MOV CS:OUT_PO,DI &lt;br /&gt;00D2 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00D3 INCO ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISK MEMORY SYSTEMS &lt;br /&gt;Disk memory is used to store long-term data. Many types of disk storage systems are available &lt;br /&gt;today. All disk memory systems use magnetic media except the optical disk memory, which &lt;br /&gt;stores data on a plastic disk. Optical disk memory is either a CD-ROM (compact disc/read-only &lt;br /&gt;memory) that is read, but never written, or a WORM (write oncelread mostly) that is read most &lt;br /&gt;of the time, but can be written once by a laser beam. Also becoming available is optical disk &lt;br /&gt;memory that can be read and written many times, but with a limitation on the number of write &lt;br /&gt;operations allowed. This section of the chapter provides an introduction to disk memory systems &lt;br /&gt;so that they may be used with computer systems. It also provides detail of their operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Floppy Disk Memory &lt;br /&gt;The most common and the most basic form of disk memory is the floppy or flexible disk. This &lt;br /&gt;magnetic recording media is available in three sizes: the 8&amp;quot; standard, 51/4&amp;quot; mini-floppy, and the &lt;br /&gt;3112&amp;quot; micro-floppy. Today the 8&amp;quot; standard version has all but disappeared, giving way to the &lt;br /&gt;mini- and micro-floppy disks. The 8&amp;quot; disk is too large and difficult to handle and stockpile. To &lt;br /&gt;solve this problem, industry developed the 51/4&amp;quot; mini-floppy disk. Today, the micro-floppy disk &lt;br /&gt;is quickly replacing the mini-floppy in newer systems because of its reduced size, ease of &lt;br /&gt;storage, and durability. Even so, many systems are still marketed with both the mini- and micro-&lt;br /&gt;floppy disk drives. In fact, one vendor markets a sin;~le disk drive that accepts both the 51/4&amp;quot; and &lt;br /&gt;31/2&amp;quot; floppy disks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All disks have several things in common. They are all organized so data are stored in &lt;br /&gt;tracks. A track is a concentric ring of data stored on a surface of a disk. Figure 12-26 illustrates &lt;br /&gt;the surface of a 51/4&amp;quot; mini-floppy disk showing a track that is divided into sectors. A sector is a &lt;br /&gt;common subdivision of a track that is designed to hold a reasonable amount of data. In many &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-4 DISK MEMORY SYSTEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-26 The format &lt;br /&gt;of a 51//' floppy disk &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Inner &lt;br /&gt;track &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;501 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;systems, a sector holds either 512 or 1,024 bytes of data. The size of a sector can vary from 128 &lt;br /&gt;bytes to the length of one entire track. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice from the illustration that there is a hole through the disk that is' labeled an index &lt;br /&gt;hole. The index hole is designed so the electronic system that reads the disk is able to find the &lt;br /&gt;beginning of a track and its first sector (00). Tracks are numbered from track 00, the outermost &lt;br /&gt;track, in increasing value toward the center or innermost track. Sectors are often numbered from &lt;br /&gt;sector 00 on the outermost track to whatever value is required to reach the innermost track and its &lt;br /&gt;last sector. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 51/4&amp;quot; Mini-Floppy Disk. Today, the 5W' floppy is probably the most popular disk size used &lt;br /&gt;with older microcomputer systems. Figure 12-27 illustrates this mini-floppy disk. The floppy &lt;br /&gt;disk is rotated at 300 RPM inside its semi-rigid plastic jacket. The head mechanism in a floppy &lt;br /&gt;disk drive makes physical contact with the surface of the disk, eventually causing wear and &lt;br /&gt;damage to the disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Today, most mini-floppy disks are double-sided. This means that data are written on both &lt;br /&gt;the top and bottom surfaces of the disk. A set of tracks is called a cylinder and consists of one &lt;br /&gt;top and one bottom track. For example, cylinder 00 consists of the outermost top and bottom &lt;br /&gt;tracks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Floppy disk data are stored in the double-density format, which uses a recording technique &lt;br /&gt;called MFM (modified frequency modulation) to store the information. Double-density, &lt;br /&gt;double-sided (DSDD) disks are normally organized with 40 tracks of data on each side of the &lt;br /&gt;disk. A double-density disk track is typically divided into nine sectors with each sector con-&lt;br /&gt;taining 512 bytes of information. This means that the total capacity of a double-density, double-&lt;br /&gt;sided disk is 40 tracks per side x 2 sides x 9 sectors per track x 512 bytes per sector, or 368,640 &lt;br /&gt;(360K) bytes of information. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Earlier disk memory systems used single-density and FM (frequency modulation) to &lt;br /&gt;store information in 40 tracks on one or two sides of the disk. Each of the eight or nine sectors on &lt;br /&gt;the single-density disk stored 256 bytes of data. This meant that a single-density disk stored 90K &lt;br /&gt;bytes of data per side. A single-density, double-sided disk stored 180K bytes of data. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;502 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-27 The 51f4&amp;quot; &lt;br /&gt;mini-floppy disk &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Drive hub----.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Write protect notch ----.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;O..-Index hole &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also common today are high-density (HD) mini-floppy disks. A high density mini-floppy &lt;br /&gt;disk contains 80 tracks of information per side with eight sectors per track. Each sector contains &lt;br /&gt;1,024 bytes of information. This gives the 51//' high density mini-floppy disk a total capacity of &lt;br /&gt;80 tracks per side x 2 sides x 15 sectors per track x 512 bytes per sector, or 1,228,800 (approxi-&lt;br /&gt;mately 1.2M) bytes of information. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The magnetic recording technique used to store data on the surface of the disk is called &lt;br /&gt;non-return to zero (NRZ) recording. With NRZ recording, magnetic flux placed on the surface &lt;br /&gt;of the disk never returns to zero. Figure 12-28 illustrates the information stored in a portion of a &lt;br /&gt;track. It also shows how the magnetic field encodes the data. Note that arrows are used in this il-&lt;br /&gt;lustration to show the polarity of the magnetic field stored on the surface of the disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The main reason that this form of magnetic encoding was chosen is that it automatically erases &lt;br /&gt;old information when new information is recorded. If another technique were used, a separate erase &lt;br /&gt;head would be required. The mechanical alignment of a separate erase head and a separate &lt;br /&gt;read/write head is virtually impossible. The magnetic flux density of the NRZ signal is so intense &lt;br /&gt;that it completely saturates (magnetizes) the surface of the disk, erasing all prior data. It also ensures &lt;br /&gt;that information will not be affected by noise, because the amplitude of the magnetic field contains &lt;br /&gt;no information. The information is stored in the placement of the changes of magnetic field. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data L &lt;br /&gt;T -1111111111111111111111111111111111111111111111 I 11111111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-28 The nonreturn to zero (NRZ) recording technique &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-4 DISK MEMORY SYSTEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-29 Modified &lt;br /&gt;frequency modulation (MFM) &lt;br /&gt;used with disk memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;503 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cjo C:o cjo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data are stored in the form of MFM (modified frequency modulation) in modem floppy &lt;br /&gt;disk systems. The MFM recording technique stores data in the form iilustrated in Figure 12-29. &lt;br /&gt;Notice that each bit time is 2 ~s wide on a double-density disk. This means that data are recorded &lt;br /&gt;at the rate of 500,000 bits per second. Each 2 ~s bit time is divided into two parts. One part is &lt;br /&gt;designated to hold a clock pulse, and the other holds a data pulse. If a clock pulse is present, it is &lt;br /&gt;1 ~s wide, as is a data pulse. Clock and data pulses are never present at the same time in one bit &lt;br /&gt;period. (Note that high-density disk drives half these times, so that a bit time is 1 ~s and a clock &lt;br /&gt;or data pulse is 0.5 ~s wide. This also doubles the transfer rate to 1 million bits per second.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If a data pulse is present, the bit time represents a logic 1. If no data or no clock is present, &lt;br /&gt;the bit time represents a logic O. If a clock pulse is present with no data pulse, the bit time also &lt;br /&gt;represents a logic O. The rules followed when data are stored using MFM are: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. A data pulse is always stored for a logic 1. &lt;br /&gt;2. No data and no clock are stored for the first logic 0 in a string of logic 0' s. &lt;br /&gt;3. The second and subsequent logic O's in a row contain a clock pulse, but no data pulse. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The reason that a clock is inserted as the second and subsequent zero in a row is to main-&lt;br /&gt;tain synchronization as data are read from the disk. The electronics used to recapture the data &lt;br /&gt;from the disk drive use a phase-locked loop to generate a clock and a data window. The phase-&lt;br /&gt;locked loop needs a clock or data to maintain synchronized operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 31ft' Micro-floppy Disk. Another very popular disk size is the 31/2&amp;quot; micro-floppy disk. Re-&lt;br /&gt;cently, this size floppy disk has begun to sell very well; in the future, it promises to be the dom-&lt;br /&gt;inant size floppy disk. The micro-floppy disk is a much-improved version of the mini-floppy &lt;br /&gt;disk described earlier. Figure 12-30 illustrates the 3'12&amp;quot; micro-floppy disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-30 The 3112&amp;quot; &lt;br /&gt;micro-floppy disk &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Write protect &lt;br /&gt;----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= E:I &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 Drive hub &lt;br /&gt;0 0 ~ Head slot &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'Head door &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;504 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Disk designers noticed several shortcomings of the mini-floppy, a scaled-down version of &lt;br /&gt;the 8&amp;quot; standard floppy, soon after it was released. Probably one of the biggest problems with the &lt;br /&gt;mini-floppy is that it is packaged in a semi-rigid plastic cover that bends easily. The micro-&lt;br /&gt;floppy is packaged in a rigid plastic jacket that will not bend easily. This provides a much greater &lt;br /&gt;degree of protection to the disk inside the jacket. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another problem with the mini-floppy is the head slot that continually exposes the surface &lt;br /&gt;of the disk to contaminants. This problem is also corrected on the micro-floppy because it is con-&lt;br /&gt;structed with a spring-loaded sliding head door. The head door remains closed until the disk is &lt;br /&gt;inserted into the drive. Once inside the drive, the drive mechanism slides the door open, ex-&lt;br /&gt;posing the surface of the disk to the read/write heads. This provides a great deal of protection to &lt;br /&gt;the surface of the micro-floppy disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Yet another improvement is the sliding plastic write-protection mechanism on the micro-&lt;br /&gt;floppy disk. On the mini-floppy disk, a piece of tape was placed over a notch on the side of the &lt;br /&gt;jacket to prevent writing. This plastic tape easily becomes dislodged inside disk drives, causing &lt;br /&gt;problems. On the micro-floppy, an integrated plastic slide has replaced the tape write-protec-&lt;br /&gt;tion mechanism. To write-protect (prevent writing) the micro-floppy disk, the plastic slide is &lt;br /&gt;moved to open the hole though the disk jacket. This allows light to strike a sensor, which in-&lt;br /&gt;hibits writing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Still another improvement is the replacement of the index hole with a different drive mech-&lt;br /&gt;anism. The drive mechanism on the mini-floppy allows the disk drive to grab the disk at any &lt;br /&gt;point. This requires an index hole so that the electronics can find the beginning of a track. The &lt;br /&gt;index hole is another trouble spot because it collects dirt and dust. The micro-floppy has a drive &lt;br /&gt;mechanism that is keyed so that it fits only one way inside the disk drive. The index hole is no &lt;br /&gt;longer required because of this keyed drive mechanism. Because of the sliding head mechanism &lt;br /&gt;and the fact that no index hole exists, the micro-floppy disk has no place to catch dust or dirt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Two types of micro-floppy disks are widely available: the double-sided, double-density &lt;br /&gt;(DSDD) and the high-density (HD). The double-sided, double-density micro-floppy disk has 80 &lt;br /&gt;tracks per side with each track containing nine sectors. Each sector contains 512 bytes of infor-&lt;br /&gt;mation. This allows 80 tracks per side x 2 sides x 9 sectors x 512 bytes per sector, or 737,280 &lt;br /&gt;(720K) bytes of data to be stored on a double-density, double-sided floppy disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The high-density, double-sided micro-floppy disk stores even more information. The high-&lt;br /&gt;density version has 80 tracks per side, but the number of sectors is doubled to 18 per track. This &lt;br /&gt;fonnat still uses 512 bytes per sector, as did the double-density fonnat. The total number of bytes &lt;br /&gt;on a high-density, double-sided micro-floppy disk is 80 tracks per side x 2 sides x 18 sectors per &lt;br /&gt;track x 512 bytes per sector, or 1,474,560 (1.44M) bytes of information. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Recently a new size 3112&amp;quot; floppy disk has been introduced, the EHD (extended high den-&lt;br /&gt;sity) floppy disk. This new fonnat stores 2.88M bytes of data on a single floppy disk. At this &lt;br /&gt;time, EMO disks are expensive and will take time to become common. Also available are the &lt;br /&gt;floptical disk, which stores data magnetically using an optical tracking system. The floptical &lt;br /&gt;disk stores 21M bytes of data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hard Disk Memory &lt;br /&gt;Larger disk memory is available in the fonn of the hard disk drive. The hard disk drive is often &lt;br /&gt;called a fixed disk because it is not removable like the floppy disk. A hard disk is also often &lt;br /&gt;called a rigid disk. The tenn Winchester drive is also used to describe a hard disk drive, but kÂ£s &lt;br /&gt;commonly today. Hard disk memory has a much larger capacity than floppy disk memory. Hard &lt;br /&gt;disk memory is available in sizes exceeding 1 G byte of data. Common, low-cost (less than $0.50 &lt;br /&gt;per megabyte) sizes are presently 850M bytes or IG byte. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are several differences between the floppy disk and the hard disk memory. The hard &lt;br /&gt;disk memory uses a flying head to store and read data from the surface of the disk. A flying head, &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-4 DISK MEMORY SYSTEMS 505 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;which is very small and light, does not touch the surface of the disk. It flies above the surface on &lt;br /&gt;a film of air that is carried with the surface of the disk as it spins. The hard disk typically spins at &lt;br /&gt;3,000 to 5,200 RPM, which is more than 10 times faster than the floppy disk. This higher rota-&lt;br /&gt;tional speed allows the head to fly (just as an airplane flies) just over the top of the surface of the &lt;br /&gt;disk. This is an important feature because there is no wear on the hard disk's surface, as there is &lt;br /&gt;with the floppy disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Problems can arise because of flying heads. One problem is a head crash If the power is &lt;br /&gt;abruptly interrupted or the hard disk drive is jarred, the head can crash onto the disk surface. This &lt;br /&gt;can damage the disk surface or the head. To help prevent crashes, some drive manufacturers &lt;br /&gt;have included a system that automatically parks the head when power is interrupted. This type of &lt;br /&gt;disk drive has auto-parking heads. When the heads are parked, they are moved to a safe landing &lt;br /&gt;zone (unused track) when the power is disconnected. Some drives are not auto-parking. These &lt;br /&gt;drives usually require a program that parks the heads on the innermost track before power is dis-&lt;br /&gt;connected. The innermost track is a safe landing area because it is the very last track filled by the &lt;br /&gt;disk drive. Parking is the responsibility of the operator in such disk drives. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another difference between a floppy disk drive and a hard disk drive are the number of &lt;br /&gt;heads and disk surfaces. A floppy disk drive has two heads, one for the upper surface and one for &lt;br /&gt;the lower surface. The hard disk drive may have up to eight disk surfaces (four platters) with up &lt;br /&gt;to two heads per surface. Each time that a new cylinder is obtained by moving the head as-&lt;br /&gt;sembly, 16 new tracks are available under the heads. Refer to Figure 12-31, which illustrates a &lt;br /&gt;hard disk system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Heads are moved from track to track using either a stepper motor or a voice coil. The &lt;br /&gt;stepper motor is slow and noisy, while the voice coil mechanism is quiet and quick. Moving the &lt;br /&gt;head assembly requires one step per cylinder in a system that uses a stepper motor to position the &lt;br /&gt;heads. In a system that uses a voice coil, the heads can be moved many cylinders with one &lt;br /&gt;sweeping motion. This makes the disk drive faster when seeking new cylinders. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Another advantage of the voice coil system is that a servo mechanism can monitor the am-&lt;br /&gt;plitude of the signal as it comes from the read head and make slight adjustments in the position &lt;br /&gt;of the heads. This is not possible with a stepper motor, which relies strictly on mechanics to po-&lt;br /&gt;sition the head. Stepper-motor-type-head positioning mechanisms can often become misaligned &lt;br /&gt;with use, while the voice coil mechanism corrects for any misalignment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hard disk drives often store information in sectors that are 512 bytes long. Data are ad-&lt;br /&gt;dressed in clusters of eight or more sectors that contain 4,096 bytes (or more) on most hard disk &lt;br /&gt;drives. Hard disk drives use either MFM or RLL to store information. MFM is described with &lt;br /&gt;floppy disk drives. Run-length limited (RLL) is described here. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-31 A hard disk Actuator arm &lt;br /&gt;drive that uses four heads per Disk platters &lt;br /&gt;platter t &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;506 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A typical older MFM hard disk drive uses 18 sectors per track so that 18K bytes of data are &lt;br /&gt;stored per track. If a hard disk drive has a capacity of 40M bytes, it contains approximately 2,280 &lt;br /&gt;tracks. If the disk drive has two heads, this means that it contains 1,140 cylinders. If it contains &lt;br /&gt;four heads, then it has 570 cylinders. These specifications vary from disk drive to disk drive. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RLL Storage. Run-length limited (RLL) disk drives use a different method than MFM for en-&lt;br /&gt;coding the data. The term RLL means that the run of zeros (zeros in a row) is limited. A common &lt;br /&gt;RLL encoding scheme in use today is RLL 2,7. This means that the run of zeros is always be-&lt;br /&gt;tween two and seven. Table 12-2 illustrates the coding used with standard RLL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data are first encoded using Table 12-2 before being sent to the drive electronics for &lt;br /&gt;storage on the disk surface. Because of this encoding technique, it is possible to achieve a 50 per-&lt;br /&gt;cent increase in data storage on a disk drive when compared to MFM. The main difference is that &lt;br /&gt;the RLL drive often contains 27 tracks instead of the 18 found on the MFM drive. (Some RLL &lt;br /&gt;drives also use 35 sectors per track.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It is interesting to note that in most cases, RLL encoding requires no change to the drive &lt;br /&gt;electronics or surface of the disk. The only difference is a slight decrease in the pulse width using &lt;br /&gt;RLL, which may require slightly finer oxide particles on the surface of the disk. Disk manufac-&lt;br /&gt;turers test the surface of the disk and grade the disk drive as either an MFM certified or an RLL &lt;br /&gt;certifie(drive. Other than grading, there is no difference in the construction of the disk drive or &lt;br /&gt;the magnetic material that coats the surface of the disks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 12-32 shows a comparison ofMFM data and RLL data. Notice that the amount of &lt;br /&gt;time (space) required to store RLL data is reduced when compared to MFM. Here a 101001011 &lt;br /&gt;is coded in both MFM and RLL so that these two standards can be compared. Notice that the &lt;br /&gt;width of the RLL signal has been reduced so that three pulses fit into the same space as a clock &lt;br /&gt;and a data pulse for MFM. A 40 M byte MFM disk can hold 60M bytes of RLL encoded data. &lt;br /&gt;Besides holding more information, the RLL drive can be written and read at a higher rate. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All hard disk drives use either MFM or RLL encoding. There are a number of disk drive &lt;br /&gt;interfaces in use today. The oldest is the ST-506 interface, which uses either MFM or RLL data. &lt;br /&gt;A disk system using this interface is also called either MFM or RLL disk system. Newer stan-&lt;br /&gt;dards are also found in use today. These include ESDI, SCSI, and IDE. All of these newer stan-&lt;br /&gt;dards use RLL even though they normally do not call attention to it. The main difference is the &lt;br /&gt;interface between the computer and the disk drive. The IDE system is becoming the standard &lt;br /&gt;hard disk memory interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The enhanced small disk interface (ESDI) system, which has disappeared, is capable of &lt;br /&gt;transferring data between itself and the computer at rates approaching 10M bytes per second. An &lt;br /&gt;ST-506 interface can approach a transfer rate of 860K bytes per second. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The small computer system interface (SCSI) system is also used because it allows up to &lt;br /&gt;. seven different disk or other interfaces to be connected to the computer through same interface &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;controller. SCSI is found in some PC-type computers and also in the Apple Macintosh system. &lt;br /&gt;An imprOVed version, SCSI-II, has started to appear in some systems. In the future, this interface &lt;br /&gt;may be replaced with IDE in most applications. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 12-2 Standard RLL &lt;br /&gt;2,7 coding Input Data Stream &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 &lt;br /&gt;10 &lt;br /&gt;010 &lt;br /&gt;0010 &lt;br /&gt;11 &lt;br /&gt;011 &lt;br /&gt;0011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RLL Output &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000100 &lt;br /&gt;0100 &lt;br /&gt;100100 &lt;br /&gt;00100100 &lt;br /&gt;1000 &lt;br /&gt;001000 &lt;br /&gt;00001000 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-4 DISK MEMORY SYSTEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data RLL &lt;br /&gt;101001011 = 010001001001001000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: o o o o , , &lt;br /&gt;, , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:Lf1; : !&lt;br /&gt;1 d &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-----i-..... &lt;br /&gt;1 :: :: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;i'i nJ'l &lt;br /&gt;, L-i-' ----'f- , , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;! , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MFM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RLL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010 001 001 001 001 000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-32 A comparison of MFM with RLL using data 101001011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, I &lt;br /&gt;, , ' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LR , , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I : &lt;br /&gt;, I &lt;br /&gt;, , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 : &lt;br /&gt;1 : &lt;br /&gt;, I &lt;br /&gt;, , &lt;br /&gt;, I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l 1 &lt;br /&gt;: ! &lt;br /&gt;I , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;! ! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;507 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The newest system is integrated drive electronics (IDE), which incorporates the disk &lt;br /&gt;controller in the disk drive and attaches the disk drive to the host system through a small inter-&lt;br /&gt;face cable. This allows many disk drives to be connected to a system without worrying about bus &lt;br /&gt;conflicts or controller conflicts. IDE drives are found in newer IBM PS-2 systems and many &lt;br /&gt;clones. Even Apple computer systems are starting to be found with IDE drives in place of the &lt;br /&gt;SCSI drives found in older Apple computers. The IDE interface is also capable of driving other &lt;br /&gt;VO devices besides the hard disk. This interface also usually contains at least a 32K-byte cache &lt;br /&gt;memory for disk data. The cache speeds disk transfers. Common access times for an IDE drive &lt;br /&gt;are often less than 11 ms, whereas the access time for a floppy disk is about 200 ms. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Optical Disk Memory &lt;br /&gt;Optical disk memory (see Figure 12-33) is commonly available in two forms: the CD-ROM &lt;br /&gt;(compact disc/read only memory) and the WORM (write oncelread mostly). The CD-ROM is &lt;br /&gt;the lowest cost optical disk, but it suffers from lack of speed. Access times for a CD-ROM are &lt;br /&gt;typically 300 ms or longer, about the same as a floppy disk. (Note that slower CD-ROM devices &lt;br /&gt;are on the market and should be avoided.) Hard disk magnetic memory can have access times as &lt;br /&gt;little as 11 ms. A CD-ROM stores 660M bytes of data or a combination of data and musical pas-&lt;br /&gt;sages. As systems develop and become more visually active, the use of the CD-ROM drive will &lt;br /&gt;become even more common. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The WORM drive sees far more commercial application than the CD-ROM. The problem &lt;br /&gt;is that its application is very specialized due to the nature of the WORM. Because data may only &lt;br /&gt;be written once, the main application is in the banking industry, insurance industry, and other &lt;br /&gt;massive data-storing organizations. The WORM is normally used to form an audit trail of trans-&lt;br /&gt;actions that are spooled onto the WORM and retrieved only during an audit. You might call the &lt;br /&gt;WORM an archiving device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Many WORM and read/write optical disk memory systems are interfaced to the micro-&lt;br /&gt;processor using the SCSI or ESDI interface standards used with hard disk memory. The differ-&lt;br /&gt;ence is that the current optical disk drives are no faster than the most floppy drives. Some &lt;br /&gt;CD-ROM drives are interfaced to the microprocessor through proprietary interfaces that are not &lt;br /&gt;compatible with other disk drives. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The main advantage of the optical disk is its durability. Because a solid-state laser beam is &lt;br /&gt;used to read the data from the disk, and the focus point is below a protective plastic coating, the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;508 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;c-=-=:cc.&amp;quot;''''~Â·--- Semitransparent mirror -----....,:'&amp;lt;/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-&amp;quot;I1-------Lenses-----.... ~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Photodiode ------I.~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-33 The optical CD-ROM memory system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;surface of the disk may contain small scratches and dirt particles and still be read correctly. This &lt;br /&gt;feature allows less care of the optical disk than a comparable floppy disk. About the only way to &lt;br /&gt;destroy data on an optical disk is to break or deeply scar the disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The read/write CD-ROM drive is here and its cost is dropping rapidly. In the near future &lt;br /&gt;we should start seeing the read/write CD-ROM drive replacing floppy disk drives. The main ad-&lt;br /&gt;vantage is the vast storage available on the read/write CD-ROM. Soon the format will change so &lt;br /&gt;that many G bytes of data will be available. The new versatile (DVD) read/write CD-ROM &lt;br /&gt;should become available sometime in later 1996 or early 1997. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIDEO DISPLAYS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Modem video displays are OEM (original equipment manufacturer) devices that are usually &lt;br /&gt;purchased and incorporated into a system. Today there are many different types of video dis-&lt;br /&gt;plays available. Of the types available, either color or monochrome versions are found. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Monochrome versions usually display information using amber, green, or paper-white dis-&lt;br /&gt;plays. The paper-white display is becoming extremely popular for many applications. The most &lt;br /&gt;common of these apl1lications are desktop publishing and computer-aided drafting (CAD). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The color displays are more diverse. Color display systems are available that accept infor-&lt;br /&gt;mation as a composite video signal much as your home television, as TTL voltage level signals &lt;br /&gt;(0 or 5V), and as analog signals (0-0.7V). Composite video displays are disappearing because the &lt;br /&gt;resolution available is too low. Today many applications require high-resolution graphics, which &lt;br /&gt;cannot be displayed on a composite display such as a home television receiver. Early composite &lt;br /&gt;video displays were found with Commodore 64, Apple 2, and similar computer systems. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-5 VIDEO DISPLAYS 509 &lt;br /&gt;Color burst &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I / Black level &lt;br /&gt;Sync pedestal ---..... 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Video line &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;! / White level &lt;br /&gt;FIGURE 12-34 The composite video signal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Video Signals &lt;br /&gt;Figure 12-34 illustrates the signal sent to a composite video display. This signal is composed of sev-&lt;br /&gt;eral parts that are required for this type of display. The signals illustrated represent the signals sent to &lt;br /&gt;a color composite video monitor. Notice that these signals include not only video but sync pulses, &lt;br /&gt;sync pedestals, and a color burst. Also notice that an audio signal is not illustrated because it often &lt;br /&gt;does not exist. Rather than include audio with the composite video signal, audio is developed in the &lt;br /&gt;computer and output from a speaker inside the computer cabinet. It can also be developed by a sound &lt;br /&gt;system and output in stereo to external speakers. The major disadvantage of the composite video dis-&lt;br /&gt;play is the resolution and color limitations. Composite video signals were designed to emulate tele-&lt;br /&gt;vision video signals so that a home television receiver could function as a video monitor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Most modem video systems use direct video signals that are generated with separate sync &lt;br /&gt;signals. In a direct video system, video information is passed to the monitor through a cable that &lt;br /&gt;uses separate lines for video and also synchronization pulses. Recall that these signals were com-&lt;br /&gt;bined in a composite video signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A monochrome (one color) monitor uses one wire for video, one for horizontal sync, and &lt;br /&gt;one for vertical sync. Often these are the only signal wires found. A color video monitor uses three &lt;br /&gt;video signals. One signal represents red, another green, and the third blue. These monitors are &lt;br /&gt;often called RGB monitors for the video primary colors of light: red (R), green (G), and blue (B). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The TIL RGB Monitor &lt;br /&gt;The RGB monitor is available as either an analog or TIL monitor. The RGB monitor uses TTL &lt;br /&gt;level signals (0 or 5 V) as video inputs and a fourth line called intensity to allow a change in in-&lt;br /&gt;tensity. The RGB video TTL display can display a total of 16 different colors. The TTL RGB &lt;br /&gt;monitor is used in the CGA (color graphics adapter) system found in older computer systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 12-3 lists these 16 colors and also the TIL signals present to generate them. Eight of &lt;br /&gt;the 16 colors are generated at high intensity, and the other eight at low intensity. The three video &lt;br /&gt;colors are red, green, and blue. These are primary colors of light. The secondary colors are cyan, &lt;br /&gt;magenta, and yellow. Cyan is a combination of blue and green video signals and is blue-green in &lt;br /&gt;color. Magenta is a combination of blue and red video signals and is a purple color. Yellow (high-&lt;br /&gt;intensity) and brown (low-intensity) are both a combination of red and green video signals. If ad-&lt;br /&gt;ditional colors are desired, TTL video is not normally used. A scheme was developed using low &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;510 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CDNTRDLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 12-3 16 colors &lt;br /&gt;found in the CGA display Intensity Red Green Blue Color &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 0 Black &lt;br /&gt;0 0 0 1 Blue &lt;br /&gt;0 0 0 Green &lt;br /&gt;0 0 1 1 Cyan &lt;br /&gt;0 1 0 0 Red &lt;br /&gt;0 1 0 1 Magenta &lt;br /&gt;0 1 1 0 Brown &lt;br /&gt;0 1 1 1 White &lt;br /&gt;1 0 0 0 Gray &lt;br /&gt;1 0 0 1 Bright Blue &lt;br /&gt;1 0 1 0 Bright Green &lt;br /&gt;1 0 1 1 Bright Cyan &lt;br /&gt;1 1 0 0 Bright Red &lt;br /&gt;1 1 0 1 Bright Magenta &lt;br /&gt;1 1 0 Yellow &lt;br /&gt;1 Bright White &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and medium color TTL video signals, which provided 32 colors, but it had little application and &lt;br /&gt;never found widespread use in the field. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 12-35 illustrates the connector most often found on the TTL RGB monitor or a &lt;br /&gt;TTL monochrome monitor. The connector illustrated is a 9-pin connector. Two of the connec-&lt;br /&gt;tions are used for ground, three for video, two for synchronization or retrace signals, and one for &lt;br /&gt;intensity. Notice that pin 7 is labeled normal video. This is the pin used on a monochrome mon-&lt;br /&gt;itor for the luminance or brightness signal. Monochrome TTL monitors use the same 9-pin con-&lt;br /&gt;nector as RGB TTL monitors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Analog RGB Monitor &lt;br /&gt;In order to display more than 16 colors, an analog video display is required. These are often &lt;br /&gt;called analog RGB monitors. Analog RGB monitors still have three video input signals, but &lt;br /&gt;don't have the intensity input. Because the video signals are analog signals instead of two-level &lt;br /&gt;TTL signals, they are any voltage level between O.OV and O.7V. This allows an infinite number &lt;br /&gt;of colors to be displayed. This is because an infinite number of voltage levels between the min-&lt;br /&gt;imum and maximum could be generated. In practice, a finite number of levels are generated. &lt;br /&gt;This is usually either 256K, 16M, or 24M colors, depending on the standard. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-35 The 9-pin DB9 Pin Function &lt;br /&gt;connector found on a TIL &lt;br /&gt;monitor Ground &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 Ground &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 Red video &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 Green video &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 Blue video &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 Intensity &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 Normal video &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 Horizontal retrace &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9 Vertical retrace &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12--5 VIDEO DISPLAYS 511 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OB15 Pin Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.'0 9 ( ( ( ( ( )\\ Red video &lt;br /&gt;\\sl ~ 1 1 1 1 74 6 3 5 2 4 0 2 9 1 2 Green video (monochrome video) 3 Blue video &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 Ground &lt;br /&gt;5 Ground &lt;br /&gt;6 Red ground &lt;br /&gt;7 Green ground (monochrome ground) &lt;br /&gt;8 Blue ground &lt;br /&gt;9 Blocked as a key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 Ground &lt;br /&gt;11 Color detect (ground on a color monitor) &lt;br /&gt;12 Monochrome detect (ground on a monochrome monitor) &lt;br /&gt;13 Horizontal retrace &lt;br /&gt;14 Vertical retrace &lt;br /&gt;15 Ground &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-36 The 1S-pin connector found on an analog monitor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 12-36 illustrates the connector used for an analog RGB or analog monochrome &lt;br /&gt;monitor. Notice that the connector has 15 pins and supports both RGB and monochrome analog &lt;br /&gt;displays. The way data are displayed on an analog RGB monitor depends upon the interface &lt;br /&gt;standard used with the monitor. Pin 9 is a key, which means that no hole exists on the female &lt;br /&gt;connector for this pin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Most analog displays use a digital-to-analog converter (DAC) to generate each color &lt;br /&gt;video voltage. A common standard uses a 6-bit DAC for each video signal to generate 64 dif-&lt;br /&gt;ferent voltage levels between OV and 0.7 V. There are 64 different red video levels, 64 different &lt;br /&gt;green video levels, and 64 different blue video levels. This allows 64 x 64 x 64 or 262,144 &lt;br /&gt;(256K) different colors to be displayed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Other arrangements are possible, but the speed of the DAC is critical. Most modem dis-&lt;br /&gt;plays require an operating conversion time of 25 ns to 40 ns maximum. When converter tech-&lt;br /&gt;nology advances, additional resolution at a reasonable price will become available. If 7 -bit &lt;br /&gt;converters are used for generating video, 128 x 128 x 128 or 2,097,152 (2M) colors are dis-&lt;br /&gt;played. In this system, a 2I-bit color code is needed so that a 7-bit code is applied to each DAC. &lt;br /&gt;Eight bit converters also find applications and allow 256 x 256 x 256 or 16,777,216 (16M) &lt;br /&gt;colors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 12-37 illustrates the video generation circuit employed in many common video &lt;br /&gt;standards, such as the short-lived EGA (enhanced graphics adapter) and VGA (variable &lt;br /&gt;graphics array) as used with an IBM-PC. This circuit is used to generate VGA video. Notice &lt;br /&gt;that each color is generated with an 18-bit digital code. Six of the 18-bits are used to generate &lt;br /&gt;each video color voltage when applied to the inputs of a 6-bit DAC. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A high-speed palette SRAM (access time of less than 40 ns) is used to store 256 different &lt;br /&gt;I8-bit codes that represent 256 different hues. This 18-bit code is applied to the digital-to-analog &lt;br /&gt;converters. The address input to the SRAM selects one of the 256 colors stored as I8-bit binary &lt;br /&gt;codes. This system allows 256 colors out of a possible 256K colors to be displayed at one time. &lt;br /&gt;In order to select any of 256 colors, an 8-bit code stored in the computer's video display RAM is &lt;br /&gt;used to specify the color of a picture element. If more colors are used in a system, the code must &lt;br /&gt;be wider. For example, a system that displays 1,024 colors out of 256K colors requires a IO-bit &lt;br /&gt;code to address the SRAM, which contains 1,024 locations, each containing an 18-bit color &lt;br /&gt;code. Some newer systems use a larger palette SRAM to store up to 64K different color codes. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;512 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data 00-07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;25 MHz &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 ~ eLK 5E &lt;br /&gt;16R8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00-05 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F374 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00f~BE3AO A1 g~ 6 A2 &lt;br /&gt;03 12 ~~ &lt;br /&gt;04 15 AS &lt;br /&gt;05 1 A6 g~ 1 A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;256 X 18 &lt;br /&gt;Palette RAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 05 &lt;br /&gt;06 07 &lt;br /&gt;08 &lt;br /&gt;09 &lt;br /&gt;010 &lt;br /&gt;011 &lt;br /&gt;012 &lt;br /&gt;013 &lt;br /&gt;014 &lt;br /&gt;015 &lt;br /&gt;016 &lt;br /&gt;017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Blue video &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F374 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Green videc &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F374 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Red video &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F374 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-37 Generation of VGA video signals &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Apple Macintosh IIci uses a 24-bit binary code tr: specify each color in its color video &lt;br /&gt;adapter. Each DAC is 8-bits wide. This means that each converter can generate 256 different &lt;br /&gt;video voltage levels. There are 256 x 256 x 256 or 16,777,216 different possible colors. As with &lt;br /&gt;the IBM VGA standard, only 256 colors are displayed at a time. The SRAM in the Apple inter-&lt;br /&gt;face is 256 x 24 instead of 256 x 18. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever a color is placed on the video display, provided ~TC is a logic 0, the system sends &lt;br /&gt;the 8-bit code that represents a color to the DO-D7 connections. The PAL 16R8 then generates &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-5 VIDEO DISPLAYS 513 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a clock pulse for UlO, which latches the color code. After 40 ns (one 25 MHz clock) the PAL &lt;br /&gt;generates a clock pulse for the DAC latches (U7, U8, and U9). This amount of time is required &lt;br /&gt;for the palette SRAM to look up the 18-bit contents of the memory location selected by U 10. &lt;br /&gt;Once the color code (l8-bit) is latched into U7-U9, the three DACs convert it to three video &lt;br /&gt;voltages for the monitor. This process is repeated for each 40 ns-wide picture element (pixel) &lt;br /&gt;that is displayed. The pixel is 40 ns wide because a 25 MHz clock is used in this system. Higher &lt;br /&gt;resolution is attainable if a higher clock frequency is used with the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the color codes (l8-bits) stored in the SRAM must be changed, this is always accom-&lt;br /&gt;plished during retrace when RTC is a logic I. This prevents any video noise from disrupting the &lt;br /&gt;image displayed on the monitor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to change a color, the system uses the SO, S 1, and S2 inputs of the PAL to select &lt;br /&gt;U 1, U2, U3, or U 10. First the address of the color to be changed is sent to latch U 10. This ad-&lt;br /&gt;dresses a location in the palette SRAM. Next, each new video color is loaded into U I, U2, and &lt;br /&gt;U3. Finally, the PAL generates a write pulse for the WE input to the SRAM to write the new &lt;br /&gt;color code into the palette SRAM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Retrace occurs 70.1 times per second in the vertical direction and 31,500 times per second &lt;br /&gt;in the horizontal direction for a 640 x 480 display. During retrace, the video signal voltage sent &lt;br /&gt;to the display must be OV. This causes black to be displayed during the retrace. Retrace itself is &lt;br /&gt;used to move the electron beam to the upper left-hand corner for vertical retrace and to the left &lt;br /&gt;margin of the screen for horizontal retrace. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The circuit illustrated causes U4-U6 buffers to be enabled so they apply 00000 each to the &lt;br /&gt;DAC latch for retrace. The DAC latches capture this code and generate OV for each video color &lt;br /&gt;signal to blank the screen. By definition, OV is considered the black level for video and 0.7V is &lt;br /&gt;considered full intensity on a video color signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The resolution of the display, for example 640 x 480, determines the amount of memory &lt;br /&gt;required for the video interface card. If this resolution is used with a 256 color display (8-bits per &lt;br /&gt;pixel), then 640 x 480 bytes of memory (307,200) are required to store all of the pixels for the &lt;br /&gt;display. Higher resolution displays are possible, but as you can imagine even more memory is re-&lt;br /&gt;quired. A 640 x 480 display has 480 video raster lines and 640 pixels per line. A raster line is &lt;br /&gt;the horizontal line of video information that is displayed on the monitor. A pixel is the smallest &lt;br /&gt;subdivision of this horizontal line. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 12-38 illustrates the video display showing the video lines and retrace. The slant of &lt;br /&gt;each video line in this illustration is greatly exaggerated, as is the spacing between lines. This il-&lt;br /&gt;lustratio'n shows retrace in both the vertical and horizontal directions. In the case of a VGA dis-&lt;br /&gt;play, as described, the vertical retrace occurs exactly 70.1 times per second and the horizontal &lt;br /&gt;retrace occurs exactly 31,500 times per second. (The Apple Macintosh IIci uses a vertical rate of &lt;br /&gt;66.67 Hz and a horizontal rate of 35 KHz to generate a 640 x 480 color display.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to generate 640 pixels across one line, it takes 40 ns x 640 or 25.6 lls. A horizontal &lt;br /&gt;time of 31,500 Hz allows a horizontal line time of 1/31,500 or 31.746 Ils. The difference be-&lt;br /&gt;tween these two times is the retrace time allowed to the monitor. (The Apple Macintosh IIci has &lt;br /&gt;a horizontal line time of 28.57 Ils.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the vertical retrace repetition rate is 70.1 Hz, the number of lines generated is de-&lt;br /&gt;termined by dividing the vertical time into the horizontal time. In the case of VGA display (a 640 &lt;br /&gt;x 400 display), this is 449.358 lines. Only 400 of these lines are used to display information; the &lt;br /&gt;rest are lost during the retrace. Since 49.358 lines are lost during the retrace, the retrace time is &lt;br /&gt;49.358 x 31.766Ils, or 1,568 Ils. It is during this relatively large amount of time that the color &lt;br /&gt;palette SRAM is changed or the display memory system is updated for a new video display. In &lt;br /&gt;the Apple Macintosh IIci computer (640 x 480), the number of lines generated is 525 lines. Of &lt;br /&gt;these total number of lines, 45 are lost during vertical retrace. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Other display resolutions are 800 x 600 and 1024 x 768. The 800 x 600 SVGA (super &lt;br /&gt;VGA) display is ideal for a 14&amp;quot; color monitor, while the 1024 x 768 EVGA or XVGA (extended &lt;br /&gt;VGA) is ideal for a 21&amp;quot; or 25&amp;quot; monitor used in CAD systems. These resolutions sound like just &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;514 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 12-38 A video &lt;br /&gt;screen illustrating the raster &lt;br /&gt;lines and retrace ----------- ------------- --------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---- --- ---- --- --- -'-'-'- ~-: ~,-,--7--- --&lt;br /&gt;Video line / &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Horizontal retrace &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. . . . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;........... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ &lt;br /&gt;/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.............. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vertical retrace &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;..... &amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;..... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;another set of numbers, but realize that an average home television receiver has a resolution of &lt;br /&gt;approximately 400 x 300. The high-resolution display available on computer systems is much &lt;br /&gt;clearer than that available on home televisions. A resolution of 1024 x 768 approaches that &lt;br /&gt;found in 35 mm film. The only disadvantage of the video display on a computer screen is the &lt;br /&gt;number of colors displayed at a time, but as time passes this will surely improve. Additional &lt;br /&gt;colors allow the image to appear more realistic because of subtle shadings that are required for a &lt;br /&gt;true high-quality life-like image. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If a display system operates with a 60 Hz vertical time and a 15,600 Hz horizontal time, the &lt;br /&gt;number of lines generated are 15,600/60 or 260 lines. The number of usable lines in this system &lt;br /&gt;is most likely 240 where 20 are lost during vertical retrace. It is clear that the number of scanning &lt;br /&gt;lines is adjustable by changing the vertical and horizontal scanning rates. The vertical scanning &lt;br /&gt;rate must be greater than or equal to 50 Hz or flickering will occur. The vertical rate must not be &lt;br /&gt;higher than about 75 Hz or problems with the vertical deflection coil may occur. The electron &lt;br /&gt;beam in a monitor is positioned by an electrical magnetic field generated by coils in a yoke that &lt;br /&gt;surrounds the neck of the picture tube. Since the magnetic field is generated by coils, the fre-&lt;br /&gt;quency of the signal applied to the coil is limited. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The horizontal scanning rate is also limited by the physical design of the coils in the yoke. &lt;br /&gt;Because of this, it is normal to find the frequency applied to the horizontal coils within a narrow &lt;br /&gt;range. This is usually 30,000 Hz-37,000 Hz or 15,000 Hz-17,000 Hz. Some newer monitors are &lt;br /&gt;called multi-sync monitors because the deflection coil is taped so that it can be driven with dif-&lt;br /&gt;ferent deflection frequencies. Sometimes both the vertical and horizontal coils are taped for dif-&lt;br /&gt;ferent vertical and horizontal scanning rates. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;High-resolution displays use either interlaced or non-interlaced scanning. The non-inter-&lt;br /&gt;laced scanning system is used in all standards except the highest. In the interlaced system, the &lt;br /&gt;video image is displayed by drawing half the image first with all of the odd s,anning lines, then &lt;br /&gt;the other half is drawn using the even scanning lines. Obviously, this system is more complex &lt;br /&gt;and is more efficient only because the scanning frequencies are reduced by 50 percent in an in-&lt;br /&gt;terlaced system. For example, a video system that uses 60 Hz for the vertical scanning frequency &lt;br /&gt;and 15,720 Hz for the horizontal frequency generates 262 (15,720/60) lines of video at the rate &lt;br /&gt;of 60 full frames per second. If the horizontal frequency is changed slightly to 15,750 Hz, 262.5 &lt;br /&gt;(15,750/60) lines are generated so two full sweeps are required to draw one complete picture of &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;12-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12-7 QUESTIONS AND PROBLEMS 515 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;525 video lines. Notice how just a slight change in horizontal frequency doubled the number of &lt;br /&gt;raster lines. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The HOLD input is used to request a DMA action, and the HLDA output signals that the &lt;br /&gt;hold is in effect. When a logic I is placed on the HOLD input, the microprocessor (1) stops &lt;br /&gt;executing the program, (2) places its address, data, and control bus at their high-impedance &lt;br /&gt;states, and (3) signals that the hold is in effect by placing a logic I on the HLDA pin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. A DMA read operation transfers data from a memory location to an external 110 device. A &lt;br /&gt;DMA write operation transfers data from an 110 device into the memory. Also available is a &lt;br /&gt;memory-to-memory transfer that allows data to be transferred between two memory loca-&lt;br /&gt;tions using DMA techniques. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The 8237 direct memory access (DMA) controller is a four-channel device that can be ex-&lt;br /&gt;panded to include additional channels of DMA. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. Disk memory comes in the form of floppy disk storage that is found as either the 51/,(' mini-&lt;br /&gt;floppy disk or 31/2&amp;quot; micro-floppy disk. Both disks are found as double-sided, double density &lt;br /&gt;(OS nO) or as high-density (HD) storage devices. The OS DO 51/4&amp;quot; disk stores 360K bytes of &lt;br /&gt;data, and the HD 51/~&amp;quot; disk stores 1.2M bytes of data. The DSDD 31/2&amp;quot; disk stores nOK &lt;br /&gt;bytes of data, and the HD 31/z&amp;quot; disk stores 1.44M bytes of data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Floppy disk memory data are stored using NRZ (non-return to zero) recording. This method &lt;br /&gt;saturates the disk with one polarity of magnetic energy for a logic I and the opposite polarity &lt;br /&gt;for a logic O. In either case, the magnetic field never returns to zero. This technique elimi-&lt;br /&gt;nates the need for a separate erase head. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Data are recorded on disks by using either modified frequency modulation (MFM) or by &lt;br /&gt;run-length limited (RLL) encoding schemes. The MFM scheme records a data pulse for a &lt;br /&gt;logic 1, no data or clock for the first logic 0 of a string or zeros, and a clock pulse for the &lt;br /&gt;second and subsequent logic 0 in a string of zeros. The RLL scheme encodes data so 50 per-&lt;br /&gt;cent more information can be packed onto the same disk area. Most modern disk memory &lt;br /&gt;systems use the RLL encoding scheme. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Video monitors are either TTL or analog. The TTL monitor uses two discrete voltage levels &lt;br /&gt;of OV and 5.0V. The analog monitor uses an infinite number of voltage levels between O.OV &lt;br /&gt;and O. 7V. The analog monitor can display an infinite number of video levels, while the TTL &lt;br /&gt;monitor is limited to two video levels. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. The color TTL monitor displays 16 different colors. This is accomplished through three &lt;br /&gt;video signals (red, green, and blue) and an intensity input. The analog color monitor can dis-&lt;br /&gt;play an infinite number of colors through its three video inputs. In practice, the most &lt;br /&gt;common form of color analog display system (VGA) can display 256K different colors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The video standards found today include VGA (640 x 480), SVGA (800 x 600) and EVGA &lt;br /&gt;or XVGA (1024 x 768). In all three cases, the video information can be 256 colors out of a &lt;br /&gt;total possible 256K colors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. Which microprocessor pins are used to request and acknowledge a DMA transfer? &lt;br /&gt;2. Explain what happens whenever a logic I is placed on the HOLD input pin. &lt;br /&gt;3. A DMA read transfers data from to _____ _ &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;516 CHAPTER 12 DIRECT MEMORY ACCESS AND DMA-CONTROLLED 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. A DMA write transfers data from to _____ _ &lt;br /&gt;5. The DMA controller selects the memory location used for a DMA transfer through what bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;signals? &lt;br /&gt;6. The DMA controller selects the 110 device used during a DMA transfer by which pin? &lt;br /&gt;7. What is a memory-to-memory DMA transfer? &lt;br /&gt;8. Describe the effect on the microprocessor and DMA controller when the HOLD and HLDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;pins are at their logic 1 levels. &lt;br /&gt;9. Describe the effect on the microprocessor and DMA controller when the HOLD and HLDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;pins are at their logic 0 levels. &lt;br /&gt;10. The 8237 DMA controller is a channel DMA controller. &lt;br /&gt;11. If the 8237 DMA controller is decoded at 110 ports 2000H-200FH, what ports are used to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;program channel .1 ? &lt;br /&gt;12. Which 8237 DMA controller register is programmed to initialize the controller? &lt;br /&gt;13. How many bytes can be transferred by the 8237 DMA controller? &lt;br /&gt;14. Write a sequence of instructions that transfer data from memory location 21000H-21OFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to 20000H-200FFH using channel 2 of the 8237 DMA controller. You must initialize the &lt;br /&gt;8237 and use the latch described in Section 12-1 to hold AI9-AJ6&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. Write a sequence of instructions that transfer data from memory to an external 110 device &lt;br /&gt;using channel 3 of the 8237. The memory area to be transferred is at location 20000H-&lt;br /&gt;20FFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. The 51/4&amp;quot; disk is known as a -floppy disk. &lt;br /&gt;17. The 31/2&amp;quot; disk is known as a -floppy disk. &lt;br /&gt;18. Data are recorded in concentric rings on the surface of a disk known as a _____ _ &lt;br /&gt;19. A track is divided into sections of data called _____ _ &lt;br /&gt;20. On a double-sided disk, the upper and lower tracks together are called a _____ _ &lt;br /&gt;21. Why is NRZ recording used on a disk memory system? &lt;br /&gt;22. Draw the timing diagram generated to write a 1001010000 using MFM encoding. &lt;br /&gt;23. Draw the timing diagram generated to write a 1001010000 using RLL encoding. &lt;br /&gt;24. What is a flying head? &lt;br /&gt;25. Why must the heads on a hard disk be parked? &lt;br /&gt;26. What is the difference between a voice coil head positioning mechanism and a stepper motor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;head positioning mechanism? &lt;br /&gt;27. What is a WORM? &lt;br /&gt;28. What is a CD-ROM? &lt;br /&gt;29. What is the difference between a TTL monitor and an analog monitor? &lt;br /&gt;30. What are the three primary colors of light? &lt;br /&gt;31. What are the three secondary colors of light? &lt;br /&gt;32. What is a pixel? &lt;br /&gt;33. A video display with a resolution of 800 x 600 contains lines of video in-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;formation with each line divided into pixels. &lt;br /&gt;34. Explain how a TTL RGB monitor can display 16 different colors. &lt;br /&gt;35. Explain how an analog RGB monitor can display an infinite number of colors. &lt;br /&gt;36. If an analog RGB video system uses 7-bit DACs, it can generate different &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;colors. &lt;br /&gt;37. Why does standard VGA only allow 256 different colors out of 256K colors to be displayed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;at one time? &lt;br /&gt;38. If a video system uses a vertical frequency of 60 Hz and a horizontal frequency of 32,400 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hz, how many raster lines are generated? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CHAPTER 13 &lt;br /&gt;The Arithmetic Coprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Intel family of arithmetic coprocessors includes the 8087,80287, 80387SX, 80387DX, &lt;br /&gt;and the 80487SX for use with the 80486SX microprocessor. The 80486DX and Pentium/ &lt;br /&gt;Pentium Pro microprocessors contain their own built-in arithmetic coprocessors. Be aware &lt;br /&gt;that some of the cloned 80486 microprocessors (from IBM and Cyrix) do not contain arith-&lt;br /&gt;metic coprocessors. The instruction sets and programming for all devices are almost iden-&lt;br /&gt;tical; the main difference is that each coprocessor is designed to function with a different &lt;br /&gt;Intel microprocessor. This chapter provides detail on the entire family of arithmetic co-&lt;br /&gt;processors. Because the coprocessor is a part of the 80486DX, Pentium, and Pentium Pro, &lt;br /&gt;and because these microprocessors are commonplace, many programs now require or at least &lt;br /&gt;benefit from a coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The family of coprocessors, which are labeled the 80X87, is able to multiply, divide, &lt;br /&gt;add, subtract, find the square root, partial tangent, partial arctangent, and logarithms. Data &lt;br /&gt;types include 16-,32-, and 64-bit signed integers; 18-digit BCD data; and 32-,64-, and 80-&lt;br /&gt;bit floating-point numbers. The operations performed by the 80X87 generally execute many &lt;br /&gt;times faster than equivalent operations written with the most efficient programs using the mi-&lt;br /&gt;croprocessor's normal instruction set. With the improved Pentium coprocessor, operations &lt;br /&gt;execute at about 5 times faster than those performed by the 80486 microprocessor with an &lt;br /&gt;equal clock frequency. Note that the Pentium can often execute a coprocessor instruction and &lt;br /&gt;two integer instructions simultaneously. The Pentium Pro coprocessor is similar in perfor-&lt;br /&gt;mance to the Pentium coprocessor except that a few new instructions have been added: &lt;br /&gt;FMOV and FCOMI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. Convert between decimal data and signed integer, BCD, and floating-point data for use by &lt;br /&gt;the arithmetic coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Explain the operation of the 80X87 arithmetic coprocessor. &lt;br /&gt;3. Explain the operation and addressing modes of each arithmetic coprocessor instruction. &lt;br /&gt;4. Develop programs that solve complex arithmetic problems using the arithmetic coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;517 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;518 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA FORMATS FOR THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the text presents the types of data used with all arithmetic coprocessor family &lt;br /&gt;members. (Refer to Table 13-1 for a listing of all Intel microprocessors and their companion &lt;br /&gt;coprocessors.) These data types include signed integer, BCD, and floating-point. Each has a &lt;br /&gt;specific use in a system, and many systems require all three data types. Note that assembly &lt;br /&gt;language programming with the coprocessor is often limited to modifying the coding gener-&lt;br /&gt;ated by a high-level language such as C/C++. In order to accomplish any such modification, &lt;br /&gt;the instruction set and some basic programming concepts are required, which are presented in &lt;br /&gt;this chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Signed Integers &lt;br /&gt;The signed integers used with the coprocessor are basically the same as those described in &lt;br /&gt;Chapter 1. When used with the arithmetic coprocessor, signed integers are 16- (word), 32- (short &lt;br /&gt;integer), or 64-bits (long integer) wide. Conversion between decimal and signed-integer format &lt;br /&gt;is handled in exactly the same manner as for the signed integers described in Chapter 1. As you &lt;br /&gt;will recall, positive numbers are stored in true form with a leftmost sign-bit of 0, and negative &lt;br /&gt;numbers are stored in two's complement form with a leftmost sign-bit of 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The word integers range in value from -32,768 to +32,767, the short integer range is Â±2 x &lt;br /&gt;10+9, and the long integer range is Â±9 x 10+18â¢ Integer data types are found in some applications &lt;br /&gt;that use the arithmetic coprocessor. Refer to Figure 13-1, which shows these three forms of &lt;br /&gt;signed-integer data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data are stored in memory using the same assembler directives described and used in ear-&lt;br /&gt;lier chapters. The DW directive defines words, DD defines short integers, and DQ defines long-&lt;br /&gt;integers. Example 13-1 shows how several different sizes of signed-integers are defined for use &lt;br /&gt;by the assembler and arithmetic coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-1 &lt;br /&gt;0000 0002 &lt;br /&gt;0002 FFDE &lt;br /&gt;0004 000004D2 &lt;br /&gt;OOOB FFFFFF9C &lt;br /&gt;OOOC 0000000000005BAO &lt;br /&gt;0014 FFFFFFFFFFFFFFB6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 13-1 Micro-&lt;br /&gt;processor and Intel &lt;br /&gt;coprocessor compatibility &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATAl DW +2 &lt;br /&gt;DATA2 DW -34 &lt;br /&gt;DATA 3 DD +1234 &lt;br /&gt;DATA4 DD -100 &lt;br /&gt;DATA 5 DQ +23456 &lt;br /&gt;DATA 6 DQ -122 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086 &lt;br /&gt;8088 &lt;br /&gt;80186 &lt;br /&gt;80188 &lt;br /&gt;80286 &lt;br /&gt;80386SX &lt;br /&gt;80386DX &lt;br /&gt;80486SX &lt;br /&gt;80486DX &lt;br /&gt;Pentium &lt;br /&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;16-bit integer &lt;br /&gt;;16-bit integer &lt;br /&gt;; short integer &lt;br /&gt;;short integer &lt;br /&gt;;long integer &lt;br /&gt;;long integer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Coprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8087 &lt;br /&gt;8087 &lt;br /&gt;80187 &lt;br /&gt;80187 &lt;br /&gt;80287 &lt;br /&gt;80387SX &lt;br /&gt;80387DX &lt;br /&gt;80487SX &lt;br /&gt;Built into microprocessor &lt;br /&gt;Built into microprocessor &lt;br /&gt;Built into microprocessor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-1 DATA FORMATS FOR THE ARITHMETIC COPROCESSOR 519 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-1 Integer for-&lt;br /&gt;mats for the 80X8? family &lt;br /&gt;of arithmetic coprocessors: &lt;br /&gt;(a) word, (b) short, and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;181 Magnitude &lt;br /&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(c) long &lt;br /&gt;31 o I 8 I Magnitude &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;63 o &lt;br /&gt;181 Magnitude &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(c) &lt;br /&gt;Note: 8 = sign-bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Binary-Coded Decimal (BCD) &lt;br /&gt;The binary-coded decimal (BCD) form requires 80-bits of memory. Each number is stored as an &lt;br /&gt;18-digit packed integer in nine bytes of memory as two digits per byte. The tenth byte contains &lt;br /&gt;only a sign-bit for the I8-digit signed BCD number. Figure 13-2 shows the format of the BCD &lt;br /&gt;number used with the arithmetic coprocessor. Note that both positive and negative numbers are &lt;br /&gt;stored in true form and never in lO's complement form. The DT directive stores BCD data in the &lt;br /&gt;memory as illustrated in Example 13-2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-2 &lt;br /&gt;0000 DATAl DT 200 ;200 decimal stored as BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000000000000200 &lt;br /&gt;OOOA DATA2 DT -10 ;-10 decimal stored as BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80000000000000000010 &lt;br /&gt;0014 DATA3 DT 10020 ;10,020 decimal stored as BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000000000010020 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Floating-Point &lt;br /&gt;Floating-point numbers are often called real numbers because they hold signed integers, frac-&lt;br /&gt;tions, and mixed numbers. A floating-point number has three parts: a sign-bit, a biased exponent, &lt;br /&gt;and a significand. Floating-point numbers are written in scientific binary notation. The Intel &lt;br /&gt;family of arithmetic coprocessors supports three types of floating-point numbers: short (32-bits), &lt;br /&gt;long (64-bits), and temporary (80-bits). Refer to Figure 13-3 for the three forms of the floating-&lt;br /&gt;point number. Please note that the short form is also called a single-precision number and the &lt;br /&gt;long form is called a double-precision number. Sometimes the 80-bit temporary form is called an &lt;br /&gt;extended-precision number. The floating-point numbers, and the operations performed by the &lt;br /&gt;arithmetic coprocessor, conform to the IEEE-754 standard as adopted by all major personal com-&lt;br /&gt;puter software producers. This includes Microsoft, which has recently stopped supporting the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;79 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-2 BCD data format for the 80X8? family of arithmetic coprocessors &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;520 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-3 Floating-&lt;br /&gt;pOint (real) format for the &lt;br /&gt;80X87 family of arithmetic &lt;br /&gt;coprocessors. (a) Short &lt;br /&gt;(single-precision) with a bias &lt;br /&gt;of 7FH, (b) long (double-pre-&lt;br /&gt;cision) with a bias of 3FFH, &lt;br /&gt;and (c) temporary (extended-&lt;br /&gt;precision) with a bias of &lt;br /&gt;3FFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3130 2322 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18 1 Exp. I Fraction &lt;br /&gt;â¢ (a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6362 52 51 &lt;br /&gt;Exp. I Fraction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ (b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;7978 64 63 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;181 Exp. 11 ! Fraction I &lt;br /&gt;(c) â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: 8 = sign-bit and Exp. = exponent &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microsoft floating-point format and also the ANSI floating-point standard popular in mainframe &lt;br /&gt;computer systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Converting to Floating-paint Form. Converting from decimal to the floating-point form is a &lt;br /&gt;simple task that is accomplished through the following steps: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Convert the decimal number into binary. &lt;br /&gt;2. Normalize the binary number. &lt;br /&gt;3. Calculate the biased exponent. &lt;br /&gt;4. Store the number in the floating-point format. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;These four steps are illustrated for the decimal number 100.2510 in Example 13-3. Here &lt;br /&gt;the decimal number is converted to a single-precision (32-bit) floating-point number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-3 &lt;br /&gt;Step Result &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 100.25 = 1100100.01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 1100100.01 = 1.10010001 x 26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 110 + 01111111 = 10000101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 Sign = 0 &lt;br /&gt;Exponent = 10000101 &lt;br /&gt;Significand = 10010001000000000000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In step three of Example 13-3, the biased exponent is the exponent, a 26 or 110, plus a bias &lt;br /&gt;of 01111111 (7FH) or 10000101 (85H). All single-precision numbers use a bias of7FH, double-&lt;br /&gt;precision numbers use a bias of 3FFH, and extended-precision numbers use a bias of 3FFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In Step 4 of Example 13-3, the information found in prior steps is combined to form the &lt;br /&gt;floating-point number. The leftmost bit is the sign-bit of the number. In this case it is a 0 because &lt;br /&gt;the number is +100.25 10. The biased exponent follows the sign-bit. The significand is a 23-bit &lt;br /&gt;number with an implied one-bit. Note that the significand of a number I.XXXX is the XXXX &lt;br /&gt;portion. The I. is an implied one-bit that is only stored in the extended-precision form of the &lt;br /&gt;floating point number as an explicit one-bit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Some special rules apply to a few numbers. The number 0, for example, is stored as all &lt;br /&gt;zeros except for the sign-bit, which can be a logic 1 to represent a negative zero. The plus and &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-1 DATA FORMATS FOR THE ARITHMETIC COPROCESSOR 521 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;minus infinity is stored as logic l's in the exponent with a significand of all zeros and the sign-&lt;br /&gt;bit that represents plus or minus. A NAN (not-a-number) is an invalid floating-point result that &lt;br /&gt;has all ones in the exponent with a significand that is not all zeros. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Converting from Floating-point Form. Conversion to a deci'i1al number from a floating-point &lt;br /&gt;number is summarized in the following steps: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Separate the sign-bit, biased exponent, and significand. &lt;br /&gt;2. Convert the biased exponent into a true exponent by subtracting the bias. &lt;br /&gt;3. Write the number as a normalized binary number. &lt;br /&gt;4. Convert it to a de-normalized binary number. &lt;br /&gt;5. Convert the de-normalized binary number to decimal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;These five steps convert a single-precision floating-point number to decimal in Example 13-4. &lt;br /&gt;Notice how the sign-bit of 1 makes the decimal result negative. Also notice that the implied I-bit is &lt;br /&gt;added to the normalized binary result in step 3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-4 &lt;br /&gt;Step Result &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 Sign ; 1 &lt;br /&gt;Exponent ; 10000011 &lt;br /&gt;Significand ; 10010010000000000000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 100 ; 10000011 - 01111111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1.1001001 X 2' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 11001.001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 -25.125 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Storing Floating-point Data in Memory. Floating-point numbers are stored with the assembler &lt;br /&gt;using the DD directive for single-precision, DQ for double-precision, and DT for extended-&lt;br /&gt;precision. Some examples of floating-point data storage are shown in Example 13-5. The author &lt;br /&gt;discovered that the Microsoft MACRO assembler version 6.0 contains an error that does not &lt;br /&gt;allow a plus-sign to be used with positive floating-point numbers. A +92.45 must be defined as &lt;br /&gt;92.45 for the assembler to function correctly. Microsoft has assured the author that this error has &lt;br /&gt;been corrected in version 6.11 of MASM if the REAL4, REAL8, or REAL 1 0 directives are used &lt;br /&gt;in place of DD, DQ, and DT to specify floating-point data. Also note that the assembler provides &lt;br /&gt;access 8087 emulator if your system does not contain a Pentium Pro, Pentium, 80486, or any &lt;br /&gt;other microprocessor with a coprocessor. The emulator comes with all Microsoft high-level &lt;br /&gt;languages or as shareware programs such as EM87. The emulator is accessed by including the &lt;br /&gt;OPTION EMULATOR statement immediately following the .MODEL statement in a program. &lt;br /&gt;Be aware that the emulator does not emulate some of the coprocessor instructions. Do not use &lt;br /&gt;this option if your system contains a coprocessor. In all cases, you must include the .8087, .187, &lt;br /&gt;.287, .387, .487, or .587 switch to enable the generation of coprocessor instructions. Note that &lt;br /&gt;there is currently no switch for the Pentium Pro, but it will most likely be .80687 when Microsoft &lt;br /&gt;produces the next version of the assembler program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-5 &lt;br /&gt;0000 e377999A DATA7 &lt;br /&gt;0004 40000000 DATA8 &lt;br /&gt;0008 486F4200 DATA9 &lt;br /&gt;oooe DATAl 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4059100000000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DD &lt;br /&gt;DD &lt;br /&gt;PEAL..) &lt;br /&gt;DQ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-247.6 &lt;br /&gt;2.0 &lt;br /&gt;2.45E+5 &lt;br /&gt;100.25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;define single-precision &lt;br /&gt;;define single-precision &lt;br /&gt;;define single-prerision &lt;br /&gt;;define double-precision &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;522 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Status &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 DATAl 1 REAL8 0.001235 ;define double-precision &lt;br /&gt;3F543BF- 2713 6A4 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOle DATAl 2 REAL10 33.9876 ;define extended-precision &lt;br /&gt;400487F34D6A161E4F76 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE 80X87 ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80X87 is designed to operate concurrently with the microprocessor. Note that the 80486DX, &lt;br /&gt;Pentium, and Pentium Pro microprocessors contain their own internal and fully compatible ver-&lt;br /&gt;sions of the 80387. With other family members, the coprocessor is an external integrated circuit &lt;br /&gt;that parallels most of the connections on the microprocessor. The 80X87 executes 68 different &lt;br /&gt;instructions. The microprocessor executes all normal instructions, and the 80X87 executes arith-&lt;br /&gt;metic coprocessor instructions. Both the microprocessor and coprocessor can execute their re-&lt;br /&gt;spective instructions simultaneously or concurrently. The numeric or arithmetic coprocessor is a &lt;br /&gt;special-purpose microprocessor that is specially designed to efficiently execute arithmetic and &lt;br /&gt;transcendental operations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The microprocessor intercepts and executes the normal instruction set and the coprocessor &lt;br /&gt;intercepts and executes only the coprocessor instructions. Recall that the coprocessor instruc-&lt;br /&gt;tions are actually escape (ESC) instructions. These instructions are used by the microprocessor &lt;br /&gt;to generate a memory address for the coprocessor so the coprocessor can execute a coprocessor &lt;br /&gt;instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Internal Structure of the 80X87 &lt;br /&gt;Figure 13-4 shows the internal structure of the arithmetic coprocessor. Notice that this device is &lt;br /&gt;divided into two major sections: the control unit and the numeric execution unit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;........................................................................................................................... &lt;br /&gt;. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control unit (CU) : Numeric execution unit (NEU) : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I â¢ &lt;br /&gt;Data &lt;br /&gt;buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T (7) &lt;br /&gt;a (6) 9 (5) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exceptions r (4) e &lt;br /&gt;!il (3) &lt;br /&gt;I &lt;br /&gt;s (2) &lt;br /&gt;t (1 ) e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(0) &lt;br /&gt;80-bit wide stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;' .............................. : .......................................................................................... . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-4 The internal structure of the 80X8? arithmetic coprocessor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-2 THE BOXB7 ARCHITECTURE 523 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The control unit interfaces the coprocessor to the microprocessor system data bus. Both of &lt;br /&gt;the devices monitor the instruction stream. If the instruction is an ESCape (coprocessor) instruc-&lt;br /&gt;tion, the coprocessor executes it; if not, the microprocessor executes it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The numeric execution unit (NEU) is responsible for executing all coprocessor instruc-&lt;br /&gt;tions. The NEU has an eight-register stack that holds operands for arithmetic instructions and the &lt;br /&gt;results of arithmetic instructions. Instructions either address data in specific stack data registers or &lt;br /&gt;use a push and pop mechanism to store and retrieve data on the top of the stack. Other registers in &lt;br /&gt;the NEU are status, control, tag, and exception pointers. A few instructions transfer data between &lt;br /&gt;the coprocessor and the AX register in the microprocessor. The FSTSW AX instruction is the only &lt;br /&gt;instruction availabie to the coprocessor that allows direct communications to the microprocessor &lt;br /&gt;through the AX register. Note that the 8087 does not contain the FSTSW AX instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The stack within the coprocessor contains eight registers that are each 80-bits wide. These &lt;br /&gt;stack registers always contain an 80-bit extended precision floating-point number. The only time &lt;br /&gt;data appear as any other form is when they reside in the memory system. The coprocessor con-&lt;br /&gt;verts from signed integer, BCD, single-precision, or double-precision form as the data are moved &lt;br /&gt;between the memory and the coprocessor register stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Status Register. The status register (see Figure 13-5) reflects the overall operation of the co-&lt;br /&gt;processor. The status register is accessed by executing the instruction (FSTSW), which stores the &lt;br /&gt;contents of the status register into a word of memory. The FSTSW AX instruction copies the &lt;br /&gt;status register directly to the microprocessor's AX register on the 80287 or above coprocessor. &lt;br /&gt;Once status is stored in memory or the AX register, the bit positions of the status register can be &lt;br /&gt;examined by normal software. The coprocessor/microprocessor communications are carried out &lt;br /&gt;through the UO ports OOF AH-OOFFH on the 80287 and UO ports 800000F AH-800000FFH on &lt;br /&gt;the 80386 through the Pentium Pro. Never use these UO ports for interfacing I/O devices to the &lt;br /&gt;microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The newer coprocessors (80287 and above) use status bit position 6 (SF) to indicate a &lt;br /&gt;stack overflow or underflow error. Following is a list of the status bits, except for SF, and their &lt;br /&gt;applications: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C3-CO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The busy bit indicates that the coprocessor is busy executing a task. Busy can be &lt;br /&gt;tested by examining the status register or by using the FW AIT instruction. Newer &lt;br /&gt;coprocessors automatically synchronize with the microprocessor, so the busy flag &lt;br /&gt;need not be tested before performing additional coprocessor tasks. &lt;br /&gt;The condition code bits indicate conditions about the coprocessor (refer to Table &lt;br /&gt;13-2 for a complete listing of each combination of these bits and their functions). &lt;br /&gt;Note that these bits have different meanings for different instructions, as indicated &lt;br /&gt;in the table. The top of the stack is denoted as ST in this table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Invalid operation error &lt;br /&gt;Denormalized operand error &lt;br /&gt;Division by zero error &lt;br /&gt;Overflow &lt;br /&gt;Underflow &lt;br /&gt;Precision error &lt;br /&gt;Error summary &lt;br /&gt;Condition code bits C3-CO &lt;br /&gt;Stack top pointer &lt;br /&gt;Busv &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-5 The 80X87 arithmetic coprocessor status register &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;524 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 13-2 The 80X87 status register condition code bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction C3 C2 Ct CO Indication &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FTST, FCOM 0 0 X 0 ST&amp;gt; Operand &lt;br /&gt;0 0 X 1 ST &amp;lt; Operand &lt;br /&gt;1 0 X 1 ST = Operand &lt;br /&gt;1 1 X 1 ST is not comparable &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPREM 01 0 00 02 Rightmost 3-bits of quotient &lt;br /&gt;? 1 ? ? Incomplete &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXAM 0 0 0 0 + unnormal &lt;br /&gt;0 0 0 1 + NAN &lt;br /&gt;0 0 1 0 - unnormal &lt;br /&gt;0 0 1 1 -NAN &lt;br /&gt;0 1 0 0 + normal &lt;br /&gt;0 1 0 1 +00 &lt;br /&gt;0 1 1 0 - normal &lt;br /&gt;0 1 1 1 -00 &lt;br /&gt;1 0 0 0 +0 &lt;br /&gt;1 0 0 1 Empty &lt;br /&gt;1 0 1 0 -0 &lt;br /&gt;1 0 1 1 Empty &lt;br /&gt;1 1 0 0 + denormal &lt;br /&gt;1 1 0 1 Empty &lt;br /&gt;1 1 1 0 - denormal &lt;br /&gt;1 1 1 1 Empty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: Unnormal = leading bits of the significand are zero; denormal = exponent at its most negative value; &lt;br /&gt;normal = standard floating-point form; NAN (not-a-number) = an exponent of all ones and a significand not &lt;br /&gt;equal to zero and the operand for FTST is zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TOP The top-of-stack (ST) bit indicates the current register addressed as the top-of-&lt;br /&gt;the-stack (ST). This is normally register o. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES The error summary bit is set if any unmasked error bit (PE, DE, OE, ZE, DE, or &lt;br /&gt;IE) is set. In the 8087 coprocessor, the error summary also caused a coprocessor &lt;br /&gt;interrupt. Since the 80287, the coprocessor interrupt has been absent from the &lt;br /&gt;family. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PE The precision error indicates that the result or operands exceed selected precision. &lt;br /&gt;DE An under-flow error indicates a non-zero result that is too small to represent with &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the current precision selected by the control word. &lt;br /&gt;OE An overflow error indicates a result that is too large to be represented. If this &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;error is masked, the coprocessor generates infinity for an overflow error. &lt;br /&gt;ZE A zero error indicates the divisor was zero while the dividend is a non-infinity or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;non-zero number. &lt;br /&gt;DE A denormalized error indicates at least one of the operands is denormalized. &lt;br /&gt;IE An invalid error indicates a stack overflow or underflow, indeterminate form &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(010, 0, -0, etc ), or the use of a NAN as an operand. This flag indicates errors &lt;br /&gt;such as those produced by taking the square root of a negative number, etc. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are two ways to test the bits of the status register once they are moved into the AX &lt;br /&gt;register with the FSTSW AX instruction. One method uses the TEST instruction to test individual &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;EXAMPLE 13-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-2 THE 80X8? ARCHITECTURE 525 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bits of the status register. The other uses the SAHF instruction to transfer the leftmost eight bits &lt;br /&gt;of the status register into the microprocessor's flag register. Both methods are illustrated in Ex-&lt;br /&gt;ample 13-6. This example uses the DIY instruction to divide the top of the stack by the contents &lt;br /&gt;of DATAl and the FSQRT instruction to find the square root of the top of the stack. The ex-&lt;br /&gt;ample also uses the FCOM instruction to compare the contents of the stack top with DATfd. &lt;br /&gt;Note that the conditional jump instructions are used with the SAHF instruction to test for the &lt;br /&gt;condition listed in Table 13-3. Although SAHF and conditional jumps cannot test all possible &lt;br /&gt;operating conditions of the coprocessor, they can help to reduce the complexity of certain tested &lt;br /&gt;conditions. Note that SAHF places CO into the carry flag, C2 into the parity flag, and C3 into the &lt;br /&gt;zero flag. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Using TEST to isolate the divide-by-zero error bit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 67&amp;amp; D8 35 00000000 R &lt;br /&gt;0007 9B DF E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDIV DATAl &lt;br /&gt;FSTSW .'\\X &lt;br /&gt;TEST AX,4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;copy status register to AX &lt;br /&gt;;test bit position 2 OOOA A9 000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOD 75 18 JNZ DIVIDE_ERROR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Using TEST to isolate the invalid operation error bit &lt;br /&gt;;after a FSQRT instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOF D9 FA FSQRT &lt;br /&gt;0011 9B DF EO &lt;br /&gt;0014 A9 0001 &lt;br /&gt;0017 75 OE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0019 67&amp;amp; D8 15 &lt;br /&gt;0020 9B DF EO &lt;br /&gt;0023 9E &lt;br /&gt;0024 74 04 &lt;br /&gt;0026 72 02 &lt;br /&gt;0028 77 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTSW AX ; copy status register to AX &lt;br /&gt;TEST AX,l ;test bit position 1 &lt;br /&gt;JNZ FSQRT_ERROR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Using the SAHF instruction and conditional jumps to &lt;br /&gt;;test for the conditions in Table 13-3 after an FCOM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RFCOM CATAl &lt;br /&gt;FSTSW AX ; copy status register to AX &lt;br /&gt;SAHF ; copy status bits to flags &lt;br /&gt;JE ST_EQUAL &lt;br /&gt;JB ST_BELOW &lt;br /&gt;JA ST_ABOVE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When the FXAM instruction and FSTSW AX are executed and followed by the SAHF &lt;br /&gt;instruction, the zero flag will contain C3. Notice from Table 13-2 that C3 indicates a +0 &lt;br /&gt;when set along with other error. The FXAM instruction could be used to test a divisor before &lt;br /&gt;a division for a zero value by using the JZ instruction following FXAM, FSTSW AX, and &lt;br /&gt;SAHF. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control Register. The control register is pictured in Figure 13-6. The control register selects &lt;br /&gt;precision, rounding co~trol, and infinity control. It also masks and unmasks the exception bits &lt;br /&gt;that correspond to the rightmost six bits of the status register. The FLDCW instruction is used to &lt;br /&gt;load a value into the control register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 13-3 Coprocessor &lt;br /&gt;C3 C2 CO Condition conditions tested with the Jump Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;conditional jump instructions &lt;br /&gt;0 0 0 ST&amp;gt; Operand JA (jump if ST above) and SAHF after FCOM or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FTST, as illustrated in 0 0 1 ST &amp;lt; Operand JB (jump if ST below) &lt;br /&gt;Example 13-6 1 0 0 ST = Operand JE (jump if ST equal) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;526 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 8 7 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· IC R!C piC PM UM OM ZM OM 1M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-.J L-.J I L- Invalid operation mask Denormalized operand mask &lt;br /&gt;Division by zero mask &lt;br /&gt;Overflow mask &lt;br /&gt;Underflow mask &lt;br /&gt;Precision error mask &lt;br /&gt;Precision control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 = Single-precision (short) &lt;br /&gt;01 = Reserved &lt;br /&gt;10 = Double-precision (long) &lt;br /&gt;11 = Extended precision (temporary) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Rounding control &lt;br /&gt;00 = Round to nearest or even &lt;br /&gt;01 = Round down toward minus infinity &lt;br /&gt;10 = Round up toward plus infinity &lt;br /&gt;11 = Chop or truncate toward zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Infinity control &lt;br /&gt;0= Projective &lt;br /&gt;1 = Affine &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-6 The 80X87 arithmetic coprocessor control register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Following is a description of each bit or grouping of bits found in the control register: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RC &lt;br /&gt;PC &lt;br /&gt;Exception &lt;br /&gt;Masks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Infinity control selects either affine or projective infinity. Affine allows &lt;br /&gt;positive and negative infinity, while projective assumes infinity is unsigned. &lt;br /&gt;Rounding control determines the type of rounding as defined in Figure 13-6. &lt;br /&gt;The precision control sets the precision of the result as defined in Figure 13-6. &lt;br /&gt;Determine whether the elTor indicated by the exception affects the elTor bit in &lt;br /&gt;the status register. If a logic 1 is placed in one of the exception control bits, the &lt;br /&gt;cOlTesponding status register bit is masked off. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tag Register. The tag register indicates the contents of each location in the coprocessor stack. &lt;br /&gt;Figure 13-7 illustrates the tag register and the status indicated by each tag. The tag indicates &lt;br /&gt;whether a register is valid, zero, invalid or infinity, or empty. The only way that a program can &lt;br /&gt;view the tag register is by storing the coprocessor environment using the FSTENV, FSAVE, or &lt;br /&gt;FRSTOR instructions. Each of these instructions stores the tag register along with other co-&lt;br /&gt;processor data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-7 The 80X87 &lt;br /&gt;arithmetic coprocessor tag &lt;br /&gt;register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TAG (7) TAG (6) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TAG (5) TAG (4) TAG (3) TAG (2) TAG (1) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TAG VALUES: &lt;br /&gt;00 = VALID &lt;br /&gt;01 = ZERO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TAG (0) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 = INVALID or INFINITY &lt;br /&gt;11 = EMPTY &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-3 INSTRUCTION SET 527 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INSTRUCTION SET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The arithmetic coprocessor executes over 68 different instructions. Whenever a coprocessor in-&lt;br /&gt;struction references memory, the microprocessor automatically generates the memory address &lt;br /&gt;for the instruction. The coprocessor uses the data bus for data transfers during coprocessor in-&lt;br /&gt;structions, and the microprocessor uses it during normal instructions. Also note that the 80287 &lt;br /&gt;uses the Intel reserved IiO ports 00F8H-00FFH for communications between the coprocessor &lt;br /&gt;and the microprocessor (even though the coprocessor only uses ports OOFCH-OOFFH). These &lt;br /&gt;ports are used mainly for the FSTSW AX instruction. The 80387-Pentiuffi Pro use I/O ports &lt;br /&gt;800000F8H-800000FFH for this communications. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the text describes the function of each instruction and lists its assembly lan-&lt;br /&gt;guage form. Because the coprocessor uses the microprocessor memory-addressing modes, not &lt;br /&gt;all possible forms of each instruction are illustrated. Each time that the assembler encounters one &lt;br /&gt;of the coprocessor mnemonic opcodes, it converts it into a machine language ESC instruction. &lt;br /&gt;The ESC instruction represents an opcode to the coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Transfer Instructions &lt;br /&gt;There are three basic data transfers: floating-point, signed-integer, and BCD. The only time that &lt;br /&gt;data ever appear in the signed-integer or BCD form is in the memory. Inside the coprocessor, &lt;br /&gt;data are always stored as an 80-bit extended-precision floating-point number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Floating-point Data Transfers. There are four traditional floating-point data transfer instructions &lt;br /&gt;in the coprocessor instruction set: FLD (load real), FST (store real), FSTP (store real and pop), &lt;br /&gt;and FXCH (exchange). A new instruction is added to the Pentium Pro called a conditiollfloatillg &lt;br /&gt;point move instruction that uses the ope ode FCMOV with a floating-point condition. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The FLD instruction loads floating-point memory data to the top of the internal stack, re-&lt;br /&gt;ferred to as ST (stack top). This instruction stores the data on the top of the stack and then decre-&lt;br /&gt;ments the stack pointer by one. Data loaded to the top of the stack are from any memory location &lt;br /&gt;or from another coprocessor register. For example, an FLD ST(2) instruction copies the contents &lt;br /&gt;of register 2 to the stack top, which is ST. The top of the stack is register 0 when the coprocessor &lt;br /&gt;is reset or initialized. Another example is the FLD DATA7 instruction, which copies the con-&lt;br /&gt;tents of memory location DATA 7 to the top of the stack. The size of the transfer is automatically &lt;br /&gt;determined by the assembler through the directives DD or REAL4 for single-precision, DQ or &lt;br /&gt;REAL 8 for double-precision, and DT or REALI 0 for extended-precision. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The FST instruction stores a copy of the top of the stack into the memory location or co-&lt;br /&gt;processor register indicated by the operand. At the time of storage, the internal, extended-preci-&lt;br /&gt;sion floating-point number is rounded to the size of the floating-point number indicated by the &lt;br /&gt;control register. , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The FSTP iri~truction stores a copy of the top of the stack into memory or any coprocessor &lt;br /&gt;register and then pops the data from the top of the stack. You might think of FST as a copy in-&lt;br /&gt;struction and FSTP as a removal instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The FXCH instruction exchanges the register indicated by the operand with the top of the &lt;br /&gt;stack. For example, the FXCH ST(2) instruction, exchanges the top of the stack with register 2. &lt;br /&gt;Integer Data Transfer Instructions. The coprocessor supports three integer data transfer instruc-&lt;br /&gt;tions: FlLD (load integer), FIST (store integer), and FISTP (store integer and pop). These three &lt;br /&gt;instructions function as did FLD, FST, and FSTP, except that the data transferred are integer &lt;br /&gt;data. The coprocessor automatically converts the internal extended-precision floating-point data &lt;br /&gt;to integer data. The size of the data is determined by the way that the label is defined with DW, &lt;br /&gt;DD, or DQ in the assembly language program. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;528 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BCD Data Transfer Instructions. Two instructions load or store BCD signed-integer data. The &lt;br /&gt;FBLD instruction loads the top of the stack with BCD memory data, and the FBSTP stores the &lt;br /&gt;top of the stack and does a pop. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 13-7 shows how the assembler automatically adjusts the FLD, FILD, and FBLD &lt;br /&gt;instructions for different-sized operands. (Look closely at the machine-coded forms of the in-&lt;br /&gt;structions.) Note that Example 13-7 begins with the .386 and .387 directives that identify the mi-&lt;br /&gt;croprocessor as an 80386 and the coprocessor as an 80387: Note that if the 80286 &lt;br /&gt;microprocessor is in use with its coprocessor, the directives .286 and .287 appear. The assembler &lt;br /&gt;by default assumes that the software is assembled for an 8086/8088 with an 8087 coprocessor. &lt;br /&gt;The .486, .487, .586, and .587 switches are also available for use with the 80486 and Pentium &lt;br /&gt;microprocessors. Even though the program in Example 13-7 executes, Code View or some other &lt;br /&gt;debugging tool must be used to view any changes to the coprocessor stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-7 &lt;br /&gt;. MODEL SMALL &lt;br /&gt;.386 ;select 80386 microprocessor &lt;br /&gt;.387 ;select 80387 coprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . DATA &lt;br /&gt;0000 4lFOOOOO DATAl DD 30.0 ; single-precision &lt;br /&gt;0004 DATA2 DQ 100.25 ; double-precision &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4059100000000000 &lt;br /&gt;OOOC DATA3 DT 33.9876 ; extended-precision &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;400487F34D6A161E4F76 &lt;br /&gt;0016 001E DATA4 DW 30 ;16-bit integer &lt;br /&gt;0018 0000001E DATA5 DD 30 ;32-bit integer &lt;br /&gt;001C DATA 6 DQ 30 ;64-bit integer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000000000001E &lt;br /&gt;0024 DATA7 DT 30H ;BCD 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000000000000030 &lt;br /&gt;0000 . CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 D9 06 0000 R FLD DATAl &lt;br /&gt;0014 DD 06 0004 R FLD DATA2 &lt;br /&gt;0018 DB 2E OOOC R FLD DATA3 &lt;br /&gt;001C DF 06 0016 R FILD DATA4 &lt;br /&gt;0020 DB 06 0018 R FILD DATA5 &lt;br /&gt;0024 DF 2E 001C R FILD DATA6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0028 DF 26 0024 R FBLD DATA7 &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium Pro FCMOV Instruction. The Pentium Pro contains a new instruction called &lt;br /&gt;FCMOV that also contains a condition. If the condition is true, the FCMOV instruction copies &lt;br /&gt;the source to the destination. The conditions tested by FCMOV and the opcodes used with &lt;br /&gt;FCMOV appear in Table 13-4. Notice that these conditions check for either an ordered or un-&lt;br /&gt;ordered. The testing for NAN and de-normalized numbers are not checked with FCMOV. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 13-8 shows how the FCMOVB (move if below) instruction is used to copy the &lt;br /&gt;contents of ST(2) to the stack top (ST) if the contents of ST(2) is below ST. Notice that the &lt;br /&gt;FCOM instruction must be used to perform the compare and the contents of the status register &lt;br /&gt;must still be copied to the flags for this instruction to function. More about the FCMOV instruc-&lt;br /&gt;tion appears with the FCOMI instruction, which is also ne\\.&amp;quot; to the Pentium Pro processor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-8 &lt;br /&gt;FCOM ST(2) &lt;br /&gt;FNSTSW AX &lt;br /&gt;SAHF &lt;br /&gt;FCMOVB ST(2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;compare ST and ST(2) &lt;br /&gt;;copy floating fli!-~.s to AX &lt;br /&gt;;copy floating f~ags to flags &lt;br /&gt;;'copy'~ST (2) to ST if below &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;! ' &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 13-4 The variation &lt;br /&gt;of the FCMOV instruction and &lt;br /&gt;conditions tested &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Arithmetic Instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCMOVB &lt;br /&gt;FCMOVE &lt;br /&gt;FCMOVBE &lt;br /&gt;FCMOVU &lt;br /&gt;FCMOVNB &lt;br /&gt;FCMOVNE &lt;br /&gt;FCMOVNBE &lt;br /&gt;FCMOVNU &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Condition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Move if below &lt;br /&gt;Move if equal &lt;br /&gt;Move if below or equal &lt;br /&gt;Move if unordered &lt;br /&gt;Move if not below &lt;br /&gt;Move if not equal &lt;br /&gt;Move if not below or equal &lt;br /&gt;Move if not ordered &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;529 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Arithmetic instructions for the coprocessor include addition, subtraction, multiplication, divi-&lt;br /&gt;sion, and square root. The arithmetic-related instructions are scaling, rounding, absolute value, &lt;br /&gt;and changing the sign. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 13-5 shows the basic addressing modes allowed for the arithmetic operations. Each &lt;br /&gt;addressing mode is shown with an example using the FADD (real addition) instruction. All arith~ &lt;br /&gt;metic operations are floating-point, except in some cases when memory data are referenced as an &lt;br /&gt;operand. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The classic stack form of addressing operand data (stack addressing) uses the top of the &lt;br /&gt;stack as the source operand and the next to the top of the stack as the destination operand. After-&lt;br /&gt;wards, a pop removes the source datum from the stack; only the result in the destination register &lt;br /&gt;remains at the top of the stack. To use this addressing mode, the instruction is placed in the pro-&lt;br /&gt;gram without any operands such as FADD or FSUB. The FADD instruction adds ST to ST(l) &lt;br /&gt;and stores the answer at the top of the stack; it also removes the original two datum from the &lt;br /&gt;stack by popping. Note carefully that FSUB subtracts ST from STell and leaves the difference at &lt;br /&gt;ST. Therefore, a reverse subtraction (FSUBR) subtracts ST(I) from ST and leaves the difference &lt;br /&gt;at ST. (Note that an error exists in Intel documentation, including the Pentium data book, that de-&lt;br /&gt;scribes the operation of some reverse instructions.) Another use for reverse operations is finding &lt;br /&gt;a reciprocal (I/x). This is accomplished, if X is at the top of the stack, by loading a 1.0 to ST &lt;br /&gt;(FLDI), followed by the FDIVR instruction. The FDIVR instruction divides ST(l) into ST, or X &lt;br /&gt;into 1, and leaves the reciprocal (l/X) at ST. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The register-addressing mode uses ST for the top of the stack and ST(n) for another loca-&lt;br /&gt;tion where n is the register number. With this fonn, one operand must be ST and the other is &lt;br /&gt;ST(n). Note that to double the top of the stack, the FADD ST,ST(O) instruction is used where &lt;br /&gt;ST(O) also addresses the top of the stack. One of the two operands in the register-addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 13-5 Arithmetic &lt;br /&gt;addressing modes Mode Form Example &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack ST(1),ST FADD &lt;br /&gt;Register ST,ST(n) FADD ST,ST(2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ST(n),ST FADD ST(2),ST &lt;br /&gt;Register pop ST(n),ST FADDP ST(3),ST &lt;br /&gt;Memory Operand FADD DATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: Stack addressing is fixed as ST(1),ST and includes &lt;br /&gt;a pop so only the result remains at the top of the stack; &lt;br /&gt;n = register number 0-7. Register addressing for any &lt;br /&gt;instruction can use a destination of ST or ST(n) as &lt;br /&gt;illustrated. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;530 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mode must be ST, while the other must be in the form;ST(n), where n is a stack register 0-7. For &lt;br /&gt;many instructions, either ST or ST(n) can be the destination. It is fairly important that the top of &lt;br /&gt;the stack be ST(O). This is accomplished by resetting or initializing the coprocessor before using &lt;br /&gt;it in a program. Another example of register-addressing is FADD ST(1),ST where the contents &lt;br /&gt;of ST are added to ST(I) and the result is placed into ST(l). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The top of the stack is always used as the destination for the memory-addressing mode be-&lt;br /&gt;cause the coprocessor is a stack-oriented machine. For example, the FADD DATA instruction &lt;br /&gt;adds the real-number contents of memory location DATA to the top of the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Arithmetic Operations. The letter P in an opcode specifies a register pop after the operation &lt;br /&gt;(FADDP compared to FADD). The letter R in an opcode (subtraction and division only) indi-&lt;br /&gt;cates reverse mode. The reverse mode is useful for memory data because memory data normally &lt;br /&gt;subtract from the top of the stack. A reversed subtract instruction subtracts the top of the stack from &lt;br /&gt;memory and stores the result in the top of the stack. For example, if the top of the stack contains a &lt;br /&gt;10 and memory location DATAl contains a 1, the FSUB DATAl instruction results in a+9 on the &lt;br /&gt;stack top and the FSUBR instruction results in a -9. Another example is FSUBR ST,ST(I), which &lt;br /&gt;will subtract ST from ST(l) and store the result on ST. A variant is FSUBR ST(1),ST, which will &lt;br /&gt;subtract ST(I) from ST and store the result on ST(I). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The letter I as a second letter in an opcode indicates that the memory operand is an in-&lt;br /&gt;teger. For example, the FADD DATA instruction is a floating-point addition, while the FIADD &lt;br /&gt;DATA is an integer addition that adds the integer at memory location DATA to the floating-&lt;br /&gt;point number at the top of the stack. The same rules apply to FADD, FSUB, FMUL, and FDIV &lt;br /&gt;instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Arithmetic-related Operations. Other operations that are arithmetic in nature include FSQRT &lt;br /&gt;(square root), FSCALE (scale a number), FPREMlFPREMI (find partial remainder), FRNDINT &lt;br /&gt;(round to integer), FXTRACT (extract exponent and significand), FABS (find absolute value), &lt;br /&gt;and FCHG (change sign). These instructions and the functions they perform follow: &lt;br /&gt;FSQRT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSCALE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. FPREMlFPREMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRNDINT &lt;br /&gt;FXTRACT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FABS &lt;br /&gt;FCHS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Finds the square root of the top of the stack and leaves the resultant &lt;br /&gt;square root at the top of the stack. An invalid error occurs for the square &lt;br /&gt;root of a negative number. For this reason, the IE bit of the status regi-&lt;br /&gt;ster should be tested whenever an invalid result can occur. The IE bit &lt;br /&gt;can be tested by loading the status register to AX with the FSTSW AX &lt;br /&gt;instruction, followed by TEST AX, I to test the IE status bit. &lt;br /&gt;Adds the contents of ST(1) (interpreted as an integer) to the exponent &lt;br /&gt;at the top of the stack. FSCALE multiplies or divides rapidly by &lt;br /&gt;powers of two. The value in ST(1) must be between 2-15 and 2+15. &lt;br /&gt;Performs modulo division of ST by ST(I). The resultant remainder is &lt;br /&gt;found in the top of the stack and has the same sign as the original &lt;br /&gt;dividend. Note that a modulo division results in a remainder without a &lt;br /&gt;quotient. Note also that FPREM is supported for the 8086 and 80287 &lt;br /&gt;and FPREM 1 should be used in newer coprocessors. &lt;br /&gt;Rounds the top of the stack to an integer. &lt;br /&gt;Decomposes the number at the top of the stack into two separate parts &lt;br /&gt;that represent the value of the unbiased exponent and the value of the &lt;br /&gt;significand. The extracted significand is found at the tOlJ of the stack, &lt;br /&gt;and the unbiased exponent at ST(I). This instruction is often used to &lt;br /&gt;convert a floating-point number into a form that can be printed as a &lt;br /&gt;mixed number. &lt;br /&gt;Changes the sign of the top of the stack to positive. &lt;br /&gt;Changes the sign from positive to negative or negative to positive. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 531 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Comparison Instructions &lt;br /&gt;The comparison instructions all examine data at the top of the stack in relation to another ele-&lt;br /&gt;ment and return the result of the comparison in the status register condition code bits C3-CO. &lt;br /&gt;Comparisons thz.l are allowed by the coprocessor are FCOM (floating-point compare), FCOMP &lt;br /&gt;(floating-point compare with a pop), FCOMPP (floating-point compare with two pops), FlCOM &lt;br /&gt;(integer compare), FlCOMP (integer compare and pop), FSTS (test), and FXAM (examine). &lt;br /&gt;New with the introduction of the Pentium Pro is the fioming compare and move results to tlags &lt;br /&gt;or FCOMI instruction. Following is a list of these instructions with a description of their functions: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCOM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCOMPand &lt;br /&gt;FCOMPP &lt;br /&gt;FICOMand &lt;br /&gt;FICOMP &lt;br /&gt;FTST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCOMII &lt;br /&gt;FUCOMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Compares the floating-point data at the top of the stack with an operand, &lt;br /&gt;which may be any register or any memory operand. If the operand is not &lt;br /&gt;coded with the instruction, the next stack element ST(I) is compared with &lt;br /&gt;the stack top ST. &lt;br /&gt;Both instructions perform as FCOM, but they also pop one or two datum &lt;br /&gt;from the stack. &lt;br /&gt;The top of the stack is compared with the integer stored at a memory &lt;br /&gt;operand. In addition to the compare, FlCOMP also pops the top of the stack. &lt;br /&gt;Tests the contents of the top of the stack against a zero. The result of the &lt;br /&gt;comparison is coded in the status register condition code bits, as illustrated &lt;br /&gt;in Table 13-2 with the status register. Also see Table 13-3 for a way of &lt;br /&gt;using SAHF and the conditional jump instruction with FTST. &lt;br /&gt;Examines the stack top and modifies the condition code bits to indicate &lt;br /&gt;whether the contents are positive, negative, normalized, etc. Refer back to &lt;br /&gt;the status register in Table 13-2. &lt;br /&gt;New to the Pentium Pro, this instruction compares in exactly the same &lt;br /&gt;manner as the FCOM instruction with one additional feature: it moves the &lt;br /&gt;floating-point flags into the flag register just as the FNSTSW AX and SAHF &lt;br /&gt;instruction did in Example 13-8. Intel has combined the FCOM, FNSTSW &lt;br /&gt;AX, and SAHF instructions to form FCOMI. Also available is the unordered &lt;br /&gt;compare or FUCOMI. Each is also available with a pop by appending the &lt;br /&gt;opcode with a P. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Transcendental Operations &lt;br /&gt;The transcendental instructions include FPTAN (partial tangent), FPATAN (partial arctangent), &lt;br /&gt;FSIN (sine), FCOS (cosine), FSINCOS (sine and cosine), F2XMl (2X_ 1 ), FYL2X (Y 10g2 X), &lt;br /&gt;and FYL2XPI (Y log2 (X + 1) ). A list of these operations follows with a description of each &lt;br /&gt;transcendental operation: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPTAN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPATAN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F2XMl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Finds the partial tangent of Y IX = tan e. The value of e is at the top of the &lt;br /&gt;stack and must be between 0 and nl4 radians for the 8087 and 80287 and &lt;br /&gt;less than 263 for the 80387, 8048617, Pentium, and Pentium Pro micropro-&lt;br /&gt;cessors. The result is a ratio found as ST = X and ST(l) = Y. If the value is &lt;br /&gt;outside of the allowable range, an invalid error occurs as indicated by the &lt;br /&gt;status register IE bit. Also note that ST(7) must be empty for this instruction &lt;br /&gt;to function properly. &lt;br /&gt;Finds the partial arctangent as e = ARCTAN X1Y. The value of X is at the top &lt;br /&gt;of the stack, and Y is at ST( I). The values of X and Y must be as follows: 0 :::; &lt;br /&gt;Y &amp;lt; X &amp;lt; 00. The instruction pops the stack and leaves e at the top of the stack. &lt;br /&gt;Finds the function 2X - 1. The value of X is taken from the top of the stack &lt;br /&gt;and the result is returned to the top of the stack. To obtain 2&amp;quot; add one to the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;532 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 13-6 Exponential &lt;br /&gt;functions Function Equation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSIN/FCOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSINCOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FYL2X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FYL2XPl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2Y x 109210 &lt;br /&gt;2Y x 1092 E &lt;br /&gt;2Y X 1092 X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;result at the top of the stack. The value of X must be in the range of -1 and &lt;br /&gt;+1. The F2XMl instruction is used to derive the functions listed in Table &lt;br /&gt;13-6. Note that the constants log2 10 and log2 e are built in as standard &lt;br /&gt;values for the coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Finds the sine or cosine of the argument located in ST expressed in radians &lt;br /&gt;(360Â° = 2IT radians), with the result found in ST. The values of ST must be &lt;br /&gt;less than 263. &lt;br /&gt;Finds the sine and cosine of ST, expressed in radians, and leaves the results &lt;br /&gt;as ST = sine and ST(l) = cosine. As with FSIN or FCOS, the initial value of &lt;br /&gt;ST must be less than 263. &lt;br /&gt;Finds Y log2 X. The value X is taken from the stack top, and Y is taken &lt;br /&gt;from ST( 1). The result is found at the top of the stack after a pop. The value &lt;br /&gt;of X must range between 0 and 00, and the value of Y must be between -00 &lt;br /&gt;and +00. A logarithm with any positive base (b) is found by the equation &lt;br /&gt;LOGb x = (LOG2 b)-l X LOG2 X &lt;br /&gt;Finds Y log2 (X + 1). The value of X is taken from the stack top, and Y is &lt;br /&gt;taken from ST(l). The result is found at the top of the stack after a pop. The &lt;br /&gt;value of X must range between 0 and 1-12/2, and the value of Y must be &lt;br /&gt;between -00 and +00. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Constant Operations &lt;br /&gt;The coprocessor instruction set includes opcodes that return constants to the top of the stack. A &lt;br /&gt;list of these instructions appears in Table 13-7. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Coprocessor Control Instructions &lt;br /&gt;The coprocessor has control instructions for initialization, exception handling, and task &lt;br /&gt;switching. The control instructions have two forms. For example, FINIT initializes the co-&lt;br /&gt;processor, as does FNINIT. The difference is that FNINIT does not cause any wait states, while &lt;br /&gt;FINIT does cause waits. The microprocessor waits for the FINIT instruction by testing the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 13-7 Constant &lt;br /&gt;operations Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDZ &lt;br /&gt;FLD1 &lt;br /&gt;FLDPI &lt;br /&gt;FLDL2T &lt;br /&gt;FLDL2E &lt;br /&gt;FLDLG2 &lt;br /&gt;FLDLN2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Constant pushed to ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+0.0 &lt;br /&gt;+1.0 &lt;br /&gt;it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;109210 &lt;br /&gt;1092 E &lt;br /&gt;10910 2 &lt;br /&gt;109, 2 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 533 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 13-8 Coprocessor &lt;br /&gt;Field Value Condition state after a reset or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;initialization &lt;br /&gt;Infinity 0 Projective &lt;br /&gt;Rounding 00 Round to nearest &lt;br /&gt;Precision 11 Extended precision &lt;br /&gt;Error masks 11111 Error bits disabled &lt;br /&gt;Busy 0 Not busy &lt;br /&gt;C3-CO ???? Unknown &lt;br /&gt;TOP 000 Register 000 or ST(O) &lt;br /&gt;ES 0 No errors &lt;br /&gt;Error bits 00000 No errors &lt;br /&gt;All tags 11 Empty &lt;br /&gt;Registers ST(0)-ST(7) Not changed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSY pin on the coprocessor. All control instructions have these two forms. Following is a list &lt;br /&gt;of each control instruction with its function: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FINITIFNINIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSETPM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDCW &lt;br /&gt;FSTCWIFNSTCW &lt;br /&gt;FSTSWAXI &lt;br /&gt;FNSTSWAX &lt;br /&gt;FCLEXlFNCLEX &lt;br /&gt;FSA VEIFNSA VE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRSTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTENVIFNSTENV &lt;br /&gt;FLDENV &lt;br /&gt;FINCST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDECSTP &lt;br /&gt;FFREE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FNOP &lt;br /&gt;FWAIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This instruction performs a reset operation on the arithmetic &lt;br /&gt;coprocessor (refer to Table 13-8 for the reset conditions). The &lt;br /&gt;coprocessor operates with a closure of projective (unsigned infinity), &lt;br /&gt;rounds to the nearest or even, and uses extended-precision when &lt;br /&gt;reset or initialized. It also sets register 0 as the top of the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Changes the addressing mode of the coprocessor to the protected-&lt;br /&gt;addressing mode. This mode is used when the microprocessor is &lt;br /&gt;also operated in the protected mode. As with the microprocessor, &lt;br /&gt;protected mode can only be exited by a hardware reset or, in the case &lt;br /&gt;of the 80386 through the Pentium Pro, with a change to the control &lt;br /&gt;register. &lt;br /&gt;Loads the control register with the word addressed by the operand. &lt;br /&gt;Stores the control register into the word-sized memory operand. &lt;br /&gt;Copies the contents of the control register to the AX register. This &lt;br /&gt;instruction is not available to the 8087 coprocessor. &lt;br /&gt;Clears the error flags in the status register and also the busy flag. &lt;br /&gt;Writes the entire state of the machine to memory. Figure 13-8 shows &lt;br /&gt;the memory layout for this instruction. &lt;br /&gt;Restores the state of the machine from memory. This instruction is &lt;br /&gt;used to restore the information saved by FSA VEIFNSA VE. &lt;br /&gt;Stores the environment of the coprocessor as shown in Figure 13-9. &lt;br /&gt;Reloads the environment saved by FSTENVIFNSTENV. &lt;br /&gt;Increments the stack pointer. &lt;br /&gt;Decrements the stack pointer. &lt;br /&gt;Frees a register by changing the destination register's tag to empty. &lt;br /&gt;It does not affect the contents of the register. &lt;br /&gt;Floating-point coprocessor NOP. &lt;br /&gt;Causes the microprocessor to wait for the coprocessor to finish an &lt;br /&gt;operation. FW AIT should be used before the microprocessor &lt;br /&gt;accesses memory data that is affected by the coprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;534 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-8 Memory &lt;br /&gt;format when the 80X87 &lt;br /&gt;registers are saved with the &lt;br /&gt;FSAVE instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-9 Memory &lt;br /&gt;format for the FSTENV in-&lt;br /&gt;struction: (a) real mode and &lt;br /&gt;(b) protected mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sl &lt;br /&gt;Offset 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;58H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;56H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;54H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18H &lt;br /&gt;16H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exponent 0-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 48--63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 32-47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 16-31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 0-15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exponent 0-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 48--63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 32-47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 16-31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 0-15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exponent 0-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 48--63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 32-47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 16-31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fraction 0-15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEH &lt;br /&gt;OCH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAH &lt;br /&gt;08H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OP 16-191 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH &lt;br /&gt;OAH &lt;br /&gt;08H &lt;br /&gt;06H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H &lt;br /&gt;02H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operand pointer (OP) 0-15 &lt;br /&gt;IP 16-191 Opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IP 0-15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tag register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Status register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OP16-191 0 &lt;br /&gt;Operand pointer 0-15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IP 16-191 Opcode &lt;br /&gt;Instruction pOinter G-15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tag register &lt;br /&gt;Status register &lt;br /&gt;Control register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Coprocessor Instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH &lt;br /&gt;OAH &lt;br /&gt;08H &lt;br /&gt;06H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H &lt;br /&gt;02H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Last stack &lt;br /&gt;element ST(7) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Next stack &lt;br /&gt;element ST(1) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stack top &lt;br /&gt;element ST(O) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Operand selector &lt;br /&gt;Operand offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS selector &lt;br /&gt;IP offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tag register &lt;br /&gt;Status register &lt;br /&gt;Control register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Although the microprocessor circuitry has not been discussed, the instruction sets of these co-&lt;br /&gt;processors and their differences with the other versions of the coprocessor can be discussed. &lt;br /&gt;These newer coprocessors contain the same basic instructions provided by the earlier versions, &lt;br /&gt;with a few additional instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80387, 80486, 80487SX, and Pentium contain the following additional instructions: &lt;br /&gt;FCOS (cosine), FPREMI (partial remainder), FSIN (sine), FSINCOS (sine and cosine), and &lt;br /&gt;FUCOM/FUCOMPIFUCOMPP (unordered compare). The sine and cosine instructions are the &lt;br /&gt;most-significant addition to the instruction set. In the earlier versions of the coprocessor, the sine &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 535 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and cosine is calculated from the tangent. The Pentium Pro contains two new floating-point in-&lt;br /&gt;structions: FCMOV (a conditional move) and FCOMI ( a compare and move to flags). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 13-9 lists the instruction sets for all versions of the coprocessor. It also lists the number &lt;br /&gt;of clocking periods required to execute each instruction. Execution times are listed for the 8087, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 13-9 The instruction set of the arithmetic coprocessor (pp. 535-550) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F2XM1 2ST -1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11110000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F2XM1 8087 310-630 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 310-630 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 211-476 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 140~279 &lt;br /&gt;Pentium 13-57 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro (see notes) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FABS Absolute value of ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11100001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FABS 8087 10-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 10-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FADD/FADDP/FIADD Addition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011000 ooOOOmmm disp 32-bit memory (FADD) &lt;br /&gt;11011100 ooOOOmmm disp 64-bit memory (FADD) &lt;br /&gt;11011dOO 11000rrr FADD ST,ST(rrr) &lt;br /&gt;11 01111 0 11000rrr FADDP ST,ST(rrr) &lt;br /&gt;11011110 ooOOOmmm disp 16-bit memory (FIADD) &lt;br /&gt;11011010 ooOOOmmm disp 32-bit memory (FIADD) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FADD FADDDATA 8087 70-143 &lt;br /&gt;FADDP FADD ST,ST(1) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 70-143 FIADD FADDP &lt;br /&gt;FIADD NUMBER 80387 23-72 &lt;br /&gt;FADD ST,ST(3) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 8-20 FADDP ST,ST(2) &lt;br /&gt;FADD ST(2),ST Pentium 1-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;536 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCLEXlFNCLEX Clear errors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011011 11100010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCLEX 8087 2-8 &lt;br /&gt;FNCLEX 80287 2-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~en~i!!m Pro &lt;br /&gt;.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCOMIFCOMPIFCOMPPIFICOM/FICOMP Compare &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011000 oo010mmm disp 32-bit memory (FCOM) &lt;br /&gt;11011100 oo010mmm disp 64-bit memory (FCOM) &lt;br /&gt;11011000 11010rrr FCOM ST(rrr) &lt;br /&gt;11011000 oo011mmm disp 32-bit memory (FCOMP) &lt;br /&gt;11011100 ooOllmmm disp 64-bit memory (FCOMP) &lt;br /&gt;11011000 11011rrr FCOMP ST(rrr) &lt;br /&gt;11011110 11011001 FCOMPP &lt;br /&gt;11011110 oo010mmm disp 16-bit memory (FICOM) &lt;br /&gt;11011010 oo010mmm disp 32-bit memory (FICOM) &lt;br /&gt;11011110 oo011mmm disp 16-bit memory (FICOMP) &lt;br /&gt;11011010 ooOllmmm disp 32-bit memory (FICOMP) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;FCOM FCOM ST(2) 8087 40-93 &lt;br /&gt;FCOMP FCOMP DATA 80287 40-93 FCOMPP FCOMPP &lt;br /&gt;FICOM FICOM NUMBER 80387 24-63 &lt;br /&gt;FICOMP FICOMP DATA3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 15-20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCOMI/FUCOMI/COMIP/FUCOMIP Compare and Load Flags &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101101111110rrr FCOMI ST(rrr) &lt;br /&gt;11011011 11101 rrr FUCOMI ST(rrr) &lt;br /&gt;1101111111110rrr FCOMIP ST(rrr) &lt;br /&gt;1101111111101rrr FUCOMIP ST(rrr) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FCOM FCOMI pT(2) 8087 -&lt;br /&gt;FUCOMI FUCOMI ST(4) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 FCOMIP FCOMIP ST(O) -&lt;br /&gt;FUCOMIP FUCOM/p ST(l) 80387 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 537 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCMOVcc Conditional Move &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011010 11 OOOrrr FCMOVB ST(rrr) &lt;br /&gt;11011010 11001 rrr FCMOVE ST(rrr) &lt;br /&gt;11011010 1101 Orrr FCMOVBE ST(rrr) &lt;br /&gt;11011010 11011 rrr FCMOVU ST(rrr) &lt;br /&gt;11011011 11000rrr FCMOVNB ST(rrr) &lt;br /&gt;11011011 11001 rrr FCMOVNE ST(rrr) &lt;br /&gt;11011011 1101 Orrr FCMOVENBE ST(rrr) &lt;br /&gt;11011011 11011 rrr FCMOVNU ST(rrr) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCMOVB FCMOVB ST(2) 8087 -&lt;br /&gt;FCMOVE FCMOVE ST(3) 80287 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCOS Cosine of ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11111111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FCOS 8087 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 123-772 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 193-279 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 18-124 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDECSTP Decrement stack pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11110110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDECSTP 8087 6-12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 6-12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;538 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDISI/FNDISI Disable interrupts &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011011 11100001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(ignored on the 80287,80387,8048617, Pentium, and Pentium Pro) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDISI 8087 2-8 &lt;br /&gt;FNDISI 80287 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDIVlFDIVP/FIDIV Division &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011000 00110mmm disp 32-bit memory (FDIV) &lt;br /&gt;11011100 00100mmm disp 64-bit memory (FDIV) &lt;br /&gt;11011 dOO 11111 rrr FDIV ST,ST(rrr) &lt;br /&gt;11011110 11111 rrr FDIVP ST,ST(rrr) &lt;br /&gt;11011110 00110mmm disp 16-bit memory (FIDIV) &lt;br /&gt;11011010 00110mmm disp 32-bit memory (FIDIV) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDIV FDIV DATA 8087 191-243 &lt;br /&gt;FDIVP FDIV ST,ST(3) 80287 191-243 FIDIV FDIVP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIDIV NUMBER 80387 88-140 &lt;br /&gt;FDIV ST,ST(5) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 8-89 FDIVP ST,ST(2) &lt;br /&gt;FDIV ST(2),ST Pentium 39-42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDIVRlFDIVRP/FIDIVR Division reversed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011000 00111mmm disp 32-bit memory (FDIVR) &lt;br /&gt;11011100 00111mmm disp 64-bit memory (FDIVR) &lt;br /&gt;11011dOO 11110rrr FDIVR ST,ST(rrr) &lt;br /&gt;11011110 11110rrr FDIVRP ST,ST(rrr) &lt;br /&gt;11011110 00111mmm disp 16-bit memory (FIDIVR) &lt;br /&gt;11011010 00111mmm disp 32-bit memory (FIDIVR) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDIVR FDIVR DATA 8087 191-243 &lt;br /&gt;FDIVRP FDIVR ST,ST(3) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 191-243 FIDIVR FDIVRP &lt;br /&gt;FIDIVR NUMBER 80387 88-140 &lt;br /&gt;FDiVR ST,ST(5) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 8-89 FDIVRP ST,ST(2) &lt;br /&gt;FDIVR ST(2),ST Pentium 39-42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 539 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FENI/FNENI Disable interrupts &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011011 11100000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(ignored on the 80287,80387,8048617 and Pentium) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FENI 8087 2-8 &lt;br /&gt;FNENI 80287 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFREE Free register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011101 11000rrr &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFREE FFREE 8087 9-16 &lt;br /&gt;FFREE ST(1) 80287 9-16 FFREE ST(2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FINCSTP Increment stack pointer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11110111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FINCSTP 8087 6-12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 6-12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;540 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FINIT/FNINIT Initialize coprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11110110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FINIT 8087 2-8 &lt;br /&gt;FNINIT 80287 2-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 12-16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLD/FILD/FBLD Load data to ST(O) &lt;br /&gt;11011001 ooOOOmmm disp 32-bit memory (FLD) &lt;br /&gt;11011101 ooOOOmmm disp 64-bit memory (FLD) &lt;br /&gt;11011011 00101 mmm disp 80-bit memory (FLD) &lt;br /&gt;11011111 ooOOOmmm disp 16-bit memory (FILD) &lt;br /&gt;11011011 ooOOOmmm disp 32-bit memory (FILD) &lt;br /&gt;11011111 00101 mmm disp 64-bit memory (FILD) &lt;br /&gt;11011111 00100mmm disp 80-bit memory (FBLD) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLD FLD DATA 8087 17-310 &lt;br /&gt;FILD FILD DATA1 80287 17-310 FBLD FBLD DEC_DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 14-275 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 3-103 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLD1 Load + 1.0 to ST(O) &lt;br /&gt;11011001 11101000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLD1 8087 15-21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 15-21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 541 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLOZ Load +0.0 to ST(O) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11101110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FLDZ 8087 11-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 11-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLOPI Load 1t to ST(O) &lt;br /&gt;11011001 11101011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FLOPI 8087 16-22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 16-22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 40 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLOL2E Load 1092e to ST(O) &lt;br /&gt;11011001 11101010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FLOL2E 8087 15-21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 15-21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 40 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLOL2T Load 109210 to ST(O) &lt;br /&gt;11011001 11101001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FLOL2T 8087 16-22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 16-22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 40 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;542 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDLG2 Load log102 to ST(O) &lt;br /&gt;11011001 11101000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDLG2 8087 18-24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 18-24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDLN2 Load loge2 to ST~O) &lt;br /&gt;11011001 11101101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FLDLN2 8087 17-23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 17-23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDCW Load control register &lt;br /&gt;11011001 oo101mmm disp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;FLDCW FLDCW DATA 8087 7-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDCW STATUS 80287 7-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDENV Load environment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 oo100mmm disp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;FLDENV FLDENV ENVIRON 8087 35-45 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDENV DATA I 80287 25-45 &lt;br /&gt;80387 71 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486n 34-44 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 32-37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 543 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FMUUFMULP/FIMUL Multiplication &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011000 00001 mmm disp 32-bit memory (FMUL) &lt;br /&gt;11011100 00001 m;'1m disp 64-bit memory (FMUL) &lt;br /&gt;11011 dOO 11001 rrr FMUL ST,ST(rrr) &lt;br /&gt;11011110 11001 rrr FMULP ST,ST(rrr) &lt;br /&gt;11011110 00001mmm disp 16-bit memory (FIMUL) &lt;br /&gt;11011010 00001mmm disp 32-bit memory (FIMUL) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FMUL FMUL DATA 8087 110-168 &lt;br /&gt;FMULP FMUL ST,ST(2) 80287 110-168 FIMUL FMUL ST(2),ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FMULP 80387 29-82 &lt;br /&gt;FIMUL DATA3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 11-27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FNOP No operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11010000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FNOP 8087 10-16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 10-16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPATAN Partial arctangent of ST(O) &lt;br /&gt;11011001 11110011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPATAN S087 250-S00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S02S7 250-800 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S0387 314-4S7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S0486/7 218-303 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 17-173 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;544 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPREM Partial remainder &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 11111000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPREM 8087 15-190 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 15-190 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 74-155 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S0486n 70-138 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 16-64 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I?entium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPREM1 Partial remainder (IEEE) &lt;br /&gt;11011001 11110101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FPREM1 8087 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 -&lt;br /&gt;80387 95-185 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486n 72-167 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 20-70 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FPTAN Partial tangent of 8T(0) &lt;br /&gt;11011001 11110010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FPTAN 8087 30-450 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 30-450 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 191-497 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486n 200-273 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 17-173 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRNDINT Round 8T(0) to an integer &lt;br /&gt;11011001 11111100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRNDINT 8087 16-50 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 i6-50 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 66-80 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486n 21-30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9-20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 545 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRSTOR Restore state &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011101 oo110mmm disp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;FRSTOR FRSTOR DATA 8087 197-207 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRSTOR STATE 80287 197-207 FRSTOR MACHINE &lt;br /&gt;80387 308 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 120-131 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 70-95 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSAVE/FNSAVE Save machine state &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011101 oo110mmm disp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;FSAVE FSAVE STATE 8087 197-207 &lt;br /&gt;FNSAVE FNSAVE STATUS 80287 197-207 FSAVE MACHINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 375 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 143-154 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 124-151 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSCALE Scale ST(O) by ST(1) &lt;br /&gt;11011001 11111101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FSCALE 8087 32-38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 32-38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 67-86 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 30-32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 20-31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSETPM Set protected mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011011 11100100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FSETPM 8087 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 2-18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 -&lt;br /&gt;Pentium -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;546 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSIN Sine of ST(O) &lt;br /&gt;11011001 11111110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSIN 8087 -&lt;br /&gt;80287 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 122-771 &lt;br /&gt;80486n 193-279 &lt;br /&gt;Pentium 16-126 &lt;br /&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSINCOS Find sine and cosine of ST(O) &lt;br /&gt;11011001 11111011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FSINCOS 8087 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 -&lt;br /&gt;80387 194-809 &lt;br /&gt;80486n 243-329 &lt;br /&gt;Pentium 17-137 &lt;br /&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSQRT Square root of ST(O) &lt;br /&gt;11011001 11111010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FSQRT 8087 180-186 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 180-186 &lt;br /&gt;80387 122-129 &lt;br /&gt;80486n 83-87 &lt;br /&gt;Pentium 70 &lt;br /&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 547 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FST/FSTP/FIST/FISTP/FBSTP Store &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 00010mmm disp 32-bit memory (FST) &lt;br /&gt;11011101 00010mmm disp 64-bit memory (FST) &lt;br /&gt;11011101 11010rrr FST ST(rrr) &lt;br /&gt;11011011 00011 mmm disp 32-bit memory (FSTP) &lt;br /&gt;11011101 00011 mmm disp 64-bit memory (FSTP) &lt;br /&gt;11011011 00111 mmm disp 80-bit memory (FSTP) &lt;br /&gt;11011101 11001rrr FSTP ST(rrr) &lt;br /&gt;11011111 00010mmm disp 16-bit memory (FIST) &lt;br /&gt;11011011 00010mmm disp 32-bit memory (FIST) &lt;br /&gt;11011111 00011 mmm disp 16-bit memory (FISTP) &lt;br /&gt;11011011 00011 mmm disp 32-bit memory (FISTP) &lt;br /&gt;11011111 00111 mmm disp 64-bit memory (FISTP) &lt;br /&gt;11011111 00110mmm disp 80-bit memory (FBSTP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FST FST DATA 8087 15-540 &lt;br /&gt;FSTP FST ST(3) 80287 15-540 FIST FST &lt;br /&gt;FISTP FSTP 80387 11-534 &lt;br /&gt;FBSTP FIST DATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FBSTP DATA6 80486/7 3-176 &lt;br /&gt;FISTP DATA9 Pentium 1-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTCW/FNSTCW Store control register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 00111 mmm disp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTCW FSTCW CONTROL 8087 12-18 &lt;br /&gt;FNSTCW FNSTCW STATUS 80287 12-18 FSTCW MACHINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTENVlFNSTENV Store environment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011001 00110mmm disp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTENV FSTENV CONTROL 8087 40-50 &lt;br /&gt;FNSTENV FNSTENV STATUS 80287 40-50 FSTENV MACHINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 103-104 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 58-67 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 48-50 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;548 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTSW/FNSTSW Store status register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011101 00111mmm disp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTSW FSTSW CONTROL 8087 12-18 &lt;br /&gt;FNSTSW FNSTSW STATUS 80287 12-18 FSTSW MACHINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTSWAX 80387 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSUB/FSUBP/FISUB Subtraction , &lt;br /&gt;i &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011000 00100mmm disp 32-bit memory (FSUB) &lt;br /&gt;I 11011100 00100mmm disp 64-bit memory (FSUB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011dOO 11101rrr FSUB ST,ST(rrr) &lt;br /&gt;110i1110 11101rrr FSUBP ST,ST(rrr) &lt;br /&gt;11011110 00100mmm disp 16-bit memory (FISUB) &lt;br /&gt;11011010 00100mmm disp 32-bit memory (FISUB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSUB FSUB DATA 8087 70-143 &lt;br /&gt;FSUBP FSUB ST,ST(2) 80287 70-143 FISUB FSUB ST(2),ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSUBP 80387 29-82 &lt;br /&gt;FISUB DATA3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 8-35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSUBR/FSUBRP/FISUBR Reverse subtraction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011000 00101 mmm disp 32-bit memory (FSUBR) &lt;br /&gt;11011100 00101mmm disp 64-bit memory (FSUBR) &lt;br /&gt;11011dOO 11100rrr FSUBR ST,ST(rrr) &lt;br /&gt;11011110 11100rrr FSUBRP ST,ST(rrr) &lt;br /&gt;11011110 00101mmm disp 16-bit memory (FISUBR) &lt;br /&gt;11011010 00101mmm disp 32-bit memory (FISUBR) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSUBR FSUBR DATA 8087 70-143 &lt;br /&gt;FSUBRP FSUBR ST,ST(2) 80287 70-143 FISUBR FSUBR ST(2),ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSUBRP 80387 29-82 &lt;br /&gt;FISUBR DATA3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 8-35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-3 INSTRUCTION SET 549 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FTST Compare ST(O) with + 0.0 &lt;br /&gt;11011001 11100100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;FTST 8087 38-48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 38-48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FUCOM/FUCOMP/FUCOMPP Unordered compare &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11011101 11100rrr FUCOM ST,ST(rrr) &lt;br /&gt;11011101 11101rrr FUCOMP ST,ST(rrr) &lt;br /&gt;11011101 11101001 FUCOMPP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Clocks &lt;br /&gt;FUCOM FUCOM ST,ST(2) 8087 -&lt;br /&gt;FUCOMP FUCOM 80287 FUCOMPP FUCOMP ST,ST(3) -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FUCOMP 80387 24-26 &lt;br /&gt;FUCOMPP 8048617 4-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FWAIT Wait &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FWAIT 8087 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 1-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXAM Examine ST(O) &lt;br /&gt;11011001 11100101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXAM 8087 12-23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 12-23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 30-38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486/7 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;550 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXCH Exchange ST(O) with another register &lt;br /&gt;11011001 11001rrr FXCH ST,ST(rrr) &lt;br /&gt;Format Examples Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXCH FXCH ST,ST(1) 8087 10-15 &lt;br /&gt;FXCH 80287 10-15 &lt;br /&gt;FXCH ST,ST(4) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXTRACT Extract components of ST(O) &lt;br /&gt;11011001 11110100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXTRACT 8087 27-55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 27-55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 70-76 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 16-20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FYL2X ST(1) x log2 ST(O) &lt;br /&gt;11011001 11110001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FYL2X 8087 900-1100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 900-1100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 120-538 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 196-329 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 22-111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXL2XP1 ST(1) x log2 [ST(O) + 1.0] &lt;br /&gt;11011001 11111001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FXL2XP1 8087 700-1000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287 700-1000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80387 257-547 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8048617 171-326 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 22-103 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: d = direction, where d = 0 for ST as the destination, and d = 1 for ST as the source; rrr = floating-point &lt;br /&gt;register number; 00 = mode; mmm = rIm field; and disp = displacement. Intel has not released clock timings for &lt;br /&gt;the Pentium Pro. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-4 PROGRAMMING WITH THE ARITHMETIC COPROCESSOR 551 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80287, 80387, 80486, 80487, Pentium, and Pentium Pro. To detennine the execution time of an in-&lt;br /&gt;struction, the clock time is multiplied by the listed execution time. The FADD instruction requires &lt;br /&gt;70-143 clocks for the 80287. Suppose that an 8 MHz clock is used with the 80287. The clocking &lt;br /&gt;period is 118 MHz or 125 ns. The FADD instruction requires between 8.75 /.ls and 17.875 /.ls to ex-&lt;br /&gt;ecute. Using a 33 MHz (33 ns) 80486DX2, this instruction requires between 0.264 /.ls and 0.6S /.ls &lt;br /&gt;to execute. On the Pentium, the FADD instruction requires from 1-7 clocks, so the FADD requires &lt;br /&gt;between 0.00752 !.ls and 0.05264 Ils if operated at 133 MHz (7.52 ns). The Pentium Pro is even &lt;br /&gt;faster than the Pentium. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table 13-9 uses some shorthand notations to represent the displacement that mayor may &lt;br /&gt;not be required for an instruction that uses a memory-addressing mode. It also uses the abbrevi-&lt;br /&gt;ation mmm to represent a register/memory addressing mode, and rrr to represent one of the &lt;br /&gt;floating-point coprocessor registers ST(0)-ST(7). The 0 (destination)-bit that appears in some &lt;br /&gt;instruction opcodes defines the direction of the data flow as in FADD ST,ST(2) or FADD &lt;br /&gt;ST(2),ST. The D-bit is a logic 0 for flow towards ST, as in FADD ST,ST(2), where ST holds the &lt;br /&gt;sum after the addition; it is a logic 1 for FADD ST(2),ST, where ST(2) holds the sum. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also note that some instructions allow a choice of whether a wait is inserted. For example, &lt;br /&gt;the FSTSW AX instruction copies the status register into AX. The FNSTSW AX instruction also &lt;br /&gt;copies the status register to AX, but without a wait. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROGRAMMING WITH THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the chapter provides programming examples for the arithmetic coprocessor. Each &lt;br /&gt;example is chosen to illustrate a programming technique for the coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Calculating the Area of a Circle &lt;br /&gt;This first programming example illustrates a simple method of addressing the coprocessor stack. &lt;br /&gt;First, recall that the equation for calculating the area of a circle is A = 1tR2. A program that per-&lt;br /&gt;fonns this calculation is listed in Example 13-9. Note that this program takes test data from an &lt;br /&gt;array called RAD that contains five sample radii. The five areas are stored in a second array &lt;br /&gt;called AREA. No attempt is made in this program to use the data from the AREA array. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 4015C28F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40B51EB8 &lt;br /&gt;411547AE &lt;br /&gt;436A8000 &lt;br /&gt;41BB3333 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A short program that finds the area of five circles whose &lt;br /&gt;;radi are stored in array RAD . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select 80386 &lt;br /&gt;;select 80387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RAD DD 2.34,5.66,9.33,234.5,23.4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 0005 [ AREA DD 5 DUP (7) &lt;br /&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;0000 .CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0010 BE 0000 MOV 51,0 ;source element 0 &lt;br /&gt;0013 BF 0000 MOV DI,O ;destination elemenL 0 &lt;br /&gt;0016 B9 0005 MOV CX,5 ;count of 5 &lt;br /&gt;0019 MAIN1: &lt;br /&gt;0019 D9 84 0000 R FLD RAD [51 1 ;radius to ST &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;552 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001D D8 C8 FMUL ST,ST(O) ;square radius &lt;br /&gt;001F D9 EB FLDPI ;n to ST &lt;br /&gt;0021 DE C9 FMUL ;mu1tip1y ST ST x ST(l) &lt;br /&gt;0023 D9 9D 0014 R FSTP AREA [OIl ;save area &lt;br /&gt;0027 46 INC SI &lt;br /&gt;0028 47 INC DI &lt;br /&gt;0029 E2 EE LOOP MAIN1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Although this is a simple program, it does illustrate the operation of the stack. To provide &lt;br /&gt;a better understanding of the operation of the stack, Figure 13-10 shows the contents of the stack &lt;br /&gt;after each instruction of Example 13-9 executes. Note that only one pass through the loop is il-&lt;br /&gt;lustrated, because the program calculates five areas. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first instruction loads the contents of memory location RAD [SI], one of the elements &lt;br /&gt;of the array, to the top of the stack. Next, the FMUL ST,ST(O) instruction squares the radius on &lt;br /&gt;the top of the stack. The FLDPI instruction loads n to the stack top. The FMUL instructions uses &lt;br /&gt;the classic stack addressing mode to multiply ST by ST(1). After the multiplication, the prior &lt;br /&gt;values of ST and ST(1) are removed from the stack and the product replaces them at the top of &lt;br /&gt;the stack. Finally, the FSTP [DI] instruction copies the top of the stack, the area, to an array &lt;br /&gt;memory location AREA and clears the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also notice how care is taken to always remove all stack data. This is important because if &lt;br /&gt;data remain on the stack at the end of the procedure, the stack top will no longer be register O. &lt;br /&gt;This could cause problems because software assumes that the top of the st,ack is register O. An-&lt;br /&gt;other way of ensuring that the coprocessor is initialized is to place the FINIT (initialization) in-&lt;br /&gt;struction at the start of the program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Finding the Resonant Frequency &lt;br /&gt;An equation commonly used in electronics is the formula for determining the resonant frequency &lt;br /&gt;of an LC circuit. The equation solved by the program illustrated in Example 13-10 is Fr = &lt;br /&gt;lhrtVLc. This example uses L1 for the inductance L, Cl for the capacitor C, and RESO for the re-&lt;br /&gt;sultant resonant frequency. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 00000000 &lt;br /&gt;0004 358637BD &lt;br /&gt;0008 358637BD &lt;br /&gt;OOOC 40000000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 D9 06 0004 R &lt;br /&gt;0014 D8 OE 0008 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0018 D9 FA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001A D8 OE OOOC R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001E D9 EB &lt;br /&gt;0020 DE C9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0022 D9 E8 &lt;br /&gt;0024 DE F1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A sample program that finds the resonant frequency of an LC &lt;br /&gt;;tank circuit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;RESO DD ? ;resonant frequency &lt;br /&gt;L1 DD 0.000001 ; inductance &lt;br /&gt;C1 DD 0.000001 ; capacitance &lt;br /&gt;TWO DD 2.0 ; constant &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;FLD L1 ;get L &lt;br /&gt;FMUL C1 ;find LC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSQRT ;find U &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FMUL TWO ;find 2U &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDPI ;get 7t &lt;br /&gt;FMUL ;get 27t&amp;amp; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLD1 ;get 1 &lt;br /&gt;FDIVR ; form 1/ (27tU) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;EXAMPLE 13-11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-4 PROGRAMMING WITH THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 13-10 Operation FLO RAD [SI] FMUL ST,ST (0) &lt;br /&gt;of the stack for Example ST(O) RADIUS ST ST(O) RADIUS2 &lt;br /&gt;13-9, Note that the stack is ST(1) ST(1) &lt;br /&gt;shown after the execution of &lt;br /&gt;the indicated instruction, ST(2) ST(2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ST(3) ST(3) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDPI FMUL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ST(O) 1t ST ST (0) ltRADIUS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ST(1) RADIUS2 &lt;br /&gt;ST(2) &lt;br /&gt;ST (3) ST (3) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTP AREA [01] &lt;br /&gt;ST (0) ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0026 D9 lE 0000 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1------1 &lt;br /&gt;ST(1) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I--------t &lt;br /&gt;ST(2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1------1 &lt;br /&gt;ST(3) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1------1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTP RESO &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save frequency &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;553 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice the straightforward manner in which the program solves this equation. Very little &lt;br /&gt;extra data manipulation is required because of the stack inside the coprocessor. Also notice how &lt;br /&gt;the constant TWO is defined for the program and how the DIVRP, using classic stack ad-&lt;br /&gt;dressing, is used to form the reciprocal. If you own a reverse-polish entry calculator, such as &lt;br /&gt;those produced by Hewlett-Packard, you are familiar with stack addressing. If not, using the co-&lt;br /&gt;processor will increase your experience with this type of entry. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Finding the Roots Using the Quadratic Equation &lt;br /&gt;This example illustrates how to find the roots of a polynomial expression (ax2 + bx + c = 0) using &lt;br /&gt;the quadratic equation. The quadratic equation is &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--.Jb2 - 4ac bÂ±----&lt;br /&gt;2a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 13-11 illustrates a program that finds the roots (Rl and R2) for the quadratic equation. &lt;br /&gt;The constants are stored in memory locations AI, Bl, and Cl. Note that no attempt is made to &lt;br /&gt;determine the roots if they are imaginary. This example tests for imaginary roots and exits to &lt;br /&gt;DOS with a zero in the roots (Rl and R2) if it finds them. In practice, imaginary roots could be &lt;br /&gt;solved for and stored in a separate set of result memory locations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A program that finds the roots of a po:ynomial equation using &lt;br /&gt;the quadratic equation. Note imaginarj&amp;quot; roots are indicated if &lt;br /&gt;both root 1 (Rl) and root 2 (R2) are zero. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;554 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0004 &lt;br /&gt;0008 &lt;br /&gt;OOOC &lt;br /&gt;0010 &lt;br /&gt;0014 &lt;br /&gt;0018 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 &lt;br /&gt;0012 &lt;br /&gt;0016 &lt;br /&gt;001A &lt;br /&gt;DOlE &lt;br /&gt;0022 &lt;br /&gt;0026 &lt;br /&gt;002A &lt;br /&gt;002E &lt;br /&gt;0032 &lt;br /&gt;0036 &lt;br /&gt;0038 &lt;br /&gt;003A &lt;br /&gt;003D &lt;br /&gt;003E &lt;br /&gt;0040 &lt;br /&gt;0042 &lt;br /&gt;0045 &lt;br /&gt;0048 &lt;br /&gt;004A &lt;br /&gt;004C &lt;br /&gt;004E &lt;br /&gt;004E &lt;br /&gt;0052 &lt;br /&gt;0054 &lt;br /&gt;0056 &lt;br /&gt;005A &lt;br /&gt;005E &lt;br /&gt;0060 &lt;br /&gt;0062 &lt;br /&gt;0066 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;40000000 TWO DD 2.0 &lt;br /&gt;40800000 FOUR DD 4.0 &lt;br /&gt;3F800000 A1 DD 1.0 &lt;br /&gt;00000000 B1 DD 0.0 &lt;br /&gt;CllOOOOO C1 DD -9.0 &lt;br /&gt;00000000 R1 DD ? &lt;br /&gt;00000000 R2 DD ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D9 &lt;br /&gt;D9 &lt;br /&gt;D9 &lt;br /&gt;D9 &lt;br /&gt;D8 &lt;br /&gt;D9 &lt;br /&gt;D8 &lt;br /&gt;D8 &lt;br /&gt;D9 &lt;br /&gt;D8 &lt;br /&gt;DE &lt;br /&gt;D9 &lt;br /&gt;9B &lt;br /&gt;9E &lt;br /&gt;74 &lt;br /&gt;D9 &lt;br /&gt;9B &lt;br /&gt;A9 &lt;br /&gt;74 &lt;br /&gt;DE &lt;br /&gt;EB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D9 &lt;br /&gt;D8 &lt;br /&gt;D8 &lt;br /&gt;D9 &lt;br /&gt;D9 &lt;br /&gt;DE &lt;br /&gt;DE &lt;br /&gt;D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EE &lt;br /&gt;16 0014 R &lt;br /&gt;1E 0018 R &lt;br /&gt;06 0000 R &lt;br /&gt;OE 0008 R &lt;br /&gt;06 0004 R &lt;br /&gt;OE 0008 R &lt;br /&gt;OE 0010 R &lt;br /&gt;06 OOOC R &lt;br /&gt;OE OOOC R &lt;br /&gt;E1 &lt;br /&gt;E4 &lt;br /&gt;DF EO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE &lt;br /&gt;FA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;FLDZ &lt;br /&gt;FST R1 &lt;br /&gt;FSTP R2 &lt;br /&gt;FLD TWO &lt;br /&gt;FMUL A1 &lt;br /&gt;FLD FOUR &lt;br /&gt;FMUL A1 &lt;br /&gt;FMUL C1 &lt;br /&gt;FLD B1 &lt;br /&gt;FMUL B1 &lt;br /&gt;FSUBR &lt;br /&gt;FTST &lt;br /&gt;FSTSW AX &lt;br /&gt;SAHF &lt;br /&gt;JZ ROOTS1 &lt;br /&gt;FSQRT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;c1ear roots &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;form 2a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;form 4ac &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; form b 2 &lt;br /&gt;; form b 2 -4ac &lt;br /&gt;;test b 2-4ac for zero &lt;br /&gt;;copy status register to AX &lt;br /&gt;;move to flags &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if b 2 -4ac is zero &lt;br /&gt;;find square root of b 2-4ac &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DF EO FSTSW AX &lt;br /&gt;0001 TEST AX,l ;test for invalid error (negative) &lt;br /&gt;04 &lt;br /&gt;D9 &lt;br /&gt;18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06 &lt;br /&gt;E1 &lt;br /&gt;F2 &lt;br /&gt;1E &lt;br /&gt;06 &lt;br /&gt;C1 &lt;br /&gt;F1 &lt;br /&gt;1E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JZ ROOTS 1 &lt;br /&gt;FCOMPP ;clear stack &lt;br /&gt;JMP ROOTS2 ;end &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROOTS1: &lt;br /&gt;OOOC R FLD B1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSUB ST,ST(l) &lt;br /&gt;FDIV ST,ST(2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0014 R FSTP R1 ;save root 1 &lt;br /&gt;OOOC R FLD B1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FADD &lt;br /&gt;FDIVR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0018 R FSTP R2 ;save root 2 &lt;br /&gt;ROOTS2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Using a Memory Array to Store Results &lt;br /&gt;The next programming example illustrates the use of a memory array and the scaled-indexed ad-&lt;br /&gt;dressing mode to access the array. Example 13-12 shows a program that calculates 100 values of &lt;br /&gt;inductive reactance. The equation for inductive reactance is XL = 2nFL. In this example, the fre-&lt;br /&gt;quency range is from 10Hz to 1000Hz for F and an inductance of 4H. Notice how the instruction &lt;br /&gt;FSTP DWORD PTR CS:[EDI+4*ECX] is used to store the reactance for each frequency begin-&lt;br /&gt;ning with the last at 1000Hz and ending with the first at 10Hz. Also notice how the FCOMP in-&lt;br /&gt;struction is used to clear the stack just before the RET instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-12 &lt;br /&gt;A program that calculates the inductive reactance of L &lt;br /&gt;at a frequency range of 10Hz to 1000Hz and stores them &lt;br /&gt;in array XL. Note that the increment is 10Hz . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. NODEL SMALL &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;EXAMPLE 13-13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 C50B0200 &lt;br /&gt;0004 0000 &lt;br /&gt;0006 00000000 &lt;br /&gt;OOOA 00000000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 E8 OOOB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-4 PROGRAMMING WITH THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 40800000 L &lt;br /&gt;0004 0064 [ XL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 &lt;br /&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0194 447AOOOO F &lt;br /&gt;0198 41200000 TEN &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 661 B9 00000064 &lt;br /&gt;0016 661 BF 00000000 R &lt;br /&gt;001C D9 EB &lt;br /&gt;001E D8 CO &lt;br /&gt;0020 D8 OE 0000 R &lt;br /&gt;0024 L1: &lt;br /&gt;0024 D9 06 0194 R &lt;br /&gt;0028 D8 C9 &lt;br /&gt;002A 67&amp;amp; D9 1C 8F &lt;br /&gt;002E D9 06 0194 R &lt;br /&gt;0032 D8 26 0198 R &lt;br /&gt;0036 D9 1E 0194 R &lt;br /&gt;003A E2 E8 &lt;br /&gt;003C D8 D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;DD 4.0 &lt;br /&gt;DD 100 DUP (?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DD 1000.0 &lt;br /&gt;DD 10.0 &lt;br /&gt;.CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV ECX,100 &lt;br /&gt;MOV EDI,OFFSET XL-4 &lt;br /&gt;FLDPI &lt;br /&gt;FADD ST,ST(O) &lt;br /&gt;FMUL L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLD F &lt;br /&gt;FMUL ST,ST(l) &lt;br /&gt;FSTP DWORD PTR &lt;br /&gt;FLD F &lt;br /&gt;FSUB TEN &lt;br /&gt;FSTP F &lt;br /&gt;LOOP L1 &lt;br /&gt;FCOMP &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;[EDI+4*ECX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;4.0H test value &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start at 1000Hz &lt;br /&gt;:increment of 10Hz &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:load count &lt;br /&gt;;address result &lt;br /&gt;;get 7t &lt;br /&gt;;form 27t &lt;br /&gt;; form 27tL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;change frequency &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displaying a Single-Precision Floating-Point Number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;555 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the text shows how to take the floating-point contents of a 32-bit single-precision &lt;br /&gt;floating-point number and display it on the video display. The procedure displays the floating-&lt;br /&gt;point number as a mixed number with an integer part and a fractional part separated by a decimal &lt;br /&gt;point. In order to simplify the procedure, a limit is placed on the display size of the mixed &lt;br /&gt;number so the integer portion is a 32-bit binary number and the fraction is a 24-bit binary &lt;br /&gt;number. The procedure will not function properly for larger or smaller numbers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 13-13 lists a program that calls a procedure for displaying the contents of &lt;br /&gt;memory location NUMB on the video display at the current cursor position. The procedure first &lt;br /&gt;tests the sign of the number and displays a minus sign for a negative number. After displaying &lt;br /&gt;the minus sign, if needed, the number is made positive by the FABS instruction. Next, it is di-&lt;br /&gt;vided into an integer and fractional part and stored at WHOLE and FRACT. Notice how the &lt;br /&gt;FRNDINT instruction is used to round the top of the stack (using the chop mode) to form the &lt;br /&gt;whole number part of NUMB. The whole number part is then subtracted from the original &lt;br /&gt;number to generate the fractional part. This is accomplished with the FSUB instruction that sub-&lt;br /&gt;tracts the contents of ST(I) from ST. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that displays the floating-point contents of NUMB &lt;br /&gt;;as a mixed decimal number . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;NUMB DD -2224.125 ;test data &lt;br /&gt;TEMP DW ? &lt;br /&gt;WHOLE DD &lt;br /&gt;FRACT DD ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL DISP ;display NUNB &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;556 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;0019 &lt;br /&gt;001B &lt;br /&gt;OOlD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOlE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOlE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOlE &lt;br /&gt;0023 &lt;br /&gt;0029 &lt;br /&gt;002D &lt;br /&gt;0031 &lt;br /&gt;0033 &lt;br /&gt;0036 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003E &lt;br /&gt;0040 &lt;br /&gt;0043 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0045 &lt;br /&gt;0047 &lt;br /&gt;0049 &lt;br /&gt;004D &lt;br /&gt;004F &lt;br /&gt;0051 &lt;br /&gt;0055 &lt;br /&gt;0059 &lt;br /&gt;005F &lt;br /&gt;0062 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0063 &lt;br /&gt;0069 &lt;br /&gt;006C &lt;br /&gt;006F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0075 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007B &lt;br /&gt;007D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0082 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0087 &lt;br /&gt;0089 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOSE &lt;br /&gt;0090 &lt;br /&gt;0093 &lt;br /&gt;0097 &lt;br /&gt;009C &lt;br /&gt;00A2 &lt;br /&gt;00A6 &lt;br /&gt;OOAA &lt;br /&gt;OOAC &lt;br /&gt;OOBO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that displays the ASCII code from AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B4 06 &lt;br /&gt;SA DO &lt;br /&gt;CD 21 &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,6 &lt;br /&gt;MOV DL,AL &lt;br /&gt;INT 21H &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;disp1ay AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A procedure that displays the floating-point contents of NUMB &lt;br /&gt;;in decimal form. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9B &lt;br /&gt;81 &lt;br /&gt;D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D9 3E 0004 R &lt;br /&gt;OE 0004 R OCOO &lt;br /&gt;2E 0004 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D9 &lt;br /&gt;D9 &lt;br /&gt;9B &lt;br /&gt;25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BO &lt;br /&gt;E8 &lt;br /&gt;D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D9 &lt;br /&gt;D9 &lt;br /&gt;DB &lt;br /&gt;DE &lt;br /&gt;D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06 0000 R &lt;br /&gt;E4 &lt;br /&gt;DF EO &lt;br /&gt;4500 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2D &lt;br /&gt;FFD4 &lt;br /&gt;E1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CO &lt;br /&gt;FC &lt;br /&gt;16 0006 R &lt;br /&gt;E1 &lt;br /&gt;E1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D9 1E OOOA R &lt;br /&gt;661 A1 0006 R &lt;br /&gt;661 BB OOOOOOOA &lt;br /&gt;B9 0000 &lt;br /&gt;53 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 BA 00000000 &lt;br /&gt;661 F7 F3 &lt;br /&gt;80 C2 30 &lt;br /&gt;52 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6A 2C &lt;br /&gt;B9 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SA C2 &lt;br /&gt;ES FF8B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BO 2E &lt;br /&gt;ES FF84 &lt;br /&gt;661 A1 OOOA R &lt;br /&gt;9B D9 3E 0004 R &lt;br /&gt;81 36 0004 R OCOO &lt;br /&gt;D9 2E 0004 R &lt;br /&gt;D9 06 OOOA R &lt;br /&gt;D9 F4 &lt;br /&gt;D9 1E OOOA R &lt;br /&gt;D9 E1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FSTCW TEMP &lt;br /&gt;OR TEMP,OCOOH &lt;br /&gt;FLDCW TEMP &lt;br /&gt;FLD NUMB ;get NUMB &lt;br /&gt;FTST &lt;br /&gt;FSTSW AX &lt;br /&gt;AND AX,4500H &lt;br /&gt;.IFAX == 0100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, '-' &lt;br /&gt;CALL DISPS &lt;br /&gt;FABS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;FLD ST &lt;br /&gt;FRNDINT &lt;br /&gt;FIST WHOLE &lt;br /&gt;FSUBR &lt;br /&gt;FABS &lt;br /&gt;FSTP FRACT &lt;br /&gt;MOV EAX, WHOLE &lt;br /&gt;MOV EBX, 10 &lt;br /&gt;MOV CX, a &lt;br /&gt;PUSH BX &lt;br /&gt;.WHILE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EDX, 0 &lt;br /&gt;DIV EBX &lt;br /&gt;ADD DL,30H &lt;br /&gt;PUSH DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. BREAK .IF EAX &lt;br /&gt;INC CX &lt;br /&gt;.IF CX == 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH &lt;br /&gt;MOV CX,O &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE 1 &lt;br /&gt;POP DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. BREAK .IF DX &lt;br /&gt;MOV AL,DL &lt;br /&gt;CALL DISPS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;MOV AL,'.' &lt;br /&gt;CALL DISPS &lt;br /&gt;MOV EAX,FRACT &lt;br /&gt;FSTCW TENP &lt;br /&gt;XOR TEMP,OCOOH &lt;br /&gt;FLDCVl TEMP &lt;br /&gt;FLD FRACT &lt;br /&gt;FXTRACT &lt;br /&gt;FSTP FRACT &lt;br /&gt;FABS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save current control word &lt;br /&gt;;set rounding to chop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;test NUMB &lt;br /&gt;;status to AX &lt;br /&gt;;get C3, C2, and CO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get integer part &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save fraction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;divide until quotient 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display whole number part &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display decimal point &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;save current control word &lt;br /&gt;;set rounding to nearest &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-4 PROGRAMMING WITH THE ARITHMETIC COPROCESSOR 557 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B2 DB 1E GOOo P &lt;br /&gt;JOB6 661 8B DE 0006 R &lt;br /&gt;OOBB 661 A1 OOOA R &lt;br /&gt;DOBF 661 Cl EO 09 &lt;br /&gt;00C3 661 D3 D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FISTP I'IHOLE &lt;br /&gt;MOV ECX, WHOLE &lt;br /&gt;MOV EAX,FRACT &lt;br /&gt;SHL EAX,9 &lt;br /&gt;RCR EAX,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00C6 661 F7 E3 &lt;br /&gt;00C9 661 50 &lt;br /&gt;OOCB 661 92 &lt;br /&gt;OOCD 04 30 &lt;br /&gt;OOCF E8 FF45 &lt;br /&gt;00D2 661 58 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00D9 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OODA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPENT' &lt;br /&gt;MUL EBX &lt;br /&gt;PUSH EAX &lt;br /&gt;XCHG EAX,EDX &lt;br /&gt;ADD AL,30H &lt;br /&gt;CALL DISPS &lt;br /&gt;POP EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL EAX == 0 &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The last part of the procedure displays the whole number part followed by the fractional &lt;br /&gt;part. The techniques are the same as introduced earlier in the text-dividing a number by ten and &lt;br /&gt;displaying the remainders in reverse order converts and displays an integer. A multiplication by &lt;br /&gt;10 converts a fraction to decimal for displaying. Note that the fractional part may contain a &lt;br /&gt;rounding error for certain values. This occurs because the number has not been adjusted to re-&lt;br /&gt;move the rounding error that is inherent in floating-point fractional numbers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reading a Mixed Number from the Keyboard &lt;br /&gt;If floating-point arithmetic is used in a program, a method of reading the number from the key-&lt;br /&gt;board and converting it to floating-point must be developed. The procedure listed in Example &lt;br /&gt;l3-14 reads a signed mixed number from the keyboard and converts it to a floating-point &lt;br /&gt;number located at memory location NUMB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 13-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0001 &lt;br /&gt;0003 &lt;br /&gt;0007 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0027 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;0000 &lt;br /&gt;41200000 &lt;br /&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D9 EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that reads a mixed number from the keyboard. &lt;br /&gt;;The result is stored at memory location NUMB as a &lt;br /&gt;;double-precision floating-point number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;SIGN DB ? &lt;br /&gt;TEMP1 DW ? &lt;br /&gt;TEN DD 10.0 ;10.0 &lt;br /&gt;NUMB DD ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;GET MACRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,l &lt;br /&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;. STARTUP &lt;br /&gt;FLDZ &lt;br /&gt;GET &lt;br /&gt;.IF AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-- ' +' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;sign indicator &lt;br /&gt;;temporary storage &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;result &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;read key macro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear ST &lt;br /&gt;;read a character &lt;br /&gt;;test for + &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C6 06 0000 R 00 MOV SIGN,O ;clear sign indicator &lt;br /&gt;GET &lt;br /&gt;.ENDIF &lt;br /&gt;.IF AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'- , ;test for -&lt;br /&gt;C6 06 0000 R 01 MOV SIGN,l ;set. sign indlcator &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GET &lt;br /&gt;.ENDIF &lt;br /&gt;. REPEAT &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;558 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0030 D8 DE 0003 R &lt;br /&gt;0034 B4 00 &lt;br /&gt;0036 2C 30 &lt;br /&gt;0038 A3 0001 R &lt;br /&gt;003B DE 06 0001 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004F D9 E8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0051 _ D8 36 0003 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0061 B4 00 &lt;br /&gt;0063 2C 30 &lt;br /&gt;0065 A3 0001 R &lt;br /&gt;0068 DF 06 0001 R &lt;br /&gt;006C D8 C9 &lt;br /&gt;006E DC C2 &lt;br /&gt;0070 D8 D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0074 D8 D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007D .D9 EO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007F D9 1E 0007 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FMUL TEN &lt;br /&gt;MOV AH,O &lt;br /&gt;SUB AL,30H &lt;br /&gt;MOV TEMPI ,AX &lt;br /&gt;FIADD TEMPI &lt;br /&gt;GET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;multiply result by 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;convert from ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;add it to result &lt;br /&gt;;get next character &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL AL &amp;lt; '0' I I AL &amp;gt; '9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF AL == ' , ;do if -&lt;br /&gt;FLD1 ;get one &lt;br /&gt;. WHILE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDIV TEN &lt;br /&gt;GET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.BREAK .IF AL &amp;lt; '0' I I AL &amp;gt; '9' &lt;br /&gt;MOV AH,O &lt;br /&gt;SUB AL,30H ;convert from ASCII &lt;br /&gt;MOV TEMP1, AX &lt;br /&gt;FILD TEMP 1 &lt;br /&gt;FMUL ST,ST(l) &lt;br /&gt;FADD ST(2),ST &lt;br /&gt;FCOMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. Ei\\IDW &lt;br /&gt;FCOMP ;clear stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF SIGN 1 &lt;br /&gt;FCHS ;make negative &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;FSTP NUMB isave result &lt;br /&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unlike other examples in this chapter, Example 13-14 uses some of the high-level lan-&lt;br /&gt;guage constructs presented in earlier chapters to reduce its size. Here the sign is fIrst read from &lt;br /&gt;the keyboard, if present, and saved for later use, as a 0 for positive and a 1 for negative, in ad-&lt;br /&gt;justing the sign of the resultant floating-point number. Next, the integer portion of the number is &lt;br /&gt;read. Notice how the .REPEAT-.UNTIL loop is used to read the number until something other &lt;br /&gt;than a number (0-9) is typed. This portion terminates with a period, space, or carriage return. If &lt;br /&gt;a period is typed, then the procedure continues and reads a fractional part by using an &lt;br /&gt;.IF-.ENDIF construct. If a space or carriage return is entered, the number is converted to &lt;br /&gt;floating-point form and stored at NUMB. Notice how a .WHILE-.ENDW loop is used to convert &lt;br /&gt;the fractional part of the number. The whole number portion is converted with a multiply by 10, &lt;br /&gt;and the fractional portion is converted with a divide by 10. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The arithmetic coprocessor functions in parallel with the microprocessor. This means that the &lt;br /&gt;microprocessor and coprocessor can execute their respective instructions simultaneously. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The data types manipulated by the coprocessor include signed-integer, floating-point, and &lt;br /&gt;binary-coded decimal (BCD). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. There are three forms of integers used with the coprocessor: word (l6-bits), short (32-bits) &lt;br /&gt;and long (64-bits). Each integer contains a signed number in true magnitu(:c for positive &lt;br /&gt;numbers and two's complement form for negative numbers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. A BCD number is stored as an I8-digit number in 10 bytes of memory. The most-significant &lt;br /&gt;byte contains the sign-bit, and the remaining nine bytes contain an I8-digit packed BCD &lt;br /&gt;number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The coprocessor supports three types of floating-point numbers: single-precision (32-bits), &lt;br /&gt;double-precision (64-bits), and extended precision (80-bits). A floating-point number has &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13--6 QUESTIONS AND PROBLEMS 559 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;three parts: the sign, biased exponent, and significand. In the coprocessor, the exponent is &lt;br /&gt;biased with a constant and the integer bit of the normalized number is not stored in the sig-&lt;br /&gt;nificand, except in the extended-precision form. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Decimal numbers are converted to floating-point numbers by (a) converting the number to &lt;br /&gt;binary, (b) normalizing the binary number, (c) adding the bias to the exponcnt, and (d) &lt;br /&gt;storing the number in floating-point fOID1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Floating-point numbers are converted to decimal by (a) subtracting the bias from the expo-&lt;br /&gt;nent, (b) unnormalizing the number, and (c) converting it to decimal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. The 80287 uses I/O space for the execution of some of its instructions. This space is invisible &lt;br /&gt;to the program and is used internally by the 80286/80287 system. These 16-bit I/O addresses &lt;br /&gt;(00F8H-00FFH) must not be used for I/O data transfers in a system that contains an 80287. &lt;br /&gt;The 80387, 80486/7, Pentium, and Pentium Pro use I/O addresses 800000F8H-800000FFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The coprocessor contains a status register that indicates busy, what conditions follow a com-&lt;br /&gt;pare or test, the location of the top of the stack, and the state of the error bits. The FSTSW &lt;br /&gt;AX instruction, followed by SAHF, is often used with conditional jump instructions to test &lt;br /&gt;for some coprocessor conditions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The control register of the coprocessor contains control bits that select infinity, rounding, &lt;br /&gt;precision, and error masks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. The following directives are often used with the coprocessor for storing data: DW (define &lt;br /&gt;word), DD (define doubleword), DQ (define quadword) and DT (define 10 bytes). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The coprocessor uses a stack to transfer data between itself and the memory system. Gener-&lt;br /&gt;ally, data are loaded to the top of the stack or removed from the top of the stack for storage. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. All internal coprocessor data are always in the 80-bit extended-precision form. The only &lt;br /&gt;time that data are in any other form is when they are stored or loaded from the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The coprocessor addressing modes include the classic stack mode, register, register with a &lt;br /&gt;pop, and memory. Stack addressing is implied and the data at ST become the source, ST(l) &lt;br /&gt;the destination, and the result is found in ST after a pop. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. The coprocessor's arithmetic operations include addition, subtraction, multiplication, divi-&lt;br /&gt;sion, and square root. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. There are transcendental functions in the coprocessor's instruction set. These functions find &lt;br /&gt;the partial tangent or arctangent, 2x - 1, Y logz X, and Y logz (X + 1). The 80387, 80486/7, &lt;br /&gt;Pentium, and Pentium Pro also include sine and cosine functions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. Constants are stored inside the coprocessor that provide +0.0, + 1.0, 1t, logz 10, logz E, 10glO &lt;br /&gt;2, and logE 2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. The 80387 functions with the 80386 microprocessor and the 80487SX functions with the &lt;br /&gt;80486SX microprocessor, but the 80486DX, Pentium, and Pentium Pro contain their own &lt;br /&gt;internal arithmetic coprocessor. The instruction performed by the earlier versions are avail-&lt;br /&gt;able on these coprocessors. In addition to these instructions, the 80387, 80486/7, Pentium, &lt;br /&gt;and Pentium Pro can also find the sine and cosine. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. The Pentium Pro contains two new floating-point instructions: FCMOV and FCOMI. The &lt;br /&gt;FCMOV instruction is a conditional move; the FCOMI performs the same task as FCOM, &lt;br /&gt;but it also places the floating-point flags into the system flag register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. List the three types of data that are loaded or stored in memory by the coprocessor. &lt;br /&gt;2. List the three integer data types, the range of the integers stored in them, and the number of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bits allotted to each. &lt;br /&gt;3. Explain how a BCD number is stored in memory by the coprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;560 CHAPTER 13 THE ARITHMETIC COPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. List the three types of floating-point numbers used with the coprocessor and the number of &lt;br /&gt;binary bits assigned to each. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Convert the following decimal numbers into single-precision floating-point numbers: &lt;br /&gt;(a) 28.75 &lt;br /&gt;(b) 624 &lt;br /&gt;(c) -0.615 &lt;br /&gt;(d) + 0.0 &lt;br /&gt;(e) -1000.5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Convert the following single-precision floating-point numbers into decimal: &lt;br /&gt;(a) 11000000 11110000 00000000 00000000 &lt;br /&gt;(b) 00111111 00010000 00000000 00000000 &lt;br /&gt;(c) 01000011 10011001 00000000 00000000 &lt;br /&gt;(d) 01000000 00000000 00000000 00000000 &lt;br /&gt;(e) 01000001 00100000 00000000 00000000 (D 00000000 00000000 00000000 00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Explain what the coprocessor does when a normal microprocessor instruction executes. &lt;br /&gt;8. Explain what the microprocessor does when a coprocessor instruction executes. &lt;br /&gt;9. What is the purpose of the C3-C0 bits in the status register? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. What operation is accomplished with the FSTSW AX instruction? &lt;br /&gt;II. What is the purpose of the IE bit in the status register? &lt;br /&gt;12. How can SAHF and a conditional jump instruction be used to determine if the top of the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;stack (ST) is equal to register ST(2)? &lt;br /&gt;13. How is the rounding mode selected in the 80X87? &lt;br /&gt;14. What coprocessor instruction uses the microprocessor's AX register? &lt;br /&gt;15. What I/O ports are reserved for coprocessor use with the 80287? &lt;br /&gt;16. How are data stored inside the coprocessor? &lt;br /&gt;17. What is a NAN? &lt;br /&gt;18. Whenever the coprocessor is reset, the top of the stack register is register number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19. What does the term chop mean in the rounding control bits of the control register? &lt;br /&gt;20. What is the difference between affine and projective infinity control? &lt;br /&gt;21. What microprocessor instruction forms the opcodes for the coprocessor? &lt;br /&gt;22. The FlNIT instruction selects -precision for all coprocessor operations. &lt;br /&gt;23. Using assembler pseudo-opcodes, form statements that accomplish the following: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) Store a 23.44 into a double-precision floating-point memory location named FROG. &lt;br /&gt;(b) Store a -123 into a 32-bit signed integer location named DATA3. &lt;br /&gt;(c) Store a -23.8 into a single-precision floating-point memory location named DATAL &lt;br /&gt;(d) Reserve a double-precision memory location named DA TA2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24. Describe how the FST DATA instruction functions. Assume that DATA is defined as a 64-&lt;br /&gt;bit memory location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;25. What does the FlLD DATA instruction accomplish? &lt;br /&gt;26. Form an instruction that adds the contents of register 3 to the top of the stack. &lt;br /&gt;27. Describe the operation of the FADD instruction. &lt;br /&gt;28. Choose an instruction that subtracts the contents of register 2 from the top of the stack and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;stores the result in register 2. &lt;br /&gt;29. What is the function of the FBSTP DATA instruction? &lt;br /&gt;30. What is the difference between a forward and a reverse division? &lt;br /&gt;31. What is the purpose of the Pentium Pro FCOMI instruction? &lt;br /&gt;32. What does a Pentium Pro FCMOVB instruction accomplish? &lt;br /&gt;33. What must occur before executing any FCMOV instruction? &lt;br /&gt;34. Develop a procedure that finds the reciprocal of the single-precision floating-point number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The number is passed to the procedure in EAX and must be returned as a reciprocal in EAX. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;13-6 QUESTIONS ANO PROBLEMS &lt;br /&gt;FIGURE 13-11 The &lt;br /&gt;series/parallel circuit &lt;br /&gt;Question 48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R1 &lt;br /&gt;R~~IR21R3IR4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RT = R1 + &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;35. What is the difference between the FTST instruction and FXAM? &lt;br /&gt;36. Explain what the F2XMI instruction calculates. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;561 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37. Which coprocessor status register bit should be tested after the FSQRT instruction executes? &lt;br /&gt;38. Which coprocessor instruction pushes n onto the top of the stack? &lt;br /&gt;39. Which coprocessor instruction places a 1.0 at the top of the stack? &lt;br /&gt;40. What will FFREE ST(2) accomplish when executed? &lt;br /&gt;41. Which instruction stores the environment? &lt;br /&gt;42. What does the FSA VE instruction save? &lt;br /&gt;43. Develop a procedure that finds the area of a rectangle (A = L x W). Memory locations for &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;this procedure are single-precision floating-point locations A, L, and W. &lt;br /&gt;44. Write a procedure that finds the capacitive reactance (XC = IhrtFCr.). Memory locations for &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;this procedure are single-precision floating-point locations XC, F, and Cl. &lt;br /&gt;45. Develop a procedure that generates a table of square roots for the integers 2 through 10. The &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;results must be stored as single-precision floating point numbers in an array called ROOTS. &lt;br /&gt;46. When is the FW AIT instruction used in a program? &lt;br /&gt;47. What is the difference between the FSTSW and FNSTSW instruction? &lt;br /&gt;48. Given the series/parallel circuit and equation illustrated in Figure 13-11, develop a program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;using single-precision values for RI, R2, R3, and R4 that finds the total resistance and stores &lt;br /&gt;the result at single-precision location RT. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;49. Develop a procedure that finds the cosine of a single-precision floating-point number. The &lt;br /&gt;angle, in degrees, is passed to the procedure in EAX, and the cosine is returned in EAX. Re-&lt;br /&gt;call that FCOS finds the cosine of an angle expressed in radians. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50. Given two arrays of double-precision floating-point data (ARRA YI and ARRA Y2) that &lt;br /&gt;each contain 100 elements, develop a procedure that finds the product of ARRAYI times &lt;br /&gt;ARRA Y2 and stores the double-precision floating-point result in a third array (ARRA Y3). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;51. Develop a procedure that takes the single-precision contents of register EBX times nand &lt;br /&gt;stores the result in register EBX as a single-precision floating-point number. You must use &lt;br /&gt;memory to accomplish this task. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52. Write a procedure that raises a single-precision floating-point number X to the power Y. Pa-&lt;br /&gt;rameters are passed to the procedure with EAX = X and EBX = Y. The result is passed back &lt;br /&gt;to the calling sequence in ECX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;53. Given that the LOG IO X = (LOG2 lOti X LOG2 X, write a procedure called LOGIO that &lt;br /&gt;finds the LOG 10 of the value at the stack top. Return the LOG IO at the stack top at the end of &lt;br /&gt;the procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;54. Use the procedure developed in Question 53 to solve the equation Gain in decibels = 20 &lt;br /&gt;LOG IO (VoutlVin). The program should take arrays of single-precision values for VOUT &lt;br /&gt;and VIN and store the decibel gains in a third array called DBG. There are 100 values for &lt;br /&gt;VOUT and VIN. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;562 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 14 &lt;br /&gt;Bus I ntertace &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Many applications require a knowledge of the bus systems located within the personal com-&lt;br /&gt;puter. At times, main boards from personal computers are used as core systems in industrial ap-&lt;br /&gt;plications. These systems often require custom interfaces attached to one of the buses on the &lt;br /&gt;main board. This chapter presents the ISA (industry standard architecture) bus, the VESA local &lt;br /&gt;bus, and the PCI (peripheral component interconnect) bus. Also provided are some simple in-&lt;br /&gt;terfaces to each of these bus systems as design guides. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Detail the pin connections and signal bus connections on the ISA, VESA local, and PCI &lt;br /&gt;buses. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Develop simple interfaces that connect to the ISA, VESA local, and PCI buses. &lt;br /&gt;3. Program interface places on boards that connect to the ISA, VESA local, and PCI buses. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE ISA BUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ISA or industry standard architecture bus has been around since the very start of the &lt;br /&gt;IBM-compatible personal computer system (circa 1982). In fact, any card from the very first per-&lt;br /&gt;sonal computer will plug into and function in any of the most modem Pentium Pro-based com-&lt;br /&gt;puters. This is alI made possible by the ISA bus interface found in all of these machines, which &lt;br /&gt;is still compatible with the early personal computers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Evoluti:n of the ISA Bus &lt;br /&gt;The ISA bus has changed from its early days. Over the years, the ISA bus has evolved from the &lt;br /&gt;original 8-bit standard to the 16-bit standard found in most systems today. Along the way there was &lt;br /&gt;even a 32-bit version called the EISA bus (extended ISA), but that seems to have alI but disap-&lt;br /&gt;peared. What remains today in most personal computers is a slot (connection) on the main board &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14-1 THE ISA BUS 563 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;that can accept either an 8-bit ISA card or a 16-bit ISA printed circuit card. The 32-bit printed cir-&lt;br /&gt;cuit cards are more often PCl or, in some older 80486-based machines, the VESA cards. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8-Bit ISA Bus Output Interface &lt;br /&gt;Figure 14-1 illustrates the 8-bit ISA connector found on the main board of all personal computer &lt;br /&gt;systems (again, this may be combined with a 16-bit connector). The ISA bus connector contains &lt;br /&gt;the entire de-multiplexed address bus (A19-AO) for the 1M byte 8088 system, the 8-bit data bus &lt;br /&gt;(D7-DO), and the four control signals MEMR, MEMW, lOR, and lOW for controlling I/O and &lt;br /&gt;any memory that might be placed on the printed circuit card. Memory is seldom added to any &lt;br /&gt;ISA bus card today because the ISA card only operates at an 8 MHz rate. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Other signals that might be useful for I/O interface are the interrupt request line &lt;br /&gt;IRQ2-IRQ7. Note that IRQ2 is redirected to IRQ9 on modern systems, and is so labeled on the &lt;br /&gt;connected in Figure 14-1. The DMA channels 0-3 control signals are also present on the con-&lt;br /&gt;nector. The DMA request inputs are labeled DRQI-DRQ3, and the DMA acknowledge outputs &lt;br /&gt;are labeled DACKO-DACK3. Notice that the DRQO input pin is missing because the early per-&lt;br /&gt;sonal computers used the DACKO output as a refresh signal to refresh any DRAM that might be &lt;br /&gt;located on the ISA card. Today this output pin contains a 15.2 !J,s clock signal. The remaining &lt;br /&gt;pins are for power and RESET. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a series of four 8-bit latches must be interfaced to the personal computer for &lt;br /&gt;32-bits of parallel data. This is accomplished by purchasing an ISA interface card (part number &lt;br /&gt;4713-1) from a company such as Vector Electronics or other companies. In addition to the edge &lt;br /&gt;connector for the ISA bus, the card also contains room at the back for interface connectors. A 37-&lt;br /&gt;pin sub-miniature D-type connector can be placed on the back of the card to transfer the 32-bits &lt;br /&gt;of data to the external source. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-1 The 8-bit ISA &lt;br /&gt;bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;? &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;$ &lt;br /&gt;a &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Back of Computer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin# &lt;br /&gt;1 GND IOCHK &lt;br /&gt;2 RESET D7 &lt;br /&gt;3 +5V D6 &lt;br /&gt;4 IRQ9 D5 &lt;br /&gt;5 -5V D4 &lt;br /&gt;6 DRQ2 D3 &lt;br /&gt;7 -12V D2 &lt;br /&gt;8 OWS D1 &lt;br /&gt;9 +12V DO &lt;br /&gt;10 GND 10 RDY &lt;br /&gt;11 MEMW AEN &lt;br /&gt;12 MEMR A19 &lt;br /&gt;13 lOW A18 &lt;br /&gt;14 lOR A17 &lt;br /&gt;15 DACK3 A16 &lt;br /&gt;16 DRQ3 A15 &lt;br /&gt;17 DACK1 A14 &lt;br /&gt;18 DRQ1 A13 &lt;br /&gt;19 DACKO A12 &lt;br /&gt;20 CLOCK A11 &lt;br /&gt;21 IRQ7 A10 &lt;br /&gt;22 IRQ6 A9 &lt;br /&gt;23 IRQ5 A8 &lt;br /&gt;24 IRQ4 A7 &lt;br /&gt;25 IRQ3 A6 &lt;br /&gt;26 DACK2 A5 &lt;br /&gt;27 TIC A4 &lt;br /&gt;28 ALE A3 &lt;br /&gt;29 +5V A2 &lt;br /&gt;30 OSC A1 &lt;br /&gt;31 GND AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C &lt;br /&gt;a &lt;br /&gt;m g &lt;br /&gt;n &lt;br /&gt;e &lt;br /&gt;n &lt;br /&gt;t &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;$ &lt;br /&gt;I &lt;br /&gt;d &lt;br /&gt;e &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;564 CHAPTER 14 BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 U2 &lt;br /&gt;00 21A1 1Y1 ~ &lt;br /&gt;01 4 lA2 1Y2~ &lt;br /&gt;02 6 1A3 lY3 ~14 &lt;br /&gt;g~ ~~~~1~1 ~~~ ~~~ 05 ~ 2A2 2Y2 t:Â±::: &lt;br /&gt;g~ 1 ~~~ m p::::;; &lt;br /&gt;~11G 1 2G &lt;br /&gt;-=- 7415244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 &lt;br /&gt;AD &lt;br /&gt;A1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOW 1 A YOel~5~~Â§=~~ B Yl C Y2 &lt;br /&gt;Y3 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3----!JlGl ~~  1E4 G2A Y6 9 G2B Y7 :::.t:: 7415138 &lt;br /&gt;U5 J AA=======~1~A~---Y~0~5 AS 2 B Yl f-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A8 3C Y2f-t 3 '--&lt;br /&gt;A9 ====~Gl ~~ ~ 43 ~~ 4 ~~~ ~~ .1::: ~ [] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L&lt;br /&gt;U&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;'/::-:4:-:l5:-&amp;quot;1,,&amp;quot;,38---l 51 1 ~ &lt;br /&gt;Al1 1 A YO 15 &lt;br /&gt;M2 8 ~ &lt;br /&gt;A13 C Y2~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Y3Pf,-Al0========~G1 ~~a= ~~~ --------&amp;quot;&amp;quot;1.~~~~~_:7&amp;quot;.,--:~~~ p.-L-&lt;br /&gt;7415138 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;1 OC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;7415374 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-2 A 32-bit parallel port interfaced to the 8-bit ISA bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,.---1.~ &lt;br /&gt;CONNECTOR 0837 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 14-2 shows a simple interface for the ISA bus that provides 32-bits of parallel TTL &lt;br /&gt;data. This example system illustrates some important points about any system interface. First, it is &lt;br /&gt;extremely important that the loading to the ISA bus is kept to one low power (LS) load. Notice that &lt;br /&gt;in this circuit a 74LS244 buffer is used to reduce the loading on the data bus. If the 74LS244 were &lt;br /&gt;not present, this system would present the data bus with four unit loads. If all bus cards provided &lt;br /&gt;heavy loads, the system would not operate properly. Notice that the output pins connect to PI, the &lt;br /&gt;37-pin connector, and that a ground wire is also attached. You must provide ground to the outside &lt;br /&gt;world or the TTL data on the parallel ports are useless. If needed, the output control pins (OC) on &lt;br /&gt;each of the 74LS374 latch chips can also be removed from ground and connected to the four re-&lt;br /&gt;maining pins on PI. This allows an external circuit to control the outputs from the latches. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A small DIP switch is placed on two of the outputs of U7 so the address can be changed if &lt;br /&gt;a conflict with another card occurs. This is unlikely unless you plan to use two of these cards in &lt;br /&gt;the same system. Address connection A2 is not decoded in this system, so it becomes a don't &lt;br /&gt;care. Refer to Table 14-1 for the addresses of each latch and each position of the S1. Note that &lt;br /&gt;only one of the two switches may be on at a time and that each port has two possible addresses &lt;br /&gt;for each switch setting because A2 is not connected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;It is very important that the I/O addresses are above I/O port 0500H. The POlts are decoded &lt;br /&gt;in this example by three 74LS 138 decoders. It would be more efficient and cost effective to de-&lt;br /&gt;code the ports with a programmable logic device. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14-1 THE ISA BUS 565 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 14-1 The 1/0 port assignments for Figure 14-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIP Switch &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-4 On &lt;br /&gt;2-3 On &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Latch U2 Latch U4 Latch U6 Latch UB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0608H or 060CH &lt;br /&gt;OE08H or OEOCH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0609H or 060DH &lt;br /&gt;OE09H or OEODH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;060AH or 060EH &lt;br /&gt;OEOAH or OEOEH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;060BH or 060FH &lt;br /&gt;OEOBH or OEOFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 14-3 shows the circuit in Figure 14-2 reworked using a PALl6L8 to decode the ad-&lt;br /&gt;dresses for the system. Notice that address bits A15-A4 are decoded by the PAL and the switch &lt;br /&gt;is connected to two of the PAL inputs. This change allows four different I/O port addresses for &lt;br /&gt;each latch, maJcing the circuit more flexible. Table 14-2 shows the port number selected by &lt;br /&gt;switch 1-4 and switch 2-3. Example 14-1 shows the program for the PALl6L8 that causes the &lt;br /&gt;port assignments of Table 14-2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 14-1 &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/20/96 &lt;br /&gt;CHIP ISA1 PAL16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 8 9 10 &lt;br /&gt;A4 A5 A6 A7 A8 A9 A10 All A12 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 18 19 20 &lt;br /&gt;A13 NC A14 A15 Sl S2 NC NC DC VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/DC /A15*/A14*/A13*/A12*/A11*A10*A9*/A8*/A7*/Sl*/S2*/A6*/A5*/A4 &lt;br /&gt;+ /A15*/A14*/A13*/A12*/A11*A10*A9*/A8*/A7*/Sl*S2*/A6*A5*/A4 &lt;br /&gt;+ /A15*/A14*/A13*/A12*/A11*A10*A9*/A8*/A7*Sl*/S2*A6*/A5*/A4 &lt;br /&gt;+ /A15*/A14*/A13*/A12*/A11*A10*A9*/A8*/A7*Sl*S2*A6*A5*/A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice in Example 14-1 how the first product term generates a logic 0 on the output to the &lt;br /&gt;decoder only when both switches are in their off positions for I/O ports 0600H-060FH. The &lt;br /&gt;74LS138 further refines the port to 604H, 605H, 606H, or 607H for the latches. The second &lt;br /&gt;product term is active when switch 1-4 is off and ~witch 2-3 is on. The other two combinations &lt;br /&gt;on the switch select the last two port address assignments in Table 14-2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 14-2 shows a small program that ~ends data to the ports in a pattern that could be &lt;br /&gt;used for testing. The pattern selected places a logic 1 on bit zero of U2 and all zeros on the re-&lt;br /&gt;maining latches. This pattern is then rotated through all 32-bits until one minute has elapsed. The &lt;br /&gt;timing is handled by the counter located at the 32-bit memory location starting at OOOO:046C, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 14-2 Port assignment in Figure 14-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Switch 1-4 Switch 2-3 Latch U2 Latch U4 Latch U6 Latch UB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Off Off 0604H 0605H 0606H 0607H &lt;br /&gt;Off On 0624H 0625H 0626H 0627H &lt;br /&gt;On Off 0644H 0645H 0646H 0647H &lt;br /&gt;On On 0664H 0665H 0666H 0667H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: On = a closed switch and Off = an open switch. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;566 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IiiW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2 &lt;br /&gt;A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;AS &lt;br /&gt;A7 &lt;br /&gt;AB &lt;br /&gt;A9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al0 &lt;br /&gt;A11 &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 14 BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul &lt;br /&gt;2 lAl lYl ~ 41A2 lY2 S lAS lYS 11 ~~~ lY4 2Yl 2A2 2Y2 ~7 2AS 2YS 2A4 2Y4 &lt;br /&gt;~lG 2G&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;US &lt;br /&gt;1 A YOl.~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B Yl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;e Y2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;YS &lt;br /&gt;6 Y4~ Gl 5 vee G2A YS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,G2B Y7 &lt;br /&gt;74LS1SB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01J &lt;br /&gt;U5 10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111 &lt;br /&gt;2 12 02~ 4 IS &lt;br /&gt;5 14 g~ 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOfTI IS os 17 07 9 IB OB &lt;br /&gt;1 :~O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16LB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;~ &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IJt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ DO 00 2 01 01 02 02 OS as 12 04 04 15 05 05 1 os g~ 1 4~ 07 1 oe lB 1 LK S6 &lt;br /&gt;urLSS74 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ DO 00 2 lS 01 01 6 I L 4 R 02 02 OS as 1 II 14 ~ D4 04 05 05 I 06 as fill 07 07 &lt;br /&gt;1 &lt;br /&gt;1 oe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-* &lt;br /&gt;-0 LK 29 &lt;br /&gt;74L~S74 ~ -0 us 2 ~OO 00 7 0 ~01 01 02 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS as &lt;br /&gt;D4 04 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t---H 05 05 ~g~ g~ 5 &lt;br /&gt;1~ oe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LK 22 &lt;br /&gt;UB 74LSS74 S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ DO 00 2 2 20 01 01 6 ,....--1-0 02 02 OS as 1 eONN~o 04 04 1 05 O~ 1 06 as 19 07 07 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-=$=&amp;quot; 1 oe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROB37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eLK &lt;br /&gt;74LSS74 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-3 A 32-bit parallel port interfaced to the 8-bit ISA bus using a PAL 16L8* for a decoder &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;which increments 18.2 times per second. This test program assumes that the latches are at 110 &lt;br /&gt;ports 0604H-0607H as selected by the switches. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 14-2 &lt;br /&gt;;A program that sends a test pattern to the 1/0 ports of &lt;br /&gt;;Figure 14-3 . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL TINY &lt;br /&gt;0000 .CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0100 B8 0000 MOV AX,O &lt;br /&gt;0103 8E D8 MOV DS,AX ;address segment OOOOH &lt;br /&gt;0105 BB 0001 MOV BX,l ;setup starting bit pattern &lt;br /&gt;0108 BA 0000 MOV DX,O ;in registers DX-BX &lt;br /&gt;010B B9 0444 MOV CX,1092 ;set count for 1 minute &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;010E BA 0604 MOV DX,0604H ; address latch U2 &lt;br /&gt;0111 8A C3 MOV AL,BL ;send BL to U2 &lt;br /&gt;0113 EE OUT DX, rL &lt;br /&gt;0114 42 INC DX ; address latch U4 &lt;br /&gt;0115 8A C7 MOV AL,BH ;send BH to U4 &lt;br /&gt;0117 EE OUT DX,AL &lt;br /&gt;0118 42 INC DX ; address latch U6 &lt;br /&gt;0119 8A C2 MOV AL,DL ;send DL to U6 &lt;br /&gt;011B EE OUT DX,AL &lt;br /&gt;011C 42 INC DX ;address latch U8 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14-1 THE ISA BUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OllD 8A C6 &lt;br /&gt;OllF D1 E2 &lt;br /&gt;0121 D1 D3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0125 B3 C2 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0128 BB 046C &lt;br /&gt;012B BD 046E &lt;br /&gt;012E 40 &lt;br /&gt;012F 83 D5 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,DH ;send DH to UB &lt;br /&gt;SHL DX,l ;rotate number in DX-BX &lt;br /&gt;RCL BX,l &lt;br /&gt;.IF CARRY? &lt;br /&gt;ADD DX,l &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AY.., [46CH] &lt;br /&gt;MOV BP, [46EH] &lt;br /&gt;INC AX &lt;br /&gt;ADC BP,O &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get counter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. UNTIL .~==[46CH] &amp;amp;&amp;amp; BP==[46EH] &lt;br /&gt;.UNTILCXZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 8-Bit ISA Bus Input Interface &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;567 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To illustrate the input interface to the ISA bus, a pair of ADC804 analog-to-digital converters &lt;br /&gt;are interfaced to the ISA bus in Figure 14-4. The connections to the converters are made &lt;br /&gt;through a 9-pin DB9 connector. The task of decoding the I/O port addresses is more complex &lt;br /&gt;because each converter needs a write pulse to start a conversion, a read pulse to read the digital &lt;br /&gt;data once it has been converted from the analog input data, and a pulse to enable the selection &lt;br /&gt;of the INTR output. Notice th!lt the INTR output is connected to data bus bit position DO. &lt;br /&gt;When INTR is input to the microprocessor. the rightmost bit of AL is tested to see if the con-&lt;br /&gt;verter is busy. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As before, great care is taken so the connections to the ISA bus present one unit load. &lt;br /&gt;Table 14-3 illustrates the I/O port assignment decoded by the PAL16L8 in Example 14-3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 14-3 &lt;br /&gt;AUTHOR Barry B. Brey &lt;br /&gt;COMPANY BreyCo &lt;br /&gt;DATE 7/21/96 &lt;br /&gt;CHIP ISA2 PAL16LB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 1 2 3 4 5 6 7 B 9 10 &lt;br /&gt;A3 A4 A5 A6 A7 AB A9 A10 All GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;pins 11 12 13 14 15 16 17 1B 19 20 &lt;br /&gt;A12 NC A13 A14 A15 lOR G NC DC VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/DC /A15*/A14*/A13*A12*/A11*/AIO*A9*/AB*/A7*/A6*/A5*/A4*/A3 &lt;br /&gt;/G = /A15*/A14*/A13*A12*/Al1*/AlO*A9*/A8*/A7*/A6*/A5*/A4*/A3*/IOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 14-4 lists a macro that can be used to read either ADC U3 or US. The address is &lt;br /&gt;generated by passing either a 0 for U3 or a 1 for US to the macro as a parameter. The macro starts &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 14-3 1/0 port &lt;br /&gt;assignments for Figure 14-4 Device &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Start ADC (U3) &lt;br /&gt;Read INTR (U3) &lt;br /&gt;Read ADC (U3) &lt;br /&gt;Start ADC (U5) &lt;br /&gt;Read INTR (U5) &lt;br /&gt;Read ADC (U5) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Port Number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1200H &lt;br /&gt;1200H &lt;br /&gt;1202H &lt;br /&gt;1201H &lt;br /&gt;1201H &lt;br /&gt;1203H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;568 CHAPTER 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;DO 16 1Y1 D1 1Y2 &lt;br /&gt;D2 1 1Y3 D3 9 1Y4 D4 7 2Y1 DS S2Y2 &lt;br /&gt;D6 2Y3 &lt;br /&gt;D7 2Y4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;gt;IK 74LS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1A1 &lt;br /&gt;1A2 &lt;br /&gt;1A3 &lt;br /&gt;1A4 &lt;br /&gt;2Al &lt;br /&gt;2A2 &lt;br /&gt;2A3 &lt;br /&gt;2A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1G &lt;br /&gt;2G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1A &lt;br /&gt;741S125 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;DO 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P B ~ &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;U3 Â§jBDBO DB1 &lt;br /&gt;DB2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~4DB3 DB4 DBS &lt;br /&gt;~g~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VI+ 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 ~Pl CLK &lt;br /&gt;.---+---I---+.1.{(C;SS -':- ~..() r+--I--r--3--;n~ ~ VREF -L- Ta01 ~ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U4 I S~IN~T~R~~A~G~N~D~B----,-~---t~==t3~C _~:==:f:=lFfr---:~~==:ii!iÂ±=::::;-fJ ADCOB04 -==- :=::Z-o ~~ 1 ~ YO 15 -= ~2~ &lt;br /&gt;IOW--+-,,-3 -t C ~~ ~ ~ &lt;br /&gt;~ G1 ~~P1H.16----f--' r!U~SiO----Vi:\\--Â§ __ +-______ ~ CONNECTOR DB9 A2----~4&amp;lt;1G2A YS 9 &amp;quot; 18 DBO VI+ 6 rs G2B ~~ R DBI 74LS13B ~ DB2 VI 7 ~g~! ~ &amp;quot; 13 DBS CLK 19 U6 ~ DB6 11&amp;lt; 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 :==:::::1~11 01 19  DB7 &lt;br /&gt;A4 312 02~ CLK 4 &lt;br /&gt;AS 4 13 03 ~1~7==~--' 1 CS I a :::!::-A6 4 14 04 16 2 RD VRE&amp;lt;f-&amp;quot;-- TÂ·001 &lt;br /&gt;A7 5 15 05 ~~ 3 WR -' B ~f1 J it g! ~ 16 i1s ~1.!~!:!:N~~~~OB-04~A~G~N~-&amp;quot;----4&amp;gt;---' &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;lOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16LB ~ Â¥ 74LS125 &lt;br /&gt;FIGURE 14-4 A pair of analog-to-digital converters interfaced to the ISA bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the converter by writing to it and then waits until the INTR pin returns to a logic 0, indicating &lt;br /&gt;that the conversion is complete before the data are read and returned in the AL register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 14-4 &lt;br /&gt;,A macro that operates either converter 0 or converter 1 and &lt;br /&gt;;returns the digital data in AL. Note that converter 0 is U3 &lt;br /&gt;,and converter 1 is us. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC MACRO &lt;br /&gt;MOV &lt;br /&gt;ADD &lt;br /&gt;OUT &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN &lt;br /&gt;TEST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. UNTIL &lt;br /&gt;ADD &lt;br /&gt;IN &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WHICH &lt;br /&gt;DX,1200H &lt;br /&gt;DX,WHICH &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,DX &lt;br /&gt;AL,l &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ZERO? &lt;br /&gt;DX,2 &lt;br /&gt;AL,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,address converter &lt;br /&gt;;start converter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,get busy signal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,address dq~a port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 16-Bit ISA Bus &lt;br /&gt;The only difference between the 8- and 16-bit ISA bus is that an additional connector is attached &lt;br /&gt;to the front of the 8-bit connector. A 16-bit JSA card contains two edge connectors. One plugs &lt;br /&gt;into the 8-bit connector, and the other into the 16-bit connector. Figure 14-5 shows the pin-out &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;024--03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D16-D2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;08-0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OG-O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO &lt;br /&gt;Al &lt;br /&gt;A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 &lt;br /&gt;irn'i &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;AS &lt;br /&gt;A9 &lt;br /&gt;Al0 &lt;br /&gt;All &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14-2 THE EXTENDED ISA (EISA) AND VESA LOCAL BUSES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 Signal ~OA 11 CCLK H}-- Conditioning 08 CCLKEN tc+- OC CCLR (rt needed) ~OO RCLK 13 OE &lt;br /&gt;t4 OF G 14 Ul &amp;quot;--l- OG &lt;br /&gt;~ OH A YO 2 8 Yl 14 r RCO C Y2 ~ I 74L Y3 Y4 6 Gl Y5 ~ CCLK 11 I 4 G2A Y6 ~~: r G28 Y7 74LS138 08 CC!;~~~~ OC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0---4- 00 RCLK 13 U2 ag~ 1 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;'r G 14 2 OG 3 12 02 OH 13 g~ 1 4 14 r RCa 6 15 05 16 06SFl 74 17 07 &lt;br /&gt;18 08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CCLK 11 I 19 ~~: 110 16L8 08 CC!;~~~  OC &lt;br /&gt;00 13 OE RCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tt g~ G 14 I RCa &lt;br /&gt;74LS590 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-~ U6 CCLK I OA ~ 08 CC!;~~~  OC ~ 00 ,. OE RCLK ~ OF 14 &amp;amp; OG G OH &lt;br /&gt;~ RCa &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LS590 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-7 A 32-bit events and general purpose counter interfaced to the EISA bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 14-5 &lt;br /&gt;. MODEL TINY &lt;br /&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; Procedure that starts the events counter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 START PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 BA 1308 MOV DX,1308H ;address the clear &lt;br /&gt;0103 EC IN AL,DX ;clear the counter &lt;br /&gt;0104 C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0105 START ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Procedure that reads the count and returns it &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0105 READC PROC NE.&amp;quot;'.R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0105 BA 1309 MOV DX,1309H ;address the latch &lt;br /&gt;0108 EC IN A.L,DX ;latch the count &lt;br /&gt;0109 BA 130C MOV DX,130CH ;address the count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;571 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I--&lt;br /&gt;Event I nput &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;in EAX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;port &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;572 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 14-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 4191999A &lt;br /&gt;0004 00000000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 14 BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OIOC 661 ED &lt;br /&gt;OIOE C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OIOF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;III &lt;br /&gt;EET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EEADC EIJDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAY.,DX ;read the count to EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The only part of this interface and software that appears strange is that an IN instruction is &lt;br /&gt;used to clear the counter and also to latch the count. The reason is that no data are transferred be-&lt;br /&gt;tween the microprocessor and the counter for these events, and it made the circuitry a little less &lt;br /&gt;complicated. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Frequency Counter. Another application for this same circuit is a frequency counter. The only &lt;br /&gt;difference between counting events and counting a frequency is how the circuit is operated. For &lt;br /&gt;example, suppose the counter is cleared and then read exactly 1 second later. The counter will &lt;br /&gt;contain a number that represents the frequency at the events input. If the frequency is needed in &lt;br /&gt;kilo-Hertz instead of Hertz, the counter is reset and then read exactly 1 ms later. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are some limitations both to the frequency that can be measured by this circuitry and &lt;br /&gt;to the accuracy of the measurement. The highest frequency is due to the speed of the counter and &lt;br /&gt;the conditioning circuitry if needed. The 74LS590 can count to at least 32 MHz. If the input is &lt;br /&gt;purely TTL (no conditioning), then this circuit can measure frequency up to 32 MHz. The con-&lt;br /&gt;ditioning circuit chosen may also limit the upper frequency limit. The accuracy is determined by &lt;br /&gt;the time between the reset and the latching of the count. If the clock in the computer system is &lt;br /&gt;very accurate, the frequency read by this system is very accurate. It is assumed that the clock in &lt;br /&gt;the personal computer is about 0.1 percent accurate, which would be the accuracy of any fre-&lt;br /&gt;quency measure by this system. This is good enough for many applications that require fre-&lt;br /&gt;quency measurements. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 14-6 shows how the system can measure a frequency if you are willing to wait &lt;br /&gt;for 1 second. Notice how the SYNC macro is used to synchronize to the clock tick and also how &lt;br /&gt;the result is scaled by mUltiplying the count by 18.2. To obtain more accurate reading, the &lt;br /&gt;scaling factor could be changed by measuring the frequency with a laboratory frequency counter &lt;br /&gt;and then modifying the contents of NUM. The sample time (point where the clear and latch op-&lt;br /&gt;eration occur) can be reduced to make more samples per second. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;NUM DD 18.2 &lt;br /&gt;TEMP DD ? &lt;br /&gt;.CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A simple frequency counter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;This procedure returns the frequency in EAX. &lt;br /&gt;;The accuracy should be fairly good. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SYNC MACRO ;;sync to clock tick &lt;br /&gt;MOV AH,O &lt;br /&gt;INT 16H ;get clock tick information into CX:DX &lt;br /&gt;MOV BX,CX &lt;br /&gt;MOV BP,DX &lt;br /&gt;. REPEAT ;sync to clock tick &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,O &lt;br /&gt;INT 16H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL CX!=BX II DX!=BP &lt;br /&gt;ENDM &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;0010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0024 &lt;br /&gt;0027 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003C &lt;br /&gt;003F &lt;br /&gt;0040 &lt;br /&gt;0043 &lt;br /&gt;0045 &lt;br /&gt;0049 &lt;br /&gt;004D &lt;br /&gt;0051 &lt;br /&gt;0055 &lt;br /&gt;0059 &lt;br /&gt;005A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14-3 THE PERIPHERAL COMPONENT INTERCONNECT (PCI) BUS 573 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FREQ PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SYNC ;sync to clock tick &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA 1308 ['-lOV ))X,1308H ;address clear counter port &lt;br /&gt;EC IN AL,DX ;clear counter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SYNC iwait for next tick &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA 130~ i&amp;quot;'10Â·v DX,1309H ;address latch port &lt;br /&gt;EC IN AL,DX ;latch count &lt;br /&gt;BA 130C MOV DX,130CH ;address counter &lt;br /&gt;661 ED IN EAX,DX ;get count &lt;br /&gt;661 A3 0004 R MOV TEMP,EAX &lt;br /&gt;DB 06 0004 R FILD TEMP iconvert to Hertz &lt;br /&gt;D8 DE 0000 R FMUL NUM &lt;br /&gt;DB 1E 0004 R FISTP TEMP ;save as integer &lt;br /&gt;661 &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A1 0004 R MOV EAX, TEMP &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FREQ ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The VESA Local Bus &lt;br /&gt;A much better approach to 32-bit interfacing is the VESA 1 local bus. The EISA bus only oper-&lt;br /&gt;ates at 8 MHz, while the VESA local bus operates at 33 MHz. This means that applications re-&lt;br /&gt;quiring high-speed data transfers benefit from the VESA local bus. This section of the chapter &lt;br /&gt;details the VESA local bus that is common for video and disk interfaces to the personal computer &lt;br /&gt;in 80486-based systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VESA Local Bus Pin-Out &lt;br /&gt;Figure 14-8 illustrates the VESA local bus (or the VL bus, as it is often called). Like the EISA &lt;br /&gt;bus, the VESA local bus is also an extension of the ISA bus. The difference is that the VESA &lt;br /&gt;local bus does not add anything to the 16-bit ISA connectors; instead, a third connector (the &lt;br /&gt;VESA connector) is added behind the 16-bit ISA connector. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The connections on this bus are very similar to the EISA bus card. The VESA local bus &lt;br /&gt;also contains a 32-bit address and data bus for interfacing memory or I/O to the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE PERIPHERAL COMPONENT INTERCONNECT (PCI) BUS &lt;br /&gt;The last bus described is the PCI (peripheral component interconnect) bus, which is virtually &lt;br /&gt;the only bus found in the newest Pentium Pro systems and just about all of the Pentium systems. &lt;br /&gt;The ISA bus still exists in all of these new systems, but only as an interface for older 8-bit and &lt;br /&gt;16-bit interface cards. In time, the ISA bus may disappear, but it is still a very important interface &lt;br /&gt;for many applications. The PCI bus has replaced the VESA local bus because of its plug-and-&lt;br /&gt;play characteristics and its ability to function with a 64-bit data bus. A PCI interface contains a &lt;br /&gt;series of registers, located in a small memory device on the PCI interface, that contain informa-&lt;br /&gt;tion about the board. The information in these registers allows the computer to automatically &lt;br /&gt;configure the PCI card. This feature, called plug-and-play, is probably the main reason that the &lt;br /&gt;PCI bus has become so popular in the newest systems. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 14-9 shows the system structure for the PCI bus in a personal computer system. No-&lt;br /&gt;tice that the microprocessor bus is separate and independent of the PCI bus. The microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I VESA is the Video Electronics Standards Association. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;574 CHAPTER 14 BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;o &lt;br /&gt;I &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;i &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin # &lt;br /&gt;, DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ 06 &lt;br /&gt;, 08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 GNO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 0'0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 012 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ +5V &lt;br /&gt;'0 014 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;0'6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'2 0'8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'3 020 &lt;br /&gt;,. GND &lt;br /&gt;,5 022 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'6 024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;n 026 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'8 028 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19 D30 &lt;br /&gt;20 .5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21 A31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;23 A29 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24 A27 &lt;br /&gt;25 A25 &lt;br /&gt;26 A23 &lt;br /&gt;27 A21 &lt;br /&gt;28 A19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30 A17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32 +5V &lt;br /&gt;33 A,3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34 A&amp;quot; &lt;br /&gt;35 A' &lt;br /&gt;3. A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37 A' &lt;br /&gt;38 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.0 A2 &lt;br /&gt;41 no &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;42 RESET &lt;br /&gt;43 Die &lt;br /&gt;44 MilO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;45 W/A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢â¢ &lt;br /&gt;â¢ 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'8 ADYRTN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;49 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50 IA09 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;51 BRDV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52 BLAST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;53 100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;54 101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;55 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;56 LClK &lt;br /&gt;57 .5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;58 LBS16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0' &lt;br /&gt;03 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GNO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0' &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0&amp;quot; &lt;br /&gt;013 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0'5 &lt;br /&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;019 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;021 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;023 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;025 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;027 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;031 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2' &lt;br /&gt;A22 &lt;br /&gt;.5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2D &lt;br /&gt;A18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AID &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WBACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LADY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LDEV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LREQ &lt;br /&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L.GNT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;102 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;103 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LKEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C &lt;br /&gt;o &lt;br /&gt;m &lt;br /&gt;p &lt;br /&gt;o &lt;br /&gt;n &lt;br /&gt;e &lt;br /&gt;n &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;i &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r---------------------------------,~ &lt;br /&gt;VESA Local Bus Card &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VESA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;c &lt;br /&gt;k &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;? &lt;br /&gt;C &lt;br /&gt;o &lt;br /&gt;m &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E &lt;br /&gt;t &lt;br /&gt;e &lt;br /&gt;r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-8 The VESA local bus connector and card &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;connects to the PCI bus through an integrated circuit called a PC! bridge. This means that virtu-&lt;br /&gt;ally any microprocessor can be interfaced to the PCI bus as long as a PCI controller or bridge is &lt;br /&gt;designed for the system. In the future, all computer systems may use the same bus. Even the &lt;br /&gt;Apple Macintosh system is switching to the PCI bus. Certainly, IBM will produce a Power-PC &lt;br /&gt;system that contains the PCI bus. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14-3 THE PERIPHERAL COMPONENT INTERCONNECT (PCI) BUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II &lt;br /&gt;Cache &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:t::t &lt;br /&gt;Resident Local Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCI Bus &lt;br /&gt;Controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dynamic RAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System BIOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCI Bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;575 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\fideo Disk Controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-9 The system block diagram for the personal computer that contains a PCI bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PCI Bus Pin-Out &lt;br /&gt;As with the other buses described in this chapter, the PCI bus contains all of the system control &lt;br /&gt;signals. Unlike the other buses, the PCI bus functions with either a 32-bit or a 64-bit data bus and &lt;br /&gt;a full 32-bit address bus. Unlike the other systems, there is no connector on a PCI board to the &lt;br /&gt;older ISA bus. Another difference is that the address and data buses are multiplexed to reduce &lt;br /&gt;the size of the edge connector. These multiplexed pins are labeled ADO-AD63 on the connector. &lt;br /&gt;Also note that the 32-bit card only has connections 1 through 62, while the 64-bit card has all 94 &lt;br /&gt;connections. The 64-bit card can accommodate a 64-bit address if it is required at some point in &lt;br /&gt;the future. Figure 14-10 illustrates the PCI bus pin-out. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with the other bus systems, the PCI bus is most often used for interfacing I/O compo-&lt;br /&gt;nents to the microprocessor. Memory could be interfaced, but it would only operate at a 33 MHz &lt;br /&gt;rate with the Pentium, which is half the speed of the 66 MHz resident local bus of the Pentium or &lt;br /&gt;Pentium Pro system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PCI Address/Data Connections &lt;br /&gt;The PCI address appears on ADO-AD31, and it is multiplexed with data. In some systems there &lt;br /&gt;is a 64-bit data bus that uses AD32-AD63 for data transfer only, but in the future this will also &lt;br /&gt;be used for extending the address to 64-bits. Figure 1.+-11 illustrates the timing diagram for the &lt;br /&gt;PCI bus, which shows the way that the address is multiplexed with data and also the control sig-&lt;br /&gt;nals used for multiplexing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;During the first clocking period, the address of the memory or I/O location appears on the &lt;br /&gt;AD connections, and the command to a PCI peripheral appears on the C/BE pins. Table 14-4 il-&lt;br /&gt;lustrates the bus commands found on the PCI bus. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;576 CHAPTER 14 BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-10 The pin-out &lt;br /&gt;of the PCI bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Back of computer &lt;br /&gt;Pin # &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lRST &lt;br /&gt;Pin # &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s &lt;br /&gt;o &lt;br /&gt;I &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;i &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'A &lt;br /&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;'3 &lt;br /&gt;14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;29 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;39 &lt;br /&gt;,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-12V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TDO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PASNT 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PASNT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REO -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+VIO _ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADa' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD29 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+3.3V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C/BE3 &lt;br /&gt;AD23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+33V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClBE2 &lt;br /&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+33V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEVSEL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+12V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;,5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TDl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;_VIIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1iS'f &lt;br /&gt;VIIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VNT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADa. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+3.3V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IOSEl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+3.3V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A01S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A016 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+33V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRAME &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TADY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+33V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SOONE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C &lt;br /&gt;o &lt;br /&gt;m &lt;br /&gt;p &lt;br /&gt;o &lt;br /&gt;n &lt;br /&gt;e &lt;br /&gt;n &lt;br /&gt;t &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;i &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s &lt;br /&gt;o &lt;br /&gt;I &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;i &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: (1) pins 63-94 exist only on the 54-bit PCI card &lt;br /&gt;(2) + VIIO is 3.3V on a 3.3V board and +5V on &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a 5V board &lt;br /&gt;(3) blank pins are reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41 +33V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;42 SERR &lt;br /&gt;43 +33V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;44 ClBE, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;45 Am4 &lt;br /&gt;46 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;47 AD12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48 AD10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;49 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;51 KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52 AD8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;53 AD7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;54 +33V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;65 ADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;56 AD3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;57 eND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;58 AD' &lt;br /&gt;59 +VIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;60 ACK64F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6' +5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62 +5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;65 ClBE6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;66 ClBE4 &lt;br /&gt;67 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;68 AD63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;69 ADS1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. +VIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;71 AD59 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;72 AD57 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;73 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74 AD55 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;75 ADS3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;76 GND &lt;br /&gt;77 ADS1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;78 AD49 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;79 +VIO &lt;br /&gt;BO AD47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8' AD45 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B2 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;83 AD43 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8, A041 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;85 GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;86 AD39 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;87 AD37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8B +VI/o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B9 AD35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;90 AD33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;92 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;93 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9' GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+3.3V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOl1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A09 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClBE. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+3.3V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;iQ)6 &lt;br /&gt;AD4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Aq&amp;lt;! &lt;br /&gt;ADO' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+VIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REQ64 &lt;br /&gt;+5V &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.sV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClBE7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClBE5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+VIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PAR64 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A062 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD60 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD58 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A056 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A054 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+VIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A052 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD50 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD46 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD44 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD'2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.VIIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD36 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C &lt;br /&gt;o &lt;br /&gt;m &lt;br /&gt;p &lt;br /&gt;o &lt;br /&gt;n &lt;br /&gt;e &lt;br /&gt;n &lt;br /&gt;t &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;i &lt;br /&gt;d &lt;br /&gt;e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCI Bus Commands &lt;br /&gt;INTA Seql&amp;amp;ence &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Special Cycle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;During the interrupt acknowledge sequence, an interrupt controller &lt;br /&gt;(the one that caused the interrupt) is addressed and interrogated for &lt;br /&gt;the interrupt vector. The byte-sized interrupt vector is returned &lt;br /&gt;during a byte read operation. &lt;br /&gt;The special cycle is used to transfer data to all PCI components. &lt;br /&gt;During this cycle, the rightmost I q~bits of the data bus contain a &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14-3 THE PERIPHERAL COMPONENT INTERCONNECT (PCI) BUS 577 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TO T1 T2 T3 T4 T5 T6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCICLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRAME \\ I! &lt;br /&gt;AD bus ( A~dreSS X !Data1 X !Data2 X Data3 X Data4 ) &lt;br /&gt;C/BE ( C9mmand X: BE's X: BE's X BE's X BE's ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ ! &lt;br /&gt;FIGURE 14-11 The basic burst mode timing for the PCI bus system. Note that this transfers &lt;br /&gt;either four 32-bit numbers (32-bit PC I) or four 64-bit numbers (64-bit PCI). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 Read Cycle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 Write Cycle &lt;br /&gt;Memory Read Cycle &lt;br /&gt;Memory Write Cycle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Configuration Read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 14-4 PCI bus &lt;br /&gt;commands &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOH indicating a processor shutdown, a OOOlH for a processor &lt;br /&gt;halt, or a 0002H for 80X86 specific code or data. &lt;br /&gt;Data are read from an 1/0 device using the VO address that appears &lt;br /&gt;on ADO-AD 15. Burst reads are not supported for VO devices. &lt;br /&gt;As with VO read, this cycle accesses an VO device, but writes data. &lt;br /&gt;Data are read from a memory device located on the PCI bus. &lt;br /&gt;As with memory read, data are accessed in a device located on the &lt;br /&gt;PCI bus. The location is written. &lt;br /&gt;Configuration information is read from the PCI device using the &lt;br /&gt;configuration read cycle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GIBE3-GIBEO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0001 &lt;br /&gt;0010 &lt;br /&gt;0011 &lt;br /&gt;0100-0101 &lt;br /&gt;0110 &lt;br /&gt;0111 &lt;br /&gt;1000-1001 &lt;br /&gt;1010 &lt;br /&gt;1011 &lt;br /&gt;1100 &lt;br /&gt;1101 &lt;br /&gt;1110 &lt;br /&gt;1111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Gommand &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA sequence &lt;br /&gt;Special cycle &lt;br /&gt;I/O read cycle &lt;br /&gt;I/O write cycle &lt;br /&gt;Reserved &lt;br /&gt;Memory read cycle &lt;br /&gt;Memory write cycle &lt;br /&gt;Reserved &lt;br /&gt;Configuration read &lt;br /&gt;Configuration write &lt;br /&gt;Memory multiple access &lt;br /&gt;Dual addressing cycle &lt;br /&gt;Line memory access &lt;br /&gt;Memory write with invalidation &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;578 CHAPTER 14 BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Configuration Write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Multiple &lt;br /&gt;Access &lt;br /&gt;Dual Addressing &lt;br /&gt;Cycle &lt;br /&gt;Line Memory Access &lt;br /&gt;Memory Write with &lt;br /&gt;Invalidation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Configuration Space &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The configuration write allows data to be written to the &lt;br /&gt;configuration area in a PCI device. Note that the address is &lt;br /&gt;specified by the configuration read. &lt;br /&gt;This is similar to the memory read access, except that it is usually &lt;br /&gt;used to access many data instead of one. &lt;br /&gt;Used for transferring address information to a 64-bit PCI device, &lt;br /&gt;which only contains a 32-bit data path. ~ I &lt;br /&gt;Used to read more than two 32-bit numbers from the PCI bus. &lt;br /&gt;This is the same as line memory access, but it is used with a write. &lt;br /&gt;This write bypasses the write-back function of the cache. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PCI interface contains a 256-byte configuration memory that allows the computer to inter-&lt;br /&gt;rogate the PCI interface. This feature allows the system to automatically configure itself for the &lt;br /&gt;PCI plug-board. Microsoft Corporation calls this plug-and-play. Figure 14-12 illustrates the &lt;br /&gt;configuration memory and its contents. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The first 64 bytes of the configuration memory contain the header that holds information &lt;br /&gt;about the PCI interface. The first 32-bit doubleword contains the unit ID code and also the &lt;br /&gt;vendor ID code. The unit ID code is a 16-bit number (D3,-D'6) that is an FFFFH if the unit is not &lt;br /&gt;installed and a number between OOOOH and FFFFH that identifies the unit if it is installed. The &lt;br /&gt;class codes identify the class of the PCI interface and are found in bits D3,-D'6 of configuration &lt;br /&gt;memory location OSH. Note that bits D'5-Do are defined by the manufacturer. The class codes &lt;br /&gt;are listed in Table 14-5 and are assigned by the PCI SIG, which is the governing body for the &lt;br /&gt;PCI bus interface standard. The vendor ID (D'5-Do) is also allocated by the PCI SIG. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The status word is loaded in bits D3,-D'6 of configuration memory location 04H, and the &lt;br /&gt;command is at bits D'5-Do of location 04H. Figure 14-13 illustrates the fonnat of both the status &lt;br /&gt;and command registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The base address space consists of a base address for the memory, a second for the 110 &lt;br /&gt;space, and a third for the expansion ROM. The first two doublewords of the base address space &lt;br /&gt;contain either the 32- or 64-bit base address for the memory present on the PCI interface. The &lt;br /&gt;next doubleword contains the base address of the 110 space. Note that, even though the Intel mi-&lt;br /&gt;croprocessors only use a 16-bit 110 address, there is room for expanding the 110 address to 32-&lt;br /&gt;bits. This also allows systems that use the 6S0XO family and PowerPC access to the PCI bus, &lt;br /&gt;because they do have 110 space that is accessed via a 32-bit address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-12 The con-&lt;br /&gt;tents of the configuration &lt;br /&gt;memory on a PCI expansion &lt;br /&gt;board &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Header (64 bytes) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Header &lt;br /&gt;Identification &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Status/Command &lt;br /&gt;Class/PowerDown &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH &lt;br /&gt;04H &lt;br /&gt;08H &lt;br /&gt;OCH &lt;br /&gt;10H 3FH 40H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Available (192 bytes) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ReseNed &lt;br /&gt;ReseNed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Extra ROM address &lt;br /&gt;ReseNed &lt;br /&gt;ReseNed &lt;br /&gt;Special &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24H &lt;br /&gt;28H &lt;br /&gt;2CH &lt;br /&gt;3CH &lt;br /&gt;34H &lt;br /&gt;38H &lt;br /&gt;3CH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14-3 THE PERIPHERAL COMPONENT INTERCONNECT (PCI) BUS 579 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 14-5 The class &lt;br /&gt;codes Class Code Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 14-13 The con-&lt;br /&gt;tents of the status and control &lt;br /&gt;words in the configuration &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOH &lt;br /&gt;0001H &lt;br /&gt;0100H &lt;br /&gt;0101H &lt;br /&gt;0102H &lt;br /&gt;0103H &lt;br /&gt;0180H &lt;br /&gt;0200H &lt;br /&gt;0201H &lt;br /&gt;0202H &lt;br /&gt;0280H &lt;br /&gt;0300H &lt;br /&gt;0301H &lt;br /&gt;0380H &lt;br /&gt;0400H &lt;br /&gt;0401H &lt;br /&gt;0480H &lt;br /&gt;0500H &lt;br /&gt;0501H &lt;br /&gt;0580H &lt;br /&gt;0600H &lt;br /&gt;0601H &lt;br /&gt;0602H &lt;br /&gt;0603H &lt;br /&gt;0604H &lt;br /&gt;0605H &lt;br /&gt;0680H &lt;br /&gt;0700H-FFFEH &lt;br /&gt;FFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Status Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Older non-VGA devices (not plug-and-play) &lt;br /&gt;Older VGA devices (not plug-and-play) &lt;br /&gt;SCSI controller &lt;br /&gt;IDE controller &lt;br /&gt;Floppy disk controller &lt;br /&gt;IPI controller &lt;br /&gt;Other hard/floppy controller &lt;br /&gt;Ethernet controller &lt;br /&gt;Token ring controller &lt;br /&gt;FOOl &lt;br /&gt;Other network controller &lt;br /&gt;VGA controller &lt;br /&gt;XGA controller &lt;br /&gt;Other video controller &lt;br /&gt;Video multimedia &lt;br /&gt;Audio multimedia &lt;br /&gt;Other multimedia controller &lt;br /&gt;RAM controller &lt;br /&gt;FLASH memory controller &lt;br /&gt;Other memory controller &lt;br /&gt;Host bridge &lt;br /&gt;ISA bridge &lt;br /&gt;EISA bridge &lt;br /&gt;MCA bridge &lt;br /&gt;PCI-PCI bridge &lt;br /&gt;PCMIA bridge &lt;br /&gt;Other bridge &lt;br /&gt;Reserved &lt;br /&gt;Unit not in any of the above classes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fast cycles (1 = supported) &lt;br /&gt;Data Parity (1 = error) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---_ Device liming (OO=fast, 10=slow, 01=medium, and 11=reserved) &lt;br /&gt;'------ Target Abort (1 = abort sent) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-------- Target Abort (1 = abort received) &lt;br /&gt;'--------- Master Abort (1 = abort) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---------- System Error (1 = error) &lt;br /&gt;'----------- Parity Error (1 = error) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Command Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1/0 address area (1 = active) &lt;br /&gt;Memory address area (1 = active) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'---- Bus master (1 = yes) &lt;br /&gt;'----- Special cycle (1 = include) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'------- Memory write with invalidation (1 = active) &lt;br /&gt;'-------- VGA palette snoop (0 = normal) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'--------- Panty error (1 = active) &lt;br /&gt;'---------- Walt cycle control (0 no) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'----------- SERR enable (1 = yes) &lt;br /&gt;'------------- Back to back cycles (1 = active) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;580 CHAPTER 14 BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIOS for PCI &lt;br /&gt;Most modem PentiumlPentium Pro-based personal computers contain the PCI bus and an exten-&lt;br /&gt;sion to the normal system BIOS that supports the PCI bus. These newer systems contain access &lt;br /&gt;to the PCI bus at interrupt vector lAH. Table 14-6 lists the functions currently available through &lt;br /&gt;the INT lAH instruction with AH = OBIH for the PCI bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 14-6 BIOS INT1 AH functions for the PCI bus (pp. 580-581) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01H BIOS Available? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =OB1H &lt;br /&gt;AL = 01H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = DOH if PCI BIOS extension is available &lt;br /&gt;BX = version number &lt;br /&gt;EOX = ASCII string 'PCI ' &lt;br /&gt;CARRY = 1 if no PCI extension present &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H PCI Unit Search &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OB1H &lt;br /&gt;AL=02H &lt;br /&gt;CX = Unit &lt;br /&gt;OX = Manufacturer &lt;br /&gt;SI=index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes) &lt;br /&gt;BX = bus and unit number &lt;br /&gt;Carry = 1 for error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The result codes are: &lt;br /&gt;DOH = successful search &lt;br /&gt;81 H = function not supported &lt;br /&gt;83H = invalid manufacturer 10 code &lt;br /&gt;86H = unit not found &lt;br /&gt;87H = invalid register number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03H PCI Class Code Search &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=OB1H &lt;br /&gt;AL=03H &lt;br /&gt;ECX = class code &lt;br /&gt;SI = index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes for function 02H) &lt;br /&gt;BX = bus and unit number &lt;br /&gt;Carry = 1 for an error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSH Start Special Cycle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=OB1H &lt;br /&gt;AL=06H &lt;br /&gt;BX = bus and unit numb&amp;quot;, .. &lt;br /&gt;EOX = data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes for function 02H) &lt;br /&gt;Carry = 1 for error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The value passed in EOX is sent to the PCI bus during the address &lt;br /&gt;phase. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;a8H Configuration Byte-Sized Read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OB1H &lt;br /&gt;AL= OSH &lt;br /&gt;BX = bus and unit number &lt;br /&gt;01 = register number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes for function 02H) &lt;br /&gt;CL = data from configuration register &lt;br /&gt;Carry = 1 for error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a9H Configuration Word-Sized Read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OB1H &lt;br /&gt;AL= OSH &lt;br /&gt;BX = bus and unit number &lt;br /&gt;01 = register number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes for function 02H) &lt;br /&gt;CX = data from configuration register &lt;br /&gt;Carry = 1 for error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;aAH Configuration Doubleword-Sized Read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OB1H &lt;br /&gt;AL = OSH &lt;br /&gt;BX = bus and unit number &lt;br /&gt;01 = register number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes for function 02H) &lt;br /&gt;ECX = data from configuration register &lt;br /&gt;Carry = 1 for error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;aSH Configuration Byte-Sized Write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OB1H &lt;br /&gt;AL= OSH &lt;br /&gt;BX = bus and unit number &lt;br /&gt;CL = data to be written to configuration register &lt;br /&gt;01 = register number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes for function 02H) &lt;br /&gt;Carry = 1 for error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;aCH Configuration Word-Sized Write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =OB1H &lt;br /&gt;AL= OSH &lt;br /&gt;BX = bus and unit number &lt;br /&gt;CX = data to be written to configuration register &lt;br /&gt;01 = register number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes for function 02H) &lt;br /&gt;Carry = 1 for error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;aDH Configuration Doubleword-Sized Write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OB1H &lt;br /&gt;AL=OSH &lt;br /&gt;BX = bus and unit number &lt;br /&gt;ECX = data to be written to configuration register &lt;br /&gt;01 = register number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = result code (see notes for function 02H) &lt;br /&gt;Carry = 1 for error &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;582 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 14 BUS INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 14-7 shows how the BIOS is used to detenmne if the PCI bus extension is available. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 14-7 &lt;br /&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . DATA &lt;br /&gt;0000 50 43 49 20 42 49 MES1 DB 'PCI BIOS NOT PRESENT$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4F 53 20 4E 4F 54 &lt;br /&gt;20 50 52 45 53 45 &lt;br /&gt;4E 54 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0015 50 43 49 20 42 49 MES2 DB 'PCI BIOS PRESENT$' &lt;br /&gt;4F 53 20 50 52 45 &lt;br /&gt;53 45 4E 54 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B4 B1 MOV AH,OB1H ;access PCI extension &lt;br /&gt;0019 BO 01 MOV AL,OlH &lt;br /&gt;001B CD 1A INT 1AH &lt;br /&gt;001D BA 0015 R MOV DX,OFFSET MES2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF CARRY? &lt;br /&gt;0022 BA 0000 R MOV DX,OFFSET MES1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;0025 B4 09 MOV AH,9 ;display string &lt;br /&gt;0027 CD 21 INT 2lH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once the presence of the BIOS is established, the contents of the configuration memory &lt;br /&gt;can be read using the BIOS functions. Note that the BIOS does not support data transfers be-&lt;br /&gt;tween the computer and the PCI interface. Data transfers are handled by drivers that are provided &lt;br /&gt;with the interface. These drivers control the flow of data between the microprocessor and the &lt;br /&gt;component found on the PCI interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. The bus systems (lSA, EISA, VESA, and PCI) allow VO and memory systems to be inter-&lt;br /&gt;faced to the personal computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The ISA bus is either 8- or 16-bits and supports either memory or VO transfers at rates of &lt;br /&gt;8 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The EISA bus is an extended version of the ISA bus that supports 8-, 16-, and 32-bit trans-&lt;br /&gt;fers between the personal computer and memory or VO at rates of 8 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. The VESA (Video Electronics Standards Association) local bus supports 32-bit transfers be-&lt;br /&gt;tween the personal computer and VO or memory at rates of 33 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The PCI (peripheral component interconnect) supports 32- or 64-bit transfers between the &lt;br /&gt;personal computer and memory or VO at rates of 33 MHz. This bus also allows virtually any &lt;br /&gt;microprocessor to be interfaced to the PCI bus via the use of a bridge interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. A plug-and-play interface is one that contains a memory that holds configuration informa-&lt;br /&gt;tion for the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. The letters ISA are an acronym for what phrase? &lt;br /&gt;2. The ISA bus system supports what size data transfers? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;14-5 QUESTIONS AND PROBLEMS 583 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Is the ISA bus interface often used for memory expansion? &lt;br /&gt;4. Develop an ISA bus interface that is decoded at addresses SOOH-803H. This interface must &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;contain an S255 accessed via these port addresses. (Don't forget to buffer all inputs to the &lt;br /&gt;ISA bus card.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Develop an ISA bus interface that decodes ports 0820H-0823H to control a single S254 &lt;br /&gt;timer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Develop a 16-bit ISA bus interface that adds a 27C256 EPROM at memory addresses &lt;br /&gt;FFOOOOH-FF7FFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Given a 74LS244 buffer and a 74LS374 latch, develop an ISA bus intelface that contains an &lt;br /&gt;S-bit input port at I/O address SOSH and an S-bit output port at I/O address SOAH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S. Create an ISA bus interface that allows four channels of analog output signals of from &lt;br /&gt;0-5.0V each. These four channels must be decoded at I/O addresses SOOH, SI OH, S20H, and &lt;br /&gt;S30H. Also develop software that supports the four channels. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. Redo Question S, but instead of four output channels, use four ADCs to create four analog &lt;br /&gt;input channels at the same addresses. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Using an S254 timer or timers, develop a darkroom timer on an ISA bus card. Your timer &lt;br /&gt;must generate a logic 0 for I/IOO-second intervals from 1/100 second to 5 minutes. Use the &lt;br /&gt;system clock of SMHz as a timing source. The software you develop must allow the user to &lt;br /&gt;select the time from the keyboard. The output signal from the timer must be a logic 0 for the &lt;br /&gt;duration of the selected time and must be passed through an inverter to enable a solid-state &lt;br /&gt;relay that controls the photographic enlarger. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. Interface a 16550 UART to the personal computer on an ISA bus interface. Develop soft-&lt;br /&gt;ware that transmits and receives data at Baud rates of 300, 1200, 9600, and 19,200. The &lt;br /&gt;UART must respond to I/O ports OE3XH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The EISA bus can transfer data that is in width at the rate of S MHz. &lt;br /&gt;13. Describe how the ISA connector is modified to accommodate the EISA interface. &lt;br /&gt;14. The VESA local bus operates at what rate? &lt;br /&gt;15. Does the VESA local bus use the contacts on the ISA bus? &lt;br /&gt;16. What is the difference between the VESA local bus and the PCI bus? &lt;br /&gt;17. Describe how the address can be captured from the PCI bus. &lt;br /&gt;IS. What is the purpose of the configuration memory found on the PCI bus interface? &lt;br /&gt;19. Define the tern p1ug-and-play. &lt;br /&gt;20. What is the purpose of the CIBE connection on the PCI bus system? &lt;br /&gt;21. How is the BIOS tested for the PCI BIOS extension? &lt;br /&gt;22. Develop a short program that interrogates the PCI bus, using the extension to the BIOS, and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;that reads the 32-bit contents of configuration register OSH. For this problem, consider that &lt;br /&gt;the bus and unit number are OOOOH. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;584 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 15 &lt;br /&gt;The 80186, 80188, and 80286 &lt;br /&gt;Microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Intel 80186/80188 and the 80286 are enhanced versions of the earlier 8086/8088 micro-&lt;br /&gt;processors. The 80186/80188 and 80286 are all 16-bit microprocessors that are upward com-&lt;br /&gt;patible to the 8086/8088. Even the hardware of these microprocessors is similar to the earlier &lt;br /&gt;versions. This chapter presents an overview of each microprocessor and points out the differ-&lt;br /&gt;ences or enhancements that are present in each version. The first part of the chapter describes &lt;br /&gt;the 80186/80188 microprocessors, and the last part discusses the 80286 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;New to this edition is a much expanded coverage of the 80186/80188 family. Intel has &lt;br /&gt;added four new versions of each of these embedded controllers to its lineup of microprocessors. &lt;br /&gt;Each is a CMOS version designated with a two-letter suffix: XL, EA, EB, and Ee. The &lt;br /&gt;80C186XL and 80C188XL models are most similar to the earlier 80186/80188 models. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Describe the hardware and software enhancements of the 80186/80188 and the 80286 &lt;br /&gt;microprocessors as compared to the 808618088. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Detail the differences between the various versions of the 80186 and 80188 embedded &lt;br /&gt;controllers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Interface the 80186/80188 and the 80286 to memory and 110. &lt;br /&gt;4. Develop software using the enhancements provided in these microprocessors. &lt;br /&gt;5. Describe the operation of the memory management unit (MMU) within the 80286 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188 ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80186 and 80188, like the 8086 and 8088, are nearly identical. The only difference between &lt;br /&gt;the 80186 and 80188 is the width of their data buses. The 80186 (like the 8086) contains a 16-bit &lt;br /&gt;data bus, while the 80188 (like the 8088) contains an 8-bit data bus. The internal register struc-&lt;br /&gt;ture of the 80186/80188 is virtually identical to the ,8086/8088. About the only difference is that &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-1 80186/80188 ARCHITECTURE 585 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the 80186/80188 contain additional reserved interrupt vectors and some very powerful built-in &lt;br /&gt;I/O features. The 80186/80188 are often called embedded controllers because of their applica-&lt;br /&gt;tion, not as a microprocessor-based computer, but as a controller. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Versions of the 80186/80188 &lt;br /&gt;As mentioned, the 80186/80188 are available in four different versions, which are all CMOS mi-&lt;br /&gt;croprocessors. Table 15-1 lists each version and lhe major fealures provided. The 80CI86XL &lt;br /&gt;and 80CI88XL are the most basic versions of the 80186/80188, while the 80C186EC and &lt;br /&gt;80C188EC are the most advanced. This text details the 80C186XLl80C188XL and then de-&lt;br /&gt;scribes the additional features and enhancements provided in the other versions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186 Basic Block Diagram &lt;br /&gt;Figure 15-1 provides the block diagram of the 80186 microprocessor that generically represents &lt;br /&gt;all versions except for the enhancements and additional features outlined in Table 15-1. Notice &lt;br /&gt;that this microprocessor has a great deal more internal circuitry than the 8086. The block dia-&lt;br /&gt;grams of the 80186 and 80188 are identical except for the pre-fetch queue, which is 4 bytes in the &lt;br /&gt;80188 and six bytes in the 80186. Like the 8088, the 80186 contains a bus interface unit (BIU) &lt;br /&gt;and an execution unit (EU). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In addition to the BIU and EU, the 80186/80188 family contains a clock generator, a pro-&lt;br /&gt;grammable interrupt controller, programmable timers, a programmable DMA controller, and a &lt;br /&gt;programmable chip selection unit. These enhancements greatly increase the utility of the &lt;br /&gt;80186/80188 and reduce the number of peripheral components required to implement a &lt;br /&gt;system. Many popular subsystems for the personal computer use the 80186/80188 as caching &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-1 The four versions of the 80186/80188 embedded controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80C186XL 80C186EA 80C186EB 80C186EC &lt;br /&gt;Feature 80C188XL 80C188EA 80C188EB 80C188EC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286-like instruction set II II II II &lt;br /&gt;Power-save (green mode) II II II &lt;br /&gt;Power down mode II II II &lt;br /&gt;80C187 interface II II II II &lt;br /&gt;ONCE mode II II II II &lt;br /&gt;Interrupt controller II II II II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8259-like &lt;br /&gt;Timer unit II II II II &lt;br /&gt;Chip selection unit II II II II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;enhanced enhanced &lt;br /&gt;DMA controller II II II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2-channel 2-channel 4-channel &lt;br /&gt;Serial communications unit II II &lt;br /&gt;Refresh controller II II II II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;enhanced enhanced &lt;br /&gt;Watchdog timer II &lt;br /&gt;1/0 ports II II &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-bits 22-bits &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;586 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1NT31iiim &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INt'2IIR1'lD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rD~T1D INn TMR OUT' TMR OUT 0 TMR IN t TMRAN t NT' INITO 1 T &lt;br /&gt;I J UEeUnONUNiTI l t t PROGRAMMAIILE I n_ &lt;br /&gt;x, lit I 0 , 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, .. IIT I ~~ AW I PROGRAMMABLE &lt;br /&gt;I INTERRUPT MAX COUNT ~~ CONTIIOI.LER I REGISTER&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'M&amp;quot; GENERAL. I CONTROL IlEGISTIRS &lt;br /&gt;PIIRPOIE I IlEGIITEIIS CONTROL, I '.oIIIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-.l IlEGllITEIIS COUNT IlEGISTIR &lt;br /&gt;t {t n { &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NTERNA,8II' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J U U ~ r-I-PROGIIAMMA8LE &lt;br /&gt;_UNIT &lt;br /&gt;0 , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHJP.IIEUCT &lt;br /&gt;-'-r- UNIT IICIURCE POINTERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-r- IUS INTERFACE ~ 2O-I1T '-r- UNIT ,Jl.1IT DEBnNATION &lt;br /&gt;8RDY &lt;br /&gt;ARDY &lt;br /&gt;TD'I' &lt;br /&gt;HOLD &lt;br /&gt;HLDA &lt;br /&gt;lID &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-r-&lt;br /&gt;i::f;: &lt;br /&gt;'-r-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEGMENT &lt;br /&gt;IlEGlIITEIIS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JI.8YTI! &lt;br /&gt;JlllEFETCII QUEUE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;III tl ~h &lt;br /&gt;POINTERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,MIT &lt;br /&gt;TllAN8FER COUNT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTROL &lt;br /&gt;IlECll8TERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l~ ~l L~AZ l:Di:\\( Lei PCSf/A' &lt;br /&gt;DTIII lRI!!sr AD1S A'1I8I \\I \\I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;ORa' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-1 The block diagram of the 80186 microprocessor. Note that the block diagram &lt;br /&gt;of the 80188 is identical except SHE/S? is missing and AD15-AD8 are relabeled A15-A8. &lt;br /&gt;(Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;disk controllers, local area network (LAN) controllers, etc. The 80186/80188 microprocessors &lt;br /&gt;also find application in the cellular telephone network as a switcher. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Software for the 80186/80188 is identical to the 80286 microprocessor without the memory &lt;br /&gt;management instructions. This means that the 80286-like instructions immediate multiplication, &lt;br /&gt;immediate shift counts, string I/O, PUSHA, POPA, BOUND, ENTER, and LEAVE all function &lt;br /&gt;on the 80186/80188 microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188 Basic Features &lt;br /&gt;In this segment of the text, we introduce the enhancements of the 80186/80188 microprocessors &lt;br /&gt;or embedded controllers that apply to all versions except where noted, but we do not provide an &lt;br /&gt;exclusive coverage. More details on the operation of each enhancement are provided later in the &lt;br /&gt;chapter. Details of each advanced version are also provided later in this chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Clock Generator. The internal clock generator replaces the external 8284A clock generator used &lt;br /&gt;with the 8086/8088 microprocessors. This reduces the component count in a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The internal clock generator has three pin connections: Xl, X2, and CLKOUT (or on some &lt;br /&gt;versions CLKIN, OSCOUT, and CLKOUT). The Xl (CLKIN) and X2 (OSCOUT) pins &amp;lt;Ire con-&lt;br /&gt;nected to a crystal that resonates at twice the operating frequency of the microprocessor. In the 8 &lt;br /&gt;MHz version of the 80186/80188, a 16 MHz crystal is attached to Xl (CLKIN) and X2 (OS-&lt;br /&gt;COUT). The 80186/80188 are available in 6 MHz, 8 MHz, 12 MHz, 16 MHz, or 25 MHz versions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CLKOUT pin provides a system clock signal that is one-half the crystal frequency &lt;br /&gt;with a 50 percent duty cycle. The CLKOUT pin drives other devices in a system and provides a &lt;br /&gt;timing source to additional microprocessors in the system. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-1 80186/80188 ARCHITECTURE 587 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In addition to these external pins, the clock generator provides the internal timing for syn-&lt;br /&gt;chronizing the READY input pin, whereas in the 8086/8088 system, READY synchronization is &lt;br /&gt;provided by the 8284A clock generator. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programmable Interrupt Controller. The programmable interl&amp;quot;lpt controller (PIC) arbitrates all &lt;br /&gt;internal and external interrupts and controls up to two external 8259A PICs. When an external &lt;br /&gt;8259 is attached, the 80186/80188 microprocessors function as the master and the 8259 func-&lt;br /&gt;tions as the slave. The 80C 186EC and 80C188EC models conlain an 8259A compatible interrupt &lt;br /&gt;controller in place of the one described here for the other versions (XL, EA, and EB). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If the PIC is operated without an 8259, it has five interrupt inputs: INTO-INT3 and NMI. &lt;br /&gt;This is an expansion from the two interrupt inputs available on the 8086/8088 microprocessors. &lt;br /&gt;In many systems, the five interrupt inputs are adequate. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timers. The timer section contains three fully programmable 16-bit timers. Timers 0 and &lt;br /&gt;generate wave-forms for external use and are driven by either the master clock of the 801861 &lt;br /&gt;80188 or by an external clock. They are also used to count external events. The third timer, timer &lt;br /&gt;2, is internal and clocked by the master clock. The output of timer 2 generates an interrupt after &lt;br /&gt;a specified number of clocks and also can provide a clock to the other timers. Timer 2 can also &lt;br /&gt;be used as a watchdog timer, because it can be programmed to interrupt the microprocessor after &lt;br /&gt;a certain length of time. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80C186EC and 80C188EC models have an additional timer called a watchdog. The &lt;br /&gt;watchdog timer is a 32-bit counter that is clocked internally by the CLKOUT signal (one-half the &lt;br /&gt;crystal frequency). Each time the counter hits zero, it reloads and generates a pulse on the &lt;br /&gt;WDTOUT pin that is four CLKOUT periods wide. This output can be used for any purpose. It &lt;br /&gt;can be wired to the reset input to cause a reset or to the NMI input to cause an interrupt. Note that &lt;br /&gt;if it is connected to the reset or NMI inputs, it is periodically reprogrammed so that it never &lt;br /&gt;counts down to zero. The purpose of a watchdog timer is to reset or interrupt the system if the &lt;br /&gt;software goes awry. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programmable DMA Unit. The programmable DMA unit contains two DMA channels, or four &lt;br /&gt;DMA channels in the 80C186EC/80Cl88EC models. Each channel can transfer data between &lt;br /&gt;memory locations, between memory and VO, or between VO devices. This DMA controller is &lt;br /&gt;similar to the 8237 DMA controller discussed in Chapter 12. The main difference is that the &lt;br /&gt;8237 has four channels, as does the EC model. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programmable Chip Selection Unit. The chip selection is a built-in programmable memory and &lt;br /&gt;VO decoder. It has 6 output lines to select memory, 7 lines to select VO on the XL and EA &lt;br /&gt;models, and 10 lines that either select memory or VO on the EB and EC models. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;On the XL and EA models, the memory selection lines are divided into three groups &lt;br /&gt;that select memory for the major sections of the 80186/80188 memory map. The lower &lt;br /&gt;memory select signal enables memory for the interrupt vectors, the upper memory select &lt;br /&gt;signal enables memory for reset, and the middle memory select signals enable up to four &lt;br /&gt;middle memory devices. The boundary of the lower memory begins at location OOOOOH, and &lt;br /&gt;the boundary of the upper memory ends at location FFFFFH. The size of the memory areas &lt;br /&gt;are programmable, and wait states (0-3 waits) can be automatically inserted with the selec-&lt;br /&gt;tion of an area of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;On the XL and EA models, each programmable VO selection signal address a 128-byte &lt;br /&gt;block of VO space. The programmable VO area starts at a base VO address programmed by the &lt;br /&gt;user, and all seven 128-byte blocks are contiguous. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;On the EB and EC models, there is an upper and lower memory chip selection pin and &lt;br /&gt;eight general-purpose memory or 110 chip selection pins. Another difference is that from &lt;br /&gt;0-15 wait states can be programmed in these two versions of the 80186/80188 embedded &lt;br /&gt;controllers. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;588 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Power Save/Power Down Feature. The power save feature allows the system clock to be divided &lt;br /&gt;by 4, 8, or 16 to reduce power consumption. The power saving feature is started by software and &lt;br /&gt;exited by a hardware event such as an interrupt. The power down feature stops the clock com-&lt;br /&gt;pletely, but it is not available on the XL version. The power down mode is entered by executing &lt;br /&gt;an HL T instruction and exited by any interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Refresh Control Unit. The refresh control unit generates the refresh row address at the interval &lt;br /&gt;programmed. The refresh control unit does not mUltiplex the address for the DRAM-this is still &lt;br /&gt;the responsibility of the system designer. The refresh address is provided to the memory system &lt;br /&gt;at the end of the programmed refresh interval, along with the RFSH control signal. The memory &lt;br /&gt;system must run a refresh cycle during the active time of the RFSH control signal. More on &lt;br /&gt;memory and refreshing is provided in the section that explains the chip selection unit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin-Out &lt;br /&gt;Figure 15-2 illustrates the pin-out of the 80Cl88XL microprocessor. Note that the 80C 186XL is &lt;br /&gt;packaged in either a 68-pin lead-less chip carrier (LCC) or in a pin grid array (PGA). The LCC &lt;br /&gt;package and PGA packages are illustrated in Figure 15-3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Definitions. The following list defines each 80C188XL pin and notes any differences be-&lt;br /&gt;tween the 80C186XL and 80C188XL microprocessors. The enhanced versions are described &lt;br /&gt;later in this chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vee &lt;br /&gt;Vss &lt;br /&gt;Xl and X2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TOP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This is the system power supply connection for Â±1O%, +5.0V. &lt;br /&gt;This is the system ground connection. &lt;br /&gt;These pins generally connect to a fundamental-mode parallel &lt;br /&gt;resonant crystal that operates an internal crystal oscillator. An &lt;br /&gt;external clock signal may be connected to the Xl pin. The internal &lt;br /&gt;master clock operates at one-half the external crystal or clock input &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5052 &lt;br /&gt;51 &lt;br /&gt;52 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARDY &lt;br /&gt;CLKOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;X2 &lt;br /&gt;Xl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vss &lt;br /&gt;ALE/QSO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDlQSMD &lt;br /&gt;WAlQSl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BHE &lt;br /&gt;AlII/58 &lt;br /&gt;A18/55 &lt;br /&gt;A17/S4 &lt;br /&gt;A161S3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOTTOM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, 'tt -&amp;quot;&amp;quot; '-10' ~L..I.L..IJ....I.I../.L..I.I..J~u....&amp;amp;.J&amp;quot;..U....t.I...I &lt;br /&gt;.~ ~ ~~~~~g~xu~~~~~~~8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PIN NO.1 MARK ~ ~ ~ :c ~ -&amp;lt; ~:::c ~ ~ ~ ~:c :c ~ :c -&amp;lt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UCS &lt;br /&gt;LCS &lt;br /&gt;PCS&amp;amp;'A2 &lt;br /&gt;PCSSIAl &lt;br /&gt;PCS4 &lt;br /&gt;iiCS3 &lt;br /&gt;Pes2 &lt;br /&gt;Pes1 &lt;br /&gt;Vss &lt;br /&gt;PCSO &lt;br /&gt;REi &lt;br /&gt;TMROUTl &lt;br /&gt;TMROUTO &lt;br /&gt;TMRIN 1 &lt;br /&gt;TMR INO &lt;br /&gt;ORQl &lt;br /&gt;OROO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-2 Pin-out of the 80186 microprocessor (Courtesy of Intel Corporation) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-1 80186/80188 ARCHITECTURE 589 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PGA Bottom View Lee Bottom View &lt;br /&gt;35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;@Â®@@@@)Â®Â®@ &lt;br /&gt;Â®Â®Â®Â®@8Â®@Â®Â®Â® &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34 &lt;br /&gt;33 &lt;br /&gt;32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52 &lt;br /&gt;53 &lt;br /&gt;54 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â®Â® @@ 31 55 &lt;br /&gt;Â®Â® Â®Â® 30 56 29 57 &lt;br /&gt;@@ Â®Â® 28 58 27 59 &lt;br /&gt;@@ @@ 26 60 &lt;br /&gt;@@ @@ 25 61 24 62 &lt;br /&gt;@@ @@ 23 63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;64 Â§0 Â®Â® 22 21 65 &lt;br /&gt;@Â®@@@@0000Â® 20 66 19 67 @@@@00008 18 68 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-3 The bottom views of the PGA and LCC style versions of the 80C188XL microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLKOUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMRINO, TMRINI &lt;br /&gt;TMROUTOand &lt;br /&gt;TMROUTl &lt;br /&gt;DRQO and DRQl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTO,INTl, &lt;br /&gt;INT2/INT AO, and &lt;br /&gt;INT3/INTAl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;signal. Note that these pins are labeled CLKIN (Xl) and OSCOUT &lt;br /&gt;(X2) on some versions of the 80186/80188. &lt;br /&gt;This pin provides a timing signal to system peripherals at one-half &lt;br /&gt;the clock frequency with a 50 percent duty cycle. &lt;br /&gt;The reset pin resets the 80186/80188. For a proper reset, the RES &lt;br /&gt;must be held low for at least 50 ms after power is applied. This &lt;br /&gt;pin is often connected to an RC circuit that generates a reset signal &lt;br /&gt;after power is applied. The reset location is identical to that of the &lt;br /&gt;8086/8088 microproeessors-FFFFOH. &lt;br /&gt;The companion reset output pin (goes high for a reset) connects &lt;br /&gt;to system peripherals to initialize them whenever the RES input &lt;br /&gt;goes low. &lt;br /&gt;This test pin connects to the BUSY output of the 80187 numeric &lt;br /&gt;coprocessor. The TEST pin is interrogated with the WAIT instruction. &lt;br /&gt;These pins are used as external clocking sources to timers 0 and 1. &lt;br /&gt;These pins provide the output signals from timers 0 and 1, which &lt;br /&gt;can be programmed to provide square waves or pulses. &lt;br /&gt;These pins are active-high level triggered DMA request lines for &lt;br /&gt;DMA channels 0 and 1. &lt;br /&gt;This is a non-maskable interrupt input. It is positive edge-triggered &lt;br /&gt;and always active. When NMI is activated, it uses interrupt vector 2. &lt;br /&gt;These are maskable interrupt inputs. They are active-high and are &lt;br /&gt;programmed as either level or edge-triggered. These pins are con-&lt;br /&gt;figured as four interrupt inputs if no external 8259 is present, or as &lt;br /&gt;two interrupt inputs if 8259s are present. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;590 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI9/0NCE, A18, &lt;br /&gt;A17, A16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR &lt;br /&gt;RD &lt;br /&gt;ARDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S2, SI, and SO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;These are multiplexed address status connections that provide the &lt;br /&gt;address (AI9-A 16) and status (S6-S3). Status bits found on address &lt;br /&gt;pins A18-A16 have no system function and are used during manu-&lt;br /&gt;facturer for testing. The A 19 pin is an input for the ONCE function &lt;br /&gt;on reset. If ONCE is held low on a reset, the microprocessor enters a &lt;br /&gt;testing mode. &lt;br /&gt;These are multiplexed address/data bus connections. During Tp &lt;br /&gt;the 80186 places AI5-AO on these pins; during T2, T3, and T4, the &lt;br /&gt;80186 uses these pins as the data bus for signals DI5-Do'-Note that &lt;br /&gt;the 80188 has pins AD7-ADO and AI5-A8â¢ &lt;br /&gt;This pin indicates (when a logic 0) that valid data are transferred &lt;br /&gt;through data bus connections DIS-D8. &lt;br /&gt;This is a multiplexed output pin that contains ALE one-half &lt;br /&gt;clock cycle earlier than in the 8086. It is used to de-multiplex the &lt;br /&gt;address/data and address/status buses. (Even though the status &lt;br /&gt;bits on A19-A16 are not used in the system, they must still be &lt;br /&gt;de-multiplexed.) &lt;br /&gt;This write pin causes data to be written to memory or I/O. &lt;br /&gt;This read pin causes data to be read from memory or I/O. &lt;br /&gt;The asynchronous READY input informs the 80186/80188 that the &lt;br /&gt;memory or I/O is ready for the 80186/80188 to read or write data. If &lt;br /&gt;this pin is tied to +5.0V, the microprocessor functions normally; if it &lt;br /&gt;is grounded, the microprocessor enters wait states. &lt;br /&gt;The synchronous READY input is synchronized with the system &lt;br /&gt;clock to provide a relaxed timing for the ready input. As with &lt;br /&gt;ARDY, SRDY is tied to +5.0V for no wait states. &lt;br /&gt;This lock pin is an output controlled by the LOCK prefix. If an &lt;br /&gt;instruction is prefixed with LOCK, the LOCK pin becomes a logic 0 &lt;br /&gt;for the duration of the locked instruction. &lt;br /&gt;These are status bits that provide the system with the type of bus &lt;br /&gt;transfer in effect. Refer to Table 15-2 for the states of the status bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The upper-memory chip select pin selects memory on the upper &lt;br /&gt;portion of the memory map. This output is programmable to enable &lt;br /&gt;memory sizes of lK-256K bytes ending at location FFFFFH. Note &lt;br /&gt;that this pin is programmed differently on the EB and EC versions. &lt;br /&gt;The lower-memory chip select pin enables memory beginning at &lt;br /&gt;location OOOOOH. This pin is programmed to select memory sizes &lt;br /&gt;from IK-256K bytes. Note that this pin functions differently for the &lt;br /&gt;EB and EC versions. &lt;br /&gt;The middle-memory chip select pins enable four middle memory &lt;br /&gt;devices. These pins are programmable to select an 8K-512K-byte &lt;br /&gt;block of memory containing four devices. Note that these pins are &lt;br /&gt;not present on the EB and EC versions. &lt;br /&gt;These are five different peripheral selection lines. Note that the &lt;br /&gt;lines are not present on the EB and EC versions. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-1 80186/80188 ARCHITECTURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-2 The 82, 81, &lt;br /&gt;and 80 status bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCSS/Al and &lt;br /&gt;PCS6/A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52 51 50 Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 Interrupt acknowledge &lt;br /&gt;0 0 1 1/0 read &lt;br /&gt;0 0 1/0 write &lt;br /&gt;0 1 1 Halt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 Opcode fetch &lt;br /&gt;0 1 Memory read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 Memory Write &lt;br /&gt;Passive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;These pins are programmed as peripheral selection lines or as &lt;br /&gt;internally latched address bits A2 and A I. These lines are not &lt;br /&gt;present on the EB and EC versions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;591 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R This pin controls the direction of data bus buffers if attached to the &lt;br /&gt;system. &lt;br /&gt;This pin enables the external data bus buffers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DC Operating Characteristics &lt;br /&gt;It is necessary to know the DC operating characteristics before attempting to interface or operate &lt;br /&gt;the microprocessor. The 80C186/801C88 microprocessors require between 42 mA and 63 mA of &lt;br /&gt;power supply current. Each output pin provides 3.0 mA of logic 0 current and -2 mA of logic &lt;br /&gt;1 current. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188 Timing &lt;br /&gt;The timing diagram for the 80186 is provided in Figure 15-4. Timing for the 80188 is identical &lt;br /&gt;except for the multiplexed address connections, which are AD7-ADO instead of ADI5-ADO, &lt;br /&gt;and the BHE, which does not exist on the 80188. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The basic timing for the 80186/80188 is composed of four clocking periods, just as in the &lt;br /&gt;8086/8088. A bus cycle for the 8 MHz version requires 500 ns, while the 16 MHz version re-&lt;br /&gt;quires 250 ns. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;There are very few differences between the timing for the 80186/80188 and the 8086/ &lt;br /&gt;8088. The most noticeable difference is that ALE appears one-half clock cycle earlier in the &lt;br /&gt;80186/80188. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Access Time. One of the more important points in any microprocessor's timing dia-&lt;br /&gt;gram is the memory access time. Access time calculations for the 80186/80188 are identical to &lt;br /&gt;those of the 8086/8088. Recall that the access time is the time allotted to the memory and I/O to &lt;br /&gt;provide data to the microprocessor after the microprocessor sends the memory or I/O its address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A close examination of the timing diagram reveals that the address appears on the address &lt;br /&gt;bus T CLAV time after the start of Tl. T CLA V is listed as 44 ns for the 8 MHz version. (See Figure &lt;br /&gt;15-5.) Data are sampled from the data bus at the end of T3, but a setup time is required before &lt;br /&gt;the clock defined as T DVCL&amp;quot; The times listed for T DVCL are 20 ns for both versions of the m:-&lt;br /&gt;croprocessor. Access time is therefore equal to three clocking periods minus both TCLA V and &lt;br /&gt;T DVCL. Access time for the 8 MHz microprocessor is 375 ns - 44 ns - 20 ns, or 311 ns. The ac~ &lt;br /&gt;cess time for the 16 MHz version is calculated in the same manner except that T CLAV is 25 ns &lt;br /&gt;and T DVCL is 15 ns. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;592 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WIllTECYCU! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT&amp;gt; C'/CU! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~~:~~ ------~V-----------------------+__r-------Â­&lt;br /&gt;~ Lei, ------t-~ &lt;br /&gt;/iiCt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-4 80186/80188 timing. (a) Read cycle timing and (b) write cycle timing (Courtesy &lt;br /&gt;of Intel Corporation) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-1 B01B6/B01BB ARCHITECTURE 593 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186 M .... lmortace llml&amp;quot;llllMponeM &lt;br /&gt;80188 (8 MHz) 80188-8 (8 MHz) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Symbol ..... meIIn Min â¢ Max. Min. Max. Unila ~ ConcIIIIonI &lt;br /&gt;Tcuo Add&amp;quot;, .. Valid Delay 5 4-4 5 83 n. c.. -20-200 pF all outpuI8 &lt;br /&gt;Tcux Add&amp;quot;, .. Hold 10 10 n. &lt;br /&gt;Tew Addre .. Floal Delay Tcux 35 Tcux Â« n. &lt;br /&gt;TCHCZ Command Una. fIoa1 Delay 45 56 n. &lt;br /&gt;TCHCV Comm.nd Un â¢â¢ Valid Delay &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a&amp;quot;arnoal) 55 76 na &lt;br /&gt;TUÂ«.l ALEWldlh TCl.Cl.&amp;quot; Ta.a.45 ne &lt;br /&gt;TCKJi ALE AdM! Oel.y 35 Â« n. &lt;br /&gt;TeHll. ALE In.cti .... Delay 35 Â« n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TLl ... &amp;quot; Addre .. Hold to ALE IneeU .... TCHQ._25 TCHClâ¢30 n. &lt;br /&gt;TCIJlY Cola V.hd Colay 10 44 10 55 n. &lt;br /&gt;To.oox Oata Hold TIme 10 10 n. &lt;br /&gt;T....,x Cota Hold after WR To.Cl-40 Ta.a._5O n. &lt;br /&gt;Tevcrv Control Adive Delay 1 5 70 5 87 n. &lt;br /&gt;TeHClV Control Adi .... Delay 2 10 55 10 76 ns &lt;br /&gt;TCVCTX COntrollnaeti .... Colay 5 55 5 76 n. &lt;br /&gt;Tcvoex ~ Inaeti .... Colay (Non-Write Cycle) 70 87 n' &lt;br /&gt;T&amp;quot;, ... Addre â¢â¢ Float to R!j Active 0 0 n. &lt;br /&gt;TCLRL lID Active Delay 10 70 10 87 n. &lt;br /&gt;Te,,&amp;quot;, RO tnactive Delay 10 55 10 76 n. &lt;br /&gt;TAIiAIJ lID InactIVe to Addre .. Active 1CI..CI..-40 Tccccâ¢5O n. &lt;br /&gt;TCLHNJ HLOA Valid Delay 10 5(1 10 67 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIM&amp;quot; RtiWidlh 2TcLCl_5O 2TClCL_5O ns &lt;br /&gt;TWLWH WRWidlh 2Ta.ca.. â¢â¢ o 2TClCL .... ns &lt;br /&gt;T_ Addre .. Valid to ALE low TCLCH-25 TCLC:H-4. n. &lt;br /&gt;TCHSV StatUS-AdM! O.'ay 10 55 10 76 n. &lt;br /&gt;TCLSH Status InactiVe Delay 10 55 10 76 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TeLT&amp;quot;&amp;quot; TImer Qutpul Delay 60 75 ns 100 pF ma. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To.&amp;quot;&amp;quot; Re .. lOeIay 60 75 ns &lt;br /&gt;TCHasy Queu. Status Colay 35 44 n. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80188 Chip-Select Timi&amp;quot;ll Reepon_ &lt;br /&gt;Symbol &amp;quot;&amp;quot; ......... Min. Max. Min. Max. Unill ~ ConcIIIIoM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TClCSy Chip-Setecl Adive Colay 66 60 n. &lt;br /&gt;Tcxcsx Chip-Selct Hold from &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Command tnactive 35 35 n. &lt;br /&gt;TCHCSX Chip-Selectlnaelive Colay 5 35 5 47 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Symbol Pa ... meter Min. M.lI. Unlta 1Ht Condition. &lt;br /&gt;TOVCL Data In Selup (AID) 20 ns &lt;br /&gt;TCLDX Dala in Hold (AID) 10 ns &lt;br /&gt;TARYHCH Asynchronous Ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(AREADY) active setup &lt;br /&gt;timeÂ· 20 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TARYLCL AREADY inactive aelup &lt;br /&gt;time 35 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCHARYX AREADY hold lime 15 na &lt;br /&gt;TSRYCL Synchronous Ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(SREADy) tranailion setup &lt;br /&gt;time 35 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCLSRY SREADY transition hold &lt;br /&gt;lime 15 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THVCL HOLD Setup&amp;quot; 25 ns &lt;br /&gt;TINVCH INTR. NMI. TEST. TIMERIN. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Setup&amp;quot; 25 ns &lt;br /&gt;TINVCL DRQO. ORal. Selup&amp;quot; 25 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;To guarantee recognition at next clock. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-5 80186 AC characteristics (Courtesy of Intel Corporation) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;594 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROGRAMMING THE 80186/80188 ENHANCEMENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section provides detail on the programming and operation of the 80186/80188 enhance-&lt;br /&gt;ments of all versions (XL, EA, EB, and EC). Section 15-3 details the use of the 80C188EB in a &lt;br /&gt;system that uses many of the enhancements discussed here. The only new feature not discussed &lt;br /&gt;here is the clock generator, which is described in the previous section on architecture. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Peripheral Control Block &lt;br /&gt;All internal peripherals are controlled by a set of 16-bit wide registers located in the peripheral &lt;br /&gt;control block (PCB). The PCB (see Figure 15--6) is a set of 256 registers located in the I/O or &lt;br /&gt;memory space. Note that this set applies to the XL and EA versions. Later in this section, the EB &lt;br /&gt;and EB version PCB is defined and discribed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever the 80186/80188 microprocessors are reset, the peripheral control block is au-&lt;br /&gt;tomatically located at the top of the I/O map (I/O addresses FFOOH-FFFFH). In most cases, it &lt;br /&gt;stays in this area of I/O space, but the PCB may be relocated at any time to any other area of &lt;br /&gt;memory or I/O. Relocation is accomplished by changing the contents of the relocation register &lt;br /&gt;(see Figure 15-7) located at offset addresses FEH and FFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The relocation register is set to a 20FFH when the 80186/80188 microprocessors are &lt;br /&gt;reset. This locates the PCB at 110 addresses FFOOH-FFFFH afterwards. To relocate the PCB, &lt;br /&gt;the user need only send a word OUT to 110 address FFFEH with a new bit pattern. For example, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-6 Peripheral &lt;br /&gt;control block (PCB) of the &lt;br /&gt;80186/80188 (Courtesy of &lt;br /&gt;Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ReiOCIIlion RegI.ar &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA DetlCl'lpIor. Chennel1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA DetlCl'lpto,. Chennel 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Chlp-Select Control RegIeI.,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIm.r 2 Control Reg1eter8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;nmer 1 Control Regl ... ,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;nmer 0 Control Regl ... ,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Controller Regl .. er. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFFSET &lt;br /&gt;FEH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;88H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80ft &lt;br /&gt;SEH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;58H &lt;br /&gt;58H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHANCEMENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ET = ESC-NO ESC TRAP &lt;br /&gt;RMX = iRM x 86 modelmaster mode &lt;br /&gt;MilO = MemoryllO 'pace &lt;br /&gt;X = Unused &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-7 Peripheral control register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;595 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to relocate the PCB to memory locations 20000H-200FFH, a 1200H is sent to I/O address &lt;br /&gt;FFFEH. Notice that MIlO is a logic 1 to select memory, and that a 200H selects memory address &lt;br /&gt;20000H as the base address of the PCB. Note that all accesses to the PCB must be word accesses &lt;br /&gt;because it is organized as 16-bit wide registers. Example 15-1 shows the software required to re-&lt;br /&gt;locate the PCB to memory location 20000H-200FFH. Note that either an 8- or 16-bit output can &lt;br /&gt;be used to program the 80186; in the 80188, never use the OUT DX,AX instruction because it &lt;br /&gt;takes additional clocking periods to execute. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 15-1 &lt;br /&gt;0100 BA FFFE &lt;br /&gt;0103 B8 1200 &lt;br /&gt;0106 EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupts in the 80186/80188 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFFFEH &lt;br /&gt;AX,1200H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address relocation register &lt;br /&gt;;code for new PCB location &lt;br /&gt;;this can also be OUT DX,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupts in the 80186/80188 are identical to the 808618088 except that there are additional &lt;br /&gt;interrupt vectors defined for some of the internal devices. A complete listing of the reserved in-&lt;br /&gt;terrupt vectors appears in Table 15-3. The first five are identical to the 8086/8088. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The array BOUND instruction interrupt is requested if the boundary of an index register is &lt;br /&gt;outside the values set up in the memory. The unused opcode interrupt occurs whenever the &lt;br /&gt;80186/80188 execute any undefined opcode. This is important if a program begins to run awry. &lt;br /&gt;Note that the unused opcode interrupt can be accessed by an instruction, but the assembler does &lt;br /&gt;not include it in the instruction set. On the Pentium Pro and some earlier Intel microprocessors, &lt;br /&gt;the OFOBH or OFB9H instruction will cause the program to call the procedure whose address is &lt;br /&gt;stored at the unused opcode interrupt vector. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The ESC opcode interrupt occurs if ESC opcodes D8H-DFH are executed. This occurs &lt;br /&gt;only if the ET (escape trap) bit of the relocation register is set. If an ESC interrupt occurs, the ad-&lt;br /&gt;dress stored on the stack by the interrupt points to the ESC instruction or to its segment override &lt;br /&gt;prefix, if one is used. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The internal hardware interrupts must be enabled by the I flag bit and must be unmasked &lt;br /&gt;to function. The I flag bit is set (enabled) with STI and cleared (disabled) with CLI. The re-&lt;br /&gt;maining internally decoded interrupts are discussed with the timers and DMA controller later in &lt;br /&gt;this section. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Controller &lt;br /&gt;The interrupt controller inside the 80186/80188 is a fairly sophisticated device. It has many in-&lt;br /&gt;terrupt inputs that arrive from the five external interrupt inputs, the DMA controller, and the &lt;br /&gt;three timers. Figure 15-8 provides a block diagram of the interrupt structure of the 80186/80188 &lt;br /&gt;interrupt controller. This controller appears in the XL, EA, and EB versions, but the EC version &lt;br /&gt;contains the exact equivalent to 8259A found in Chapter 11. In the EB version, the DMA inputs &lt;br /&gt;are replaced with inputs from the serial unit for receive and transmit. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;596 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-3 80186/80188 &lt;br /&gt;interrupt vectors Name Type Address Priority &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Divide error 0 00000H-00003H 1 &lt;br /&gt;Single-step 1 00004H-00007H 1A &lt;br /&gt;NMI pin 2 00008H-0000BH 1 &lt;br /&gt;Breakpoint 3 OOOOCH-OOOOFH 1 &lt;br /&gt;Overflow 4 00010H-00013H 1 &lt;br /&gt;BOUND instruction 5 00014H-00017H 1 &lt;br /&gt;Unused opcode 6 00018H-0001 BH 1 &lt;br /&gt;ESCape opocde 7 0001CH-0001FH 1 &lt;br /&gt;Timer 0 8 00020H-00023H 2A &lt;br /&gt;Reserved 9 00024H-00027H &lt;br /&gt;DMAO 10 00028H-0002BH 4 &lt;br /&gt;DMA1 11 0OO2CH-0002FH 5 &lt;br /&gt;INTO 12 00030H-00033H 6 &lt;br /&gt;INT1 13 00034H-00037H 7 &lt;br /&gt;INT2 14 00038H-0003BH 8 &lt;br /&gt;INT3 15 0003CH-0003FH 9 &lt;br /&gt;80187 16 00040H-00043H 1 &lt;br /&gt;Reserved 17 00044H-00047H &lt;br /&gt;Timer 1 18 00048H-0004BH 2B &lt;br /&gt;Timer 2 19 0004CH-0004FH 2C &lt;br /&gt;Serial 0 receiver 20 00050H-00053H 3A &lt;br /&gt;Serial 0 transmitter 21 00054H-00057H 3B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: Priority level 1 has the highest priority and level 9 the lowest. Some &lt;br /&gt;interrupts have the same priority. Only the EB and EC versions contain the &lt;br /&gt;serial unit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt controller operates in two modes: master and slave mode. The mode is se-&lt;br /&gt;lected by a bit in the interrupt control register (EB and EC versions) called the CAS bit. If the &lt;br /&gt;CAS bit is a logic 1, the interrupt controller connects to external 8259A programmable interrupt &lt;br /&gt;controllers (see Figure 15-9); if CAS is a logic 0, the internal interrupt controller is selected. In &lt;br /&gt;many cases, there are enough interrupts within the 80186/80188, so the slave mode is not nor-&lt;br /&gt;mally used. Note that in the XL and EA versions, the master and slave modes are selected in the &lt;br /&gt;peripheral control register at offset address FER. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-8 80186/80188 &lt;br /&gt;programmable interrupt &lt;br /&gt;controller (Courtesy of Intel &lt;br /&gt;Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIMER TIMER TIMER DMA DMA &lt;br /&gt;o 1 2 D , INTO INT1 INT2 INT3 NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMAD &lt;br /&gt;CONTROL REG. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMAl &lt;br /&gt;CONTROL REG. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXT. INPUT 0 &lt;br /&gt;CONTROL REO. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C~T:'~:E~. I &lt;br /&gt;EXT. INPUT 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTROL REG. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTERRUPT &lt;br /&gt;PRIORITY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESOLVER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTERRUPT &lt;br /&gt;REQUEST REG. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTl!RRUPT &lt;br /&gt;MASK REG. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;..... ---&amp;lt;001 IN-SERYICE &lt;br /&gt;REO. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRIOR. LEV; &lt;br /&gt;MASK REG. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-----&amp;lt;001 ~~:T~R~. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHANCEMENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClKIN A191#ONCE &lt;br /&gt;OSCOUT AI8 &lt;br /&gt;ClKOUT A17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Al6 &lt;br /&gt;RESIN A15 &lt;br /&gt;RESOUT A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A13 &lt;br /&gt;HOLD A12 &lt;br /&gt;HlDA A11 &lt;br /&gt;NMI A10 &lt;br /&gt;INTO A9 &lt;br /&gt;INT1 A8 &lt;br /&gt;INT2 &lt;br /&gt;INT3 AD7 &lt;br /&gt;INT4 AD6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD5 &lt;br /&gt;TOIN AD4 &lt;br /&gt;TOOUT AD3 &lt;br /&gt;T1IN AD2 &lt;br /&gt;T10UT AD1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 ADO P2.DIRXD1 &lt;br /&gt;P2.1fTXD1 RD &lt;br /&gt;P2.21BlCK1 WR &lt;br /&gt;P2.31SINT1 ALE &lt;br /&gt;P2.4I#CTS DEN &lt;br /&gt;P2.5IBlCKD DTI#R &lt;br /&gt;P2.6 &lt;br /&gt;P2.7 lC5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UCS &lt;br /&gt;READY &lt;br /&gt;TEST P1.DI#GCSO &lt;br /&gt;lOCK P1.1I#GCS1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P1.21#GCS2 &lt;br /&gt;52 P1.31#GCS3 &lt;br /&gt;S1 P1.41#GCS4 &lt;br /&gt;SO P1.5J#GCS5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P1.61#GCS6 &lt;br /&gt;RF5H P1.71#GCS7 &lt;br /&gt;PDTMR &lt;br /&gt;CT50 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52 RXDD TXDO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80C188EB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-9 The interconnection between the 80C188EB and two 8259A programmable &lt;br /&gt;interrupt controllers. Note: Only the connections vital for this interface are shown. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;597 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This portion of the text does not detail the programming of the interrupt controller. Instead, &lt;br /&gt;it is limited to a discussion of the internal structure of the interrupt controller. The programming &lt;br /&gt;and application of the interrupt controller is discussed in the sections that describe the timer and &lt;br /&gt;DMA controller. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Controller Registers. Figure 15-10 illustrates the interrupt controller registers, which &lt;br /&gt;are located in the peripheral control block beginning at offset address 22H (except for the EC &lt;br /&gt;version, which is compatible with the 8259A and uses ports at offset addresses OOH and 02H for &lt;br /&gt;the master an~ 04H and 06H for the slave). In the EB version, the interrupt controller is pro-&lt;br /&gt;grammed at offset address 02H. Also notice that the EB version has an additional interrupt input &lt;br /&gt;(mT4). &lt;br /&gt;Siave Mode. When the interrupt controller operates in the slave mode, it uses up to two external &lt;br /&gt;8259A programmable interrupt controllers for interrupt input expansion. Figure 15-9 shows &lt;br /&gt;how the external interrupt controllers connect to the 80186/80188 interrupt input pins for slave &lt;br /&gt;operatiop.. Here the INTO and INTI inputs are used as external connections to the interrupt re-&lt;br /&gt;quest outputs of the 8259s, and INTAO (INT2) and INTAI (INT3) are used as interrupt ac-&lt;br /&gt;knowledge signals to the external controllers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Control Registers. There are interrupt control registers in both modes of operation that &lt;br /&gt;each control a single interrupt source. Figure 15-11 depicts the binary bit pattern of each of these &lt;br /&gt;interrupt control registers. The mask bit enables (0) or disables (I) the interrupt input represented &lt;br /&gt;by the control word, and the priority bits set the priority level of the interrupt source. The highest &lt;br /&gt;priority level is 000, and the lowest is Ill. The CAS bit is used to enable slave or cascade mode &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;598 CHAPTER 15 THE 80186. 80188. AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-10 The I/O &lt;br /&gt;offset port assignment for the &lt;br /&gt;interrupt control unit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-11 The inter-&lt;br /&gt;rupt control registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XL and EA Versions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT3 Control Register 1EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT2 Control Register 1CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT1 Control Register 1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTO Control Register 18H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA 1 Control Register I 16H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMAO Control Register 14H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer Control Register 12H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Status 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Request OEH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In Service OCH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRIMSK OAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Masks 08H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POLL Status 06H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POLL 04H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EOI 02H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer and Serial Control Registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT2. INT3. and INT4 Control Registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EB Version &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT3 Control Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT2 Control Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT1 Control Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTO Control Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT4 Control Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Serial Control Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer Control Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Status &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Request &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In Service &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRIMSK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Masks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POLL Status &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POLL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EOI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I I I I I I I I r I i I P21 Pl I POI &lt;br /&gt;INTO and INT1 Control Registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I [ [ [ [ [~[ ~ [ r I i [ P2 [ Pl [ PO [ &lt;br /&gt;P2-PO = Priority Level &lt;br /&gt;Mask = 0 enables interrupt &lt;br /&gt;L VL = 0 = edge and 1 = level triggering &lt;br /&gt;CAS = 1 selects slave mode &lt;br /&gt;SFNM = 1 selects special fully nested mode &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHANCEMENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-12 The inter-&lt;br /&gt;rupt request register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Request Register (EB version) &lt;br /&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-- I I I I I I I I ~ I ~ I ~ I ~ I ~ I ~ I I r I &lt;br /&gt;Interrupt Request Register (XL and EA versions) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I IIIIIII 1~1~1~1~1~1~llrl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;599 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(0 enables slave mode), and the SFNM bit selects the special fully nested mode. The SFNM al-&lt;br /&gt;lows the priority structure of the 82S9A to be maintained. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Request Register. The interrupt request register contains an image of the intelTUpt &lt;br /&gt;sources in each mode of operation. Whenever an interrupt is requested, the corresponding inter-&lt;br /&gt;rupt request bit becomes a logic 1 even if the interrupt is masked. The request is cleared when-&lt;br /&gt;ever the 80186/80188 acknowledges the interrupt. Figure IS-12 illustrates the binary bit pattern &lt;br /&gt;of the interrupt request register for both the master and slave modes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mask and Priority Mask Registers. The interrupt mask register has the same format as the inter-&lt;br /&gt;rupt request register illustrated in Figure IS-12. If a source is masked (disabled), the corre-&lt;br /&gt;sponding bit of the interrupt mask register contains a logic I; if enabled, it contains a logic O. The &lt;br /&gt;interrupt mask register is read to determine which interrupt sources are masked and which are &lt;br /&gt;enabled. A source is masked by setting the source's mask bit in its interrupt control register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The priority mask register, illustrated in Figure IS-13, shows the priority of the interrupt &lt;br /&gt;currently being serviced by the 80186/80188. The level of the interrupt is indicated by priority &lt;br /&gt;bits P2-PO. Internally, these bits prevent an interrupt by a lower priority source. These bits are &lt;br /&gt;automatically set to the next lower level at the end of an interrupt as issued by the 80186/80188. &lt;br /&gt;If no other interrupts are pending, these bits are set (Ill) to enable all priority levels. &lt;br /&gt;In-service Register. The in-service register has the same binary bit pattern as the request reg-&lt;br /&gt;ister of Figure 15-12. The bit that corresponds to the interrupt source is set if the 80186/80188 is &lt;br /&gt;currently acknowledging the interrupt. The bit is reset at the end of an interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Poll and Poll Status Registers. Both the interrupt poll and interrupt poll status registers &lt;br /&gt;share the same binary bit patterns as those illustrated in Figure 15-14. These registers have a bit &lt;br /&gt;(INT REQ) that indicates an interrupt is pending. This bit is set if an interrupt is received with &lt;br /&gt;sufficient priority, and cleared when an interrupt is acknowledged. The S-bits indicate the inter-&lt;br /&gt;rupt vector type number of the highest priority pending interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;These two registers may appear to be identical because they contain the same informa-&lt;br /&gt;tion. However, they differ in function. When the interrupt poll register is read, the interrupt is &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-13 The priority &lt;br /&gt;mask register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Priority Mask Register &lt;br /&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I I I I I I I I I I P21 Pl I PO I &lt;br /&gt;P2-PO = Priority Level &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;600 CHAPTER 15 THE 80186,80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-14 The poll &lt;br /&gt;and poll status registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Poll and Poll Status Registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;liIIIIIIIIIIIII;I~ITlxl &lt;br /&gt;IREO = 1 = Interrupt pending &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VT4-VTO = Interrupt type number of highest priority pending interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;acknowledged. When the interrupt poll status register is read, no acknowledge is sent. These &lt;br /&gt;registers are used only in the master mode, and not the slave mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;End-ot-interrupt Register. The end-of-interrupt (EOI) register causes the termination of an in-&lt;br /&gt;terrupt when written by a program. Figure 15-1S shows the contents of the EOI register for both &lt;br /&gt;the master and slave mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the master mode, writing to the EOI register ends either a specific interrupt level or &lt;br /&gt;whatever level is currently active (nonspecific). In the nonspecific mode, the NSPEC bit must be &lt;br /&gt;set before the EOI register is written to end a nonspecific interrupt. The nonspecific EOI clears &lt;br /&gt;the highest level interrupt bit in the in-service register. The specific EOI clears the selected bit in &lt;br /&gt;the in-service register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the slave mode, the level of the interrupt to be terminated is written to the EOI register. &lt;br /&gt;The slave mode does not allow a nonspecific EOI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Status Register. The format of interrupt status register is depicted in Figure 15-16. In &lt;br /&gt;the master mode, T2-TO indicates which timer (timer 0, timer 1, or timer 2) is causing an inter-&lt;br /&gt;rupt. This is necessary because all three timers have the same interrupt priority level. These bits &lt;br /&gt;are set when the timer requests an interrupt and are cleared when the interrupt is acknowledged. &lt;br /&gt;The DHLT (DMA halt) bit is used only in the master mode; when set, it stops a DMA action. &lt;br /&gt;Note that the interrupt status register is different for the EB version. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-15 The end of &lt;br /&gt;interrupt (EOI) register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-16. The inter-&lt;br /&gt;rupt status register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;End of Interrupt Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Status Register (XL and EA) &lt;br /&gt;15 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~I &lt;br /&gt;Interrupt Status Register (EB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I NMII I I I I I I I I I I STX I SRX I T21 T1 I TO I &lt;br /&gt;SRX = serial receiver &lt;br /&gt;STX = serial transmitter &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHANCEMENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-17 The inter-&lt;br /&gt;rupt vector register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Vector Register (slave) &lt;br /&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I I I I I I I I T41 T31. ~21 T1 I TO I &lt;br /&gt;601 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Vector Register. The intermpt vector register is present only in the slave mode and &lt;br /&gt;only in the XL and EA versions at offset address 20H. It is used to specify the most-significant &lt;br /&gt;five bits of the interrupt vector type number. Figure 15-17 illustrates the format of this register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timers &lt;br /&gt;The 80186/80188 contain three fully programmable 16-bit timers. Each is totally independent of &lt;br /&gt;the others. Two of the timers (timer 0 and timer 1) have input and output pins that allow them to &lt;br /&gt;count external events or generate wave-forms. The third timer (timer 2) connects to the &lt;br /&gt;80186/80188 clock and is used as a DMA request source, a prescaler for other timers, or as a &lt;br /&gt;watchdog timer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 15-18 shows the internal structure of the timer unit. Notice that the timer unit con-&lt;br /&gt;tains one counting element that is responsible for updating all three counters. Each timer is actu-&lt;br /&gt;ally a register that is rewritten from the counting element (a circuit that reads a value from a &lt;br /&gt;timer register and increments it before returning it). The counter element is also responsible for &lt;br /&gt;generating the outputs through pins TOOUT and TlOUT, reading the TorN and TlIN pins, and &lt;br /&gt;causing a DMA request from the terminal count (TC) of timer 2. Timer 2 is programmed to re-&lt;br /&gt;quest a DMA action. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer Register Operation. The timers are controlled by a block of registers in the peripheral &lt;br /&gt;control block (see Figure 15-19). Each timer has a count register, maximum-count register or &lt;br /&gt;registers, and a control register. These registers may all be read or written at any time because the &lt;br /&gt;80186/80188 microprocessors ensure that the contents never change during a read or write. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The timer count register contains a 16-bit number that is incremented whenever an input to the &lt;br /&gt;timer occurs. Timers 0 and 1 are incremented at the positive edge on an external input pin, every &lt;br /&gt;fourth 80186/80188 clock, or by the output of timer 2. Timer 2 is clocked on every fourth 80186/80188 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-18 Internal &lt;br /&gt;structure of the 80186/80188 &lt;br /&gt;timers (Courtesy of Intel &lt;br /&gt;Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CPU &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA &lt;br /&gt;REQUEST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T. &lt;br /&gt;IN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T, &lt;br /&gt;IN &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;602 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-19 The offset &lt;br /&gt;locations and contents of the &lt;br /&gt;registers used to control the &lt;br /&gt;timers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(XL and EA) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;(EB and EC) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;j &lt;br /&gt;46H or66H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;44H or64H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;42H or62H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40H or60H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3EH or5EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3CH or5CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3AH or5AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38H or58H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36H or 56H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34H or54H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32H or52H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30H or 50H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T2 Control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T2 Compare A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T2 Count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 Control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 Compare B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 Compare A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 Count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TO Control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TO Compare B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TO Compare A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TO Count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer Control Register (O and 1) &lt;br /&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I~ I~ I~ I~ I I I I I I I~I ~I pi ~I ~I~ &lt;br /&gt;Timer Control Register (2) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I~I~I~IIIIIIII~IIIII~ &lt;br /&gt;clock pulse and has no other timing source. This means that in the 8 MHz version of the &lt;br /&gt;80186/80188, timer 2 operates at 2 MHz and the maximum counting frequency oftimers 0 and 1 is &lt;br /&gt;2 MHz. Figure 15-20 depicts these four clocking periods, which are not related to the bus timing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each timer has at least one maximum count called a compare register (compare register A &lt;br /&gt;for timers 0 and 1) that is loaded with the maximum count of the count register to generate an &lt;br /&gt;output. Whenever the count register is equal to the maximum-count compare register, it is cleared &lt;br /&gt;to O. With a maximum count of OOOOH, the counter counts 65,536 times. For any other value, the &lt;br /&gt;timer counts the true value of the count. For example, if the maximum count is 0002H, then the &lt;br /&gt;counter will count from 0 to 1 and then be cleared to O-a modulus 2 counter has two states. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timers 0 and 1 each have a second maximum-count compare register (compare register B) &lt;br /&gt;that is selected by the control register for the timer. Either maximum-count compare register A &lt;br /&gt;or both maximum-count compare registers A and B are used with these timers as programmed by &lt;br /&gt;the AL T bit in the control register for the timer. When both maximum-count compare registers &lt;br /&gt;are used, the timer counts up to the value in maximum-count compare register A, clears to 0, and &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHANCEMENTS 603 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIMER IN &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIMER IN &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIMER 0 &lt;br /&gt;SERVICED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIMER 1 &lt;br /&gt;SERVICED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIMER 2 &lt;br /&gt;SERVICED DEAD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIMER 0 &lt;br /&gt;SERVICED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1MEROUT ----------------------------------~r------~---------------------&lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIMER OUT &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Timer in 0 resolution time &lt;br /&gt;2. Timer in 1 resolution time &lt;br /&gt;3. Modified count value written into 80186 timer 0 count register &lt;br /&gt;4. Modified count value written into 80186 tim' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-20 Timing for the 80186/80188 timers (Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;then counts up to the count in maximum-count compare register B. This process is then repeated. &lt;br /&gt;Using both maximum-count registers allows the timer to count up to 131,072. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The control register (refer again to Figure 15-19) of each timer is 16-bits wide and speci-&lt;br /&gt;fies the operation of the timer. A definition of each control bit follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EN The enable bit allows the timer to start counting. If EN is cleared, the timer will &lt;br /&gt;not count. If it is set, the timer counts. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INH The inhibit bit allows a write to the timer control register to affect the enable bit &lt;br /&gt;(EN). If INH is set, then the EN bit can be set or cleared to control the counting. If &lt;br /&gt;INH is cleared, EN is not affected by a write to the timer control register. This &lt;br /&gt;allows other features of the timer to be modified without enabling or disabling the &lt;br /&gt;timer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RIU &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Me &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RTG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt bit allows an interrupt to be generated by the timer. If INT is set, an &lt;br /&gt;interrupt will occur each time that the maximum count is reached in either &lt;br /&gt;maximum-count compare register. If this bit is cleared, no interrupt is generated. &lt;br /&gt;When the interrupt request is generated, it remains in force even if the EN bit is &lt;br /&gt;cleared after the interrupt request. &lt;br /&gt;The register in use bit indicates which maximum-count compare register is &lt;br /&gt;currently in use by the timer. If RID is a logic 0, then maximum-count compare &lt;br /&gt;register A is in use. This bit is a read-only bit, and writes do not affect it. &lt;br /&gt;The maximum count bit indicates that the timer has reached its maximum count. &lt;br /&gt;This bit becomes a logic 1 when the timer reaches its maximum count, and &lt;br /&gt;remains a logic 1 until the Me bit is cleared by writing a logic O. This allows the &lt;br /&gt;maximum count to be detected by software. &lt;br /&gt;The re-trigger bit is active only for external clocking (EXT = 0). The RTG bit is &lt;br /&gt;used only with timers 0 and 1 to select the operation of the timer input pins (TorN &lt;br /&gt;and TlIN). If RTG is a logic 0, the external input will cause the timer to count if &lt;br /&gt;it is a logic 1; the timer will hold its count (stop counting) if it is a logic O. If RTG &lt;br /&gt;is a logic I, the external input pin clears the timer count to OOOOH each time a &lt;br /&gt;positive edge occurs. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;604 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;p &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The prescaier bit selects the clocking source for timers 0 and I. If EXT = 0 and &lt;br /&gt;P = 0, the source is one-fourth the system clock frequency. If P = 1, the source is &lt;br /&gt;timer 2. &lt;br /&gt;The external bit selects internal timing (EXT = 0) or external timing (EXT = 1). &lt;br /&gt;If EXT = 1, the timing source is applied to the TOIN or TUN pins. In this mode, &lt;br /&gt;the timer increments after each positive-edge on the timer input pin. If EXT = 0, &lt;br /&gt;the clocking source is from one of the internal sources. &lt;br /&gt;The alternate bit selects single maximum-count mode (maximum-count compare &lt;br /&gt;register A) if a logic 0 or alternate maximum-count mode (maximum-count &lt;br /&gt;compare registers A and B) if a logic 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONT The continuous bit selects continuous operation if a logic 1. In continuous &lt;br /&gt;operation, the counter automatically continues counting after it reaches its &lt;br /&gt;maximum count. If CaNT is a logic 0, the timer will automatically stop couming &lt;br /&gt;and clear the EN bit. Note that whenever the 80186/80188 are reset the timers are &lt;br /&gt;automatically disabled. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer Output Pin. Timers 0 and I have an output pin used to generate either square waves or &lt;br /&gt;pulses. To produce pulses, the timer is operated in single maximum-count mode (AL T = 0). In &lt;br /&gt;this mode, the output pin goes low for one clock period when the counter reaches its maximum &lt;br /&gt;count. By controlling the CaNT bit in the control register, either a single pulse or continuous &lt;br /&gt;pulses can be generated. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To produce square waves or varying duty cycles, the alternate mode (ALT = 1) is selected. &lt;br /&gt;In this mode, the output pin is a logic 1 while maximum-count compare register A controls the &lt;br /&gt;timer; it is a logic 0 while maximum-count compare register B controls the timer. As with the &lt;br /&gt;single maximum-count mode, the timer can generate either a single square wave or continuous &lt;br /&gt;square waves. Refer to Table 15-4 for the function of the ALT and CaNT control bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Almost any duty cycle can be generated in the altemate mode. For example, suppose that a &lt;br /&gt;10 percent duty cycle is required at a timer output pin. Maximum-count register A is loaded with a &lt;br /&gt;10 and maximum-count register B with a 90 to produce an output that is a logic 1 for 10 clocks and &lt;br /&gt;a logic 0 for 90 clocks. This also divides the frequency of the timing source by a factor of 100. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Real-time Clock Example. Many systems require the time of day. This is often called a real-&lt;br /&gt;time clock. A timer within the 80186/80188 can provide the timing source for software that &lt;br /&gt;maintains the time of day. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The hardware required for this application is too simple to illustrate. All that is required is &lt;br /&gt;that the TUN pin be connected to +5.0V through a pull-up resistor to enable timer 1. In the ex-&lt;br /&gt;ample, timers 1 and 2 are used to generate a I-second interrupt that provides the software with a &lt;br /&gt;timing source. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The software required to implement a real-time clock is listed in Examples 15-2 and 15-3. &lt;br /&gt;Example 15-2 illustrates the software required to initialize the timers. Example 15-3 shows an &lt;br /&gt;interrupt service procedure that keeps time. There is another procedure in Example 15-3 that in-&lt;br /&gt;crements a BCD modulus counter. None of the software required install the interrupt vector, and &lt;br /&gt;time of day is illustrated here. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-4 Fvnction of &lt;br /&gt;AL T and CONT in the timer &lt;br /&gt;control register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;o &lt;br /&gt;1 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;1 &lt;br /&gt;o &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Single pulse &lt;br /&gt;Continuous pulses &lt;br /&gt;Single square wave &lt;br /&gt;Continuous square waves &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHANCEMENTS 605 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 15-2 &lt;br /&gt;FF62 T2 _CA EQU OFF62H ;address of t ;mel 2 compare A &lt;br /&gt;FF66 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CON EQU OFF66H ;address of timer 2 control &lt;br /&gt;FF60 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CNT EQU OFF60H ; address of timer 2 count &lt;br /&gt;FF5A T1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CA EQU OFF5AH ; address of timer 1 compare A &lt;br /&gt;FF58 T1 _CON EQU OFF58H ;address of timer 1 control &lt;br /&gt;FF5E Tl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CNT EQU OFF5EH ;address of timer 1 count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 CLOCK_UP PROC F,\\P. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 B8 4E20 MOV AX,20000 ; count for timer 2 &lt;br /&gt;0013 BA FF62 MOV DX,T2_CA ;address timer 2 compare A &lt;br /&gt;0016 EE OUT DX,AL ;program for 10 ms &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 B8 0064 MOV AX,100 ; count for timer 1 &lt;br /&gt;001A BA FF5A MOV DX,T1_CA ;address timer 1 compare A &lt;br /&gt;001D EE OUT DX,AL ;program for 1 second &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001E B8 0000 MOV AX,O &lt;br /&gt;0021 BA FF60 MOV DX,T2_CNT ;address timer 2 count &lt;br /&gt;0024 EE OUT DX,AL ;clear count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0025 BA FF5E MOV DX,Tl_CNT ;address timer 1 count &lt;br /&gt;0028 EE OUT DX,AL ;clear count &lt;br /&gt;0029 B8 COOl MOV AX,OC001H ;enable timer 2 &lt;br /&gt;002C BA FF66 MOV pX,T2_CON ;address timer 2 control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;002F EE OUT DX,AL &lt;br /&gt;0030 B8 E009 MOV AX,OE009H ;enable timer 1 &lt;br /&gt;0033 BA FF58 MOV DX,T1_CON ; address timer 1 control &lt;br /&gt;0036 EE OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0037 CB RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 CLOCK_UP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timer 2 is programmed to divide by a factor of 20,000. This causes the clock (2 MHz on &lt;br /&gt;the 8 MHz version of the 80186/80188) to be divided down to one pulse every 10 ms. The clock &lt;br /&gt;for timer 1 is derived internally from the timer 2 output. Timer 1 is programmed to divide by 100 &lt;br /&gt;and generates a pulse once per second. The control register of timer 1 is programmed so that this &lt;br /&gt;one-second pulse generates an interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt service procedure is called once per second to keep time. This procedure in-&lt;br /&gt;crements the contents of memory location SECONDS. Once every 60 seconds, the contents of &lt;br /&gt;next memory location (SECONDS + 1) is incremented. Finally, once per hour, the contents of &lt;br /&gt;memory location SECONDS + 2 is incremented. The time is stored in these three consecutive &lt;br /&gt;memory locations in BCD so the system software can easily access the time. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 15-3 &lt;br /&gt;0000 00 SECONDS DB ;time &lt;br /&gt;0001 00 MINUTES DB &lt;br /&gt;0002 00 HOURS DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 INTRS PROC FAR USES AX SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0102 BE 0000 R MOV SI,OFFSET SECONDS ; address time &lt;br /&gt;0105 B4 60 MOV AH,60H &lt;br /&gt;0107 E8 OOOF CALL UP_COUNT jincrement seconds &lt;br /&gt;010A 75 01&amp;gt;. JNZ ENDI &lt;br /&gt;010C E8 OOOA CALL UP_COUNT ; increment minutes &lt;br /&gt;010F 75 05 JNZ EtTDI &lt;br /&gt;0111 B4 24 MOV AH,24H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;606 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0113 E8 C003 CALL UP_COUNT ;increment hours &lt;br /&gt;0116 El-::JI: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0119 :r-:7RS ENDP &lt;br /&gt;0119 UP_COUNT PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0119 2E: 8A 04 MOV AL,CS: [SI] ;get count &lt;br /&gt;011C 46 INC SI &lt;br /&gt;0110 04 01 ADD AL,l ;increment count &lt;br /&gt;011F 27 OM ;make it BCD &lt;br /&gt;0120 2E: 88 44 FF MOV CS: [SI-1] ,AL ;save new count &lt;br /&gt;0124 2A C4 SUB AL,AH ;test modulus &lt;br /&gt;0126 75 04 JNE ENDU ;if no roll-over needed &lt;br /&gt;0128 2E: 88 44 FF MOV CS: [SI-1] ,AL ;clear count &lt;br /&gt;012C ENDU: &lt;br /&gt;012C C3 RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0120 UP_COUNT ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA Controller &lt;br /&gt;The DMA controller within the 80186/80188 has two fully independent DMA channels. Each &lt;br /&gt;has its own set of 20-bit address registers, so any memory or YO location is accessible for a &lt;br /&gt;DMA transfer. In addition, each channel is programmable for auto-increment or auto-decrement &lt;br /&gt;to either source or destination registers. This controller is not available in the EB or EC versions. &lt;br /&gt;The EC version contains a modified 4-channel DMA controller, while the EB version contains &lt;br /&gt;no DMA controller. This text does not describe the DMA controller within the EC version. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 15-21 illustrates the internal register structure of the DMA controller. These regis-&lt;br /&gt;ters are located in the peripheral control block at offset addresses COH-DFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that both DMA channel register sets are identical. Each channel contains a control &lt;br /&gt;word, a source and destination pointer, and a transfer count. The transfer count is 16-bits and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFFSET &lt;br /&gt;DEH &lt;br /&gt;DCK &lt;br /&gt;DAH &lt;br /&gt;DIH &lt;br /&gt;DlH &lt;br /&gt;D4H &lt;br /&gt;D2H &lt;br /&gt;DOH &lt;br /&gt;CEH &lt;br /&gt;CCH &lt;br /&gt;CAH &lt;br /&gt;ClH &lt;br /&gt;ClH &lt;br /&gt;C4H &lt;br /&gt;C2H &lt;br /&gt;COH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SOURCE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;x &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;III &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;III &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;x x &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I Ixl I I &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11' 1. &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;he 1. &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;)C )C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I I xl I I &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;III III 11. 1. &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;III III 11. 1. &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SYNCHRONIZATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTROL WOAD &lt;br /&gt;TRANSFER COUNT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DESTINATION POINTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SOURCE POINTER CHANNEL 1 f &lt;br /&gt;CHANNEL 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONTROL WORD â¢ &lt;br /&gt;TRANSFER COUNT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DESTINATION POINTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SOURCE POINTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-21 Register structur~ of the 80186/80188 DMA controller (Courtesy of Intel &lt;br /&gt;Corporation) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHMJCEMENTS 607 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;allows unattended DMA transfers of bytes (80188/80186) and words (80186 only). Each time &lt;br /&gt;that a byte or word is transferred, the count is decremented by I until it reaches OOOOH-the ter-&lt;br /&gt;minal count. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The source and destination pointers are each 20-bits wide, so DMA transfers can occur to &lt;br /&gt;any n:emory location or I/O address without concem for segment and offset addresses. If the source &lt;br /&gt;or destination address is an I/O pOlt, bits A 19-A 16 must be 0000 or a malfunction may occur. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Channel Control Register. Each DMA channel contains its own channel comrol register (refeI &lt;br /&gt;to Figure 15-21), which defines its operation. The leftmost 6-bits specify the operation of the &lt;br /&gt;source and destination registers. The MIIO bit indicates a memory or I/O location, DEC causes &lt;br /&gt;the pointer to be decremented, and INC causes the pointer to be incremented. If both the INC and &lt;br /&gt;DEC bits are I, then the pointer is unchanged after each DMA transfer. Notice that memory-to-&lt;br /&gt;memory transfers are possible with this DMA controller. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The TC (terminal count) bit causes the DMA channel to stop transfers when the channel &lt;br /&gt;count register is decremented to OOOOH. If this bit is a logic 1, the DMA controller continues to &lt;br /&gt;transfer data even after the terminal count is reached. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The INT bit enables interrupts to the interrupt controller. If set, this bit causes an interrupt &lt;br /&gt;to be issued when the tenninal count of the channel is reached. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The SYN bit selects the type of synchronization for the channel: 00 = no synchronization, &lt;br /&gt;01 = source synchronization, and 10 = destination synchronization. When either unsynchronized &lt;br /&gt;or source synchronization is selected, data are transferred at the rate of 2M bytes per second. &lt;br /&gt;These two types of synchronization allow transfers to occur without interruption. If destination &lt;br /&gt;synchronization is selected, the transfer rate is slower (1.3M bytes per second), and the controller &lt;br /&gt;relinquishes control to the 80186/80188 after each DMA transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The P bit selects the channel priority. If P = 1, the channel has the highest priority. If both &lt;br /&gt;channels have the same priority, the controller alternates transfers between channels. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The TRDQ bit enables DMA transfers from timer 2. If this bit is a logic 1, the DMA re-&lt;br /&gt;quest originates from timer 2. This can prevent the DMA transfers from using all of the micro-&lt;br /&gt;processor's time for the transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CHG/NOCHG bit determines whether START/STOP changes for a write to the con-&lt;br /&gt;trol register. The START/STOP bit starts or stops the DMA transfer. To start a DMA transfer, &lt;br /&gt;both CHG/NOCHG and START/STOP are placed at a logic 1 level. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The BYTE/WORD bit selects whether the transfer is byte- or word-sized. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Sample Memory-fa-memory Transfer. The built-in DMA controller is capable of performing &lt;br /&gt;memory-to-memory transfers. The procedure used to program the controller and start the &lt;br /&gt;transfer is listed in Example 15-4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 15-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.186 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Memory-to-memory DMA transfer procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Ca1ling parameters: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS:SI = source address &lt;br /&gt;ES:DI = destination address &lt;br /&gt;CX = count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MACRO &lt;br /&gt;MOV &lt;br /&gt;SHL &lt;br /&gt;ADD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEGA,OFFA,DMAA &lt;br /&gt;AX, SEGA &lt;br /&gt;AX,4 &lt;br /&gt;AX,OFFA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; ; get segment &lt;br /&gt;;shift segment left 4 places &lt;br /&gt;;;add in offset &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;608 CHAPTER 15 THE 80186,80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 MOVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETA &lt;br /&gt;GETA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0032 BA FFC8 &lt;br /&gt;0035 8B Cl &lt;br /&gt;0037 EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 BA FFCA &lt;br /&gt;003B Ba B606 &lt;br /&gt;003E EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003F CB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0040 MOVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,DMAA &lt;br /&gt;OUT DX,AL &lt;br /&gt;PUSHF &lt;br /&gt;MOV AX,SEGA &lt;br /&gt;SHR AX,12 &lt;br /&gt;POPF &lt;br /&gt;ADD AX,O &lt;br /&gt;ADD DX,2 &lt;br /&gt;OUT DX,AL &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS,SI,OFFCOH &lt;br /&gt;ES,DI,OFFC4H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFC8H &lt;br /&gt;MOV AX,CX &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFCAH &lt;br /&gt;MOV AX,OB606H &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;address DMA controller &lt;br /&gt;;;program rightmost 16-bits &lt;br /&gt;;;save possible carry &lt;br /&gt;; ; get segment &lt;br /&gt;;;for leftmost 4-bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;add in possible carry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program source address &lt;br /&gt;;program destination address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;start transfer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure in Example 15-4 transfers data from the data segment location addressed &lt;br /&gt;by SI into the extra segment location addressed by DI. The number of bytes transferred is held in &lt;br /&gt;register CX. This operation is identical to the REP MOVSB instruction, but execution occurs at &lt;br /&gt;a much higher speed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Chip Selection Unit &lt;br /&gt;The chip selection unit simplifies the interface of memory and I/O to the 80186/80188. This unit &lt;br /&gt;contains programmable chip selection logic. In small- and medium-sized systems, no external &lt;br /&gt;decoder is required to select memory and I/O. Large systems, however, may still require external &lt;br /&gt;decoders. There are two forms of the chip selection unit; one form found in the XL and EA ver-&lt;br /&gt;sions differs from the unit found in the EB and EC versions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Chip Selects. Six pins (XL and EA versions) or 10 pins (EB and EC versions) are &lt;br /&gt;used to select different external memory components in a small- or medium-sized &lt;br /&gt;801 86/801 88-based system. The UCS (upper chip select) pin enables the memory device lo-&lt;br /&gt;cated in the upper portion of the memory map most often populated with ROM. This program-&lt;br /&gt;mable pin allows the size of the ROM to be specified and also the number of wait states &lt;br /&gt;required. Note that the ending address of the ROM is FFFFFH. The LCS (lower chip select) pin &lt;br /&gt;selects the memory device (usually a RAM) that begins at memory location OOOOOH. As with &lt;br /&gt;the UCS pin. the memory size and number of wait states are programmable. The remaining four &lt;br /&gt;or eight pins select middle memory devices. The four pins in the XL and EA version &lt;br /&gt;(MCS3-MCSO) are programmed for both the starting (base) address and memory size. Note &lt;br /&gt;that all devices must be of the same size. The e;~ht pins (GCS7-GCSO) in lilt:: EB and EC ver-&lt;br /&gt;sions are programmed by size all&amp;quot;: ~:so by starting address and can represent a memory device &lt;br /&gt;or an 110 device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Peripheral Chip Selects. The 80186/80188 address up to seven external peripheral devices with &lt;br /&gt;pins PCSG-PCSO (in the XL and EA versions). The GCS pins are used. in the EB and EC ver-&lt;br /&gt;sions to select up to eight memory or I/O rkvices. The base 110 address is programmed at any &lt;br /&gt;I K-byte interval with port address block sizes of 128 bytes. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHANCEMENTS 609 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-5 Wait state &lt;br /&gt;control bits R2, R 1 , and RO R2 R1 RO Number of Waits READY required &lt;br /&gt;(XL and EA versions) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 X X Yes &lt;br /&gt;1 0 0 0 No &lt;br /&gt;1 0 1 1 No &lt;br /&gt;1 1 0 2 No &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 3 No &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the Chip Selection Unit for XL and fA Versions. The number of wait states in each &lt;br /&gt;section of the memory and the I/O are programmable. The 80186/80188 microprocessor have &lt;br /&gt;built-in wait state generators that can introduce between 0-3 wait states. Table 15-5 lists the &lt;br /&gt;logic levels required on bits R2-RO in each programmable register to select variou, numbers of &lt;br /&gt;wait states. These three lines also select if an external READY signal is required to generate wait &lt;br /&gt;states. If READY is selected, the external READY signal is in parallel with the internal wait &lt;br /&gt;state generator. For example, if READY is a logic 0 for three clocking periods. but the internal &lt;br /&gt;wait state generator is programmed to insert two wait states, then three are inserted. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a 64K-byte EPROM is located at the top of the memory system and requires &lt;br /&gt;two wait states for proper operation. To select this device for this section of memory. the ues &lt;br /&gt;pin is programmed for a memory range of FOOOOH-FFFFFH with two wait states. figure 15-22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-22 The chip &lt;br /&gt;selection registers for the XL &lt;br /&gt;and EA versions of the &lt;br /&gt;80186/80188 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;Upper Memory Control Register (offset = AOH) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Lower Memory Control Register (offset = A2H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Peripheral Chip Select Base Address (offset = A4H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mid-range Memory Base Address (offset = ASH) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mid-range Memory Size (offset = A8H) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;610 CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-6 Upper memo-&lt;br /&gt;ry programming for register Start Address Block Size Value for No Waits, No READY &lt;br /&gt;AOH (XL and EA versions) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFCOOH 1K 3FC4H &lt;br /&gt;FF800H 2K 3F84H &lt;br /&gt;FFOOOH 4K 3F04H &lt;br /&gt;FEOOOH 8K 3E04H &lt;br /&gt;FCOOOH 16K 3C04H &lt;br /&gt;F8000H 32K 3804H &lt;br /&gt;FOOOOH 64K 3004H &lt;br /&gt;EOOOOH 128K 1004H &lt;br /&gt;COOOOH 256K 0OO4H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lists the control registers for all memory and I/O selections in the peripheral control block at &lt;br /&gt;offset addresses AO-A9H. Notice that the rightmost 3-bits of these control registers are from &lt;br /&gt;Table 15-5. The control register for the upper memory area is at location PCB offset address &lt;br /&gt;AOH. This I6-bit register is programmed with the starting address of the memory area (FOOOOH, &lt;br /&gt;in this case) and the number of wait states. Please note that the upper 2-bits of the address must &lt;br /&gt;be programmed as 00 and that only address bits AI7-AIO are programmed into the control reg-&lt;br /&gt;ister. Refer to Table 15-6 for examples illustrating the codes for various memory sizes. Because &lt;br /&gt;our example requires two wait states, the basic address is the same as in the table for a 64K de-&lt;br /&gt;vice, except that the rightmost 3-bits are 110 instead of 100. The datum sent to the upper memory &lt;br /&gt;control register is 3006H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Suppose that a 32K-byte SRAM that requires no waits and no READY input is located at &lt;br /&gt;the bottom of the memory system. To program the LCS pin to select this device, register A2 is &lt;br /&gt;loaded in exactly the same manner as register AOH. In this example, a 07FCH is sent to register &lt;br /&gt;A2H. Table 15-7 lists the programming values for the lower chip selection output. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The central part of the memory is programmed via two registers: A6H and A8H. Register &lt;br /&gt;A6H programs the beginning or base address of the middle memory select lines (MCS3-MCSO) &lt;br /&gt;and number of waits. Register A8H defines the size of the block of memory and the individual &lt;br /&gt;memory device size (refer to Table 15-8). In addition to block size, the number of peripheral &lt;br /&gt;wait states are programmed as with other areas of memory. The EX (bit 7) and MS (bit 6) specify &lt;br /&gt;the peripheral selection lines and will be discussed shortly. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, suppose that four 32K-byte SRAMs are added to the middle memory area &lt;br /&gt;beginning at location 80000H and ending at location 9FFFFH with no wait states. To program &lt;br /&gt;the middle memory selection lines for this area of memory, we place the leftmost 7-bits in &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-7 Lower memo-&lt;br /&gt;ry programming for register &lt;br /&gt;A2H (XL and EA versions) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ending Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003FFH &lt;br /&gt;007FFH &lt;br /&gt;OOFFFH &lt;br /&gt;01FFFH &lt;br /&gt;03FFFH &lt;br /&gt;07FFFH &lt;br /&gt;OFFFFH &lt;br /&gt;1FFFFH &lt;br /&gt;3FFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Block Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1K &lt;br /&gt;2K &lt;br /&gt;4K &lt;br /&gt;8K &lt;br /&gt;16K &lt;br /&gt;32K &lt;br /&gt;64K &lt;br /&gt;128K &lt;br /&gt;256K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Value for No Waits, No READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004H &lt;br /&gt;0044H &lt;br /&gt;OOC4H &lt;br /&gt;01C4H &lt;br /&gt;03C4H &lt;br /&gt;07C4H &lt;br /&gt;OFC4H &lt;br /&gt;1 FC4H &lt;br /&gt;3FC4H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-2 PROGRAMMING THE 80186/80188 ENHANCEMENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-8 Middle memo-&lt;br /&gt;ry programming for register &lt;br /&gt;A8H (XL and EA versions) Block Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8K &lt;br /&gt;16K &lt;br /&gt;32K &lt;br /&gt;64K &lt;br /&gt;128K &lt;br /&gt;256K &lt;br /&gt;512K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Chip Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2K &lt;br /&gt;4K &lt;br /&gt;8K &lt;br /&gt;16K &lt;br /&gt;32K &lt;br /&gt;64K &lt;br /&gt;128K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Value for No waits, No &lt;br /&gt;READY, and EX=O MS=1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0144H &lt;br /&gt;0344H &lt;br /&gt;0744H &lt;br /&gt;OF44H &lt;br /&gt;1F44H &lt;br /&gt;3F44H &lt;br /&gt;7F44H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;611 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;register A6H, with bits 8-3 containing logic O's and the rightmost 3-bits containing the ready &lt;br /&gt;control bits. For this example, register A6H is loaded with 8004H. Register A8H is programmed &lt;br /&gt;with a IF44H, assuming that EX = 0 and MS = I and no wait states and no READY are required &lt;br /&gt;for the peripherals. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register A4H programs the peripheral chip selection pins (PCS6-PCSO) along with the &lt;br /&gt;EX and MS bits of register A8H. Register A4H holds the beginning or base address of the pe-&lt;br /&gt;ripheral selection lines. The peripherals may be placed in memory or I/O map. If they are &lt;br /&gt;placed in the I/O map, A 19-A 16 of the port number must be 0000. Once the starting address &lt;br /&gt;is programmed on any IK-byte I/O address boundary, the PCS pins are spaced at 128-byte &lt;br /&gt;intervals. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For example, if register A4H is programmed with a 0204H, with no waits and no READY &lt;br /&gt;synchronization, the memory address begins at 02000H or the I/O port begins at 2000H. In this &lt;br /&gt;case, the I/O ports are PCSO = 2000H, PCSI = 2080H, PCS2 = 2100H, PCS3 = 2180H, PCS4 = &lt;br /&gt;2200H, PCSS = 2280H, and PCS6 = 2300H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The MS bit of register A8H selects memory mapping or I/O mapping for the peripheral se-&lt;br /&gt;lect pins. If MS is a logic 0, then the PCS lines are decoded in the memory map. If it is a logic I, &lt;br /&gt;then the PCS lines are in the I/O map. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The EX bit selects the function of the PCSS and PCS6 pins. If EX = I, these PCS pins se-&lt;br /&gt;lect I/O devices. If EX = 0, these pins provide the system with latched address lines Al and A2. &lt;br /&gt;The Al and A2 pins are used by some I/O devices to select internal registers and are provided for &lt;br /&gt;this purpose. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming the Chip Selection Unit for fB and fC Versions. As mentioned earlier, the EB and &lt;br /&gt;EC versions have a different chip selection unit. These newer versions of the 80186/80188 con-&lt;br /&gt;tain an upper and lower memory chip selection pin as do earlier versions, but they do not contain &lt;br /&gt;middle selection and peripheral selection pins. In place of the middle and peripheral chip selec-&lt;br /&gt;tion pins, the EB and EC versions contain eight general chip selection pins (GCS7-GCSO) that &lt;br /&gt;select either a memory device or an I/O device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Programming is also different because each of the chip selection pins contains a starting &lt;br /&gt;address register and an ending address register. Refer to Figure IS-23 for the offset address of &lt;br /&gt;each pin and also the contents of the start and end registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that programming for the EB and EC versions of the 80186/80188 are much easier &lt;br /&gt;than for the earlier XL and XA versions. For example, to program the UCS pin for an address &lt;br /&gt;that begins at location FOOOOH and ends at location FFFFFH (64K bytes), the starting address &lt;br /&gt;register (offset = A4H) is programmed with F002H for a starting address of FOOOOH with two &lt;br /&gt;wait states. The ending address register (offset = A6H) is programmed with OOOEH for an ending &lt;br /&gt;address of FFFFFH for memory with no external READY synchronization. The other chip se-&lt;br /&gt;lection pins are programmed in a similar fashion. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;612 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A6H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A4H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;98H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;96H &lt;br /&gt;94H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;92H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;90H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;88H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;86H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;84H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UCS stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UCS start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LCS stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LCS start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CGS7stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CGS7start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS6stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS6 start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS5stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS5 start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS4 stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS4 start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS3 stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS3start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS2stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS2 start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS1 stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCS1 start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCSOstop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GCSO start &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Start register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Stop register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: A 19-A 10 are memory address A 19-A 10 or 1/0 address bits A 15-A6. &lt;br /&gt;W53-W50 select between 0 and 15 wait states. &lt;br /&gt;CSEN enables the pin if CSEN = 1. &lt;br /&gt;ISTOP = if ISTOP = 1 the memory address is OFFFFFH or the 1/0 address is OFFFFH. &lt;br /&gt;MEM = MEM = 1 selects memory and MEM = 0 selects 110. &lt;br /&gt;RDY = enables external ready if RDY = 1 for more than 15 wait states. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-23 The chip selection unit in the EB and EC versions of the 80186/80188 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15-3 80C188EB EXAMPLE INTERFACE &lt;br /&gt;Because the 80186/80188 microprocessors are designed as embedded controllers, this section of &lt;br /&gt;the text provides an example of such an application. The example illustrates simple memory and &lt;br /&gt;I/O attached to the 80C188EB microprocessor. It also lists the software required to program the &lt;br /&gt;80C188EB and its internal registers after a system reset. The software to control the system itself &lt;br /&gt;is not provided. Figure 15-24 illustrates the pin-out of the 80C188EB version of the 80188 mi-&lt;br /&gt;croprocessor. Note the differences between this version and the XL version presented earlier in &lt;br /&gt;the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80C188EB version contains some new features not present on earlier versions. These &lt;br /&gt;include two I/O ports (PI and P2) that are shared with other functions and two serial communi-&lt;br /&gt;cations interfaces that are built into the processor. It does not contain a DMA controller as did &lt;br /&gt;the XL version. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80188 can be interfaced with a small system designed to be used as a microprocessor &lt;br /&gt;trainer. The trainer illustrated in this text uses a 27256 EPROM for program storage, three 62256 &lt;br /&gt;SRAMs for data storage, an 8279 programmable keyboard/display interface, and one of the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-3 80C188EB EXAMPLE INTERFACE 613 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-24 The pin-out 41 ClKIN A19/#ONCE &lt;br /&gt;of the 80C188EB version of 40 OSCOUT A18 82 44 CLKOUT A17 81 the 80188 microprocessor A16 80 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESIN A15 79 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESOUT A14 77 &lt;br /&gt;A13 75 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOLD A12 73 &lt;br /&gt;HLDA All 71 &lt;br /&gt;NMI Ala 69 &lt;br /&gt;INTO A9 67 &lt;br /&gt;INn AS 62 &lt;br /&gt;INT2 &lt;br /&gt;INT3 AD7 78 &lt;br /&gt;INT4 AD6 76 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS 74 46 TOIN AD4 72 45 TOOUT AD3 70 48 TlIN AD2 68 47 Tl0UT AD1 66 &lt;br /&gt;ADO 61 57 P2.0/RXDl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;58 p2.1rrXDl RD &lt;br /&gt;59 P2.21BLCKl WR &lt;br /&gt;55 P2.3/SINTl ALE &lt;br /&gt;56 P2.4/#CTS DEN &lt;br /&gt;54 P2.5/BLCKO DT/#R &lt;br /&gt;50 P2.6 &lt;br /&gt;49 P2.7 LCS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UCS &lt;br /&gt;READY &lt;br /&gt;TEST P1.0/#GCSO &lt;br /&gt;LOCK Pl.l/#GCSl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pl.2/#GCS2 &lt;br /&gt;S2 P1.3/#GCS3 &lt;br /&gt;Sl Pl.4/#GCS4 &lt;br /&gt;SO P1.5/#GCS5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P1.6/#GCS6 &lt;br /&gt;RFSH Pl.71#GCS7 &lt;br /&gt;PDTMR &lt;br /&gt;CTSO &lt;br /&gt;RXDO &lt;br /&gt;TXDO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80C188EB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;built-in serial ports for serial communications. Figure 15-25 illustrates a small microprocessor &lt;br /&gt;trainer based on the 80Cl88EB microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory is selected by the UCS pin for the 27256 EPROM and the LCS pin for one of the &lt;br /&gt;62256 SRAMs; the GCSO and GCS 1 pins select the remaining SRAM devices. The 8270 key-&lt;br /&gt;board/display peripherals are selected by GCS2. Note that five wait states are programmed for &lt;br /&gt;the EPROM assuming a very slow 450 ns EPROM, two waits for the 250 ns SRAM, and two &lt;br /&gt;waits for the 8279 keyboard/display interface. Faster EPROM and SRAM reduce or eliminate &lt;br /&gt;the number of waits required for the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The system places the EPROM at memory addresses F8000H-FFFFFH; the SRAM at &lt;br /&gt;00000H-07FFFH, 80000H-87FFFH. and 88000H-8FFFFH; and the 8279 at I/O ports &lt;br /&gt;1000H-107FH. In this system, as is normally the case, we do not modify the address of the pe-&lt;br /&gt;ripheral control block, which resides at I/O ports FFOOH-FFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 15-5 lists the software required to initialize the 80CI88EB microprocessor. It &lt;br /&gt;does not list any of the software required to program 8279, nor does it show the software re-&lt;br /&gt;quired to operate the system as a microprocessor-based trainer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 15-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.186 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;;A program that initializes the 80C188EB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORG 8000H ;start of EPROM &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CLKIN &lt;br /&gt;OSCOtJT &lt;br /&gt;ClKOUT &lt;br /&gt;RESIN &lt;br /&gt;RESOUT &lt;br /&gt;HOLD &lt;br /&gt;HLDA &lt;br /&gt;NM' &lt;br /&gt;INTO &lt;br /&gt;INTl &lt;br /&gt;INT2 &lt;br /&gt;INTl &lt;br /&gt;INT4 &lt;br /&gt;TOIN &lt;br /&gt;TOOIlT &lt;br /&gt;TtlN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~i~ ~'-P201RXDI P2.lrrXD1 q&amp;quot; P2211RCKI P23/SINTI P24/'CTS P25JBlCKO P2. P2.7 &lt;br /&gt;14 READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST PI.OI'GCSO &lt;br /&gt;LOCK P1.1/IGCS. 27256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PI.21'GCS2 &lt;br /&gt;52 &lt;br /&gt;S, PI.31'GCSl PI.4/'GCS4 &lt;br /&gt;SO PI &amp;amp;f.GCSS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PI61.GCS6 &lt;br /&gt;RFSH PU/.GCS7 &lt;br /&gt;porMR &lt;br /&gt;eTsa &lt;br /&gt;RXDO &lt;br /&gt;TXDO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOC1B8EB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UlIA ~ &lt;br /&gt;'489 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;veco â¢ I .. I .. I .. I .. I .. I .. I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-25 A small system using the BOC1BBEB embedded controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;!!!. &lt;br /&gt;Y7 V, &lt;br /&gt;YO &lt;br /&gt;Y4 &lt;br /&gt;Y3 &lt;br /&gt;Y2 &lt;br /&gt;VI &lt;br /&gt;Vo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'''' vcco-A./V&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GZB &lt;br /&gt;GZ. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74LSr38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ue &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ 1111 t-Â±f:; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IIIIIII -=--i a3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.&amp;quot;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'i:t &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0) &lt;br /&gt;-&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.j&amp;gt;,. &lt;br /&gt;'&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(&amp;quot;') &lt;br /&gt;::x:: &lt;br /&gt;J&amp;gt; &lt;br /&gt;&amp;quot;tJ &lt;br /&gt;-t &lt;br /&gt;m &lt;br /&gt;:D &lt;br /&gt;~ &lt;br /&gt;U1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-t &lt;br /&gt;::x:: &lt;br /&gt;m &lt;br /&gt;00 &lt;br /&gt;'=! &lt;br /&gt;00 &lt;br /&gt;~ &lt;br /&gt;00 &lt;br /&gt;'=! &lt;br /&gt;00 &lt;br /&gt;00 &lt;br /&gt;-J&amp;gt; &lt;br /&gt;Z &lt;br /&gt;0 &lt;br /&gt;00 &lt;br /&gt;0 &lt;br /&gt;N &lt;br /&gt;00 &lt;br /&gt;en &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;s: &lt;br /&gt;c=; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:; t::fC? II 11111 :D 0 &lt;br /&gt;&amp;quot;tJ &lt;br /&gt;:D &lt;br /&gt;0 &lt;br /&gt;(&amp;quot;') &lt;br /&gt;m &lt;br /&gt;(f) &lt;br /&gt;(f) &lt;br /&gt;0 &lt;br /&gt;:D (f) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-3 BOC1 BBEB EXAMPLE INTERFACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8000 &lt;br /&gt;8003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8006 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8007 &lt;br /&gt;800A &lt;br /&gt;800D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;800E &lt;br /&gt;8011 &lt;br /&gt;8014 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8015 &lt;br /&gt;8018 &lt;br /&gt;801B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;801C &lt;br /&gt;801F &lt;br /&gt;8022 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8023 &lt;br /&gt;8026 &lt;br /&gt;8029 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;802A &lt;br /&gt;802D &lt;br /&gt;8030 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8031 &lt;br /&gt;8034 &lt;br /&gt;8037 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8038 &lt;br /&gt;803B &lt;br /&gt;803E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;803F &lt;br /&gt;8042 &lt;br /&gt;8045 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8046 &lt;br /&gt;8049 &lt;br /&gt;804C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;804D &lt;br /&gt;8050 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8051 &lt;br /&gt;8054 &lt;br /&gt;8055 &lt;br /&gt;8058 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FFA6 &lt;br /&gt;B8 OOOE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FFAO &lt;br /&gt;B8 0002 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FFA2 &lt;br /&gt;B8 080A &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF80 &lt;br /&gt;B8 0802 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF82 &lt;br /&gt;B8 100A &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF84 &lt;br /&gt;B8 1002 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF86 &lt;br /&gt;B8 180A &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF88 &lt;br /&gt;B8 1002 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF8A &lt;br /&gt;B8 1048 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF60 &lt;br /&gt;B8 8067 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF62 &lt;br /&gt;B8 0059 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF66 &lt;br /&gt;ED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA FF62 &lt;br /&gt;ED &lt;br /&gt;83 C8 20 &lt;br /&gt;EE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;IN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;IN &lt;br /&gt;OR &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFFA6H &lt;br /&gt;AX,OOOEH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFFAOH &lt;br /&gt;AX,0002H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFFA2H &lt;br /&gt;AX,080AH &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF80H &lt;br /&gt;AX,0802H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF82H &lt;br /&gt;AX,100AH &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF84H &lt;br /&gt;AX,1002H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF86H &lt;br /&gt;AX,180AH &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF88H &lt;br /&gt;AX,1002H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF8AH &lt;br /&gt;AX,1048H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF60H &lt;br /&gt;AX,8067H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF62H &lt;br /&gt;AX,59H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF66H &lt;br /&gt;AX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFF62H &lt;br /&gt;AX,DX &lt;br /&gt;AX,20H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address UCS stop &lt;br /&gt;;FFFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set stop address for UCS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address LCS start &lt;br /&gt;;OOOOOH with 2 waits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;615 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set start address for SRAM U4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address LCS stop &lt;br /&gt;;07FFFH &lt;br /&gt;;set stop address for SRAM U4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address GCSO start &lt;br /&gt;;08000H with 2 waits &lt;br /&gt;;set start address for SRAM US &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address GCSO stop &lt;br /&gt;;OFFFFH &lt;br /&gt;;set stop address for SRAM US &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address GCS1 start &lt;br /&gt;;10000H with 2 waits &lt;br /&gt;;set start address for SRAM U6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address GCS1 stop &lt;br /&gt;; 17FFFH &lt;br /&gt;;set stop address for SRAM U6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address GCS2 start &lt;br /&gt;;1000H with 2 waits &lt;br /&gt;;set start address for 8279 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address GCS2 stop &lt;br /&gt;;103FH (I/O) &lt;br /&gt;;set stop address for 8279 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address serial baud rate &lt;br /&gt;;generate a 9600 Baud rate &lt;br /&gt;;set Baud rate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address serial control register &lt;br /&gt;;7 data, even parity, 1 stop &lt;br /&gt;;set serial port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address serial status register &lt;br /&gt;;clear serial port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address serial control register &lt;br /&gt;;read control register &lt;br /&gt;;set REN bit &lt;br /&gt;;enable serial port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Remainder of system software is placed at this point. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFO BA FFA4 &lt;br /&gt;FFF3 B8 F805 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFF6 EE &lt;br /&gt;FFF7 E9 8006 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT &lt;br /&gt;JMP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFFFOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFFA4H &lt;br /&gt;AX,OF805H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,AL &lt;br /&gt;MAIN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;reset location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address GCS start &lt;br /&gt;;F8000H with 5 waits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set start address for UCS &lt;br /&gt;;jump to start of EPROM &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;616 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION TO THE 80286 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80286 microprocessor is an advanced version of the 8086 microprocessor that is designed &lt;br /&gt;for multiuser and multitasking environments. The 80286 addresses 16M byte of physical &lt;br /&gt;memory and 1 G bytes of virtual memory by using its memory-management system. This section &lt;br /&gt;of the text introduces the 80286 microprocessor, which finds use in earlier AT-style personal &lt;br /&gt;computers that once pervaded the computer market and still finds some application. The 80286 &lt;br /&gt;is basically an 8086 that is optimized to execute instructions in fewer clocking periods than the &lt;br /&gt;8086. The 80286 is also an enhanced version of the 8086 because it contains a memory manager. &lt;br /&gt;At this time, the 80286 no longer has a place in the personal computer system, but it does find &lt;br /&gt;application in control systems as an embedded controller. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Hardware Features &lt;br /&gt;Figure 15-26 provides the internal block diagram of the 80286 microprocessor. Notice that like &lt;br /&gt;the 80186/80188, the 80286 does not incorporate internal peripherals; instead it contains a &lt;br /&gt;memory-management unit (MMU) that is called the address unit in the block diagram. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As a careful examination of the block diagram reveals, address pins A23-AO, BUSY, CAP, &lt;br /&gt;&amp;quot;'E=R&amp;quot;&amp;quot;R&amp;quot;&amp;quot;'O&amp;quot;'&amp;quot;R=-, PEREQ, and PEACK are new or additional pins that do not appear on the 8086 micro-&lt;br /&gt;processor. The BUSY, ERROR, PEREQ, and PEACK signals are used with the microprocessor &lt;br /&gt;extension or coprocessor, of which the 80287 is an example. Note that the TEST pin is now re-&lt;br /&gt;ferred to as the BUSY pin. The address bus is now 24-bits wide to accommodate the 16M bytes of &lt;br /&gt;physical memory. The CAP pin is connected to a 0.047 IlF, Â±20% capacitor that acts as a 12V &lt;br /&gt;filter and connects to ground. The pin-outs of the 8086 and 80286 are illustrated in Figure 15-27 &lt;br /&gt;for comparative purposes. Note that the 80286 does not contain a multiplexed address/data bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As mentioned in Chapter 1, the 80286 operates in both the real and protected modes. In the &lt;br /&gt;real mode, the 80286 addresses a 1M-byte memory address space and is virtually identical to the &lt;br /&gt;8086. In the protected mode, the 80286 addresses a 16M byte memory space. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 15-28 illustrates the basic 80286 microprocessor system. Notice that the clock is &lt;br /&gt;provided by the 82284 clock generator (similar to the 8284A), and the system control signals are &lt;br /&gt;provided by the 82288 system bus controller (similar to the 8288). Also notice the absence of the &lt;br /&gt;latch circuits used to de-multiplex the 8086 address/data bus. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ ADDREsSuNrT(AU) - - - - - - - - - - - - - - - - - - - ~ &lt;br /&gt;I-!....I....r..... A&amp;quot; - Ao. &lt;br /&gt;r--,..,.-v SHE. MilO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;t I &lt;br /&gt;I I &lt;br /&gt;I ~--~~ &lt;br /&gt;I ~'-+- I&amp;gt;EACI\\ t+..JL-+- PEREQ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I-------J ~--1_f....I.- READY. HO\\.D &lt;br /&gt;'--....... ~ $1. so, CODIINTA &lt;br /&gt;~----------lr:r-v LDCK. HLDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REseT &lt;br /&gt;I CU( &lt;br /&gt;I ~ &lt;br /&gt;I EXECUTION UNIT (EU) '----&amp;quot;&amp;quot;&amp;quot;'1rrTf'-r-----~,,-:-t~~~-L==::J Yee &lt;br /&gt;---Â·-------------------------------~~~;~,--r-~r.;~U;~y~-~-~-~-~-~-~-~'_~~~~~~~~~~~~~~~~CAP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IHTR EAAOA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-26 The block diagram of the 80286 microprocessor (Courtesy of Intel Corporation) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-4 INTRODUCTION TO THE 80286 617 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-27 The 8086 33 MN ADO READY AD &lt;br /&gt;and 80286 microprocessor 22 ADl ClK Al READY AD2 RESET A2 &lt;br /&gt;pin-outs. Notice that the 19 ClK AD3 A3 21 RESET AD4 SO A4 &lt;br /&gt;80286 does not have a multi- 18 AD5 Sl A5 25 INTR AD6 A6 plexed address/data bus. AD7 MilO A7 ~4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD8 lOCK A8 _ZL 7 22 AD9 6 NMI A9 21 AD10 INTR Al0 &lt;br /&gt;ADll 5 All 20 &lt;br /&gt;AD12 4 HOLD A12 19 &lt;br /&gt;AD13 3 HlDA A13 18 2 17 8086 AD14 39 A14 16 AD15 38 ERROR A15 AD16/S3 37 BUSY A16 A17/S4 36 PEREa A17 A18/S5 35 PEACK A18 A19/S6 COD/INTA A19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34 52 A20 CAP A21 &lt;br /&gt;DEN A22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/A &lt;br /&gt;A23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30 MIlO BHE HlDA 80286 &lt;br /&gt;17 HOLD RD DO &lt;br /&gt;3 NMI WR Dl TEST ALE D2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA D3 &lt;br /&gt;D4 &lt;br /&gt;D5 &lt;br /&gt;D6 &lt;br /&gt;D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L &lt;br /&gt;D8 &lt;br /&gt;D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dl0 &lt;br /&gt;Dll &lt;br /&gt;D12 &lt;br /&gt;D13 &lt;br /&gt;D14 &lt;br /&gt;D15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Additional Instructions &lt;br /&gt;The 80286 has even more instructions than its predecessors. These extra instructions control the &lt;br /&gt;virtual memory system through the memory manager of the 80286. Table 15-9 lists the addi-&lt;br /&gt;tional 80286 instructions with a comment about the purpose of each. These instructions are the &lt;br /&gt;only new instructions added to the 80286. Note that the 80286 also contains the new instructions &lt;br /&gt;added to the 80186/80188 such as INS, OUTS, BOUND, ENTER, LEAVE, PUSHA, POPA, and &lt;br /&gt;the immediate multiplication and immediate shift and rotate counts. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 15-9 Additional &lt;br /&gt;80286 instructions Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLTS &lt;br /&gt;LOGT &lt;br /&gt;SGOT &lt;br /&gt;LlOT &lt;br /&gt;SlOT &lt;br /&gt;LLOT &lt;br /&gt;SLOT &lt;br /&gt;LMSW &lt;br /&gt;SMSW &lt;br /&gt;LAR &lt;br /&gt;LSL &lt;br /&gt;SAR &lt;br /&gt;ARPL &lt;br /&gt;VERR &lt;br /&gt;VERW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Purpose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Clears the task-switched flag bit &lt;br /&gt;Loads the global descriptor table register &lt;br /&gt;Stores the global descriptor table register &lt;br /&gt;Loads the interrupt descriptor table register &lt;br /&gt;Stores the interrupt descriptor table register &lt;br /&gt;Loads the local descriptor table register &lt;br /&gt;Stores the local descriptor table register &lt;br /&gt;Loads the machine status word &lt;br /&gt;Stores the machine status word &lt;br /&gt;Loads the access rights &lt;br /&gt;Loads the segment limit &lt;br /&gt;Stores the access rights &lt;br /&gt;Adjusts the requested privilege level &lt;br /&gt;Verifies a read access . &lt;br /&gt;Verifies a write access &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;618 CHAPTER 15 THE 80186,80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~D~--iiii--~~X1'---~R:EA~J~~~1~ri:it:t=======~========G:~RE~A:DY;---------:n 24 M~Z RESET 2 ~~~ET ------1-1-1-1---&amp;quot;&amp;quot;-1 X2 15 PClK r;:::j:t====:::t~SO ~ ~ ~ &lt;br /&gt;AYEN r+t--------Â¥.---lMJiO L==::t~ SRDY 910 lOCK SYEN NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;r;::==~SO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S1 VCC ~P6~ Reset &lt;br /&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address bus &lt;br /&gt;r&amp;lt;1O--~~~--~~--~~RES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F/C ERROR &lt;br /&gt;82284 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10uF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.047U~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;910 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSY &lt;br /&gt;PEREa &lt;br /&gt;PEACK &lt;br /&gt;COD/iN'iA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 &lt;br /&gt;SO &lt;br /&gt;S1 &lt;br /&gt;DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY &lt;br /&gt;ClK &lt;br /&gt;CEN/AEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CENl &lt;br /&gt;CMDlY &lt;br /&gt;MB &lt;br /&gt;82288 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTA 13 &lt;br /&gt;10RC 12 &lt;br /&gt;10RC 11 Control bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MRDC &lt;br /&gt;MWTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DT/R 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 DEN &lt;br /&gt;ALE 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MCE 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 15-28 The interconnection of the 80286 microprocessor. 82284 clock generator, and 8288 system bus &lt;br /&gt;controller &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Following are descriptions of instructions not explained under the memory-management &lt;br /&gt;section. The instructions described here are special and are used only for the conditions indicated. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The clear task-switched flag ceLTS) instruction clears the TS (task-switched) &lt;br /&gt;flag bit to a logic O. If the TS flag bit is a logic I. and the 80287 numeric copro-&lt;br /&gt;cessor is used by the task, an interrupt occurs (vector type 7). This allows the &lt;br /&gt;function of the coprocessor to be emulated with software. The CL TS instruction &lt;br /&gt;is used in a system and is considered a privileged instruction because it can only &lt;br /&gt;be executed in the protected mode at privilege level O. There is no set TS flag &lt;br /&gt;instruction. This is accomplished by writing a logic 1 to bit position 3 (TS) of the &lt;br /&gt;machine status word (MSW) by using the LMSW instruction. &lt;br /&gt;The load access rights (LAR) instruction reads the segment descriptor and places &lt;br /&gt;a copy of the access rights byte into a 16-bit register. An example is the LAR &lt;br /&gt;AX,BX instruction that loads AX with the access rights byte from the descriptor &lt;br /&gt;selected by the selector value found in BX. This instruction is used to get the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15-5 SUMMARY 619 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARPL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VERR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VERW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;access rights so that it can be checked before a program uses the segment of &lt;br /&gt;memory described by the descriptor. &lt;br /&gt;The load segment limit (LSL) instruction loads a user-specified register with the &lt;br /&gt;segment limit. For example, the LSL AX,BX instruction loads AX with the limit &lt;br /&gt;of the segment described by the descriptor selected by the selector in BX. This &lt;br /&gt;instruction is used to test the limit of a segment. &lt;br /&gt;The adjust requested privilege level (ARPL) instruction is used to test a selector &lt;br /&gt;so that the privilege level of the requested selector is not violated. An example is &lt;br /&gt;ARPL AX,CX where AX contains the requested privilege level and CX contains &lt;br /&gt;the selector value to be used to access a descriptor. If the requested privilege level &lt;br /&gt;is of a lower priority than the descriptor under test, the zero flag is set. This may &lt;br /&gt;require that a program adjust the requested privilege level or indicate a privilege &lt;br /&gt;violation. &lt;br /&gt;The verify for read access (VERR) instruction verifies that a segment can be &lt;br /&gt;read. Recall from Chapter 1 that a code segment can be read-protected. If the &lt;br /&gt;code segment can be read, the zero flag bit is set. The VERR AX instruction tests &lt;br /&gt;the descriptor selected by the AX register. &lt;br /&gt;The verify for write access (VERW) instruction is used to verify that a segment &lt;br /&gt;can be written. Recall from Chapter I that a data segment can be write-protected. &lt;br /&gt;If the data segment can be written, the zero flag bit is set. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Virtual Memory Machine &lt;br /&gt;A virtual memory machine is a machine that maps a larger memory space (I G byte for the &lt;br /&gt;80286) into a much smaller physical memory space (16M bytes for the 80286). This allows a &lt;br /&gt;very large system to execute in smaller physical memory systems. This is accomplished by &lt;br /&gt;spooling the data and programs between the fixed disk memory system and the physical &lt;br /&gt;memory. Addressing a IG-byte memory system is accomplished by the descriptors in the 80286 &lt;br /&gt;microprocessor. Each 80286 descriptor describes a 64K-byte memory segment and the 80286 al-&lt;br /&gt;lows 16K descriptors. This (64K x 16K) allows a maximum of IG byte of memory to be de-&lt;br /&gt;scribed for the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As mentioned in Chapter 1, descriptors describe the memory segment in the protected &lt;br /&gt;mode. The 80286 has descriptors that define codes, data, stack segments, interrupts, procedures, &lt;br /&gt;and tasks. Descriptor accesses are performed by loading a segment register with a selector in the &lt;br /&gt;protected mode. The selector accesses a descriptor that describes an area of the memory. Addi-&lt;br /&gt;tional detail on descriptors and their applications is given in Chapter 1 and also Chapters 16 and &lt;br /&gt;17. Please refer to these chapters for a much more detailed view of the protected mode memory-&lt;br /&gt;management system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The 80186/80188 microprocessors contain the same basic instruction set as the 8086/8088 &lt;br /&gt;microprocessors, except that a few additional instructions are added. The 80186/80188 are &lt;br /&gt;thus enhanced versions of the 8086/8088 microprocessors. The new instructions include &lt;br /&gt;PUSHA, POPA, INS, OUTS, BOUND, ENTER, LEAVE, and immediate multiplication &lt;br /&gt;and shift/rotate counts. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Hardware enhancements to the 80186/80188 include a clock generator, programmable inter-&lt;br /&gt;rupt controller, three programmable timers, programmable DMA controller, programmable &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;620 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 15 THE 80186, 80188, AND 80286 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;chip selection logic unit, a watchdog timer, a dynamic RAM refresh logic circuit, and addi-&lt;br /&gt;tional features on various versions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The clock generator allows the 80186/80188 to operate from an external TTL level clock &lt;br /&gt;source or from a crystal attached to the X I (CLKIN) and X2 (OSCOUT) pins. The frequency &lt;br /&gt;of the crystal is twice the operating frequency of the microprocessor. The 80186/80188 &lt;br /&gt;microprocessors are available in speeds of 6-20 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. The programmable interrupt controller arbitrates all internal and external interrupt requests. &lt;br /&gt;It is also capable of operating with two external 8259A interrupt controllers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. There are three programmable timers located within the 80186/80188. Each timer is a fully &lt;br /&gt;programmable 16-bit counter used to generate wave forms or count events. Two of the &lt;br /&gt;timers, timers 0 and 1, have external inputs and outputs. The third timer, timer 2, is clocked &lt;br /&gt;from the system clock and is used either to provide a clock for another timer or to request a &lt;br /&gt;DMAaction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. The programmable DMA controller is a fully programmable two-channel controller. DMA &lt;br /&gt;transfers are made between memory and I/O, I/O and I/O, or between memory locations. &lt;br /&gt;DMA requests occur from software, hardware, or the output of timer 2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. The programmable chip selection unit is an internal decoder that provides up to 13 output &lt;br /&gt;pins to select memory (6 pins) and I/O (7 pins). It also inserts 0-3 wait states with or without &lt;br /&gt;external READY synchronization. On the EB and EC versions, the number of wait states &lt;br /&gt;can be programmed from 0-15. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. The only difference between the timing of the 80186/80188 and the 8086/8088 is that ALE &lt;br /&gt;appears one-half clock pulse earlier. Otherwise, the timing is identical. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The 6 MHz version of the 80186/80188 allows 417 ns of access time for the memory; the &lt;br /&gt;8 MHz version allows 309 ns. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The internal 80186/80188 peripherals are programmed via a peripheral control block (PCB) &lt;br /&gt;initialized at I/O ports FFOOH-FFFFH. The PCB may be moved to any area of memory or &lt;br /&gt;I/O by changing the contents of the PCB relocation register at initial I/O location FFFEH &lt;br /&gt;andFFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;II. The 80286 is an 8086 that has been enhanced to include a memory-management unit &lt;br /&gt;(MMU). The 80286 is capable of addressing a 16M-byte physical memory space because of &lt;br /&gt;the management unit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The 80286 contains the same instructions as the 80186/80188 except for a handful of addi-&lt;br /&gt;tional instructions that control the memory-management unit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. Through the memory-management unit, the 80286 microprocessor addresses a virtual &lt;br /&gt;memory space of I G byte as specified by the 16K descriptors stored in two descriptor tables. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. List the differences between the 8086/8088 and the 80186/80188 microprocessors. &lt;br /&gt;2. What hardware enhancements are added to the 80186/80188 that are not present in the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086/8088? &lt;br /&gt;3. The 80186/80188 are packaged in what types of integrated circuit? &lt;br /&gt;4. If the 20 MHz crystal is connected to Xl and X2, what frequency signal is found at &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLKOUT? &lt;br /&gt;5. Describe the differences between the 80C 188XL and the 80C l88EB versions of the 80188 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;embedded controller. &lt;br /&gt;6. The fan-out from any 80186/80188 pin is for a logic O. &lt;br /&gt;7. How many clocking periods are found in an 80186/80188 bus cycle? &lt;br /&gt;8. What is the main difference between the 8086/8088 and 80186/80188 timing? &lt;br /&gt;9. What is the importance of memory access time? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;15-6 QUESTIONS AND PROBLEMS 621 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. How much memory access time is allowed by the 80186/80188 if operated with a 6 MHz &lt;br /&gt;clock? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. Where is the peripheral control block located after the 80186/80188 is reset? &lt;br /&gt;12. Write the software required to move the peripheral control block to memory locations &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I OOOOH-l OOFFH. &lt;br /&gt;13. What interrupt vector is used by the INTO pin on the 80186/80188 microprocessors? &lt;br /&gt;14. How many interrupt vectors are available to the interrupt controller located within the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188 microprocessors? &lt;br /&gt;15. What two modes of operation are available to the interrupt controller? &lt;br /&gt;16. What is the purpose of the interrupt control register? &lt;br /&gt;17. Whenever an interrupt source is masked, the mask bit in the interrupt mask register is a logic &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. What is the difference between the interrupt poll and interrupt poll status registers? &lt;br /&gt;19. What is the purpose of the end-of-interrupt (EO!) register? &lt;br /&gt;20. How many 16-bit timers are found within the 801 86/801 88? &lt;br /&gt;21. Which timers have input and output pin connections? &lt;br /&gt;22. Which timer connects to the system clock? &lt;br /&gt;23. If two maximum-count compare registers are used with a timer, explain the operation of the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;timer. &lt;br /&gt;24. What is the purpose of the INH timer control register bit? &lt;br /&gt;25. What is the purpose of the P timer control register bit? &lt;br /&gt;26. The timer control register bit AL T selects what type of operation for timers 0 and I? &lt;br /&gt;27. Explain how the timer output pins are used. &lt;br /&gt;28. Develop a program that causes timer 1 to generate a continuous signal that is a logic 1 for &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;123 counts and a logic 0 for 23 counts. &lt;br /&gt;29. Develop a program that causes timer 0 to generate a single pulse after 105 clock pulses on its &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;input pin have occurred. &lt;br /&gt;30. How many DMA channels are controlled by the DMA controller in the 80C186XL? &lt;br /&gt;31. The DMA controller's source and destination registers are each bits wide. &lt;br /&gt;32. How is the DMA channel started with software? &lt;br /&gt;33. The chip selection unit (XL and EA) has pins to select memory devices. &lt;br /&gt;34. The chip selection unit (XL and EA) has pins to select peripheral devices. &lt;br /&gt;35. The last location of the upper memory block as selected by the UCS pin is location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36. The middle memory chip selection pins (XL and EA) are programmed for a _____ _ &lt;br /&gt;address and a block size. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37. The lower memory area as selected by LCS begins at address _____ _ &lt;br /&gt;38. The internal wait state generator (EB and EC versions) is capable of inserting between &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;______ and wait states. &lt;br /&gt;39. Program register A8H (XL and EA) so the mid-range memory block size is 128K bytes. &lt;br /&gt;40. What is the purpose of the EX bit in register A8H? &lt;br /&gt;41. Develop the software required to program the GCS3 pin so that it selects memory from lo-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cation 20000H-2FFFFH and inserts two wait states. &lt;br /&gt;42. Develop the software required to program the GSC4 pin so that it selects an I/O device for &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ports 1000H-103FH and inserts one wait state. &lt;br /&gt;43. The 80286 microprocessor addresses bytes of physical memory. &lt;br /&gt;44. When the memory manager is in use, the 80286 addresses bytes of virtual &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory. &lt;br /&gt;45. The instruction set of the 80286 is identical to the ______ , except for the memory-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;management instructions. &lt;br /&gt;46. What is the purpose of the VERR instruction? &lt;br /&gt;47. What is the purpose of the LSL instruction? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;622 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 16 &lt;br /&gt;The 80386 and 80486 Microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;The 80386 microprocessor is a full 32-bit version of the earlier 8086/8088 and 80286 16-bit &lt;br /&gt;microprocessors and represents a major advancement in the architecture. Along with this larger &lt;br /&gt;word size are many improvements and additional features. The 80386 microprocessor features &lt;br /&gt;multitasking, memory management, virtual memory with or without paging, software protec-&lt;br /&gt;tion, and a large memory system. All software written for the early 8086/8088 and the 80286 is &lt;br /&gt;upward compatible to the 80386 microprocessor. The amount of memory addressable by the &lt;br /&gt;80386 is increased from the 1M byte found in the 8086/8088 and the 16M bytes found in the &lt;br /&gt;80286 to 4G bytes in the 80386. The 80386 can switch between protected mode and real mode &lt;br /&gt;without resetting the microprocessor. Switching from protected mode to real mode was a &lt;br /&gt;problem on the 80286 microprocessor because it required a hardware reset. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80486 microprocessor is an enhanced version of the 80386 microprocessor that exe-&lt;br /&gt;cutes many of its instructions in one clocking period. The 80486 microprocessor also contains &lt;br /&gt;an 8K-byte cache memory and improved 80387 numeric coprocessor. (Note that the 80486DX4 &lt;br /&gt;contains a 16K cache.) When the 80486 is operated at the same clock frequency as an 80386, it &lt;br /&gt;performs with about a 50 percent speed improvement. In Chapter 17, we shall see that the Pen-&lt;br /&gt;tium and Pentium Pro, which both contain a 16K cache memory, perform at better than twice &lt;br /&gt;the speed of the 80486 microprocessor. The Pentium and Pentium Pro also contain improved &lt;br /&gt;numeric coprocessors that operate five times faster than the 80486 numeric coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Contrast the 80386/80486 microprocessors with earlier Intel microprocessors. &lt;br /&gt;2. Describe the operation of the 80386/80486 memory management unit and paging unit. &lt;br /&gt;3. Switch between protected mode and real mode. &lt;br /&gt;4. Define the operation of additional 80386/80486 instructions and addr Â·:;sing modes. &lt;br /&gt;5. Explain the operation of a cache memory system. &lt;br /&gt;6. Detail the interrupt structure and direct memory access structure of the 80386/80486. &lt;br /&gt;7. Contrast the 80486 with the 80386 microprocessor. &lt;br /&gt;8. Explain the operation of the 80486 cache memory. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-1 INTRODUCTION TO THE 80386 MICROPROCESSOR 623 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION TO THE 80386 MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before the 80386 or any other microprocessor can be used in a system, the function of each pin &lt;br /&gt;must be understorn. This section of the chapter details the operation of each pin along with the &lt;br /&gt;external memory system and VO structures of the 80386. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-1 illustrates the pin-out of the 80386DX microprocessor, which is packaged in &lt;br /&gt;a 132-pin POA (pin grid array). Two versions of the 80386 are commonly available: the &lt;br /&gt;80386DX, illustrated and described in this chapter, is the full version, and the 80386SX is a re-&lt;br /&gt;duced bus version of the 80386. A new version of the 80386-the 80386EX-incorporates the &lt;br /&gt;AT bus system, dynamic RAM controller, programmable chip selection logic, 26 address pins, &lt;br /&gt;16 data pins, and 24 I/O pins. The 80386DX addresses 40 bytes of memory through its 32-bit &lt;br /&gt;data bus and 32-bit address. The 80386SX, more like the 80286, addresses 16M bytes of &lt;br /&gt;memory with its 24-bit address bus via its 16-bit data bus. The 80386SX was developed after the &lt;br /&gt;80386DX for applications that didn't require the full 32-bit bus version. The 80386SX is found &lt;br /&gt;in many personal computers that use the same basic motherboard design as the 80286. At this &lt;br /&gt;time, most applications, including Windows, require less than 16M bytes of memory, so the &lt;br /&gt;80386SX is a fairly popular and less costly version of the 80386 microprocessor. Even though &lt;br /&gt;the 80486 has become a less expensive upgrade path for newer systems, the 80386 can still be &lt;br /&gt;used for many applications. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with earlier versions of the Intel family of microprocessors, the 80386 requires a single &lt;br /&gt;+5.0V power supply for operation. The power supply current averages 550 mA for the 25 MHz &lt;br /&gt;version of the 80386, 500 mA for the 20 MHz version, and 450 mA for the 16 MHz version. Also &lt;br /&gt;available is a 33 MHz version that requires 600 mA of power supply current. Note that during &lt;br /&gt;some modes of normal operation, power supply current can surge to over 1.0 A. This means that &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The pin-outs BEO &lt;br /&gt;of the 80386DX and 80386SX BE1 00 BE2 &lt;br /&gt;microprocessors 01 BE3 02 A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03 A3 &lt;br /&gt;04 A4 &lt;br /&gt;05 A5 18 A1 00 1 &lt;br /&gt;06 A6 51 A2 01 100 &lt;br /&gt;07 A7 52 A3 02 99 &lt;br /&gt;08 A8 53 A4 03 96 &lt;br /&gt;09 A9 54 A5 04 95 &lt;br /&gt;010 A10 55 A6 05 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;94 &lt;br /&gt;011 A11 56 A7 06 93 012 A12 58 A8 07 &lt;br /&gt;013 A13 59 A9 08 &lt;br /&gt;014 A14 60 A10 09 &lt;br /&gt;015 A15 1 A11 010 &lt;br /&gt;016 A16 62 A12 011 &lt;br /&gt;017 A17 64 A13 012 &lt;br /&gt;018 803860X A18 65 A14 013 &lt;br /&gt;019 A19 66 A15 014 &lt;br /&gt;020 A20 70 A16 015 &lt;br /&gt;D21 A21 72 A17 80386SX &lt;br /&gt;022 A22 73 A18 AOS &lt;br /&gt;023 A23 74 A19 BHE &lt;br /&gt;024 A24 75 A20 BLE &lt;br /&gt;025 A25 76 A21 OIG &lt;br /&gt;026 A26 7 A22 MliO &lt;br /&gt;027 A27 80 A23 HOLO &lt;br /&gt;028 A28 HLO~ &lt;br /&gt;029 A29 BUSY 40 030 A30 CLK2 INTR &lt;br /&gt;031 A31 ERROR NMI 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOS W/R FLT 33 LOCK RESET NA OIG NA &lt;br /&gt;BS16 MliO PEREQ WIR 25 &lt;br /&gt;REAOY LOCK REAOY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;014 HOLO PEREQ M14 HOLOA BUSY &lt;br /&gt;B7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ERROR &lt;br /&gt;INTR B8 NMI 9 RESET 12 CLK2 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;624 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the power supply and power distribution network must be capable of supplying these current &lt;br /&gt;surges. This device contains multiple VCC and VSS connections that must all be connected to &lt;br /&gt;+S.OV and grounded for proper operation. Some of the pins are labeled N/C (no connection) and &lt;br /&gt;must not be connected. Additional versions of the 80386SX are available with a +3.3V power &lt;br /&gt;supply. These are often found in portable notebook or laptop computers and are usually pack-&lt;br /&gt;aged in a surface mount device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each 80386 output pin is capable of providing 4.0 mA (address and data connections) or &lt;br /&gt;5.0 mA (other connections). This represents an increase in drive current compared to the 2.0 mA &lt;br /&gt;available on earlier 8086, 8088, and 80286 output pins. Each input pin represents a small load re-&lt;br /&gt;quiring only Â±IO JlA of current. In some systems, except the smallest, these current levels require &lt;br /&gt;bus buffers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The function of each 80386DX group of pins follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A31-A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D31-DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WIR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;READY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D/e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address bus connections address any Df the I G x 32 memory klcations &lt;br /&gt;found in the 80386 memory system. Note that AO and Al are encoded in the &lt;br /&gt;bus enable (BE3-BEO) to select any or all of the four bytes in a 32-bit wide &lt;br /&gt;memory location. Also note that because the 80386SX contains a I6-bit data &lt;br /&gt;bus in place of the 32-bit data bus found on the 80386DX, Al is present on the &lt;br /&gt;80386SX and the bank selection signals are replaced with BHE and BLE. The &lt;br /&gt;BHE signal enables the upper data bus half, and the BLE signal the lower. &lt;br /&gt;Data bus connections transfer data between the microprocessor and its &lt;br /&gt;memory and I/O system. Note that the 80386SX contains DI5-Do-&lt;br /&gt;Bank enable signals select the access of a byte, word, or double word of data. &lt;br /&gt;These signals are generated internally by the microprocessor from address bits &lt;br /&gt;Al and AO. On the 80386SX, these pins are replaced by BHE, BLE, and AI. &lt;br /&gt;MemorylIO selects a memory device when a logic loran I/O device when a &lt;br /&gt;logic O. During the I/O operation, the address bus contains a l6-bit I/O address &lt;br /&gt;on address connections A IS-A2. &lt;br /&gt;Write/read indicates that the current bus cycle is a write when a logic 1 or a &lt;br /&gt;read when a logic O. &lt;br /&gt;The address data strobe becomes active whenever the 80386 has issued a &lt;br /&gt;valid memory or I/O address. This signal is combined with the W if{ signal to &lt;br /&gt;generate the separate read and write signals present in the earlier 8086-80286 &lt;br /&gt;microprocessor-based systems. &lt;br /&gt;Reset initializes the 80386, causing it to begin executing software at memory &lt;br /&gt;location FFFFFFFOH. The 80386 is reset to the real mode and the leftmost 12 &lt;br /&gt;address connections remain logic 1 's (FFFH) until a far jump or far call is &lt;br /&gt;executed. This allows compatibility with earlier microprocessors. &lt;br /&gt;Clock times 2 is driven by a clock signal that is twice the operating frequency &lt;br /&gt;of the 80386. For example, to operate the 80386 at 16 MHz, we apply a &lt;br /&gt;32 MHz clock to this pin. &lt;br /&gt;Ready controls the number of wait states inserted into the timing to lengthen &lt;br /&gt;memory accesses. &lt;br /&gt;Lock becomes a logic 0 whenever an instruction is prefixed with the LOCK: &lt;br /&gt;prefix. This is most often used during DMA accesses. &lt;br /&gt;Data/control indicates that the data bus contains data for or from memory or &lt;br /&gt;I/O when a logic 1. If Die is a logic 0, the microprocessor is halted or executes &lt;br /&gt;an intelTupt acknowledge. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-1 INTRODUCTION TO THE 80386 MICROPROCESSOR 625 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOLD &lt;br /&gt;HLDA &lt;br /&gt;PEREQ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ERROR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bus size 16 selects either a 32-bit data bus (BS 16:: 1) or a 16-bit data bus &lt;br /&gt;(BS 16 :: 0). In most cases, if an 80386DX is operated on a 16-bit data bus, we &lt;br /&gt;use the 80386SX that has a 16-bit data bus. &lt;br /&gt;Next address caus'!s the 80386 to output the address of the next instruction or &lt;br /&gt;data in the current bus cycle. This pin is often used for pipelining the address. &lt;br /&gt;Hold requests a DMA action. &lt;br /&gt;Hold acknowledge indicates that the 80386 is currently in a hold condition. &lt;br /&gt;The coprocessor request asks the 80386 to relinquish control and is a direct &lt;br /&gt;connection to the 80387 arithmetic coprocessor. &lt;br /&gt;Busy is an input used by the WAIT or FW AIT instruction that waits for the &lt;br /&gt;coprocessor to become not busy. This is also a direct connection to the 80387 &lt;br /&gt;from the 80386. &lt;br /&gt;Error indicates to the microprocessor that an error is detected by the &lt;br /&gt;coprocessor. &lt;br /&gt;An interrupt request is used by external circuitry to request an interrupt. &lt;br /&gt;A non-maskable interrupt requests a non-maskable interrupt as it did on the &lt;br /&gt;earlier versions of the microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Memory System &lt;br /&gt;The physical memory system of the 80386DX is 4G bytes in size and is addressed as such; if vir-&lt;br /&gt;tual addressing is used, 64T bytes are mapped into the 4G bytes of physical space by the memory &lt;br /&gt;management unit and descriptors. Note that virtual addressing allows a program to be larger than &lt;br /&gt;4G bytes if a method of swapping with a very large hard disk drive exists. Figure 16-2 shows the &lt;br /&gt;organization of the 80386DX physical memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory is divided into four 8-bit wide memory banks, each containing up to IG &lt;br /&gt;byte of memory. This 32-bit wide memory organization allows bytes, words, or double words &lt;br /&gt;of memory data to be accessed directly. The 80386DX transfers up to a 32-bit wide number in &lt;br /&gt;a single memory cycle, whereas the early 8088 requires four cycles to accomplish the same &lt;br /&gt;transfer and the 80286 and 80386SX require two cycles. Today the data width is important, es-&lt;br /&gt;pecially with single-precision floating-point numbers that are 32-bits wide. High-level soft-&lt;br /&gt;ware normally uses floating-point numbers for data storage, so 32-bit memory locations speed &lt;br /&gt;the execution of high-level software when it is written to take advantage of this wider &lt;br /&gt;memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each memory byte is numbered in hexadecimal as they were in prior versions of the family. &lt;br /&gt;The difference is that the 80386DX uses a 32-bit wide memory address with memory bytes num-&lt;br /&gt;bered from locations OOOOOOOOH through FFFFFFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The two memory banks in the 8086, 80286. and 80386SX system are accessed via BLE &lt;br /&gt;(AO on the 8086 and 80286) and BHE. In the 80386DX, the memory banks are accessed via four &lt;br /&gt;bank enable signals BE3-BEO. This arrangement allows a single byte to be accessed when one &lt;br /&gt;bank enable signal is activated by the microprocessor. It also allows a word to be addressed &lt;br /&gt;when two bank enable signals are activated. In most cases. a word is addressed in bank 0 and I &lt;br /&gt;or in bank 2 and 3. Memory location OOOOOOOOH is in bank O. location OOOOOOOIH is in bank I, &lt;br /&gt;location 00000002H is in bank 2, and location 00000003H is in bank 3. The 80386DX does not &lt;br /&gt;contain address connections AO and A I because these have been encoded as the bank enable sig-&lt;br /&gt;nals. Likewise, the 80386SX does not contain the AO address pin because it is encoded in the &lt;br /&gt;BLE and BHE signals. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;626 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-2 The memory &lt;br /&gt;system for the 80386 micro-&lt;br /&gt;processor. Notice that the &lt;br /&gt;memory is organized as four &lt;br /&gt;banks, each containing 1 G &lt;br /&gt;byte. Memory is accessed as &lt;br /&gt;8-,16-, or 32-bit data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank 3 Bank 2 Bank 1 BankO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1Gx8 1Gx8 1Gx8 1G x8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. 16 bits ~I IÂ· . 16 bits . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. 32 bits . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Buffered System. Figure 16-3 shows the 80386DX connected to buffers that increase fan-out &lt;br /&gt;from its address, data, and control connections. This microprocessor is operated at 25 MHz using &lt;br /&gt;a 50 MHz clock input signal generated by an integrated oscillator module. Oscillator modules &lt;br /&gt;are almost always used to provide a clock in modern microprocessor-based equipment. The &lt;br /&gt;HLDA signal is used to enable all buffers in a system that uses direct memory access. Otherwise, &lt;br /&gt;the buffer enable pins are connected to a ground in a non-DMA system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pipelines and Caches. The cache memory is a buffer that allows the 80386 to function more ef-&lt;br /&gt;ficiently with lower DRAM speeds. A pipeline is a special way of handling memory accesses so &lt;br /&gt;the memory has additional time to access data. A 16 MHz 80386 allows memory devices with &lt;br /&gt;access times of 50 ns or less to operate at full speed. Obviously, there are few DRAMs currently &lt;br /&gt;available with these access times. In fact, the fastest DRAMs currently in use have an access &lt;br /&gt;time of 60 ns or longer. This means that some technique must be found to interface these &lt;br /&gt;memory devices, which are slower than required by the microprocessor. Three techniques are &lt;br /&gt;available: interleaved memory, caching, and a pipeline. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The pipeline is the preferred means of interfacing memory because the 80386 micro-&lt;br /&gt;processor supports pipelined memory accesses. Pipelining allows memory an extra clocking pe-&lt;br /&gt;riod to access data. The extra clock extends the access time from 50 ns to 81 ns on an 80386 &lt;br /&gt;operating with a 16 MHz clock. The pipe, as it is often called, is set up by the microprocessor. &lt;br /&gt;When an instruction is fetched from memory, the microprocessor often has extra time before the &lt;br /&gt;next instruction is fetched. During this extra time, the address of the next instruction is sent out &lt;br /&gt;from the address bus ahead of time. This extra time (one clock period) is used to allow additional &lt;br /&gt;access time to slower memory components. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Not all memory references can take advantage of the pipe, which means that some memory &lt;br /&gt;cycles are not pipelined. These non-pipelined memory cycles request one wait state if the normal &lt;br /&gt;pipeline cycle requires no wait states. Overall, a pipe is a cost-saving feature that reduces the ac-&lt;br /&gt;cess time required by the memory system in low-speed systems. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;~~2 ~B2 A2. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111111 &lt;br /&gt;1 B3 A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;:::-t} B4 A4 6 &lt;br /&gt;U6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~BS A5 7 &lt;br /&gt;::---l} B. A5 DO &lt;br /&gt;'--lL: ~ 01 02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dig + &lt;br /&gt;03 &lt;br /&gt;D. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74FCT64'5 &lt;br /&gt;05 &lt;br /&gt;O. &lt;br /&gt;07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~ bDl ll &lt;br /&gt;O. d. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ B1 Al}:i: &lt;br /&gt;010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~g~ ~ &lt;br /&gt;011 &lt;br /&gt;012 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B4 A4 &lt;br /&gt;013 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~B5 A5 7 III 014 ~B6 A5 015 1 B7 A7 016 &lt;br /&gt;B8 AS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;017 &lt;br /&gt;01. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ o,g 01. 020 021 &lt;br /&gt;74FCT645 022 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;023 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,-YL-~Bl A12 &lt;br /&gt;02. &lt;br /&gt;025 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;182 A24 &lt;br /&gt;02. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ B3 A3 &lt;br /&gt;027 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 B4 A4 &lt;br /&gt;028 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 85 AS 7 &lt;br /&gt;02' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ B6 AS &lt;br /&gt;030 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-..lL g~ ~~ &lt;br /&gt;.&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;031 &lt;br /&gt;ADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ a vee NA O'R 10K '~ 8816 74FCT645 READY HOLD &lt;br /&gt;HOLDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~2 ~ 'NTR ~82 A2 NM' 1 B3 A3 RESET &lt;br /&gt;~B4 A46 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK2 &lt;br /&gt;1 85 AS 8038. t::::3:t B6 AS 8 B7 A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B. AS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;n,2 ~ &lt;br /&gt;14tCI()4~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r-----f 50 MHz I Oscilialor &lt;br /&gt;vee &lt;br /&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--I U1A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;2 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.. II.. &lt;br /&gt;74F14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U5B &lt;br /&gt;R!!,ET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r 10uF &lt;br /&gt;74F14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-3 A fully buffered 25 MHz 80386DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I fl r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 U7 &lt;br /&gt;4 1Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lA2 &lt;br /&gt;lA3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEO &lt;br /&gt;11 lA4 2Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEl &lt;br /&gt;1 &lt;br /&gt;15 2A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IIII &lt;br /&gt;0.3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE3 &lt;br /&gt;17 0.4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2 &lt;br /&gt;A3 cl ~~ A. &lt;br /&gt;A5 74f244 &lt;br /&gt;A6 &lt;br /&gt;A7 11~ .u!l A. A' 1= lAI Al0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A11 &lt;br /&gt;lA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A12 1111 &lt;br /&gt;lA3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A13 &lt;br /&gt;lA4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A14 &lt;br /&gt;2Al &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A15 &lt;br /&gt;2A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI. &lt;br /&gt;2A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A17 1 &lt;br /&gt;2M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AI. bb !~ A19 &lt;br /&gt;A20 74F244 &lt;br /&gt;A21 &lt;br /&gt;A22 &lt;br /&gt;A23 U. &lt;br /&gt;A24 lAI &lt;br /&gt;.05 1.0 &lt;br /&gt;A2. lA3 &lt;br /&gt;.07 lA4 &lt;br /&gt;A28 2Al &lt;br /&gt;A2' 2A2 &lt;br /&gt;A30 2A3 &lt;br /&gt;A31 2A' &lt;br /&gt;w/jj RÂ· bb Of!; !~ &lt;br /&gt;MIlO i=l LOCK 74F244 PEREa 110. BUSY ERROR lAI 1.0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lA3 &lt;br /&gt;1M &lt;br /&gt;2Al &lt;br /&gt;2A2 &lt;br /&gt;2A3 &lt;br /&gt;2A' ~ I:~ &lt;br /&gt;74f244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.lllL &lt;br /&gt;lAI &lt;br /&gt;lA2 &lt;br /&gt;lA3 &lt;br /&gt;lA' &lt;br /&gt;2Al &lt;br /&gt;2A2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-j 2A3 &lt;br /&gt;2A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o---;t&amp;lt; la &lt;br /&gt;74F244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data bus (D31-00) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AddreSSbU~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1Y1 ~8 &lt;br /&gt;1Y2 14 &lt;br /&gt;~~~ 12 2Vl~ &lt;br /&gt;2V2 R=--~~~~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;l:::::: lVI lV2 &lt;br /&gt;lV3 e:; &lt;br /&gt;IV. &lt;br /&gt;2Vl 8 2V2 &lt;br /&gt;2V3 8 2V4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;!=::: 1Y1 lV2 &lt;br /&gt;lV3 r=:: lV4 &lt;br /&gt;2Vl 8: 2V2 &lt;br /&gt;2V3 8 2V. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1Y1 H~ lV2 &lt;br /&gt;lV3 tiE;: lV4 &lt;br /&gt;2Vl t:::: 2V2 &lt;br /&gt;2V3 t::: 2V4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lVI !L....-&lt;br /&gt;lV2 ~ &lt;br /&gt;lV3 &lt;br /&gt;IV' &lt;br /&gt;2Vl &lt;br /&gt;2V2 &lt;br /&gt;2V3 &lt;br /&gt;2V. I-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â§fQ &lt;br /&gt;Â§f.1 &lt;br /&gt;~ &lt;br /&gt;BE3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W/a &lt;br /&gt;0,,&amp;quot;--&lt;br /&gt;MIlO &lt;br /&gt;ADS &lt;br /&gt;elK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HLDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;READY &lt;br /&gt;HOLD &lt;br /&gt;INTR &lt;br /&gt;t;ML &lt;br /&gt;lOCK &lt;br /&gt;~a &lt;br /&gt;Il!&amp;amp;L &lt;br /&gt;ERROR &lt;br /&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;en &lt;br /&gt;.!.. &lt;br /&gt;Z &lt;br /&gt;-i &lt;br /&gt;:0 &lt;br /&gt;0 &lt;br /&gt;Cl &lt;br /&gt;c: &lt;br /&gt;C&amp;quot;) &lt;br /&gt;-i &lt;br /&gt;0 &lt;br /&gt;Z &lt;br /&gt;-i &lt;br /&gt;0 &lt;br /&gt;-i &lt;br /&gt;:r: &lt;br /&gt;m &lt;br /&gt;00 &lt;br /&gt;C&amp;gt; &lt;br /&gt;to&amp;gt; &lt;br /&gt;00 &lt;br /&gt;en &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5: &lt;br /&gt;C&amp;quot;) &lt;br /&gt;:0 &lt;br /&gt;0 &lt;br /&gt;-u &lt;br /&gt;:0 &lt;br /&gt;0 &lt;br /&gt;C&amp;quot;) &lt;br /&gt;m &lt;br /&gt;en &lt;br /&gt;en &lt;br /&gt;0 &lt;br /&gt;:0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;en &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot; &lt;br /&gt;&amp;quot;'&amp;quot; &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;628 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Not all systems can take advantage of the pipe. These systems typically operate at 20, 25. &lt;br /&gt;or 33 MHz. In these higher-speed systems, another technique must be used to increase the &lt;br /&gt;memory system speed. The cache memory system improves overall performance of the memory &lt;br /&gt;systems for data that is accessed more than once. Note that the 80486 contains an internal cache &lt;br /&gt;called a level one cache, while the 80386 can only contain an external cache called a level two &lt;br /&gt;cache. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A cache is a high-speed memory system that is placed between the microprocessor and the &lt;br /&gt;DRAM memory system. Cache memory devices are usually static RAM memory components &lt;br /&gt;with access times of less than 25 ns. In many cases, we see cache memory systems of sizes be-&lt;br /&gt;tween 32K and 1M byte. The size of the cache memory is determined more by the application &lt;br /&gt;than by the microprocessor. If a program is small and refers to little memory data, a small cache &lt;br /&gt;is beneficial. If a program is large and references large blocks of memory, the largest cache size &lt;br /&gt;possible is recommended. In many cases, a 64K-byte cache improves speed sufficiently, but the &lt;br /&gt;maximum benefit is often derived from a 256K-byte cache. It has been found that increasing the &lt;br /&gt;cache size much beyond 256K provides little benefit to the operating speed of the system that &lt;br /&gt;contains an 80386 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interleaved Memory Systems. An interleaved memory system is another method for improving &lt;br /&gt;the speed of a system. Its only disadvantage is that it costs considerably more memory because &lt;br /&gt;of its structure. Interleaved memory systems are present in some systems so that memory access &lt;br /&gt;times can be lengthened without the need for wait states. In some systems, an interleaved &lt;br /&gt;memory may still require wait states, but may reduce their number. An interleaved memory &lt;br /&gt;system requires two or more complete sets of address buses and a controller that provides ad-&lt;br /&gt;dresses for each bus. Systems that employ two complete buses are called a two-way interleave, &lt;br /&gt;whereas systems that use four complete buses are called a/our-way interleave. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;An interleaved memory is divided into two or four parts. For example, if an interleaved &lt;br /&gt;memory system is developed for the 80386SX microprocessor, one part contains the 16-bit ad-&lt;br /&gt;dresses OOOOOOH-OOOOOIH, 000004H-000005H, etc. while the other part contains addresses &lt;br /&gt;000002-000003, 000006H-000007H, etc. While the microprocessor accesses locations OOOOOOH-&lt;br /&gt;OOOOOIH, the interleave control logic generates the address strobe signal for locations 000002H-&lt;br /&gt;000003H. The selects and accesses the word at location 000002H-OOOOO3H while the micro-&lt;br /&gt;processor processes the word at location OOOOOOH-OOOOOl H. This process alternates memory sec-&lt;br /&gt;tions, increasing the performance of the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interleaving lengthens the amount of access time provided to the memory because the ad-&lt;br /&gt;dress is generated to select the memory before the microprocessor accesses it. This is because the &lt;br /&gt;microprocessor pipelines memory addresses, sending the next address out before the data are &lt;br /&gt;read from the last address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A minor problem with interleaving is that the memory addresses must be accessed so that &lt;br /&gt;each section is addressed alternately. This does not always happen as a program executes. &lt;br /&gt;Under normal program execution, the microprocessor alternately addresses memory approxi-&lt;br /&gt;mately 93 percent of the time. For the remaining 7 percent, the microprocessor addresses data &lt;br /&gt;in the same memory section, which means that the memory system must cause wait states 7 per-&lt;br /&gt;cent of memory accesses because of the reduced access time. The access time is reduced be-&lt;br /&gt;cause the memory must wait until the previous data are transferred before it can obtain its &lt;br /&gt;address. This leaves it with less access time; therefore, a wait state is required for accesses in &lt;br /&gt;the same memo ~' bank. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Refer to Figure 16-4 for the timing diagram of the address as it appears at the micro-&lt;br /&gt;processor address pins. This timing diagram shows how the next address is output before the cur-&lt;br /&gt;rent data are accessed. It also shows how access time is increased using interleaved memory &lt;br /&gt;addresses for each section of memory compared to a non-interleaved access, which requires a &lt;br /&gt;wait state. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;elK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2-A31 .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00-031 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOSO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Section 0 transfer ~ I 0( Section 1 transfer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Section 0 &lt;br /&gt;address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;------r---------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 T1 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 0( Section 0 transfer ~ I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 &lt;br /&gt;(Twait) &lt;br /&gt;TW T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Section 0 Section O:address Section o:address Section O:address &lt;br /&gt;address--4-________ -4 __________ 4-________ -4 ____ ~,~----r_---------r----------r_---J.L---~---------4----------4-------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Section 1 X Section ~ addres~ ), II -!--&lt;br /&gt;address &amp;quot; L. --~~--------_i:'----__:_----_t_---J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: 0( Section 1 access time:--+! &lt;br /&gt;, (interleaved) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: 0( Section 0 access time --+! &lt;br /&gt;, (interleaved) ~ Section 0 access time ---+i (with a wait) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(non interleaved) &lt;br /&gt;FIGURE 16-4 The timing diagram of an interleaved memory system showing the access times and address signals for both sections of memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;...... &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T &lt;br /&gt;Z &lt;br /&gt;-i &lt;br /&gt;:D &lt;br /&gt;a &lt;br /&gt;CJ &lt;br /&gt;c &lt;br /&gt;C') &lt;br /&gt;-i &lt;br /&gt;Ci &lt;br /&gt;z &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a &lt;br /&gt;-i &lt;br /&gt;::z: &lt;br /&gt;m &lt;br /&gt;0:&amp;gt; &lt;br /&gt;o &lt;br /&gt;W &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;s:: &lt;br /&gt;C'5 &lt;br /&gt;:D &lt;br /&gt;a &lt;br /&gt;&amp;quot;&amp;quot;0 &lt;br /&gt;:D &lt;br /&gt;a &lt;br /&gt;C') &lt;br /&gt;m &lt;br /&gt;en &lt;br /&gt;en &lt;br /&gt;a &lt;br /&gt;:D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;en &lt;br /&gt;N &lt;br /&gt;to &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;630 CHAPTER 16 THE 80386 AND 80486 MICRDPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-5 pictures the interleave controller. Admittedly, this is a fairly complex logic &lt;br /&gt;circuit that needs some explanation. First, if the SEL input (used to select this section of the &lt;br /&gt;memory) is inactive (logic 0), then the WAIT signal is a logic 1. Also, both ALEO and ALE1, &lt;br /&gt;used to strobe the address to the memory sections, are logic 1 's, causing the latches connected to &lt;br /&gt;them to become transparent. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As soon as the SEL input becomes a logic 1, this circuit begins to function. The A 1 input &lt;br /&gt;is used to determine which latch (U2B or U5A) becomes a logic 0, selecting a section of the &lt;br /&gt;memory. Also, the ALE pin that becomes a logic 0 is compared with the previous state of the &lt;br /&gt;ALE pins. If the same section of memory is accessed a second time, the WAIT signal becomes a &lt;br /&gt;logic 0, requesting a wait state. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-6 illustrates an interleaved memory system that uses the circuit of Figure 16-5. &lt;br /&gt;Notice how the ALEO and ALEI signals are used to capture the address for either section of &lt;br /&gt;memory. The memory in each bank is 16-bits wide. If accesses to memory require 8-bit data, &lt;br /&gt;then in most cases the system causes wait states. As a program executes, the 80386SX fetches in-&lt;br /&gt;struction 16-bits at a time from normally sequential memory locations. Program execution uses &lt;br /&gt;interleaving in most cases. If a system is going to access mostly 8-bit data, it is doubtful that &lt;br /&gt;memory interleaving will reduce the number of wait states. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The access time allowed by an interleaved system such as the one shown in Figure 16-6 is &lt;br /&gt;increased to 112 ns from 69 ns using a 16 MHz system clock. (If a wait state is inserted, access &lt;br /&gt;time with a 16 MHz clock is 136 ns, which means that an interleaved system performs at about &lt;br /&gt;the same rate as a system with one wait state.) If the clock is increased to 20 MHz, the inter-&lt;br /&gt;leaved memory requires 89.6 ns, whereas standard, non-interleaved memory interfaces allow &lt;br /&gt;48 ns for memory access. At this higher clock rate, 80 ns DRAMs function properly, without &lt;br /&gt;wait states when the memory addresses are interleaved. If an access to the same section occurs, &lt;br /&gt;then a wait state is inserted. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Input/Output System &lt;br /&gt;The 80386 input/output system is the same as that found in any Intel 8086 family micro-&lt;br /&gt;processor-based system. There are 64K different bytes of I/O space available if isolated I/O is &lt;br /&gt;implemented. With isolated I/O, the IN and OUT instructions are used to transfer I/O data be-&lt;br /&gt;tween the microprocessor and I/O devices. The I/O port address appears on address bus connec-&lt;br /&gt;tions AI5-A2, with BE3-BEO used to select a byte, word, or doubleword of I/O data. If &lt;br /&gt;memory-mapped I/O is implemented, then the number of I/O locations can be any number up to &lt;br /&gt;4G bytes. With memory-mapped I/O, any instruction that transfers data between the micro-&lt;br /&gt;processor and memory system can be used for I/O transfers, because the I/O device is treated as &lt;br /&gt;a memory device. Almost all 80386 systems use isolated I/O because of the I/O protection &lt;br /&gt;scheme provided by the 80386 in protected mode operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-7 shows the I/O map for the 80386 microprocessor. Unlike the I/O map of ear-&lt;br /&gt;lier Intel microprocessors, which were 16-bits wide, the 80386 uses a full 32-bit wide I/O system &lt;br /&gt;divided into four banks. This is identical to the memory system, which is also divided into four &lt;br /&gt;banks. Most I/O transfers are 8-bits wide because we often use ASCII code (a 7-bit code) for &lt;br /&gt;transferring alphanumeric data between the microprocessor and printers and keyboards. This &lt;br /&gt;may change if Unicode, a 16-bit alphanumeric code, becomes common and replaces ASCII &lt;br /&gt;code. Recently, I/O devices that are 16- and even 32-bits wide have appeared for systems such as &lt;br /&gt;disk memory and video displa~' interfaces. These wider I/O paths increase the data transfer rate &lt;br /&gt;between the microprocessor and the I/O device when compared to 8-bit transfers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The I/O locations are numbered from OOOOH through FFFFH. A portion of the I/O map is &lt;br /&gt;designated for the 80387 arithmetic coprocessor. Although the port numbers for the coprocessor &lt;br /&gt;are well above the normal I/O map, it is important that they be taken into account when de-&lt;br /&gt;coding I/O space (overlaps). The coprocessor uses I/O locations 800000F8H-800000FFH for &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;ADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MRDe &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MWTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ir=D 1. U2A 1 3 J P Q~ &lt;br /&gt;3 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74AS02 ,-----1-&amp;lt; ClK &lt;br /&gt;2 K t o r--L-&lt;br /&gt;I~ 74AS112 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I U3A 1 &lt;br /&gt;1 2J 3 ;- U1B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3B 74ASOO 5 &lt;br /&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 6 &lt;br /&gt;'&amp;quot; S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74AS02 &lt;br /&gt;74ASOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1C ~ V U4A 74AS04 &lt;br /&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1D &lt;br /&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74AS02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;---1.L J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13 ClK &lt;br /&gt;R1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,.1L K 1K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;USB 11 J p Q 9 &lt;br /&gt;R 13 ClK &lt;br /&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or--Z-lr elL K l 1 4 74AS112 &lt;br /&gt;14 USA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-- ....L J P Q S &lt;br /&gt;1 R ClK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C 13 2 oc-L-K l &lt;br /&gt;1~ 74ASl12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U6A 6 USB ~ 4 U7A 3 9 L-L J P Q S P Q &lt;br /&gt;R 74AS08 1 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U6B ClK C 7 4 ~K C 0 6 l 0 6 l &lt;br /&gt;1 LY 1 74ASl12 &lt;br /&gt;4 74ASl12 74AS08 S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U4B &lt;br /&gt;4 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74AS04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U6C &lt;br /&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 &lt;br /&gt;10 U8A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;74AS08 1 &lt;br /&gt;U6D 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;4 &lt;br /&gt;74AS08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 74AS02 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURI;: 16-5 The interleaved control logic, which generates separate ADS signals and a WAIT signal used to control interleaved memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADSO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;en &lt;br /&gt;.!.. &lt;br /&gt;Z &lt;br /&gt;-I &lt;br /&gt;:D &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;c &lt;br /&gt;&amp;lt;&amp;gt; &lt;br /&gt;:::j &lt;br /&gt;0 &lt;br /&gt;Z &lt;br /&gt;-I &lt;br /&gt;0 &lt;br /&gt;-I &lt;br /&gt;:::c &lt;br /&gt;m &lt;br /&gt;co &lt;br /&gt;a &lt;br /&gt;w &lt;br /&gt;co &lt;br /&gt;en &lt;br /&gt;s:: &lt;br /&gt;C'5 &lt;br /&gt;:D &lt;br /&gt;0 &lt;br /&gt;&amp;quot;0 &lt;br /&gt;:D &lt;br /&gt;0 &lt;br /&gt;&amp;lt;&amp;gt; &lt;br /&gt;m &lt;br /&gt;en &lt;br /&gt;en &lt;br /&gt;0 &lt;br /&gt;:D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;en &lt;br /&gt;w &lt;br /&gt;~ &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;632 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDC &lt;br /&gt;WTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M--&lt;br /&gt;M--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;elK &lt;br /&gt;ADS &lt;br /&gt;SEl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W AIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,..-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;latch &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;I &lt;br /&gt;r--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Latch &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALE &lt;br /&gt;'----r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 Interleave &lt;br /&gt;logic &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AlEO r---&lt;br /&gt;AlE1 r--&lt;br /&gt;WAIT ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(see Fig. 10-37) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;section &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;j&amp;quot;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/ &lt;br /&gt;r &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V r- CS I Decoder J &lt;br /&gt;Memory &lt;br /&gt;section ) 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~j &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I Decoder CS I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-6 An interleaved memory system showing the address latches and the interleaved logic circuit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-7 The isolated &lt;br /&gt;I/O map for the 80386 micro-&lt;br /&gt;processor. Here four banks &lt;br /&gt;of 8-bits each are used to &lt;br /&gt;address 64K different I/O &lt;br /&gt;locations. I/O is numbered &lt;br /&gt;from location OOOOH to &lt;br /&gt;FFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0003 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank 3 Bank 2 Bank 1 BankO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-__ --' 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;communications between the 80387 and 80386. The 80287 numeric coprocessor designed for &lt;br /&gt;use with the 80286 uses I/O addresses 00F8H-OOFFH for coprocessor communications. Because &lt;br /&gt;we often only decode address connections A15-A2 to select an I/O device, be aware that the co-&lt;br /&gt;processor will activate devices 00F8H-OOFFH unless address line A31 is also decoded. This &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-1 INTRODUCTION TO THE 80386 MICROPROCESSOR 633 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;should present no problem because you really should not be using I/O ports 00F8H-00FFH for &lt;br /&gt;any purpose. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The only new feature that is added to the 80386 with respect to I/O is the I/O privilege in-&lt;br /&gt;formation added to the tail end of the TSS when the 80386 is operated in protected mode. As de-&lt;br /&gt;3cribed in the section on memory management, an I/O location can be blocked or inhibited in &lt;br /&gt;protected mode. If the blocked I/O location is addressed, an interrupt (type 13, general fault) is &lt;br /&gt;generated. This scheme is added so that I/O access can be prohibited in a multi-user environ-&lt;br /&gt;ment. Blocking is an extension of the protected mode operation, as are privilege levels. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory and 1/0 Control Signals &lt;br /&gt;The memory and I/O are controlled with separate signals. The MilO signal indicates whether the &lt;br /&gt;data transfer is between the microprocessor and the memory (MilO = 1) or I/O (MilO = 0). In ad-&lt;br /&gt;dition to MilO, the memory and I/O systems must read or write data. The wiR signal is a logic 0 &lt;br /&gt;for a read operation, and a logic 1 for a write operation. The ADS signal is used to qualify the &lt;br /&gt;MilO and W iR control signals. This is a slight deviation from earlier Intel microprocessors that &lt;br /&gt;didn't use ADS for qualification. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Refer to Figure 16-8 for a simple circuit that generates four control signals for the memory &lt;br /&gt;and I/O devices in the system. Notice that two control signals are developed for memory control &lt;br /&gt;(MRDC and MWTq and two for I/O control (lORC and lowq. These signals are consistent &lt;br /&gt;with the memory and I/O control signals generated for use in earlier versions of the Intel micro-&lt;br /&gt;processor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Timing &lt;br /&gt;Timing is important to understanding how to interface memory and I/O to the 80386 micro-&lt;br /&gt;processor. Figure 16-9 shows the timing diagram of a non-pipelined memory read cycle. Notice &lt;br /&gt;that the timing is referenced to the CLK2 input signal and that a bus cycle consists of four &lt;br /&gt;clocking periods. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each bus cycle contains two clocking states with each state (Tl and T2) containing two &lt;br /&gt;clocking periods. Notice in Figure 16-9 that the access time is listed as time number 3. The &lt;br /&gt;16 MHz version allows memory an access time of 78 ns before wait states are inserted in this &lt;br /&gt;non-pipe1ined mode of operation. To select the non-pipelined mode, we place a logic 1 on the &lt;br /&gt;NApin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-10 illustrates the read timing when the 80386 is operated in the pipelined mode. &lt;br /&gt;Notice that additional time is allowed to the memory for accessing data because the address is sent &lt;br /&gt;out early. Pipelined mode is selected by placing a logic 0 on the NA pin and by using address &lt;br /&gt;latches to capture the pipelined address. The clock pulse that is applied to the address latches &lt;br /&gt;comes from the ADS signal. Address latches must be used with a pipe1ined system as well as &lt;br /&gt;with interleaved memory banks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-8 Generation &lt;br /&gt;of memory and liD control &lt;br /&gt;signals for the 80386, 80486, &lt;br /&gt;and Pentium &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W/R --------,;;; A &lt;br /&gt;B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/iO -------I--&amp;gt;oI...i e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ri--7-i G1 &lt;br /&gt;G2A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS ------I--t---&amp;quot;o G2B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;YO DÂ±-'~---IORe &lt;br /&gt;Y1 lowe &lt;br /&gt;Y2 &lt;br /&gt;Y3 &lt;br /&gt;Y4 ~i:---- MRDe &lt;br /&gt;Y5 MWTC &lt;br /&gt;Y6 &lt;br /&gt;Y7 &lt;br /&gt;L..7&amp;quot;&amp;quot;'4&amp;quot;&amp;quot;'F~1-3~8--&amp;quot;'&amp;quot; &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;634 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-9 The non-&lt;br /&gt;pipelined read timing for the &lt;br /&gt;80386 microprocessor T1 T2 T1 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, , j5=: 3~; --+i , , &lt;br /&gt;Data: -----------~----------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, , &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-----------1----------C: , , , , &lt;br /&gt;, &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;, , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33 MHz 25 MHz 20 MHz &amp;quot;'6 MHz &lt;br /&gt;Time 1 &lt;br /&gt;Time 2 &lt;br /&gt;Time 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-15 ns &lt;br /&gt;5 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;46 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-21 ns &lt;br /&gt;7ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4-30 ns 4-36 ns &lt;br /&gt;11 ns 11 ns &lt;br /&gt;59 ns 78 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notice that the pipelined address appears one complete clocking state before it normally ap-&lt;br /&gt;pears with non-pipelined addressing. In the 16 MHz version of the 80386, this allows an additional &lt;br /&gt;62.5 ns for memory access. In a non-pipelined system, a memory access time of 78 ns is allowed to &lt;br /&gt;the memory system; in a pipelined system, 140.5 ns is allowed. The advantages of the pipelined &lt;br /&gt;system are that no wait states are required (in many, but not all bus cycles) and much lower-speed &lt;br /&gt;memory devices may be connected to the microprocessor. The disadvantage is that we need to in-&lt;br /&gt;terleave memory to use a pipe, which requires additional circuitry and occasional wait states. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-10 The &lt;br /&gt;pipelined read timing for the &lt;br /&gt;80386 microprocessor T1 T2 T1 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address Address 1 Addr~ss 2 Address 3 : &lt;br /&gt;I I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;: : : 3 : ~I f+2 &lt;br /&gt;Data D ----------+----------e-------r ---- ---e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &amp;quot; &lt;br /&gt;I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS 1\\ I i\\ ( &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NA 1\\ I &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ I &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-1 INTRODUCTION TO THE 80386 MICROPROCESSOR 635 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Wait States &lt;br /&gt;Wait states are needed if memory access times are long compared with the time allowed by the &lt;br /&gt;80386 for memory access. In a non-pipe lined 33 MHz system, memory access time is only 46 ns. &lt;br /&gt;Currently, no DRAM memory exists that has an access time of 46 ns. This means that wait states &lt;br /&gt;must be introduced to access the DRAM (l wait for 70 ns DRAM) or an EPROM that has an ac-&lt;br /&gt;cess time of 100 ns (2 waits). Note that this wait state is built into a motherboard and cannot be &lt;br /&gt;removed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The READY input controls whether or not wait states are inserted into the timing. The &lt;br /&gt;&amp;quot;&amp;quot;,,;-;--;o=&amp;gt;, READY input on the 80386 is a dynamic input that must be activated during each bus cycle. &lt;br /&gt;Figure 16-11 shows a few bus cycles with one cycle normal (0 wait) cycle and one that contains &lt;br /&gt;a single wait state. Notice how the READY input is controlled to cause 0 or 1 wait. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The READY signal is sampled at the end of a bus cycle to determine if the clock cycle is &lt;br /&gt;T2 or TW. If READY = 0 at this time, it is the end of the bus cycle or T2. If READY is 1 at the &lt;br /&gt;end of a clock cycle, the cycle is a TW and the microprocessor continues to test READY, &lt;br /&gt;searching for a logic 0 and the end of the bus cycle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In a non-pipe lined system, whenever ADS becomes a logic 0, a wait state is inserted if &lt;br /&gt;&amp;quot;R:;=E&amp;quot;A-;D&amp;quot;'y'&amp;quot; = 1. After ADS returns to a logic 1, the positive edges of the clock are counted to gen-&lt;br /&gt;erate the READY signal. The READY signal becomes a logic 0 after the first clock to insert 0 &lt;br /&gt;wait states. If 1 wait state is inserted, the READY line must remain a logic 1 until at least two &lt;br /&gt;clocks have elapsed. If additional wait states are desired, then additional time must elapse before &lt;br /&gt;READY is cleared. This essentially allows any number of wait states to be inserted into the &lt;br /&gt;timing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-12 shows a circuit that inserts 0 through 3 wait states for various memory ad-&lt;br /&gt;dresses. In the example, 1 wait state is produced for a DRAM access and 2 waits are pro-&lt;br /&gt;duced for an EPROM access. The 74Fl64 clears whenever ADS is low and DIC is high. It &lt;br /&gt;begins to shift after ADS returns to a logic 1 level. As it shifts the 00000000 in the shift reg-&lt;br /&gt;ister begins to fill with logic l's from the QA connection towards the QH connection. The &lt;br /&gt;four different outputs are connected to an inverting multiplexer that generates the active low &lt;br /&gt;READY signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address )------i------i-'! X~ ___ -+ _____ -+-_____ + &lt;br /&gt;, , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data D: ----- -- -- --~- ----- -- --0: -------- __ L ------ -- -- ----~- -- --- ---c: &lt;br /&gt;, , &amp;quot; &lt;br /&gt;I I 'I&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, , , &lt;br /&gt;, , , &lt;br /&gt;, , , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;u &lt;br /&gt;FIGURE 16-11 A non-pipelined 80386 with 0 and 1 wait states &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;636 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;e~2--------------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OIC-------' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 TW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JJ &lt;br /&gt;D/C : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS 1&amp;quot;\\\\.-_-,1 &lt;br /&gt;READY lJ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Wit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W IS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Wits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Select EPROM &lt;br /&gt;~---------' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 TW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;w &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lLJ &lt;br /&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LlJ &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Select DRAM n\\.-_-+--_-+-_--J!: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TW T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'-+ , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ll &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Select EPROM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-12. (a) Circuit and (b) timing that selects 1 wait state for DRAM and 2 waits for EPROM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-2 SPECIAL 80386 REGISTERS &lt;br /&gt;A new series of registers, not found in earlier Intel microprocessors, appears in the 80386 as con-&lt;br /&gt;trol, debug, and test registers. Control registers CRO-CR3 control various features, registers &lt;br /&gt;DRO-DR7 facilitate debugging, and registers TR6 and TR7 are used to test paging and caching. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control Registers &lt;br /&gt;In addition to the EFLAGS and EIP described earlier, there are other control registers found in &lt;br /&gt;the 80386. Control register 0 (CRO) is identical to the MSW (machine status word) found in the &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16--2 SPECIAL 80386 REGISTERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MSW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-13 The control &lt;br /&gt;register structure of the &lt;br /&gt;80386 microprocessor G 000000000000000 00000000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Not used &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page fault linear address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page directory base &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;637 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E T EM P &lt;br /&gt;T S MP E CRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CR1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CR2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000000000 CR3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 microprocessor, except that it is 32-bits wide instead of 16 bits. Additional control regis-&lt;br /&gt;ters are CR1, CR2, and CR3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-13 illustrates the control register structure of the 80386. Control register CR 1 is &lt;br /&gt;not used in the 80386, but is reserved for future products. Control register CR2 holds the linear &lt;br /&gt;page address of the last page accessed before a page fault interrupt. Finally, control register CR3 &lt;br /&gt;holds the base address of the page directory. The rightmost l2-bits of the 32-bit page table ad-&lt;br /&gt;dress contain zeros and combine with the remainder of the register to locate the start of the 4K-&lt;br /&gt;long page table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register CRO contains a number of special control bits that are defined as follows in the &lt;br /&gt;80386: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PG Selects page table translation of linear addresses into physical addresses when PG = &lt;br /&gt;1. Page table translation allows any linear address to be assigned any physical &lt;br /&gt;memory location. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ET Selects the 80287 coprocessor when ET = 0 or the 80387 coprocessor when ET = 1. &lt;br /&gt;This bit was installed because there was no 80387 available when the 80386 first &lt;br /&gt;appeared. In most systems, ET is set to indicate that an 80387 is present in the &lt;br /&gt;system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TS Indicates that the 80386 has switched tasks (in protected mode, changing the contents &lt;br /&gt;of TR places a 1 into TS). If TS = 1, a numeric coprocessor instruction causes a type &lt;br /&gt;7 (coprocessor not available) interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EM Is set to cause a type 7 interrupt for each ESC instruction. (ESCape instructions are &lt;br /&gt;used to encode instructions for the 80387 coprocessor.) We often use this interrupt to &lt;br /&gt;emulate, with software, the function of the coprocessor. Emulation reduces the &lt;br /&gt;system cost, but it often takes at least 100 times longer to execute the emulated &lt;br /&gt;coprocessor instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MP Is set to indicate that the arithmetic coprocessor is present in the system. &lt;br /&gt;PE Is set to select the protected mode of operation for the 80386. It may also be cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to reenter the real mode. This bit can only be set in the 80286. The 80286 could not &lt;br /&gt;return to real mode without a hardware reset, which precludes its use in most systems &lt;br /&gt;that use protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Debug and Test Registers &lt;br /&gt;Figure 16-14 shows the sets of debug and test registers. The first four debug registers contain &lt;br /&gt;32-bit linear breakpoint addresses. (A linear address is a 32-bit address generated by a micro-&lt;br /&gt;processor instruction that mayor may not be the same as the physical address.) The breakpoint &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;638 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 16 15 &lt;br /&gt;BREAKPOINT 0 LINEAR ADDRESS &lt;br /&gt;BREAKPOINT 1 LINEAR ADDRESS &lt;br /&gt;BREAKPOINT 2 LINEAR ADDRESS &lt;br /&gt;BREAKPOINT 3 LINEAR ADDRESS &lt;br /&gt;Intel reserved. Do not define. &lt;br /&gt;Intel reserved. Do not define. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B B B 0 000 0 T S 0 a a o 0 &lt;br /&gt;o B B B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 2 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORO &lt;br /&gt;DR1 &lt;br /&gt;DR2 &lt;br /&gt;DR3 &lt;br /&gt;DR4 &lt;br /&gt;DRS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DR6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEN1Rlwi LEN 1~lwl LEN IRlwl LEN 1~lw 0 oG o 0 OG L G L G LG L G L 333222111000 0 E E 3 3 2 2 1 100 DR7 &lt;br /&gt;31 16 15 o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 12 11 a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LINEAR ADDRESS V 0 0 U U W W 0 01 0 0 C # # # TR6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PHYSICAL ADDRESS a 0 0 a a 0 0 P REP 0 0 L TR7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-14 The debug and test registers of the 80386 (Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addresses, which may locate an instruction or datum, are constantly compared with the addresses &lt;br /&gt;generated by the program. If a match occurs, the 80386 will cause a type 1 interrupt (TRAP or &lt;br /&gt;debug interrupt) to occur if directed by debug registers DR6 and DR7. This feature is a much-&lt;br /&gt;expanded version of the basic trapping or tracing allowed with the earlier Intel microprocessors &lt;br /&gt;through the type 1 interrupt. The breakpoint addresses are very useful in debugging faulty soft-&lt;br /&gt;ware. The control bits in DR6 and DR7 are defined as follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BT &lt;br /&gt;BS &lt;br /&gt;BD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B3-BO &lt;br /&gt;LEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If set (1) , the debug interrupt was caused by a task switch. &lt;br /&gt;If set, the debug interrupt was caused by the TF bit in the flag register. &lt;br /&gt;If set, the debug interrupt was caused by an attempt to read the debug register with &lt;br /&gt;the GD bit set. The GD bit protects access to the debug registers. &lt;br /&gt;Indicate which of the four debug breakpoint addresses caused the debug interrupt. &lt;br /&gt;Each of the four length fields pertains to each of the four breakpoint addresses &lt;br /&gt;stored in DRO-DR3. These bits further define the size of access at the breakpoint &lt;br /&gt;address as 00 (byte), 01 (word), or 11 (doubleword). &lt;br /&gt;Each of the four read/write fields pertains to each of the four breakpoint addresses &lt;br /&gt;stored in DRO-DR3. The RW field selects the cause of action that enabled a break-&lt;br /&gt;point address as 00 (instruction access), 01 (data write), and 11 (data read and write). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GD If set, GD prevents any read or write of a debug register by generating the debug &lt;br /&gt;interrupt. This bit is automatically cleared during the debug interrupt so that the &lt;br /&gt;debug registers can be read or changed if needed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GE If set, selects a global breakpoint address for any of the four breakpoint address &lt;br /&gt;registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LE If set, selects a local breakpoint address for any of the four breakpoint address &lt;br /&gt;registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The test registers, TR6 and TR7, are used to test the translation look-aside buffer (TLB). &lt;br /&gt;The TLB is used with the paging unit within the 80386. The TLB holds the most commonly used &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-3 80386 MEMORY MANAGEMENT 639 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;page table address translations. The TLB reduces the number of memory reads required for &lt;br /&gt;looking up page translation addresses in the page translation tables. The TLB holds the most &lt;br /&gt;common 32 entries from the page table, and it is tested with the TR6 and TR7 test registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Test register TR6 holds the tag field (linear address) of the TLB, and TR7 holds the phys-&lt;br /&gt;ical address of the TLB. To write a TLB entry, perfom the following steps: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Write TR7 for the desired physical address, PL, and REP values. &lt;br /&gt;2. Write TR6 with the linear address, making sure that C = O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To read a TLB entry: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Write TR6 with the linear address, making sure that C = 1. &lt;br /&gt;2. Read both TR6 and TR7. Ifthe PL bit indicates a hit, then the desired values ofTR6 and TR7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;indicate the contents of the TLB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bits found in TR6 and TR7 indicate the following conditions: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;V Shows that the entry in the TLB is valid. &lt;br /&gt;D Indicates that the entry in the TLB is invalid or dirty. &lt;br /&gt;U A bit for the TLB. &lt;br /&gt;W Indicates that the area addressed by the TLB entry is writable. &lt;br /&gt;C Selects a write (0) or immediate lookup (1) for the TLB. &lt;br /&gt;PL Indicates a hit if a logic 1. &lt;br /&gt;REP Selects which block of the RLB is written. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Refer to the section on memory management and the paging unit for more detail on the &lt;br /&gt;function of the TLB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 MEMORY MANAGEMENT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory-management unit (MMU) within the 80386 is similar to the MMU inside the &lt;br /&gt;80286, except that the 80386 has a paging unit not found in the 80286. The MMU performs the &lt;br /&gt;task of converting linear addresses, as they appear as outputs from a program, into physical ad-&lt;br /&gt;dresses that access a physical memory location located anywhere within the memory system. &lt;br /&gt;The 80386 uses the paging mechanism to allocate any physical address to any logical address. &lt;br /&gt;Therefore, even though the program is accessing memory location AOOOOH with an instruction, &lt;br /&gt;the actual physical address could be memory location 100000H, or any other location if paging &lt;br /&gt;is enabled. This feature allows virtually any software, written to operate at any memory location, &lt;br /&gt;to function in an 80386 because any linear location can become any physical location. Earlier &lt;br /&gt;Intel microprocessors did not have this flexibility. Paging is used with DOS 5.0/6.x to relocate &lt;br /&gt;80386 and 80486 memory at addresses above FFFFFH and into spaces between ROMs at loca-&lt;br /&gt;tions DOOOO-DFFFFH and other areas as they are available. The area between ROMs is often re-&lt;br /&gt;ferred to as upper memory; the area above FFFFFH is referred to as extended memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Descriptors and Selectors &lt;br /&gt;Before the memory paging unit is discussed, we will examine the descriptor and selector for the &lt;br /&gt;80386 microprocessor. The 80386 uses descriptors in much the same fashion as the 80286. In &lt;br /&gt;both microprocessors, a descriptor is a series of 8 bytes that describe and locate a memory seg-&lt;br /&gt;ment. A selector (segment register) is used to index a descriptor from a table of descriptors. The &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;640 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;main difference between the 80286 and 80386 is that the latter has two additional selectors (FS &lt;br /&gt;and GS) and the most-significant two bytes of the qescriptor are defined for the 80386. Another &lt;br /&gt;difference is that 80386 descriptors use a 32-bit base address and a 20-bit limit, instead of a &lt;br /&gt;24-bit base address and a 16-bit limit as found on the 80286. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80286 addresses a 16M-byte memory space with its 24-bit base address and has a seg-&lt;br /&gt;ment length limit of 64K bytes due to the 16-bit limit. The 80386 addresses a 4G-byte memory &lt;br /&gt;space with its 32-bit ~ase address and has a segment length limit of 1M byte or 4G bytes due to &lt;br /&gt;a 20-bit limit that is .used in two different ways. The 20-bit limit can access a segment with a &lt;br /&gt;length of 1 M byte if ~he granularity bit (G) = O. If G = 1, the 20-bit limit allows a segment length &lt;br /&gt;of4G bytes. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The granularity bit is found in the 80386 descriptor. If G = 0, the number stored in the limit &lt;br /&gt;is interpreted directly as a limit, allowing it to ~ontain any limit between OOOOOH and FFFFFH &lt;br /&gt;for a segment size up to 1M byte. If G = 1, the number stored in the limit is interpreted as &lt;br /&gt;OOOOOXXXH through FFFFFXXXH, where the XXX is OOOH. This allows the limit of the seg-&lt;br /&gt;ment to range between 0 bytes to 4G bytes in steps of 4K bytes. A limit of00001H indicates that &lt;br /&gt;the limit is 4Kbytes when G = 1, and 1 byte when G = O. An example is a segment that begins at &lt;br /&gt;physical address 10000000H. If the limit is 00001H and G = 0, this segment begins at &lt;br /&gt;10000000H and ends at 1000000lH. If G = 1 with the same limit (OOOOlH), the segment begins &lt;br /&gt;at location 10000000H and ends at location 1000IQOOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-15 shows how the 80386 addresses a memory segment in the protected mode &lt;br /&gt;using a selector and a descriptor. Note that this is identical to the way that a segment is addressed &lt;br /&gt;by the 80286. The difference is the size of the segment accessed by the 80386. The selector uses &lt;br /&gt;its leftmost 13-bits to select a descriptor from a descriptor table. The TI bit indicates either the &lt;br /&gt;local (TI = 1) or global (TI = 0) descriptor table. The rig~tmost 2-bits of the selector define the &lt;br /&gt;requested privilege level of the access. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the selector uses a 13-bit code to access a descriptor, there are at most 8,192 de-&lt;br /&gt;scriptors in each table, local or global. Since each segment (iIi an 80386) can be 4G bytes in &lt;br /&gt;length, we can access 16,384 segments at a time with the two descriptor tables. This allows the &lt;br /&gt;80386 to access a virtual memory size of 64T bytes. Of course, only 4G bytes of memory actu-&lt;br /&gt;ally exist in the memory system (1 T byte = 1,024G bytes). If a program requires more than 4G &lt;br /&gt;bytes of memory at a time, it can be swapped between the memory system and a disk drive or &lt;br /&gt;other form of large volume storage. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80386 uses descriptor tables for both global (GDT) and local (LDT) descriptors. A &lt;br /&gt;third descriptor table appears for interrupt (IDT) descriptors or gates. The first six bytes of the de-&lt;br /&gt;scriptor are the same as in the 80286, which allows 80286 software to be upward compatible with &lt;br /&gt;the 80386. (An 80286 descriptor used OOH for its most-significant two bytes.) See Figure 16-16 &lt;br /&gt;for the 80286 and 80386 descriptor. The base address is 32-bits in the 80386, the limit is 20-bits, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-15 Protected &lt;br /&gt;mode addressing using a &lt;br /&gt;segment register as a &lt;br /&gt;selector (Courtesy of Intel &lt;br /&gt;Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48132 BIT POINTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I-___ -f;.../--,..SE_G_MENT LIMIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MEMORY OPERAND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AC ~ESS RIGHTS &lt;br /&gt;LIMIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BASE ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEGMENT &lt;br /&gt;DESCRIPTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEGMENT BASE &lt;br /&gt;ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SELECTED &lt;br /&gt;SEGMENT &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-3 80386 MEMORY MANAGEMENT 641 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and a G bit selects the limit multiplier (1 or 4K times). The fields in the descriptor for the 80386 &lt;br /&gt;are defined as follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base (B31-BO) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Limit (L19-LO) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Access Rights &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AVL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Defines the starting 32-bit address of the segment within the 4G-byte &lt;br /&gt;physical address space of the 80386 microprocessor. &lt;br /&gt;Defines the limit of the segment in units of bytes if the G bit = 0, or in &lt;br /&gt;units of 4K bytes if G = 1. This allows a segment to be of any length &lt;br /&gt;from 1 byte to 1M byte if G = 0 and from 4K bytes to 4G bytes if G = i. &lt;br /&gt;Recall that the limit indicates the last byte in a segment. &lt;br /&gt;Determines privilege level and other information about the segment. This &lt;br /&gt;byte varies with different types of descriptors and is elaborated with each &lt;br /&gt;descriptor type. &lt;br /&gt;The granularity bit selects a multiplier of 1 or 4K times for the limit &lt;br /&gt;field. If G = 0, the multiplier is 1; if G = 1, the mUltiplier is 4K. &lt;br /&gt;Selects the default register size. If D = 0, the registers are 16-bits wide, &lt;br /&gt;as in the 80286; if D = 1, they are 32-bits wide, as in the 80386. This &lt;br /&gt;bit determines whether prefixes are required for 32-bit data and index &lt;br /&gt;registers. If D = 0, then a prefix is required to access 32-bit registers and &lt;br /&gt;to use 32-bit pointers. If D = 1, then a prefix is required to access 16-bit &lt;br /&gt;registers and 16-bit pointers. The USE16 and USE32 directives appended &lt;br /&gt;to the SEGMENT statement in assembly language control the setting of &lt;br /&gt;the D bit. In the real mode, it is always assumed that the registers are &lt;br /&gt;16-bits wide, so any instruction that references a 32-bit register or pointer &lt;br /&gt;must be prefixed. The current version of DOS assumes D = O. &lt;br /&gt;This bit is available to the operating system to use in any way that it sees &lt;br /&gt;fit. It often indicates that the segment described by the descriptor is &lt;br /&gt;available. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Descriptors appear in two forms in the 80386 microprocessor: the segment descriptor and &lt;br /&gt;the system descriptor. The segment descriptor defines data, stack, and code segments; the system &lt;br /&gt;descriptor defines information about the system's tables, tasks, and gates. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment Descriptors. Figure 16-17 shows the segment descriptor. This descriptor fits the gen-&lt;br /&gt;eral form as dictated in Figure 16-16, but the access rights bits are defined to indicate how the &lt;br /&gt;data, stack, or code segment described by the descriptor functions. Bit position 4 of the access &lt;br /&gt;rights byte determines if the descriptor is a data or code segment descriptor (S = 1) or a system &lt;br /&gt;segment descriptor (S = 0). Note that the labels used for these bits may vary in different versions &lt;br /&gt;of Intel literature, but perform the same tasks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 D escnptor 80386 Descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reserved 6 Base (B24-B31) GIDIOfl Limit r (L16-L19) 6 &lt;br /&gt;AccesS' rights I Base (B23-B16) 4 Access rights Base (B23-B16) 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base (B15-BO) 2 Base (B15-BO) 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Limit (L 15-LO) o Limit (L 15-LO) o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-16 The descriptors for the 80286 and 80386 microprocessors &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;642 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-17 The format &lt;br /&gt;of the 80386 segment &lt;br /&gt;descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Limit (L16-L19) 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Limit (L 15-LO) o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Following is a description of the access rights bits and their functions in the segment de-&lt;br /&gt;scriptor: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P Present is a logic 1 to indicate that the segment is present. If P = 0 and the segment &lt;br /&gt;is accessed through the descriptor, a type II interrupt occurs. This interrupt &lt;br /&gt;indicates that a segment was accessed that is not present in the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DPL Descriptor privilege level sets the privilege level of the descripl;)r where 00 has &lt;br /&gt;the highest privilege and 11 has the lowest. This is used to protei ~ access to &lt;br /&gt;segments. If a segment is accessed with a privilege level that is lower (higher in &lt;br /&gt;number) than the DPL, a privilege violation interrupt occurs. Privilege levels are &lt;br /&gt;used in a multi-user system to prevent access to an area of the system memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S Segment indicates a data or code segment descriptor (S = 1) or a system segment &lt;br /&gt;descriptor (S = 0). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E Executable selects a data (stack) segment (E = 0) or a code segment (E = I). E also &lt;br /&gt;defines the function of the next two bits (X and RW). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;X If E = 0, then X indicates the direction of expansion for the data segment. If X = 0, &lt;br /&gt;the segment expands upward, as in a data segment; if X = I, the segment expands &lt;br /&gt;downward, as in a stack segment. If E = 1, then X indicates if the privilege level of &lt;br /&gt;the code segment is ignored (X = 0) or observed (X = 1). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RW IfE = 0, then RW indicates that the data segment may be written (RW = I) or not &lt;br /&gt;written (RW = 0). If E = 1, then RW indicates that the code segment may be read &lt;br /&gt;(RW = I) or not read (RW = 0). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A Accessed is set each time that the microprocessor accesses the segment. It is some-&lt;br /&gt;times used by the operating system to keep track of which segments have been &lt;br /&gt;accessed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System Descriptor. The system descriptor is illustrated in Figure 16-18. There are 16 possible &lt;br /&gt;system descriptor types (see Table 16-1 for the different descriptor types), but not all are used in &lt;br /&gt;the 80386 microprocessor. Some of these types are defined for the 80286 so that the 80286 soft-&lt;br /&gt;ware is compatible with the 80386. Some of the types are new and unique to the 80386. Some &lt;br /&gt;have yet to be defined and are reserved for future Intel products. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-18 The general &lt;br /&gt;format of an 80386 system &lt;br /&gt;descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Access rights byte -+-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 Descri~tor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base (B24-B31) G 10 10 10 I(L1~\\9) &lt;br /&gt;pi DfLI 0 I :TyJ,e: Base (B23-B16) , , , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base (B15-BO) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Limit (L 15-LO) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-3 80386 MEMORY MANAGEMENT 643 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 16-1 80386 system &lt;br /&gt;descriptor types Type Purpose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 Invalid &lt;br /&gt;0001 Available 80286 TSS &lt;br /&gt;0010 LOT &lt;br /&gt;0011 Busy 80286 TSS &lt;br /&gt;0100 80286 call gate &lt;br /&gt;0101 Task gate (80286 or 80386) &lt;br /&gt;0110 80286 interrupt gate &lt;br /&gt;0111 80286 trap gate &lt;br /&gt;1000 Invalid &lt;br /&gt;1001 Available 80386 TSS &lt;br /&gt;1010 Reserved for future Intel products &lt;br /&gt;1011 Busy 80386 TSS &lt;br /&gt;11 00 80386 call gate &lt;br /&gt;1101 Reserved for future Intel products &lt;br /&gt;1110 80386 interrupt gate &lt;br /&gt;1111 80836 trap gate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Descriptor Tables &lt;br /&gt;The descriptor tables define all of the segments used in the 80386 when operated in the protected &lt;br /&gt;mode. There are three types of descriptor tables: the global descriptor table (GDT), the local de-&lt;br /&gt;scriptor table (LDT), and the interrupt descriptor table (IDT). The registers used by the 80386 to &lt;br /&gt;address these three tables are called the global descriptor table register (GDTR), the local de-&lt;br /&gt;scriptor table register (LDTR), and the interrupt descriptor table register (IDTR). These registers &lt;br /&gt;are loaded respectively with the LGDT, LLDT, and LIDT instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The descriptor table is a variable-length array of data with each entry holding an 8-byte &lt;br /&gt;long descriptor. The local and global descriptor tables hold up to 8,192 entries each, and the in-&lt;br /&gt;terrupt descriptor table holds up to 256 entries. A descriptor is indexed from either the local or &lt;br /&gt;global descriptor table by the selector that appears in a segment register. Figure 16-19 shows a &lt;br /&gt;segment register and the selector that it holds in the protected mode. The leftmost 13-bits index &lt;br /&gt;a descriptor, the TI bit selects either the local (TI = 1) or global (TI = 0) descriptor table, and the &lt;br /&gt;RPL bits indicate the requested privilege level. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Whenever a new selector is placed into one of the segment registers, the 80386 accesses &lt;br /&gt;one of the descriptor tables and automatically loads the descriptor into a program-invisible cache &lt;br /&gt;portion of the segment register. As long as the selector remains the same in the segment register, &lt;br /&gt;no additional accesses are required to the descriptor table. The operation of fetching a new de-&lt;br /&gt;scriptor from the descriptor table is program-invisible because the microprocessor automatically &lt;br /&gt;accomplishes this each time that the segment register contents are changed in the protected &lt;br /&gt;mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-20 shows how a sample global descriptor table (GDT), which is stored at memory &lt;br /&gt;address OOOlOOOOH, is accessed through the segment register and its selector. This table contains &lt;br /&gt;four entries. The first is a null (0) descriptor. Descriptor 0 must always be a null descriptor. The &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-19 A segment &lt;br /&gt;register showing the selector, &lt;br /&gt;T1 bit, and requested privi-&lt;br /&gt;lege level (RPL) bits &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 3 2 1 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Selector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment register &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;644 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;Memory system &lt;br /&gt;r--------, FFFFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Global descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;~&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1-___ --1 00100100 &lt;br /&gt;001000FF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;92 &lt;br /&gt;Descriptor 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1------1-___ --1 00100000 &lt;br /&gt;OOOFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 0 &lt;br /&gt;00 &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS 00 &lt;br /&gt;0008 I FF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 00000000 &lt;br /&gt;FIGURE 16-20 Using the DS register to select a descriptor from the global descriptor table. &lt;br /&gt;In this example, the DS register accesses memory locations 00100000H-Q01000FFH as a data &lt;br /&gt;segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;other entries address various segments in the 80386 protected mode memory system. In this il-&lt;br /&gt;lustration, the data segment register contains a 0008H. This means that the selector is indexing &lt;br /&gt;descriptor location I in the global descriptor table (TI = 0), with a requested privilege level &lt;br /&gt;of 00. Descriptor 1 is located 8 bytes above the base descriptor table address, beginning at lo-&lt;br /&gt;cation 00010008H. The descriptor located in this memory location accesses a base address of &lt;br /&gt;00200000H and a limit of IOOH. This means that this descriptor addresses memory locations &lt;br /&gt;00200000H-00200100H. Because this is the DS (data segment) register, the data segment is lo-&lt;br /&gt;cated at these locations in the memory system. If data are accessed outside of these boundaries, &lt;br /&gt;an interrupt occurs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The local descriptor table (LDT) is accessed in the same manner as the global descriptor &lt;br /&gt;table (GDT). The only difference in access is that the TI bit is cleared for a global access and set &lt;br /&gt;for a local access. Another difference exists if the local and global descriptor table registers are &lt;br /&gt;examined. The global descriptor table register (GDTR) contains the base address of the global &lt;br /&gt;descriptor table and the limit. The local descriptor table register (LDTR) only contains a selector &lt;br /&gt;and is 16-bits wide. The contents of the LDTR addresses a type 0010 system descriptor that con-&lt;br /&gt;tains the base address and limit of the LDT. This scheme allows one global table for all tasks, but &lt;br /&gt;many local tables, one or more for each task, if necessary. Global descriptors describe memory &lt;br /&gt;for the system, while local descriptors describe memory for applications or tasks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Like the GDT, the interrupt descriptor table (IDT) is addressed by storing the base address &lt;br /&gt;and limit in the interrupt descriptor table register (IDTR). The main difference between the GDT &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-3 80386 MEMORY MANAGEMENT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-21 The gate &lt;br /&gt;descriptor for the 80386 &lt;br /&gt;microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Access rights byte ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;645 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 Gate Descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset (031-016) 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;pl D~LI I ' , , I )1, ,I Word count :TYpe: 0 0 0 (C4-CO) 4 &lt;br /&gt;Selector 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset (015-00) o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and IDT is that the IDT contains only interrupt gates rather than segment and system descriptors, &lt;br /&gt;as do the GDT and LDT. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-21 shows the gate descriptor, a special form of the system descriptor described &lt;br /&gt;earlier. (Refer back to Table 16-1 for the different gate descriptor types.) Notice that the gate de-&lt;br /&gt;scriptor contains a 32-bit offset address, a word count, and a selector. The 32-bit offset address &lt;br /&gt;points to the location of the interrupt service procedure or other procedure. The word count indi-&lt;br /&gt;cates how many words are transferred from the caller's stack to the stack of the procedure ac-&lt;br /&gt;cessed by a call gate. Note that the word count field is not used with an interrupt gate. The &lt;br /&gt;selector is used to indicate the location of the task state segment (TSS) in the GDT or LDT if it &lt;br /&gt;is a local procedure. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When a gate is accessed, the contents of the selector are loaded into the task register (TR). &lt;br /&gt;The acceptance of the gate depends on the privilege and priority levels. A return instruction &lt;br /&gt;(RET) ends a call gate procedure, and a return from interrupt instruction (I RET) ends an inter-&lt;br /&gt;rupt gate procedure. Tasks are usually accessed with a CALL or an INT instruction, where the &lt;br /&gt;call instruction addresses a call gate in the descriptor table and the interrupt addresses an inter-&lt;br /&gt;rupt descriptor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The difference between real mode interrupts and protected mode interrupts is that the in-&lt;br /&gt;terrupt vector table is an IDT in the protected mode. The IDT still contains up to 256 interrupt &lt;br /&gt;levels, but each level is accessed through an interrupt gate instead of an interrupt vector. Thus, &lt;br /&gt;interrupt type number 2 is located at IDT descriptor number 2 at 16 locations above the base ad-&lt;br /&gt;dress of the IDT. This also means that the first lK byte of memory no longer contains interrupt &lt;br /&gt;vectors, as it did in the real mode. The IDT can be located at any location in the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Task State Segment (TSS) &lt;br /&gt;The task state segment (TSS) descriptor contains information about the location, size, and privi-&lt;br /&gt;lege level of the task state segment, just as any other descriptor. The difference is that the TSS &lt;br /&gt;described by the TSS descriptor does not contain data or code. It contains the state of the task and &lt;br /&gt;linkage so that tasks can be nested, one task can call a second, which can call a third and so forth. &lt;br /&gt;The TSS descriptor is addressed by the task register (TR). The contents of the TR are changed by &lt;br /&gt;the LTR instruction or whenever the protected mode program executes a far JMP or CALL in-&lt;br /&gt;struction. The LTR instruction is used to initially access a task during system initialization. After &lt;br /&gt;initialization, the CALL or JUMP instructions normally switch tasks. In most cases, we use the &lt;br /&gt;CALL instructions to initiate a new task. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The TSS is illustrated in Figure 16-22. As can be seen, the TSS is quite a formidable sec-&lt;br /&gt;tion of memory, containing many different types of information. The first word of the TSS is la-&lt;br /&gt;beled back-link. This is the selector that is used on a return (RET or lRET) to link back to the &lt;br /&gt;prior TSS by loading the back-link selector into the TR. The following word must contain a O. &lt;br /&gt;The second through the seventh doublewords contain the ESP and ESS values for privilege &lt;br /&gt;levels 0-2. These are required in case the current task is interrupted so these privilege level (PL) &lt;br /&gt;stacks can be addressed. The eighth word (offset lCH) contains the contents of CR3, which &lt;br /&gt;stores the base address of the prior state's page directory register. This must be restored if paging &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;646 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOTE: &lt;br /&gt;BIT_MAP _OFFSET &lt;br /&gt;must be .;; DFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,.------------ .. &lt;br /&gt;I ACCES~I TSS ~ I r-I RIGHTS LIMIT : &lt;br /&gt;I &lt;br /&gt;I I &lt;br /&gt;I BASE rr I &lt;br /&gt;: 31 PROGRAM 0: &lt;br /&gt;I INVISIBLE I I ____________ ..J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TASK REGISTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TR SELECTOR r &lt;br /&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 1615 &lt;br /&gt;0000000000000000 BACK LINK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESPO &lt;br /&gt;0000000000000000 I SSO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP1 &lt;br /&gt;0000000000000000 SS1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESP2 &lt;br /&gt;0000000000000000 SS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CR3 &lt;br /&gt;EIP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EFLAGS &lt;br /&gt;EAX &lt;br /&gt;ECX &lt;br /&gt;EDX &lt;br /&gt;EBX &lt;br /&gt;ESP &lt;br /&gt;EBP &lt;br /&gt;ESI &lt;br /&gt;EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000000000000000 ES &lt;br /&gt;0000000000000000 CS &lt;br /&gt;0000000000000000 SS &lt;br /&gt;0000000000000000 OS &lt;br /&gt;0000000000000000 FS &lt;br /&gt;0000000000000000 GS &lt;br /&gt;0000000000000000 LOT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â°O~ &lt;br /&gt;4 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 &lt;br /&gt;C &lt;br /&gt;10 &lt;br /&gt;14 &lt;br /&gt;18 &lt;br /&gt;1C= &lt;br /&gt;20 &lt;br /&gt;24 &lt;br /&gt;28 &lt;br /&gt;2C &lt;br /&gt;30 &lt;br /&gt;34 &lt;br /&gt;38 &lt;br /&gt;3C &lt;br /&gt;40 &lt;br /&gt;44 &lt;br /&gt;48 &lt;br /&gt;4C &lt;br /&gt;50 &lt;br /&gt;54 &lt;br /&gt;58 &lt;br /&gt;5C &lt;br /&gt;60 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TSS BASE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STACKS &lt;br /&gt;FOR &lt;br /&gt;CPL 0,1,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CURRENT &lt;br /&gt;TASK &lt;br /&gt;STATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIT MAP OFFSET(15:0) 0000000000000000 I T ~ &lt;br /&gt;AVAILABLE __ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SYSTEM STATUS, ETC. 'D &lt;br /&gt;IN 386â¢ CPU TSS ' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEBUG &lt;br /&gt;TRAP BIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 24 &lt;br /&gt;63 56 &lt;br /&gt;95 88 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;65407 &lt;br /&gt;65439 &lt;br /&gt;65471 &lt;br /&gt;65503 &lt;br /&gt;65535 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;23 16 15 8 7 0 &lt;br /&gt;55 48 47 40 39 &lt;br /&gt;87 80 79 72 71 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1/0 PERMISSION BITMAP &lt;br /&gt;(ONE BIT PER BYTE 1/0 &lt;br /&gt;PORT. BITMAP MAY BE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRUNCATED USING &lt;br /&gt;TSS LIMIT.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32 'BIT &lt;br /&gt;64 &lt;br /&gt;96 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;65472 &lt;br /&gt;65504 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFFS ET+C &lt;br /&gt;SET + 10 OFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFFS &lt;br /&gt;OFFS &lt;br /&gt;OFFS &lt;br /&gt;OFFS &lt;br /&gt;OFFS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;FFH&amp;quot; OFFS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ET + 1FEC &lt;br /&gt;ET + 1FFO &lt;br /&gt;ET + 1FF4 &lt;br /&gt;ET + 1FF8 &lt;br /&gt;ET + 1FFC &lt;br /&gt;ET +2000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ TSS LIMIT = OFFSET + 2000H 386â¢ CPU TSS DESCRIPTOR (IN GOT) 0 &lt;br /&gt;SEGMENT BASE 15 ... 0 SEGMENT LIMIT 15 .. 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BASE 31 .. 24IGI1 10101 ~9~~J ppfL/ol JYf'1 I BASE 23 .. 16 &lt;br /&gt;Type = 9: Available 386'&amp;quot; CPU TSS. &lt;br /&gt;Type = B: Busy 386'&amp;quot; CPU TSS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-22 The task state segment (TSS) descriptor (Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;is in effect. The contents of the next 17 doublewords are loaded into the registers indicated. &lt;br /&gt;Whenever a task is accessed, the entire state of the machine (all of the registers) is stored in these &lt;br /&gt;memory locations and then reloaded from the same locations in the new TSS. The last word &lt;br /&gt;(offset 66H) contains the I/O permission bit map base address. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-4 MOVING TO PROTECTED MODE 647 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The I/O permission bit map allows the TSS to block I/O operations to inhibited I/O port ad-&lt;br /&gt;dresses via an I/O permission denial interrupt. The permission denial interrupt is type number 13, &lt;br /&gt;the general protection fault interrupt. The I/O permission bit map base address is the offset ad-&lt;br /&gt;dress from the start of the TSS. This allows the same permission map to be used by many TSSs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each I/O permission bit map is 64K bits (8K bytes) long beginning at the offset address in-&lt;br /&gt;dicated by the I/O permission bit map base address. The first byte of the I/O permission bit map &lt;br /&gt;contains I/O permission for I/O ports 0000H-0007H. The rightmost bit contains permission for &lt;br /&gt;port number OOOOH, and the leftmost for port number 0007H. This sequence continues for the &lt;br /&gt;very last port address (FFFFH) stored in the leftmost bit of the last byte of the I/O permission bit &lt;br /&gt;map. A logic 0 placed in an I/O permission bit map bit enables the I/O port address, while a logic &lt;br /&gt;1 inhibits or blocks the I/O port address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In review of the operation of a task switch, which requires only 17 Ils to execute, we list &lt;br /&gt;the following steps: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The gate contains the address of the procedure or location jumped to by the task switch. It &lt;br /&gt;also contains the selector number of the TSS descriptor and the number of words transferred &lt;br /&gt;from the caller to the user stack area for parameter passing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The selector is loaded into TR from the gate. (This step is accomplished by a CALL or JMP &lt;br /&gt;that refers to a valid TSS descriptor.) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The TR selects the TSS. &lt;br /&gt;4. The current state is saved in the current TSS and the new TSS is accessed with the state of the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;new task (all the registers) loaded into the microprocessor. The current state is saved at the TSS &lt;br /&gt;selector currently found in the TR. Once the current state is saved, a new value (by the JMP or &lt;br /&gt;CALL) for the TSS selector is loaded into TR and the new state is loaded from the new TSS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The return from a task is accomplished by the following steps: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The current state of the microprocessor is saved in the current TSS. &lt;br /&gt;2. The back-link selector is loaded to the TR to access the prior TSS so the prior state of the ma-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;chine can be returned to and be restored to the microprocessor. The return for a called TSS is &lt;br /&gt;accomplished by the IRET instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVING TO PROTECTED MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to change the operation of the 80386 from the real mode to the protected mode, several &lt;br /&gt;steps must be followed. Real mode operation is accessed after a hardware reset or by changing &lt;br /&gt;the PE bit to a logic 0 in CRO. Protected mode operation is accessed by placing a logic 1 into the &lt;br /&gt;PE bit of CRO, but before this is done some other things must be initialized. The following steps &lt;br /&gt;accomplish the switch from the real mode to the protected mode: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Initialize the interrupt descriptor table so it contains valid interrupt gates for at least the first &lt;br /&gt;32 interrupt type numbers. The IDT may (and often does) contain up to 256 8-byte interrupt &lt;br /&gt;gates defining all 256 interrupt types. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Initialize the global descriptor table (GDT) so it contains a null descriptor at descriptor 0, and &lt;br /&gt;valid descriptors for at least one code, one stack, and one data segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Switch to protected mode, setting the PE bit in CRO. &lt;br /&gt;4. Perform an intrasegment (near) JMP to flush the internal instruction queue and load the TR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;with the base TSS descriptor. &lt;br /&gt;5. Load all the data selectors (segment registers) with their initial selector values. &lt;br /&gt;6. The 80386 is now operating in the protected mode, using the segment descriptors that are de-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;fined in GDT and IDT. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;648 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-23 The memory &lt;br /&gt;map for Example 16-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFFFFF r---------------, &lt;br /&gt;Reset Software FFFFFFFO I-_____________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data and Code Segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Global Descriptors &lt;br /&gt;00000100 I-_____________ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt Descriptors &lt;br /&gt;00000000 L-_____________ ....J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-23 shows the protected system memory map set up using steps 1-6. The soft-&lt;br /&gt;ware for this task is listed in Example 16-1. This system contains one data segment descriptor &lt;br /&gt;and one code segment descriptor with each segment set to 4G bytes in length. This is the sim-&lt;br /&gt;plest protected mode system possible, loading all the segment registers,. except code, with the &lt;br /&gt;same data segment descriptor from the GDT. The privilege level is initialized to 00, the highest &lt;br /&gt;level. This system is most often used where one user has access to the microprocessor and re-&lt;br /&gt;quires the entire memory space. This program is designed for use in a system that does not use &lt;br /&gt;DOS or shell from Windows to DOS. Later in this section, we show how to go to protected mode &lt;br /&gt;in a DOS environment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 16-1 &lt;br /&gt;. MODEL SMALL &lt;br /&gt;.386P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . DATA &lt;br /&gt;0000 0040 [ IDTl DD 64 DUP (?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Global descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 DESCO DQ 0 &lt;br /&gt;0000000000000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;code segment descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0108 FFFF DESCI DW OFFFFH &lt;br /&gt;OlOA 0000 DW 0 &lt;br /&gt;OlOC 0000 DW 0 &lt;br /&gt;OlOE 9E DB 9EH &lt;br /&gt;OlOF 8F DB 8FH &lt;br /&gt;0110 00 DB 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;data segment descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0111 FFFF DESC2 D~l OFFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;space for 32 interrupt vectors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;clear null descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; limit = 4G &lt;br /&gt;;base address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;code segment &lt;br /&gt;;G = 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; limit 4G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOOOOH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0113 &lt;br /&gt;0115 &lt;br /&gt;0117 &lt;br /&gt;0118 &lt;br /&gt;0119 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01111. &lt;br /&gt;011C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0120 &lt;br /&gt;0122 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0028 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0044 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0048 &lt;br /&gt;004B &lt;br /&gt;004E &lt;br /&gt;0051 &lt;br /&gt;0054 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0070 &lt;br /&gt;0072 &lt;br /&gt;0076 &lt;br /&gt;0079 &lt;br /&gt;007E &lt;br /&gt;0083 &lt;br /&gt;0086 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;008B &lt;br /&gt;0090 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0095 &lt;br /&gt;0098 &lt;br /&gt;009C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;009F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00A1 &lt;br /&gt;00A1 &lt;br /&gt;00A4 &lt;br /&gt;00A6 &lt;br /&gt;00A8 &lt;br /&gt;OOAA &lt;br /&gt;OOAC &lt;br /&gt;OOAE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVING TO PROTECTED MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 D\\'i &lt;br /&gt;0000 DW &lt;br /&gt;92 DB &lt;br /&gt;8F DB &lt;br /&gt;00 DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;10T table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOFF lOT my &lt;br /&gt;00000000 IOTA DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;GDT table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 GDT OW &lt;br /&gt;00000000 GDTA DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;0 &lt;br /&gt;92H &lt;br /&gt;8FH &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFFH &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17H &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;base address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;data segment &lt;br /&gt;;G = 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOOOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set limit to FFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set limit to 17H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;649 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAK32 MACRO SEG,OFF ;;make a seg+off a linear address &lt;br /&gt;MOV EAX,O &lt;br /&gt;MOV EBX,O &lt;br /&gt;MOV AX,SEG &lt;br /&gt;MOV BX,OFF &lt;br /&gt;SHL EAX,4 &lt;br /&gt;ADD EAX,EBX &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MAK32 OS,OFFSET 10'1'1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 A3 OllC R MOV IDTA,EAX ;save 10'1' address &lt;br /&gt;MAK32 DS,OFFSET DESCO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 A3 0122 R MOV GDTA,EAX ; save GDT address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B9 0020 MOV CX,32 &lt;br /&gt;BF 0000 R MOV OI,OFFSET IDT1 &lt;br /&gt;BE 0000 MOV SI,O &lt;br /&gt;B8 0000 MOV AX,O &lt;br /&gt;8E CO MOV ES,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT ; setup first 32 interrupts &lt;br /&gt;MAK32 ES: [SI+2] ,ES: [SI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;89 05 MOV [OI] ,AX &lt;br /&gt;661 C1 E8 10 SHR EAX,16 &lt;br /&gt;89 45 06 MOV [01+6] ,AX &lt;br /&gt;C7 45 02 0008 MOV WORD PTR [01+2],8 &lt;br /&gt;C7 45 04 8FOO MOV WORD PTR [D1+4] ,8FOOH &lt;br /&gt;83 C7 08 ADD DI,8 &lt;br /&gt;83 C6 04 ADD SI,4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;OF 01 1E 011A R LIDT FWORD PTR IDT ;load IDT &lt;br /&gt;OF 01 16 0120 R LGOT FWORO PTR GDT ; load GDT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OF 20 CO MOV EAX,CRO ;set PE &lt;br /&gt;661 83 C8 01 OR EAX,l &lt;br /&gt;OF 22 CO MOV CRO,EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EB 00 JMP START inear jump &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;START: &lt;br /&gt;B8 0010 MOV AX,10H ;set selector 2 &lt;br /&gt;8E 08 MOV DS,AX &lt;br /&gt;8E CO MOV ES,AX &lt;br /&gt;8E DO MOV SS,AX &lt;br /&gt;8E E8 MOV GS,AX &lt;br /&gt;8E EO MOV FS,AX &lt;br /&gt;661 BC FFFFFOOO MOV ESP,OFFFFFOOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;now in protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;650 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 16-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0008 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0000 &lt;br /&gt;0002 0000 &lt;br /&gt;0004 00 &lt;br /&gt;0005 00 &lt;br /&gt;0006 00 &lt;br /&gt;0007 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0068 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0000 &lt;br /&gt;0002 0000 &lt;br /&gt;0004 00000000 &lt;br /&gt;0008 0000 &lt;br /&gt;OOOA 0000 &lt;br /&gt;OOOC 00000000 &lt;br /&gt;0010 0000 &lt;br /&gt;0012 0000 &lt;br /&gt;0014 00000000 &lt;br /&gt;0018 0000 &lt;br /&gt;001A 0000 &lt;br /&gt;001C 00000000 &lt;br /&gt;0020 00000000 &lt;br /&gt;0024 00000000 &lt;br /&gt;0028 00000000 &lt;br /&gt;002C 00000000 &lt;br /&gt;0030 00000000 &lt;br /&gt;0034 00000000 &lt;br /&gt;0038 00000000 &lt;br /&gt;003C 00000000 &lt;br /&gt;0040 00000000 &lt;br /&gt;0044 00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In more complex systems, the steps required to initialize the system in the protected mode &lt;br /&gt;are more involved. For complex systems that are often multi-user systems, the registers are &lt;br /&gt;loaded using the task state segment (TSS). The steps required to place the 80386 into protected &lt;br /&gt;mode operation for a more complex system using a task switch follow: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Initialize the interrupt descriptor table so it refers to valid interrupt descriptors with at least 32 &lt;br /&gt;descriptors in the IDT. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. Initialize the global descriptor table so it contains at least two task state segment (TSS) de-&lt;br /&gt;scriptors and the initial code and data segments required for the initial task. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Initialize the task register (TR) so it points to a valid TSS, because when the initial task switch &lt;br /&gt;occurs and accesses the new TSS, the current registers are stored in the initial TSS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. Switch to protected mode using an intrasegment (near) jump to flush the internal instruction &lt;br /&gt;queue. Load TR with the current TSS selector. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. Load the TR with a far jump instruction to access the new TSS and save the current state. &lt;br /&gt;6. The 80386 is now operating in the protected mode under control of the first task. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 16-2 illustrates the software required to initialize the system and switch to pro-&lt;br /&gt;tected mode using a task switch. The initial system task operates at the highest level of protection &lt;br /&gt;(00) and controls the entire operating environment for the 80386. In many cases, it is used to &lt;br /&gt;boot (load) software that allows many users to access the system in a multi-user environment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STACK 800H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;DESC STRUC ;define descriptor structure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LlM_L DW a &lt;br /&gt;BAS_L DW a &lt;br /&gt;BAS_M DB a &lt;br /&gt;ACCESS DB a &lt;br /&gt;Ll~M DB a &lt;br /&gt;BAS_H DB a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DESC ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TSS STRUC ;define TSS structure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BACK_L DW a &lt;br /&gt;DW a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESPO DD a &lt;br /&gt;SSO DW a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DW a &lt;br /&gt;ESP1 DD a &lt;br /&gt;SSl DW a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DW a &lt;br /&gt;ESP2 DD a &lt;br /&gt;SS2 DW a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DW 0 &lt;br /&gt;CCR3 DD 0 &lt;br /&gt;ElP DD a &lt;br /&gt;TFALGS DD 0 &lt;br /&gt;EEAX DD a &lt;br /&gt;EECX DD a &lt;br /&gt;EEDX DD 0 &lt;br /&gt;EEBX DD a &lt;br /&gt;EESP DD 0 &lt;br /&gt;EEBP DD a &lt;br /&gt;EESl DD a &lt;br /&gt;EEDl DD 0 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-4 MOVING TO PROTECTED MODE 651 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0048 0020 EES OW 20H &lt;br /&gt;004A 0000 OW 0 &lt;br /&gt;004C 0018 ECS OW 18H &lt;br /&gt;004E 0000 OW 0 &lt;br /&gt;0050 0020 ESS OW 20H &lt;br /&gt;0052 0000 OW 0 &lt;br /&gt;0054 0020 EOS OW 20H &lt;br /&gt;0056 0000 OW 0 &lt;br /&gt;0058 0020 EFS OW 20H &lt;br /&gt;005A 0000 OW 0 &lt;br /&gt;005C 0020 EGS OW 20H &lt;br /&gt;005E 0000 OW 0 &lt;br /&gt;0060 000c)' ELOT OW 0 &lt;br /&gt;0062 0000 OW 0 &lt;br /&gt;0064 0000 OW 0 &lt;br /&gt;0066 0000 BlTM OW 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TSS ENOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0000 0000 TSS1 TSS &amp;lt;&amp;gt; ;task state 1 &lt;br /&gt;00000000 &lt;br /&gt;0000 0000 00000000 &lt;br /&gt;0000 0000 00000000 &lt;br /&gt;0000 0000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;0020 0000 0018 &lt;br /&gt;0000 0020 0000 &lt;br /&gt;0020 0000 0020 &lt;br /&gt;0000 0020 0000 &lt;br /&gt;0000 0000 0000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0068 0000 0000 TSS2 TSS &amp;lt;&amp;gt; ;task state 2 &lt;br /&gt;00000000 &lt;br /&gt;0000 0000 00000000 &lt;br /&gt;0000 0000 00000000 &lt;br /&gt;0000 0000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;00000000 00000000 &lt;br /&gt;0020 0000 0018 &lt;br /&gt;0000 0020 0000 &lt;br /&gt;0020 0000 0020 &lt;br /&gt;0000 0020 0000 &lt;br /&gt;0000 0000 0000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 0040 [ lOT1 00 64 OUP (? ) ;space for 32 interrupt vectors &lt;br /&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Global descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 0000 0000 00 GOTO OESC &amp;lt;&amp;gt; ;clear null descriptor &lt;br /&gt;00 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0108 0000 0028 00 TG1 OESC &amp;lt;0,28H,0,85H,0,0&amp;gt; ;task gate 1 &lt;br /&gt;85 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OlEO 0000 0030 00 TG2 OESC &amp;lt;0,30H,0,85H,0,0&amp;gt; ;task gate 2 &lt;br /&gt;85 00 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01E8 FFFF 0000 00 ACS OESC &amp;lt;-1,0,0,9AH,OCFH,0&amp;gt; ;code segment (4G) &lt;br /&gt;9A CF 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01FO FFFF 0000 00 OSl OESC &amp;lt;-1,0,0,92H,OCFH,0&amp;gt; ;data segment (4G) &lt;br /&gt;92 CF 00 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;652 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01F8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0200 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0208 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2208 &lt;br /&gt;220A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;220E &lt;br /&gt;2210 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0028 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0044 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0048 &lt;br /&gt;004B &lt;br /&gt;004E &lt;br /&gt;0051 &lt;br /&gt;0054 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0070 &lt;br /&gt;0072 &lt;br /&gt;0076 &lt;br /&gt;0079 &lt;br /&gt;007E &lt;br /&gt;0083 &lt;br /&gt;0086 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;008B &lt;br /&gt;008E &lt;br /&gt;0091 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOAC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOEC &lt;br /&gt;OOFl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00F6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFF 0000 &lt;br /&gt;89 CF 00 &lt;br /&gt;FFFF 0000 &lt;br /&gt;89 CF 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2000 [ &lt;br /&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOFF &lt;br /&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0017 &lt;br /&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 TSI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 TS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IOBP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;IDT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IDT &lt;br /&gt;IDTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;GDT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GDT &lt;br /&gt;GDTA &lt;br /&gt;. CODE &lt;br /&gt;MAK32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAKD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DESC &amp;lt;-1,0,0,89H,OCFH,0&amp;gt; ;TSS1 available &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DESC &amp;lt;-1,0,0,89H,OCFH,0&amp;gt; ;TSS2 available &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB 2000H DUP (0) ;enable all I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;table data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DW OFFH ;set limit to FFH &lt;br /&gt;DD 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;table data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DW 17H ;set limit to 17H &lt;br /&gt;DD 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MACRO SEG,OFF ;;make a seg+off a linear address &lt;br /&gt;MOV EAX,O &lt;br /&gt;MOV EBX, a &lt;br /&gt;MOV AX,SEG &lt;br /&gt;MOV BX,OFF &lt;br /&gt;SHL EAX,4 &lt;br /&gt;ADD EAX,EBX &lt;br /&gt;ENDM &lt;br /&gt;MACRO TSS,DES ;;save base address &lt;br /&gt;PUSH EAX &lt;br /&gt;MOV EBX, 0 &lt;br /&gt;MOV BX,OFFSET TSS &lt;br /&gt;ADD EAX,EBX &lt;br /&gt;MOV DES.BAS_L,AX &lt;br /&gt;SHR EAX,16 &lt;br /&gt;MOV DES.BAS_M,AL &lt;br /&gt;MOV DES.BAS_H,AH &lt;br /&gt;POP EAX &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MAK32 DS,OFFSET IDT1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 A3 220A R MOV IDTA,EAX isave IDT address &lt;br /&gt;MAK32 DS,OFFSET GDTO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 A3 2210 R MOV GDTA, EAX isave GDT address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B9 0020 MOV CX,32 &lt;br /&gt;BF OODO R MOV DI,OFFSET IDT1 &lt;br /&gt;BE 0000 MOV SI,O &lt;br /&gt;B8 0000 MOV AX,O &lt;br /&gt;8E CO MOV ES,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT ; setup first 32 interrupts &lt;br /&gt;MAK32 ES: [SI+2] ,ES: [SI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;89 05 MOV [DI] ,AX &lt;br /&gt;661 C1 E8 10 SHR EAX,16 &lt;br /&gt;89 45 06 MOV [DI+6] ,AX &lt;br /&gt;C7 45 02 0008 MOV WORD PTR [DI+2],8 &lt;br /&gt;C7 45 04 8FOO MOV WORD PTR [DI+4],8FOOH &lt;br /&gt;83 C7 08 ADD DI,8 &lt;br /&gt;83 C6 04 ADD SI,4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;B8 0208 R MOV AX,OFFSET IOBP ;setup IO bit map &lt;br /&gt;A3 0066 R MOV TSSl.BITM,AX &lt;br /&gt;A3 OOCE R MOV TSS2.BITM,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11AK32 CS,OFFSET TASKl ;get task 1 address &lt;br /&gt;661 A3 0088 R MOV TSS2.EIP,EAX ;save it in task 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAKD TSS1,TS1 &lt;br /&gt;MAKD TSS2,TS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OF 01 1E 2208 R LIDT FWORD PTR IDT ;load IDT &lt;br /&gt;OF 01 16 220E R LGDT FWORD PTR GDT ;load GDT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OF 20 CO MOV EAX,CRO ;set PE &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;00F9 661 83 C8 &lt;br /&gt;OOFD OF 22 CO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100 EB 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0102 START: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0102 B8 0008 &lt;br /&gt;0105 OF 00 D8 &lt;br /&gt;0108 B8 0010 &lt;br /&gt;010B FF EO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 16-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;0000 00000000 &lt;br /&gt;0004 00000000 &lt;br /&gt;0008 00000000 &lt;br /&gt;OOOC 00000000 &lt;br /&gt;0010 0000 &lt;br /&gt;0012 OD OA OA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;72 61 6D &lt;br /&gt;65 72 20 &lt;br /&gt;72 6F 72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0026 OD OA OA &lt;br /&gt;4D 49 20 &lt;br /&gt;74 20 70 &lt;br /&gt;73 65 6E &lt;br /&gt;24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003B OD OA OA &lt;br /&gt;74 20 65 &lt;br /&gt;75 67 68 &lt;br /&gt;65 61 6C &lt;br /&gt;65 6D 6F &lt;br /&gt;2E 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0056 OD OA OA &lt;br /&gt;75 6C 64 &lt;br /&gt;6F 74 20 &lt;br /&gt;76 65 20 &lt;br /&gt;20 70 72 &lt;br /&gt;65 63 74 &lt;br /&gt;20 6D 6F &lt;br /&gt;2E 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-4 MOVING TO PROTECTED MODE 653 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 OR EAX,l &lt;br /&gt;MOV CRO,EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP START inear jump &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,8 ;address TSS1 &lt;br /&gt;LTR AX &lt;br /&gt;MOV AX,lOH &lt;br /&gt;JMP AX ; jump to TSS2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;inow in protected mode at task l. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TASK1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Neither Example 16-1 nor 16-2 is written to function in the personal computer environ-&lt;br /&gt;ment. The personal computer environment requires the use of either the VePI (virtual control &lt;br /&gt;program interface) driver provided by the HIMEM.SYS driver in DOS or the DPMI (DOS pro-&lt;br /&gt;tected mode interface) driver provided by Windows when shelling to DOS. Example 16-3 shows &lt;br /&gt;how to switch to protected mode using VePI and then display the contents of any area of &lt;br /&gt;memory. This includes memory in the extended memory area or anywhere else. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;A program that displays the contents of any area of memory &lt;br /&gt;;including extended memory. &lt;br /&gt;j***command line syntax*** &lt;br /&gt;;EDUMP XXXX,YYYY where XXXX is the start address and YYYY is &lt;br /&gt;;the end address. &lt;br /&gt;;Note: this program must be executed from WINDOWS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STACK 1024 ;stack area of 1,024 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;ENTRY DD ? ;DPMI entry point &lt;br /&gt;EXIT DD ? ;DPMI exit point &lt;br /&gt;FIRST DD ? ;first address &lt;br /&gt;LAST1 DD ? ;last address &lt;br /&gt;MSIZE DW ? ;memory needed for DPMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50 61 ERR1 DB 13,10,10, 'Parameter error.$' &lt;br /&gt;65 74 &lt;br /&gt;65 72 &lt;br /&gt;2E 24 &lt;br /&gt;44 50 ERR2 DB 13,10,10, 'DPMI not present.$' &lt;br /&gt;6E 6F &lt;br /&gt;72 65 &lt;br /&gt;74 2E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4E 6F ERR3 DB 13,10,10, 'Not enough real memory.$' &lt;br /&gt;6E 6F &lt;br /&gt;20 72 &lt;br /&gt;20 6D &lt;br /&gt;72 79 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;43 6F ERR4 DB 13,10,10, 'Could not move to protected mode.$' &lt;br /&gt;20 6E &lt;br /&gt;6D 6F &lt;br /&gt;74 6F &lt;br /&gt;6F 74 &lt;br /&gt;65 64 &lt;br /&gt;64 65 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;654 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007B 00 OA OA 43 61 ERR5 DB &lt;br /&gt;6E 6E 6F 74 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13,10,10, 'Cannot allocate selector.$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;61 6C 6C 6F 63 &lt;br /&gt;61 74 65 20 73 &lt;br /&gt;65 6C 65 63 74 &lt;br /&gt;6F 72 2E 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0098 00 OA OA 43 61 ERR6 DB &lt;br /&gt;6E 6E 6F 74 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13,10,10, 'Cannot use base address.$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;75 73 65 20 62 &lt;br /&gt;61 73 65 20 61 &lt;br /&gt;64 64 72 65 73 &lt;br /&gt;73 2E 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00B4 00 OA OA 43 61 ERR7 DB &lt;br /&gt;6E 6E 6F 74 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13,10,10, 'Cannot allocate 64K to 1imit.$' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;61 6C 6C 6F 63 &lt;br /&gt;61 74 65 20 36 &lt;br /&gt;34 4B 20 74 6F &lt;br /&gt;20 6C 69 60 69 &lt;br /&gt;74 2E 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0005 00 OA 24 CRLF DB &lt;br /&gt;0008 50 72 65 73 73 MESl DB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 61 6E 79 20 &lt;br /&gt;6B 65 79 2E 2E &lt;br /&gt;2E 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13,10, '$' &lt;br /&gt;'Press any key ... $' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;register array storage for DPMI function 0300H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00E9 &lt;br /&gt;00E9 &lt;br /&gt;OOED &lt;br /&gt;OOFl &lt;br /&gt;00F5 &lt;br /&gt;00F9 &lt;br /&gt;OOFD &lt;br /&gt;0101 &lt;br /&gt;0105 &lt;br /&gt;0109 &lt;br /&gt;010B &lt;br /&gt;0100 &lt;br /&gt;010F &lt;br /&gt;0111 &lt;br /&gt;0113 &lt;br /&gt;0115 &lt;br /&gt;0117 &lt;br /&gt;0119 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= 00E9 &lt;br /&gt;00000000 &lt;br /&gt;00000000 &lt;br /&gt;00000000 &lt;br /&gt;00000000 &lt;br /&gt;00000000 &lt;br /&gt;00000000 &lt;br /&gt;00000000 &lt;br /&gt;00000000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 8C CO &lt;br /&gt;0012 &lt;br /&gt;0014 &lt;br /&gt;0016 &lt;br /&gt;0018 &lt;br /&gt;001B &lt;br /&gt;ODIC &lt;br /&gt;001E &lt;br /&gt;0020 &lt;br /&gt;0022 &lt;br /&gt;0025 &lt;br /&gt;0027 &lt;br /&gt;0029 &lt;br /&gt;002C &lt;br /&gt;002E &lt;br /&gt;0031 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BC DB &lt;br /&gt;2B 08 &lt;br /&gt;8B C4 &lt;br /&gt;Cl E8 04 &lt;br /&gt;40 &lt;br /&gt;03 08 &lt;br /&gt;B4 4A &lt;br /&gt;CD 21 &lt;br /&gt;E8 0001 &lt;br /&gt;73 OA &lt;br /&gt;B4 09 &lt;br /&gt;BA 0012 R &lt;br /&gt;CD 21 &lt;br /&gt;E9 OOAA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0031 E8 OOAB &lt;br /&gt;0034 72 OA &lt;br /&gt;0036 B4 09 &lt;br /&gt;0038 BA 0026 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY EQU &lt;br /&gt;REDI DO &lt;br /&gt;RESI DO &lt;br /&gt;REBP DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THIS BYTE &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;REBX DO &lt;br /&gt;REDX DO &lt;br /&gt;RECX DO &lt;br /&gt;REAX DO &lt;br /&gt;RFLAG OW &lt;br /&gt;RES OW &lt;br /&gt;ROS OW &lt;br /&gt;RFS OW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RGS &lt;br /&gt;RIP &lt;br /&gt;RCS &lt;br /&gt;RSP &lt;br /&gt;RSS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OW 0 &lt;br /&gt;OW 0 &lt;br /&gt;OW 0 &lt;br /&gt;OW 0 &lt;br /&gt;OW 0 &lt;br /&gt;.CODE &lt;br /&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,ES &lt;br /&gt;MOV BX,DS &lt;br /&gt;SUB EX,AX &lt;br /&gt;MOV AX,SP &lt;br /&gt;SHR AX,4 &lt;br /&gt;INC AX &lt;br /&gt;ADD BX,AX &lt;br /&gt;MOV AH,4AH &lt;br /&gt;INT 21H &lt;br /&gt;CALL GETDA &lt;br /&gt;JNC MAIN1 &lt;br /&gt;MOV AH,9 &lt;br /&gt;!10V DX,OFFSET ERRl &lt;br /&gt;INT 21H &lt;br /&gt;J!1P MAINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL ISDP!1I &lt;br /&gt;JC MAIN2 &lt;br /&gt;MOV AH,9 &lt;br /&gt;MOV OX,OFFSET ERR2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;EDI &lt;br /&gt;;ESI &lt;br /&gt;;EBP &lt;br /&gt;ireserved &lt;br /&gt;;EBX &lt;br /&gt;;EDX &lt;br /&gt;;ECX &lt;br /&gt;;EAX &lt;br /&gt;;flags &lt;br /&gt;;ES &lt;br /&gt;;DS &lt;br /&gt;;FS &lt;br /&gt;;GS &lt;br /&gt;;IP &lt;br /&gt;;CS &lt;br /&gt;;SP &lt;br /&gt;;SS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;find size of program and data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;find stack size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;BX = length in paragraphs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;modify memory allocation &lt;br /&gt;;get command line information &lt;br /&gt;;if parameters are good &lt;br /&gt;iparameter error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;is OPMI loaded? &lt;br /&gt;;if DPMI present &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-4 MOVING TO PROTECTED MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;003B &lt;br /&gt;003D &lt;br /&gt;0040 &lt;br /&gt;0040 &lt;br /&gt;0043 &lt;br /&gt;0048 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CD 21 INT 21H &lt;br /&gt;MAINE E9 009B JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN2: &lt;br /&gt;B8 0000 MOV AX,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MSIZE,O &lt;br /&gt;MAIN2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;83 3E 0010 R 00 CMP &lt;br /&gt;74 F6 JE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004A 8B 1E 0010 R &lt;br /&gt;004E B4 48 &lt;br /&gt;0050 CD 21 &lt;br /&gt;0052 73 09 &lt;br /&gt;0054 B4 09 &lt;br /&gt;0056 BA 003B R &lt;br /&gt;0059 CD 21 &lt;br /&gt;005B EB 7E &lt;br /&gt;005D &lt;br /&gt;005D 8E CO &lt;br /&gt;005F B8 0000 &lt;br /&gt;0062 FF 1E 0000 R &lt;br /&gt;0066 73 09 &lt;br /&gt;0068 B4 09 &lt;br /&gt;006A BA 0056 R &lt;br /&gt;006D CD 21 &lt;br /&gt;006F EB 6A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0071 &lt;br /&gt;0071 B8 0000 &lt;br /&gt;0074 B9 0001 &lt;br /&gt;0077 CD 31 &lt;br /&gt;0079 72 48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN3: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BX,MSIZE &lt;br /&gt;MOV AH,48H &lt;br /&gt;INT 21H &lt;br /&gt;JNC MAIN3 &lt;br /&gt;MOV AH,9 &lt;br /&gt;MOV DX,OFFSET ERR3 &lt;br /&gt;INT 21H &lt;br /&gt;JMP MAINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV ES,AX &lt;br /&gt;MOV AX,O &lt;br /&gt;CALL DS:ENTRY &lt;br /&gt;JNC MAIN4 &lt;br /&gt;MOV AH,9 &lt;br /&gt;MOV DX,OFFSET ERR4 &lt;br /&gt;INT 21H &lt;br /&gt;JMP MAINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;PROTECTED MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN4: &lt;br /&gt;MOV AX,OOOOH &lt;br /&gt;MOV CX,l &lt;br /&gt;INT 31H &lt;br /&gt;JC MAIN7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BX,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display DPMI not present &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;indicate 0 memory needed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if DPMI needs no memory &lt;br /&gt;;get amount &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;allocate memory for DPMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if not enough real memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;16-bit application &lt;br /&gt;;switch to protected mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if switch failed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get local selector &lt;br /&gt;;only one is needed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if error &lt;br /&gt;;save selector &lt;br /&gt;;load ES with selector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;007B &lt;br /&gt;007D &lt;br /&gt;007F &lt;br /&gt;0082 &lt;br /&gt;0086 &lt;br /&gt;008A &lt;br /&gt;008C &lt;br /&gt;008E &lt;br /&gt;0091 &lt;br /&gt;0094 &lt;br /&gt;0097 &lt;br /&gt;0099 &lt;br /&gt;009B &lt;br /&gt;009E &lt;br /&gt;00A1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8B D8 &lt;br /&gt;8E CO &lt;br /&gt;B8 0007 &lt;br /&gt;8B OE OOOA R &lt;br /&gt;8B 16 0008 R &lt;br /&gt;CD 31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;INT &lt;br /&gt;JC &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;INT &lt;br /&gt;JC &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES,AX &lt;br /&gt;AX,0007H &lt;br /&gt;CX,WORD &lt;br /&gt;DX,WORD &lt;br /&gt;31H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set base address &lt;br /&gt;PTR FIRST+2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;72 3D &lt;br /&gt;B8 0008 &lt;br /&gt;B9 0000 &lt;br /&gt;BA FFFF &lt;br /&gt;CD 31 &lt;br /&gt;72 38 &lt;br /&gt;B9 0018 &lt;br /&gt;BE 0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E8 00F4 &lt;br /&gt;E8 OOCE &lt;br /&gt;46 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0008 R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAINS: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PTR FIRST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN8 &lt;br /&gt;AX,0008H &lt;br /&gt;CX,O &lt;br /&gt;DX,OFFFFH &lt;br /&gt;31H &lt;br /&gt;MAIN9 &lt;br /&gt;CX,24 &lt;br /&gt;SI,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL DADDR &lt;br /&gt;CALL DDATA &lt;br /&gt;INC SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00A1 &lt;br /&gt;00A4 &lt;br /&gt;00A7 &lt;br /&gt;00A8 &lt;br /&gt;OOAC &lt;br /&gt;00B1 &lt;br /&gt;00B3 &lt;br /&gt;00B8 &lt;br /&gt;OOBA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 A1 &lt;br /&gt;661 3B &lt;br /&gt;74 07 &lt;br /&gt;661 FF &lt;br /&gt;EB E7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06 OOOC R &lt;br /&gt;MOV EAX,FIRST &lt;br /&gt;CMP EAX,LAST1 &lt;br /&gt;JE MAIN6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06 0008 R INC FIRST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOBA B8 0001 &lt;br /&gt;OOBD 8C C3 &lt;br /&gt;OOBF CD 31 &lt;br /&gt;00C1 EB 18 &lt;br /&gt;00C3 &lt;br /&gt;00C3 &lt;br /&gt;00C6 &lt;br /&gt;00C9 &lt;br /&gt;OOCB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BA 007B R &lt;br /&gt;E8 0096 &lt;br /&gt;EB 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCB BA 0098 R &lt;br /&gt;OOCE E8 008E &lt;br /&gt;00D1 EB E7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP MAINS &lt;br /&gt;MAIN6: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN7: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN8: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,OOOlH &lt;br /&gt;MOV BX,ES &lt;br /&gt;INT 31H &lt;br /&gt;JMP MAINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFSET ERRS &lt;br /&gt;CALL DISPS &lt;br /&gt;JMP MAINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFSET ERR6 &lt;br /&gt;CALL DISPS &lt;br /&gt;JMP MAIN6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;set limit to 64K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if error &lt;br /&gt;;load line count &lt;br /&gt;;load offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display address, if needed &lt;br /&gt;;display data &lt;br /&gt;;point to next data &lt;br /&gt;;test for end &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if done &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;release descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display cannot allocate selector &lt;br /&gt;;exit to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display cannot use base address &lt;br /&gt;;release descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;655 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;656 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00D3 &lt;br /&gt;00D3 BA 00B4 R &lt;br /&gt;00D6 E8 0086 &lt;br /&gt;00D9 EB DF &lt;br /&gt;OODB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OODF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OODF B8 1687 &lt;br /&gt;OOE:? CD 2F &lt;br /&gt;00E4 OB CO &lt;br /&gt;00E6 75 OD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAIN9: &lt;br /&gt;MOV &lt;br /&gt;CALL &lt;br /&gt;JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MAINE: &lt;br /&gt;. EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,OFFSET &lt;br /&gt;DISPS &lt;br /&gt;MAIN6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ERR7 &lt;br /&gt;;display cannot allocate 64K limit &lt;br /&gt;;release descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The ISDPMI procedure tests for the presence of DPMI. &lt;br /&gt;:***exit parameters*** &lt;br /&gt;; carry 1; if DPMI is present &lt;br /&gt;; carry 0; if DPMI is not present &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ISDPMI PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,1687H ;get DPMI status &lt;br /&gt;INT 2FH ; DOS multiplex &lt;br /&gt;OR AX,AX &lt;br /&gt;JNZ ISDPMI1 ;if no DPMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00E8 89 36 0010 R MOV MSIZE,SI isave amount of memory needed &lt;br /&gt;OOEC 89 3E 0000 R MOV WORD PTR ENTRY,DI &lt;br /&gt;OOFO 8C 06 0002 R MOV WORD PTR ENTRY+2,ES &lt;br /&gt;00F4 F9 &lt;br /&gt;00F5 &lt;br /&gt;00F5 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00F6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00F6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00F6 1E &lt;br /&gt;00F7 06 &lt;br /&gt;00F8 1F &lt;br /&gt;00F9 07 &lt;br /&gt;OOFA BE 0081 &lt;br /&gt;OOFD &lt;br /&gt;OOFD &lt;br /&gt;OOFE &lt;br /&gt;0100 &lt;br /&gt;0102 &lt;br /&gt;0104 &lt;br /&gt;0106 &lt;br /&gt;0107 &lt;br /&gt;0107 &lt;br /&gt;010A &lt;br /&gt;010C &lt;br /&gt;010E &lt;br /&gt;0114 &lt;br /&gt;0117 &lt;br /&gt;0119 &lt;br /&gt;011B &lt;br /&gt;0121 &lt;br /&gt;0122 &lt;br /&gt;0124 &lt;br /&gt;0124 &lt;br /&gt;0125 &lt;br /&gt;0125 &lt;br /&gt;0126 &lt;br /&gt;0127 &lt;br /&gt;0128 &lt;br /&gt;0129 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AC &lt;br /&gt;3C 20 &lt;br /&gt;74 FB &lt;br /&gt;3C OD &lt;br /&gt;74 1E &lt;br /&gt;4E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E8 0020 &lt;br /&gt;3C 2C &lt;br /&gt;75 16 &lt;br /&gt;661 26: &lt;br /&gt;E8 0013 &lt;br /&gt;3C OD &lt;br /&gt;75 09 &lt;br /&gt;661 26: &lt;br /&gt;F8 &lt;br /&gt;EB 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1E &lt;br /&gt;06 &lt;br /&gt;1F &lt;br /&gt;07 &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STC &lt;br /&gt;ISDPMI1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ISDPMI ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The GETDA procedure retrieves the command line parameters &lt;br /&gt;;for memory display in hexadecimal. &lt;br /&gt;;FIRST = the first address from the command line &lt;br /&gt;;LAST1 = the last address from the command line &lt;br /&gt;;***return parameters*** &lt;br /&gt;; carry 1; if error &lt;br /&gt;;carry = 0; for no error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETDA PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETDA1: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETDA2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH DS &lt;br /&gt;PUSH ES &lt;br /&gt;POP DS &lt;br /&gt;POP ES &lt;br /&gt;MOV SI,81H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LODSB &lt;br /&gt;CMP AL,' &lt;br /&gt;JE GETDA1 &lt;br /&gt;CMP AL,13 &lt;br /&gt;JE GETDA3 &lt;br /&gt;DEC SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL GETNU &lt;br /&gt;CMP &lt;br /&gt;JNE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL, I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;89 16 0008 R MOV &lt;br /&gt;CALL &lt;br /&gt;CMP &lt;br /&gt;JNE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETDA3 &lt;br /&gt;ES:FIRST,EDX &lt;br /&gt;GETNU &lt;br /&gt;AL,13 &lt;br /&gt;GETDA3 &lt;br /&gt;ES:LAST1,EDX 89 16 OOOC R MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLC &lt;br /&gt;JMP GETDA4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETDA3: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETDA4: &lt;br /&gt;STC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH DS &lt;br /&gt;PUSH ES &lt;br /&gt;POP DS &lt;br /&gt;POP ES &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exchange ES with DS &lt;br /&gt;;address command line &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;skip spaces &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if space &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if enter error &lt;br /&gt;;adjust SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get first number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if no comma = error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get second number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;if error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;indicate no error &lt;br /&gt;;return no error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;indi'9.te error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;exchange ES with DS &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;012A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;012A &lt;br /&gt;0130 &lt;br /&gt;0130 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0139 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;013B &lt;br /&gt;013D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0143 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0145 &lt;br /&gt;0147 &lt;br /&gt;0149 &lt;br /&gt;014D &lt;br /&gt;014F &lt;br /&gt;0151 &lt;br /&gt;0151 &lt;br /&gt;0154 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0155 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0155 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0155 &lt;br /&gt;0156 &lt;br /&gt;0158 &lt;br /&gt;015A &lt;br /&gt;015D &lt;br /&gt;015E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015F &lt;br /&gt;0166 &lt;br /&gt;0169 &lt;br /&gt;016B &lt;br /&gt;016D &lt;br /&gt;016F &lt;br /&gt;0172 &lt;br /&gt;0174 &lt;br /&gt;0174 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0175 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-4 MOVING TO PROTECTED MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETDA ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Th p GETNU procedure extracts a number from the command line &lt;br /&gt;;and returns with it in EDX and last command line character in &lt;br /&gt;;AL as a delimiter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETNU PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 BA 00000000 MOV EDX,O ;clear result &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2C 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2C 30 &lt;br /&gt;72 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2C 07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3C OF &lt;br /&gt;77 08 &lt;br /&gt;661 C1 E2 04 &lt;br /&gt;02 DO &lt;br /&gt;EB DF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8A 44 FF &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52 &lt;br /&gt;8A DO &lt;br /&gt;B4 06 &lt;br /&gt;E8 0084 &lt;br /&gt;SA &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETNU1: &lt;br /&gt;LODSB ;get digit from command line &lt;br /&gt;.IF AL &amp;gt;= 'a' &amp;amp;&amp;amp; AL &amp;lt;= 'z' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AL,20H ;make uppercase &lt;br /&gt;.ENDIF &lt;br /&gt;SUB AL,' 0' &lt;br /&gt;JB GETNU2 &lt;br /&gt;.IF AL &amp;gt; 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;CMP &lt;br /&gt;JA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,OFH &lt;br /&gt;GETNU2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETNU2: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHL EDX,4 &lt;br /&gt;ADD &lt;br /&gt;JMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DL,AL &lt;br /&gt;GETNU1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, [SI-1] &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETNU ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;convert from ASCII &lt;br /&gt;;if not a number &lt;br /&gt;;convert A-F from ASCII &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; if not O-F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;add digit to EDX &lt;br /&gt;;get next digit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get delimiter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The DISPC procedure displays the ASCII character found &lt;br /&gt;;in register AL. &lt;br /&gt;;&amp;quot;'&amp;quot;**uses*** &lt;br /&gt;;INT21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPC PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH DX &lt;br /&gt;MOV DL,AL &lt;br /&gt;MOV AH,6 &lt;br /&gt;CALL INT21H &lt;br /&gt;POP DX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPC ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;do real INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The DISPS procedure displays a character string from &lt;br /&gt;;protected mode addressed by DS:EDX. &lt;br /&gt;i***uses*** &lt;br /&gt;;DISPC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 81 E2 OOOOFFFF AND EDX,OFFFFH &lt;br /&gt;67&amp;amp; 8A 02 &lt;br /&gt;3C 24 &lt;br /&gt;74 07 &lt;br /&gt;661 42 &lt;br /&gt;EB FFE3 &lt;br /&gt;EB EB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, [EDX] ;get character &lt;br /&gt;CMP AL,' $' ;test for end &lt;br /&gt;JE DISP1 ; if end &lt;br /&gt;INC EDX ;address next character &lt;br /&gt;CALL DISPC ;display character &lt;br /&gt;JMP DISPS ;repeat until $ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP1: &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The DDATA procedure displays a byte of data at the location &lt;br /&gt;;addressed by ES:SI. The byte is followed by one space. &lt;br /&gt;i***uses*** &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;657 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;658 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0175 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0175 &lt;br /&gt;0178 &lt;br /&gt;017B &lt;br /&gt;017E &lt;br /&gt;0181 &lt;br /&gt;0184 &lt;br /&gt;0186 &lt;br /&gt;0189 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;018A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;018A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;018A &lt;br /&gt;018C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0192 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0194 &lt;br /&gt;0197 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0198 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0198 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0198 &lt;br /&gt;019C &lt;br /&gt;019E &lt;br /&gt;01AD &lt;br /&gt;01A3 &lt;br /&gt;01A6 &lt;br /&gt;01A7 &lt;br /&gt;01A9 &lt;br /&gt;01AC &lt;br /&gt;OlAF &lt;br /&gt;OlAF &lt;br /&gt;01B1 &lt;br /&gt;01B3 &lt;br /&gt;01B6 &lt;br /&gt;01B8 &lt;br /&gt;01BB &lt;br /&gt;01BE &lt;br /&gt;01C1 &lt;br /&gt;01C1 &lt;br /&gt;01C2 &lt;br /&gt;01C5 &lt;br /&gt;OlCA &lt;br /&gt;01CA &lt;br /&gt;01CE &lt;br /&gt;01DO &lt;br /&gt;01D3 &lt;br /&gt;01D5 &lt;br /&gt;01D6 &lt;br /&gt;01D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26: 8A 04 &lt;br /&gt;CO E8 04 &lt;br /&gt;E8 OOOC &lt;br /&gt;26: 8A 04 &lt;br /&gt;E8 0006 &lt;br /&gt;BO 20 &lt;br /&gt;E8 FFCC &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24 OF &lt;br /&gt;04 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04 07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E8 FFBE &lt;br /&gt;C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;DIP and DISPC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DDATA PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, ES: [SI) &lt;br /&gt;SHR AL,4 &lt;br /&gt;CALL DIP &lt;br /&gt;MOV AL,ES:[SI) &lt;br /&gt;CALL DIP &lt;br /&gt;MOV AL,' , &lt;br /&gt;CALL DISPC &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DDATA ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display first digit &lt;br /&gt;;get byte &lt;br /&gt;;display second digit &lt;br /&gt;;display space &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The DIP procedure displays the right nibble found in AL as a &lt;br /&gt;;hexadecimal digit. &lt;br /&gt;;***uses*** &lt;br /&gt;;DISPC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND AL,OFH &lt;br /&gt;ADD AL,30H &lt;br /&gt;.IF AL &amp;gt; 39H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;CALL DISPC &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIP ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get right nibble &lt;br /&gt;;convert to ASCII &lt;br /&gt;;if A-F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display digit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The DADDR procedure displays the hexadecimal address found &lt;br /&gt;;in DS:FIRST if it is a paragraph boundary. &lt;br /&gt;i***uses*** &lt;br /&gt;;DIP, DISPS, DISPC, and INT21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DADDR PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;661 A1 0008 R MOV EAX,FIRST ;get address &lt;br /&gt;A8 OF TEST AL,OFH ;test for XXXXXXXO &lt;br /&gt;75 40 JNZ DADDR4 ;if not, don't display address &lt;br /&gt;BA 00D5 R MOV DX,OFFSET CRLF &lt;br /&gt;E8 FFB9 CALL DISPS ; display CR and LF &lt;br /&gt;49 DEC CX ;decrement line count &lt;br /&gt;75 18 JNZ DADDR2 ;if not end of page &lt;br /&gt;BA 00D8 R MOV DX,OFFSET MES1 ;if end of page &lt;br /&gt;E8 FFBO CALL DISPS ;display press any key &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DADDR1: &lt;br /&gt;B4 06 MOV AH,6 ;get any key, no echo &lt;br /&gt;B2 FF MOV DL,OFFH &lt;br /&gt;E8 002B CALL INT21H ;do real INT 21H &lt;br /&gt;74 F7 JZ DADDR1 ;if nothing typed &lt;br /&gt;BA 00D5 R MOV DX,OFFSET CRLF &lt;br /&gt;E8 FFA1 CALL DISPS ;display CRLF &lt;br /&gt;B9 0018 MOV CX,24 ;reset line count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DADDR2: &lt;br /&gt;51 PUSH CX ;save line count &lt;br /&gt;B9 0008 MOV CX,8 ;load digit count &lt;br /&gt;661 8B 16 0008 R MOV EDX, FIRST ;get address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DADDR3 : &lt;br /&gt;661 C1 C2 04 ROL EDX,4 &lt;br /&gt;8A C2 MOV AL,DL &lt;br /&gt;E8 FFB7 CALL DIP ;display digit &lt;br /&gt;E2 F5 LOOP DADDR3 ;repeat 8 times &lt;br /&gt;59 POP CX ;retrieve line count &lt;br /&gt;BO 3A MOV AL I.' &lt;br /&gt;E8 FF7A CALL DISPC ;display colon &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;01DB BO &lt;br /&gt;01DD E8 &lt;br /&gt;OlEO &lt;br /&gt;OlEO C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01E1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01E1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01E1 66 &lt;br /&gt;01E5 66 &lt;br /&gt;OlEA 66 &lt;br /&gt;01EF 66 &lt;br /&gt;01F4 66 &lt;br /&gt;01F9 66 &lt;br /&gt;01FE 66 &lt;br /&gt;0203 9C &lt;br /&gt;0204 58 &lt;br /&gt;0205 A3 &lt;br /&gt;0208 06 &lt;br /&gt;0209 B8 &lt;br /&gt;020C BB &lt;br /&gt;020F B9 &lt;br /&gt;0212 1E &lt;br /&gt;0213 07 &lt;br /&gt;0214 BF &lt;br /&gt;0217 CD &lt;br /&gt;0219 07 &lt;br /&gt;021A A1 &lt;br /&gt;021D 50 &lt;br /&gt;021E 9D &lt;br /&gt;021F 661 &lt;br /&gt;0224 661 &lt;br /&gt;0229 661 &lt;br /&gt;022E 661 &lt;br /&gt;0232 661 &lt;br /&gt;0237 661 &lt;br /&gt;023C 661 &lt;br /&gt;0241 C3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0242 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-5 VIRTUAL 8086 MODE 659 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 MOV AL, &lt;br /&gt;FF75 CALL DISPC ;display space &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DADDR4: &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DADDR ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;The INT21H procedure gains access to the real mode DOS &lt;br /&gt;;INT 21H instruction with the parameters intact. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT21H PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 0105 R MOV REAX,EAX ;save registers &lt;br /&gt;89 1E 00F9 R MOV REBX,EBX &lt;br /&gt;89 OE 0101 R MOV RECX,ECX &lt;br /&gt;89 16 OOFD R MOV REDX,EDX &lt;br /&gt;89 36 OOED R MOV RESI,ESI &lt;br /&gt;89 3E 00E9 R MOV REDI,EDI &lt;br /&gt;89 2E 00F1 R MOV REBP,EBP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHF &lt;br /&gt;POP AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0109 R MOV RFLAG,AX &lt;br /&gt;PUSH ES ;do DOS interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0300 MOV AX,0300H &lt;br /&gt;0021 MOV BX,21H &lt;br /&gt;0000 MOV CX,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH DS &lt;br /&gt;POP ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00E9 R MOV DI,OFFSET ARRAY &lt;br /&gt;31 INT 31H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP ES &lt;br /&gt;0109 R MOV AX,RFLAG ;restore registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8B &lt;br /&gt;8B &lt;br /&gt;8B &lt;br /&gt;A1 &lt;br /&gt;8B &lt;br /&gt;8B &lt;br /&gt;8B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;POPF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3E 00E9 R MOV EDI,REDI &lt;br /&gt;36 OOED R MOV ESI,RESI &lt;br /&gt;2E OOFl R MOV EBP,REBP &lt;br /&gt;0105 R MOV EAX,REAX &lt;br /&gt;lE 00F9 R MOV EBX,REBX &lt;br /&gt;OE 0101 R MOV ECX,RECX &lt;br /&gt;16 OOFD R MOV EDX,REDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT21H ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIRTUAL 8086 MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;One special mode of operation not discussed thus far is the virtual 8086 mode. This special mode is &lt;br /&gt;designed so multiple 8086 real mode software applications can execute at one time. Figure 16-24 il-&lt;br /&gt;lustrates two 8086 applications mapped into the 80386 using the virtual mode. If the operating &lt;br /&gt;system allows multiple applications to execute, it is usually done through a technique called time-&lt;br /&gt;slicing. The operating system allocates a set amount of time to each task. For example, if three tasks &lt;br /&gt;are executing, the operating system can allocate 1 ms to each task. This means that after each mil-&lt;br /&gt;lisecond, a task switch occurs to the next task. In this manner, all tasks receive a portion of the 80386 &lt;br /&gt;execution time, resulting in a system that appears to execute more than one task at a time. The task &lt;br /&gt;times can be adjusted to give any task any percentage of the microprocessor execution time. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A system that can use this technique is a print spooler. The print spooler can function in &lt;br /&gt;one DOS partition and be accessed 10 percent of the time. This allows the system to print using &lt;br /&gt;the print spooler, but it doesn't detract from the system because it only uses 10 percent of the &lt;br /&gt;system time. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;660 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Map FIGURE 16-24 Two tasks &lt;br /&gt;resident to an 80386 oper-&lt;br /&gt;ated in the virtual 8086 mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFFFFF ,------------------, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001FFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TASK 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MSDOS &lt;br /&gt;00100000 &lt;br /&gt;OOOFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TASK 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MSDOS &lt;br /&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The main difference between 80386 protected mode operation and the virtual 8086 mode &lt;br /&gt;is the way the segment registers are interpreted by the microprocessor. In the virtual 8086 mode, &lt;br /&gt;the segment registers are used as they are in the real mode: as a segment address and offset ad-&lt;br /&gt;dress capable of accessing a 1M-byte memory space from locations OOOOOH-FFFFFH. Access to &lt;br /&gt;many virtual 8086 mode systems is made possible by the paging unit that is explained in the next &lt;br /&gt;section. Through paging, the program still accesses memory below the 1M-byte boundary, yet &lt;br /&gt;the microprocessor can access a physical memory space at any location in the 4G-byte range of &lt;br /&gt;the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Virtual 8086 mode is entered by changing the VM bit in the EFLAG register to a logic 1. &lt;br /&gt;This mode is entered via an IRET instruction if the privilege level is 00. This bit cannot be set in &lt;br /&gt;any other manner. An attempt to access a memory address above the 1M-byte boundary will &lt;br /&gt;cause a type 13 interrupt to occur. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The virtual 8086 mode could be used to share one microprocessor with many users by par-&lt;br /&gt;titioning the memory so that each user has his/her own DOS partition. User 1 could be allocated &lt;br /&gt;memory locations 00 100000H-OIFFFFFH, user 2 locations 0020000H-02FFFFFH, and so &lt;br /&gt;forth. The system software located at memory locations OOOOOOOOH-OOOFFFFFH could then &lt;br /&gt;share the microprocessor between users by switching from one to another to execute software. In &lt;br /&gt;this manner, one microprocessor is shared by many users. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;THE MEMORY PAGING MECHANISM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The paging mechanism allows any linear (logical) address, as it is generated by a program, to be &lt;br /&gt;placed into any physical memory page, as generated by the paging mechanism. A linear &lt;br /&gt;memory page is a page that is addressed with a selector and an offset in either the real or pro-&lt;br /&gt;tected mode. A physical memory page is a page that exists at some actual physical memory lo-&lt;br /&gt;cation. For example, linear memory location 20000H could be mapped into physical memory &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-6 THE MEMORY PAGING MECHANISM 661 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;location 30000H, or any other location, with the paging unit. This means that an instruction that &lt;br /&gt;accesses location 20000H actually accesses location 30000H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each 80386 memory page is 4K bytes long. Paging allows the system software to be &lt;br /&gt;placed at any physical address with the paging mechanism. Three components are Llsed in page &lt;br /&gt;ac&amp;quot;dress translation: the page directory, the page table, and the actual physical memory page. &lt;br /&gt;Note that EEM386.EXE, the extended memory manager, uses the paging mechanism to simulate &lt;br /&gt;expanded memory in extended memory and also to generate upper memory blocks between &lt;br /&gt;system ROMs. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Page Directory &lt;br /&gt;The page directory contains the location of up to 1,024 page translation tables. Each page &lt;br /&gt;translation table translates a logic address into a physical address. The page directory is stored &lt;br /&gt;in the memory and accessed by the page descriptor address register (CR3) (see Figure 16-13). &lt;br /&gt;Control register CR3 holds the base address of the page directory, which starts at any 4K-byte &lt;br /&gt;boundary in the memory system. The MOY CR3,reg instruction is used to initialize CR3 for &lt;br /&gt;paging. In a virtual 8086 mode system, each 8086 DOS partition would have its own page &lt;br /&gt;directory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The page directory contains up to 1,024 entries that are each 4 bytes long. The page direc-&lt;br /&gt;tory itself occupies one 4K-byte memory page. Each entry in the page directory (refer to Figure &lt;br /&gt;16-25) translates the leftmost lO-bits of the memory address. This lO-bit portion of the linear &lt;br /&gt;address is used to locate different page tables for different page table entries. The page table ad-&lt;br /&gt;dress (A32-AI2), stored in a page directory entry, accesses a 4K-byte long page translation &lt;br /&gt;table. Completely translating any linear address into any physical address requires 1,024 page &lt;br /&gt;tables that are each 4K bytes long, plus the page table directory, which is also 4K-bytes in length. &lt;br /&gt;This translation scheme requires up to 4M plus 4K bytes of memory for a full address transla-&lt;br /&gt;tion. Only the largest operating systems support this size of address translation. Many commonly &lt;br /&gt;found operating systems translate only the first 16M bytes of the memory system if paging is en-&lt;br /&gt;abled. This includes programs such as Windows. This translation requires four entries in the &lt;br /&gt;page directory (16 bytes) and four complete page tables (l6K bytes). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The page table directory entry control bits, as illustrated in Figure 16-25, perform the fol-&lt;br /&gt;lowing functions: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R/Wand &lt;br /&gt;V/S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-25 The page &lt;br /&gt;table directory entry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dirty is undefined for page table directory entries by the 80386 microprocessor &lt;br /&gt;and is provided for use by the operating system. &lt;br /&gt;Accessed is set to a logic 1 whenever the microprocessor accesses the page &lt;br /&gt;directory entry. &lt;br /&gt;Read/write and user/supervisor are both used in the protection scheme, as &lt;br /&gt;listed in Table 16-2. Both bits combine to develop paging priority level &lt;br /&gt;protection for level 3, the lowest user level. &lt;br /&gt;Present, if a logic 1, indicates that the entry can be used in address translation. &lt;br /&gt;If P = 0, the entry cannot beÂ·used for translation. A not present entry can be &lt;br /&gt;used for other purposes, such as indicating that the page is currently stored on &lt;br /&gt;the disk. If P = 0, the remaining bits of the entry can be used to indicate the &lt;br /&gt;location of the page on the disk memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page Table Address &lt;br /&gt;(A31-A12) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 11 10 9 8 7 6 5 4 3 2 0 &lt;br /&gt;I I I I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I I I I I I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'Reserved' 0' 0' D' A' 0' 0 'U/S'RIW'P &lt;br /&gt;I I I I I I I I I I &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;662 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 16-2 Protection for &lt;br /&gt;level 3 using UlS and RIW VIS RIW Access Level 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 None &lt;br /&gt;0 1 None &lt;br /&gt;1 0 Read-only &lt;br /&gt;1 1 Read/write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Page Table &lt;br /&gt;The page table contains 1,024 physical page addresses accessed to translate a linear address &lt;br /&gt;into a physical address. Each page table translates a 4M-byte section of the linear memory into &lt;br /&gt;4M bytes of physical memory. The format for the page table entry is exactly the same as for the &lt;br /&gt;page directory entry (refer to Figure 16-25). The main difference is that the page directory &lt;br /&gt;entry contains the physical address of a page table, while the page table entry contains the phys-&lt;br /&gt;icai address of a 4K-byte physical page of memory. The other difference is the D (dirty) bit, &lt;br /&gt;which has no function in the page directory entry, indicates that a page has been written to in a &lt;br /&gt;page table entry. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-26 illustrates the paging mechanism in the 80386 microprocessor. Here, the &lt;br /&gt;linear address 00C03FFCH, as generated by a program, is converted to physical address &lt;br /&gt;XXXXX3FCH, as translated by the paging mechanism. (Note: XXXXX is any 4K-byte physical &lt;br /&gt;page address.) The paging mechanism functions in the following manner: &lt;br /&gt;1. The 4K-byte long page directory is stored as the physical address located by CR3. This ad-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;dress is often called the root address. One page directory exists in a system at a time. In the &lt;br /&gt;8086 virtual mode, each task has its own page directory, aJIowing different areas of physical &lt;br /&gt;memory to be assigned to different 8086 virtual tasks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The upper lO-bits of the linear address (bits 31-22), as determined by the descriptors de-&lt;br /&gt;scribed earlier in this chapter or by a real address, are applied to the paging mechanism to se-&lt;br /&gt;lect an entry in the page directory. This maps the page directory entry to the leftmost lO-bits &lt;br /&gt;of the linear address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The page table is addressed by the entry stored in the page directory. This allows up to 4K &lt;br /&gt;page tables in a fully-populated and translated system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. An entry in the page table is addressed by the next lO-bits of the linear address (bits 21-12). &lt;br /&gt;5. The page table entry contains the actual physical address of the 4K-byte memory page. &lt;br /&gt;6. The rightmost 12-bits of the linear address (bits 11-0) select a location in the memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;page. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The paging mechanism allows the physical memory to be assigned to any linear ad-&lt;br /&gt;dress through the paging mechanism. For example, suppose that linear address 20000000H is &lt;br /&gt;selected by a program, but this memory location does not exist in the physical memory &lt;br /&gt;system. The 4K-byte linear page is referenced as locations 20000000H-20000FFFH by the &lt;br /&gt;program. Because this section of physical memory does not exist, the operating system might &lt;br /&gt;assign an existing physical memory page such as 12000000H-12000FFFH to this linear &lt;br /&gt;address range. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the address translation process, the leftmost 10-bits of the linear address select page direc-&lt;br /&gt;tory entry 200H, located at offset address 800H in the page directory. This page directory entry &lt;br /&gt;contains the address of the page table for linear addresses 20000000H-203FFFFFH. Linear ad-&lt;br /&gt;dress bits (21-12) select an entry in this page table that corresponds to a 4K-byte memory page. For &lt;br /&gt;linear addresses 2000000H-20000FFFH, the first entry (entry 0) in the page table is selected. This &lt;br /&gt;first entry contains the physical address of the actual memory page, or I 2000000H-l2000FFFH in &lt;br /&gt;this example. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-6 THE MEMORY PAGING MECHANISM 663 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Linear address &lt;br /&gt;31 2221 1211 a &lt;br /&gt;1 0000000011 0000000011 : 1111111111001 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;4K byte memory page &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XXXXXFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I XXXXXFFE XXXXXFFO &lt;br /&gt;~ XXXXXFFC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page table (number 3) XXXXXFFB &lt;br /&gt;~3FF OOFFFOOO OOFFFFFF XXXXX007 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3FE OOFFEOOO - OOFFEFFF XXXXX006 Page table directory 3FO OOFFOOOO - OOFFOFFF XXXXX005 &lt;br /&gt;3FF FFCOOOOO - FFFFFFFF 3FC OOFFCOOO - OOFFCFFF XXXXX004 &lt;br /&gt;3FE FF800000 - FFBFFFFF 3FB OOFFSOOO - OOFFBFFF XXXXX003 &lt;br /&gt;3FO FF400000 - FF7FFFFF XXXXX002 &lt;br /&gt;3FC FFOOOOOO - FF3FFFFF 7 00C07000 - 00C07FFF XXXXXOOI &lt;br /&gt;3FB FECOOOOO - FEFFFFFF 6 00C06000 - 00C06FFF XXXXXOOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 00C05000 - 00C05FFF &lt;br /&gt;7 01 COOOOO - 01 FFFFFF 4 00C04000 - 00C04FFF &lt;br /&gt;6 01800000 - 01 BFFFFF ul 00C03000 - 00C03FFF f-5 01400000 - 017FFFFF 00C02000 - 00C02FFF 4 01000000 - 013FFFFF 00C01000 - OOCOl FFF + 3 OOCOOOOO - OOFFFFFF OOCOOOOO - OOCOOFFF &lt;br /&gt;2 00800000 - OOBFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CR3 1 00400000 - 007FFFFF &lt;br /&gt;Root address a 00000000 - 003FFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: 1. The address ranges illustrated in the page directory and page table &lt;br /&gt;represent the linear address ranges selected and not the contents of these tables. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The addresses (XXXXX) listed in the memory page are selected by the page table entry. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-26 The translation of linear address OOC03FFC to physical memory address XXXXXFFC. The &lt;br /&gt;value of XXXXX is determined by the page table entry (not shown here). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Take, for example, a typical DOS-based computer system. The memory map for the &lt;br /&gt;system appears in Figure 16-27. Notice from the map that there are unused areas of memory that &lt;br /&gt;could be paged to a different location, giving a DOS real mode application program more &lt;br /&gt;memory. The normal DOS memory system begins at location OOOOOH and extends to location &lt;br /&gt;9FFFFH, which is 640K bytes of memory. Above location 9FFFFH, we find sections devoted to &lt;br /&gt;video cards, disk cards, and the system BIOS ROM. In this example, an area of memory just &lt;br /&gt;above 9FFFFH is unused (AOOOO-AFFFFH). This section of the memory could be used by DOS &lt;br /&gt;so that the total applications memory area is 704K instead of 640K. Be careful when using &lt;br /&gt;AOOOOH-AFFFFH for additional RAM because the video card uses this area for bit-mapped &lt;br /&gt;graphics in modes 12H and 13H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of memory can be used by mapping it into extended memory at locations &lt;br /&gt;102000H-ll FFFFH. Software to accomplish this translation and initialize the page table directory &lt;br /&gt;and page tables required to set up memory are illustrated in Example 16-4. Note that this procedure &lt;br /&gt;initializes the page table directory and a page table, and loads CR3. It does not switch to protected &lt;br /&gt;mode and it does enable paging. Note that paging functions in real mode memory operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 1~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.HODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.386P &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;664 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-27 Memory &lt;br /&gt;map for an AT-style clone FFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000 &lt;br /&gt;OFFFFF &lt;br /&gt;OEOOOO &lt;br /&gt;OB8000 &lt;br /&gt;OBOOOO &lt;br /&gt;OAFFFF &lt;br /&gt;OAOOOO &lt;br /&gt;09FFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;page directory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 00000004 PDIR DD 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;page table 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0004 0400 TABO DD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010 &lt;br /&gt;0016 &lt;br /&gt;0018 &lt;br /&gt;001C &lt;br /&gt;0022 &lt;br /&gt;0028 &lt;br /&gt;002C &lt;br /&gt;0030 &lt;br /&gt;0033 &lt;br /&gt;0036 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;66/ B8 00000000 MOV &lt;br /&gt;8C C8 MOV &lt;br /&gt;66 C1 EO 04 SHL &lt;br /&gt;66 05 00000004 R ADD &lt;br /&gt;66 25 FFFFFOOO AND &lt;br /&gt;66 83 CO 07 ADD &lt;br /&gt;66 A3 0000 R MOV &lt;br /&gt;B9 0100 MOV &lt;br /&gt;BF 0004 R MOV &lt;br /&gt;8C D8 MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0038 8E co MOV &lt;br /&gt;MOV ~:3A 66/ B8 00000007 &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0040 66/ AB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1024 DUP (?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX,O &lt;br /&gt;AX,CS &lt;br /&gt;EAX,4 &lt;br /&gt;EAX,OFFSET TABO &lt;br /&gt;EAX,OFFFFFOOOH &lt;br /&gt;EAX,7 &lt;br /&gt;PDIR,EAX &lt;br /&gt;CX,256 &lt;br /&gt;DI,OFFSET TABO &lt;br /&gt;AX,DS &lt;br /&gt;ES,AX &lt;br /&gt;EAX,7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOSD &lt;br /&gt;0042 66/ 05 00001000 ADD EAX,4096 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;004A 66/ B8 00102007 &lt;br /&gt;0050 B9 0010 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;MOV EAX,0102007H &lt;br /&gt;MOV CX,16 &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Map &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Extended Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;eGA Memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unused &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOSTPA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;address page table 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;remap 00000H-09FFFH &lt;br /&gt;ito 00000H-09FFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;remap OAOOOH-OAFFFH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-7 INTRODUCTION TO THE 80486 MICROPROCESSOR 665 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0053 661 AB STOSD ;to 102000H-11FFFFH &lt;br /&gt;0055 661 05 00001000 ADD EAX,4096 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;005D 661 B8 00000000 MOV EAX, 0 &lt;br /&gt;0063 8C 08 MOV AX,DS &lt;br /&gt;0065 661 C1 EO 04 SHL EAX,4 &lt;br /&gt;0069 661 05 00000000 R ADD EAX,OFFS=~ PS:? ;load CR3 with page directory &lt;br /&gt;006F OF 22 D8 MOV CR3,EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;additional software to remap other areas of memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;end &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION TO THE 80486 MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80486 microprocessor is a highly integrated device containing well over 1.2 million transis-&lt;br /&gt;tors. Located within this powerful integrated circuit are a memory-management unit (MMU); a &lt;br /&gt;complete numeric coprocessor that is compatible with the 80387; a high-speed level one cache &lt;br /&gt;memory that contains 8K bytes of space; and a full 32-bit microprocessor that is upward compat-&lt;br /&gt;ible with the 80386 microprocessor. The 80486 is currently available as a 25 MHz, 33 MHz, &lt;br /&gt;50 MHz, 66 MHz, or 100 MHz device. Note that the 66 MHz version is double-clocked and the &lt;br /&gt;100 MHz version is triple-clocked. In 1990, Intel demonstrated a 100 MHz version (not double-&lt;br /&gt;clocked) of the 80486 for Computer Design magazine, but this version has yet to be released. Ad-&lt;br /&gt;vanced Micro Devices (AMD) has produced a 40 MHz version that is also available in an 80 MHz &lt;br /&gt;(double-clocked) and a 120 MHz (triple-clocked) form. The 80486 comes as an 80486DX or an &lt;br /&gt;80486SX. The only difference between these devices is that the 80486SX does not contain the &lt;br /&gt;numeric coprocessor, which reduces its price. The 80487SX numeric coprocessor is available as &lt;br /&gt;a separate component for the 80486SX microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section details the differences between the 80486 and 80386 microprocessors. These &lt;br /&gt;differences are few, as shall be seen. The most notable differences apply to the cache memory &lt;br /&gt;system and parity generator. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin-out of the 80486DX and 80486SX Microprocessors &lt;br /&gt;Figure 16-28 illustrates the pin-out of the 80486DX microprocessor, a 168-pin PGA. The &lt;br /&gt;80486SX, also packaged in a 168-pin PGA, is not illustrated because only a few differences &lt;br /&gt;exist. Note that pin B 15 is NMI on the 80486DX and pin A15 is NMI on the 80486SX. The only &lt;br /&gt;other differences are that pin A15 is IGNNE on the 80486DX (not present o~ the 80486SX), pin &lt;br /&gt;C14 is FERR on the 80486DX, and pins B15 and C14 on the 80486SX are not connected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When connecting the 80486 microprocessor, all V cc and V ss pins must be connected to &lt;br /&gt;the power supply for proper operation. The power supply must be capable of supplying 5.0V &lt;br /&gt;Â±1O %, with up to 1.2 A of surge current for the 33 MHz version. The average supply current is &lt;br /&gt;650 rnA for the 33 MHz version. Intel has also produced a 3.3V version that requires an average &lt;br /&gt;of 500 rnA at a triple-clock speed of 100 MHz. Logic 0 outputs allow up to 4.0 rnA of current, &lt;br /&gt;and logic 1 outputs allow up to 1.0 rnA. If larger currents are required, as they often are, then the &lt;br /&gt;80486 must be buffered. Figure 16-29 shows a buffered 80486DX system. In the circuit shown, &lt;br /&gt;only the address, data, and parity signals are buffered. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Definitions &lt;br /&gt;A31-A2 Address outputs A31-A2 provide the memory and I/O with the address during &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;normal operation; during a cache line invalidation, A31-A4 are used to drive &lt;br /&gt;the microprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;666 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;p &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;N &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;F &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A27 A26 A23 NC A14 VSS A12 VSS VSS VSS VSS VSS Al0 VSS A6 A4 AOS# &lt;br /&gt;o 0 0 0 0 0 000 000 000 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2B A25 VCC VSS AlB VCC A 15 VCC VCC VCC VCC All AS VCC A3 BLAST# NC &lt;br /&gt;o 0 0 0 0 0 0 0 0 000 000 0 0 &lt;br /&gt;A31 VSS A17 A19 A21 A24 A22 A20 A16 A13 A9 A5 A7 A2 BREO PLOCK#PCHK# &lt;br /&gt;o 0 0 0 0 0 0 0 0 000 0 000 0 &lt;br /&gt;DO A29 A30 &lt;br /&gt;000 &lt;br /&gt;02 01 OPO &lt;br /&gt;000 &lt;br /&gt;vss vcc D4 &lt;br /&gt;000 &lt;br /&gt;vss 06 07 &lt;br /&gt;000 &lt;br /&gt;vss vcc 014 &lt;br /&gt;000 &lt;br /&gt;vcc 05 016 &lt;br /&gt;000 &lt;br /&gt;vss 03 OP2 &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vss vcc 012 &lt;br /&gt;000 &lt;br /&gt;OPl OB 015 &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VSS VCC 010 &lt;br /&gt;000 &lt;br /&gt;09 013 017 &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48Sâ¢ Microprocessor &lt;br /&gt;PIN SIDE VIEW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HLDA vee vss &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lOCK# MI1O# WiR# &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIC# vcc VSS &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PWT vee vss &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEO# vec vss &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE2# BE1# PCO &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BROYI VCC VSS &lt;br /&gt;000 &lt;br /&gt;NC vcc VSS &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;KEN# ROY# BE3# &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOLD vee vss &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A20Mt1 BSB# BOFF# &lt;br /&gt;000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;011 01B ClK VCC VCC 027 026 02B 030 NC NC NC NC FERR#FlUSH# RESET BSl6# &lt;br /&gt;o 0 0 0 0 0 0 0 0 000 0 0 0 0 0 &lt;br /&gt;019 021 vss VSS vss 025 VCC 031 vcc NC vcc NC NC NC NMI NC EAOS# &lt;br /&gt;o 0 0 0 0 0 000 000 000 0 0 &lt;br /&gt;020 022 NC 023 OP3 024 VSS 029 VSS NC VSS NC NC NC IClNNE# INTR AHOLD &lt;br /&gt;o 0 0 0 0 0 000 000 000 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;234 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt;br /&gt;240440-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-28 The pin-out of the 80486 (Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A20M The address bit 20 mask causes the 80486 to wrap its address around from &lt;br /&gt;location OOOFFFFFH to OOOOOOOOH, as does the 8086 microprocessor- This &lt;br /&gt;provides a memory system that functions like the 1M-byte real memory system &lt;br /&gt;in the 8086 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS The address data strobe becomes a logic zero to indicate that the address bus &lt;br /&gt;contains a valid memory address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AHOLD The address hold input causes the microprocessor to place its address bus &lt;br /&gt;connections at their high-impedance state, with the remainder of the buses &lt;br /&gt;staying active. It is often used by another bus master to gain access for a cache &lt;br /&gt;invalidation cycle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BE3-BEO Byte enable outputs select a bank of the memory system when information is &lt;br /&gt;transferred between the microprocessor and its memory and 1/0 space. The &lt;br /&gt;BE3 signal enables D31-D24, BE2 enables D23-D16, BEl enables D1S-D8, &lt;br /&gt;and BEO enables D7-DO. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BLAST '; he burst last output shows that the burst bus cycle is complete on the next &lt;br /&gt;activation of the BRDY signal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOFF The back-off input causes the microprocessor to place its buses at their high-&lt;br /&gt;impedance state during the next clock cycle. The microprocessor remains in &lt;br /&gt;the bus hold state until the BOFF pin is placed at a logic 1 level. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IJrI IIII &lt;br /&gt;~ 81 AI 2 B2 A2 4 ~ Ul :::=l B3 A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;i IIII &lt;br /&gt;B4 A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEO :::=l BS AS DO ;:::::J B6 A6 8 Dl BEl B7 A7 D2 BE2 B8 A8 D3 BE3 G~ II D4 A2 DS A3 &amp;quot;~ DS A4 74AS645 D7 AS &lt;br /&gt;08 AS ~~1 OS A7 A1R= Dl0 A8 W rr Dl1 A9 N B2 A2 -1-- D12 Al0 ~i! A3 D13 All A4 D14 A12 AS I r DIS A13 t=l B6 AS DIS A14 ~ B7 A7 &lt;br /&gt;D17 A1S B8 AS &lt;br /&gt;018 A1S R b-tL D19 A17 4 nog D20 A18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74AS645 D21 A19 &lt;br /&gt;D22 A20 7 ~~ D23 A21 024 A22 &amp;gt; ~1 ~1 D2S A23 &lt;br /&gt;D26 A24 1 83 A3 &lt;br /&gt;027 A25 ~ B4 A4 D28 A2S 1 85 S&lt;br /&gt;D29 A27 1 86 A6 &lt;br /&gt;D30 A28 I~ 1 B7 A7 D31 A29 01 88 AS A30 n,geÂ£:: &amp;quot;eLK A31 RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= ~ NMI ADS INTA DJC U 8S16 WIA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;?1 2 BSO MIlO Bl AI A20M LOCK B2 A2 4 HOLD PLOCK B3 A3 HLDA PCHK ~ B4 A4 AHOLD BREQ B5 A5 ROY DPO ff t-t::=l 116 Ab UWN (WI ill A7 BLAST DP2 &amp;quot;--J 1111 A8 FEIIR DP3 ill:: ~ IONNi: LADS II 1 PWl FLU~I-t DlR PCD BOFF 74AS645 KEN &lt;br /&gt;80486 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~ 1 81 AI 2 1 82 A2&lt;br /&gt;1 83 A3 t:::=i 84 A4 ~ 1 B5 A5 tE 12 86 AS t:::::lÂ± B7 A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B8 AS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~ &lt;br /&gt;74AS645 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-29 An 80486 microprocessor showing the buffered address, data, and parity buses &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U8 &lt;br /&gt;&amp;quot; Dl 4 D2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D3 &lt;br /&gt;D4 1 DS 4 D6 1 D7 1 D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r---4: C &lt;br /&gt;74AS53J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I~ U9 Dl Il D2 D3 1 D4 &lt;br /&gt;II DS OS D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D8 &lt;br /&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;c 1 &lt;br /&gt;74ASS33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ Ul0 3 Dl D2 D3 D4 DS 17 OS D7 D8 ~ 11 C 74F04 2 74AS533 &lt;br /&gt;U1I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3 Dl &lt;br /&gt;D2 &lt;br /&gt;D3 &lt;br /&gt;D4 &lt;br /&gt;D5 &lt;br /&gt;06 &lt;br /&gt;D7 &lt;br /&gt;DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74AS533 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 &lt;br /&gt;3 Dl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18~ :::j 8; &lt;br /&gt;~8~ &lt;br /&gt;--' D8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74AS533 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.----&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 f~ 02 03 04 OS as 07 08 &lt;br /&gt;01 ~ 02 03 Q4 ~ OS .,S 07 08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~I 04 1 as 1 as 1 &lt;br /&gt;g~ 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;al~ 02 03 &lt;br /&gt;g~ 1 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;DO -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;r 01 02 03 Q4 05 06 07 08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DPO-DP3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00-031 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEO-BE3 &lt;br /&gt;A2-A31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1: &lt;br /&gt;Z &lt;br /&gt;--I &lt;br /&gt;:D &lt;br /&gt;o &lt;br /&gt;CI &lt;br /&gt;C &lt;br /&gt;~ &lt;br /&gt;a &lt;br /&gt;z &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;d &lt;br /&gt;--I &lt;br /&gt;:r: &lt;br /&gt;m &lt;br /&gt;ex&amp;gt; &lt;br /&gt;o &lt;br /&gt;..,. &lt;br /&gt;ex&amp;gt; &lt;br /&gt;0&amp;gt; &lt;br /&gt;s: &lt;br /&gt;c=5 &lt;br /&gt;:D &lt;br /&gt;o &lt;br /&gt;&amp;quot; :D &lt;br /&gt;o &lt;br /&gt;(&amp;quot;) &lt;br /&gt;m &lt;br /&gt;en &lt;br /&gt;en &lt;br /&gt;o &lt;br /&gt;:D &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0') &lt;br /&gt;0') &lt;br /&gt;-oJ &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;668 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BREQ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D31-DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DJC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DP3-DPO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLUSH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HLDA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOLD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IGNNE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 16-3 &lt;br /&gt;identification &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The burst ready input is used to signal the microprocessor that a burst cycle is &lt;br /&gt;complete. &lt;br /&gt;The bus request output indicates that the 80486 has generated an internal bus &lt;br /&gt;request. &lt;br /&gt;The bus size 8 input causes the 80486 to structure itself with an 8-bit data bus &lt;br /&gt;to access byte-wide memory and I/O components. &lt;br /&gt;The bus size 16 input causes the 80486 to structure itself with a 16-bit data &lt;br /&gt;bus to access word-wide memory and I/O components. &lt;br /&gt;The clock input provides the 80486 with its basic timing signal. The clock input &lt;br /&gt;is a TTL-compatible input that is 25 MHz to operate the 80486 at 25 MHz. &lt;br /&gt;The data bus transfers data between the microprocessor and its memory and &lt;br /&gt;I/O system. Data bus connections D7-DO are also used to accept the interrupt &lt;br /&gt;vector type number during an interrupt acknowledge cycle. &lt;br /&gt;The data/control output indicates whether the current operation is a data transfer &lt;br /&gt;or control cycle. Refer to Table 16-3 for the function of D/e, MilO, and W iR. &lt;br /&gt;Data parity I/O provides even parity for a write operation and check parity for &lt;br /&gt;a read operation. If a parity error is detected during a read, the PCHK output &lt;br /&gt;becomes a logic 0 to indicate a parity error. If parity is not used in a system, &lt;br /&gt;these lines must be pulled-high to +5.0V or to 3.3V in a system that uses a &lt;br /&gt;3.3V supply. &lt;br /&gt;The exte,rnal address strobe input is used with AHOLD to signal that an &lt;br /&gt;external address is used to perform a cache invalidation cycle. &lt;br /&gt;The floating-point error output indicates that the floating-point coprocessor &lt;br /&gt;has detected an error condition. It is used to maintain compatibility with DOS &lt;br /&gt;software. &lt;br /&gt;The cache flush input forces the microprocessor to erase the contents of its &lt;br /&gt;8K-byte internal cache. &lt;br /&gt;The hold acknowledge output indicates that the HOLD input is active and that &lt;br /&gt;the microprocessor has placed its buses at their high-impedance state. &lt;br /&gt;The hold input requests a DMA action. It causes the address, data, and control &lt;br /&gt;buses to be placed at their high-impedance state and also, once recognized, &lt;br /&gt;causes HLDA to become a logic O. &lt;br /&gt;The ignore numeric error input causes the coprocessor to ignore floating-&lt;br /&gt;point errors and to continue processing data. This signal does not affect the &lt;br /&gt;state of the FERR pin. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bus cycle &lt;br /&gt;MilO DiG WIR Bus Cycle Type &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 Interrupt acknowledge &lt;br /&gt;0 0 1 Halt/special &lt;br /&gt;0 0 I/O read &lt;br /&gt;0 1 1 I/O write &lt;br /&gt;1 0 0 Opcode fetch &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 1 Reserved &lt;br /&gt;0 Memory read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory write &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-7 INTRODUCTION TO THE 80486 MICROPROCESSOR 669 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMI &lt;br /&gt;pcn &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PWT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;w/R: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt request input requests a maskable interrupt as it does in all &lt;br /&gt;other family members. &lt;br /&gt;The caGhe enable input causes the current bus to be stored in the internal &lt;br /&gt;cache. &lt;br /&gt;The lock output becomes a logic 0 for any instru&amp;lt;.:lion that is prefixed with the &lt;br /&gt;lock prefix. &lt;br /&gt;Memory/IO defines whether the address bus contains a memory address or an &lt;br /&gt;I/O port number. It is also combined with the W IR signal to generate memory &lt;br /&gt;and I/O read and write control signals. &lt;br /&gt;The non-maskable interrupt input requests a type 2 interrupt. &lt;br /&gt;The page cache disable output reflects the state of the peD attribute bit in the &lt;br /&gt;page table entry or the page directory entry. &lt;br /&gt;The parity check output indicates that a parity error was detected during a &lt;br /&gt;read operation on the OP3-DPO pins. &lt;br /&gt;The pseu&amp;lt;Jo-lock output indicates that the current operation requires more than &lt;br /&gt;one bus cycle to perform. This signal becomes a logic 0 for arithmetic &lt;br /&gt;coprocessor operations that access 64- or 80-bit memory data. &lt;br /&gt;The page write through output indicates the state of the PWT attribute bit in &lt;br /&gt;the page table entry or the page directory entry. &lt;br /&gt;The ready input indicates that a non-burst bus cycle is complete. The ROY &lt;br /&gt;signal must be returned or the microprocessor places wait states into its timing &lt;br /&gt;until ROY is asserted. &lt;br /&gt;The reset input initializes the 80486 as it does in other family members. &lt;br /&gt;Table 16-4 shows the effect of the RESET input on the 80486 microprocessor. &lt;br /&gt;Write/read signals that the current bus cycle is either a read or a write. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Basic 80486 Architecture &lt;br /&gt;The architecture of the 80486DX is almost identical to the 80386. Added to the 80386 architec-&lt;br /&gt;ture inside the 804860X is a math coprocessor and an 8K-byte level one cache memory. The &lt;br /&gt;80486SX is almost identical to an 80386 with an 8K-byte cache, but no numeric coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 16-4 The effect of &lt;br /&gt;the RESET signal Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;EOX &lt;br /&gt;EFLAGS &lt;br /&gt;EIP &lt;br /&gt;ES &lt;br /&gt;CS &lt;br /&gt;OS &lt;br /&gt;SS &lt;br /&gt;FS &lt;br /&gt;GS &lt;br /&gt;10TR &lt;br /&gt;CRO &lt;br /&gt;DR? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Initial Value with Self Test &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOOOOH &lt;br /&gt;00000400H + 10* &lt;br /&gt;00000002H &lt;br /&gt;OOOOFFFOH &lt;br /&gt;OOOOH &lt;br /&gt;FOOOH &lt;br /&gt;OOOOH &lt;br /&gt;OOOOH &lt;br /&gt;OOOOH &lt;br /&gt;OOOOH &lt;br /&gt;base = 0, limit = 3FFH &lt;br /&gt;60000010H &lt;br /&gt;OOOOOOOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Initial Value without Self Test &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;? &lt;br /&gt;00000400H + 10* &lt;br /&gt;00000002H &lt;br /&gt;OOOOFFFOH &lt;br /&gt;OOOOH &lt;br /&gt;FOOOH &lt;br /&gt;OOOOH &lt;br /&gt;OOOOH &lt;br /&gt;OOOOH &lt;br /&gt;OOOOH &lt;br /&gt;base = 0, limit = 3FFH &lt;br /&gt;60000010H &lt;br /&gt;OOOOOOOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'Note: Revision 10 number is supplied by Intel for revisions to the microprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;670 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-30 The internal &lt;br /&gt;programming model of the &lt;br /&gt;80486 (Courtesy of Intel &lt;br /&gt;Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 &lt;br /&gt;General-Purpose Registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24123 16 15 8(7 &lt;br /&gt;AH AX AL &lt;br /&gt;BH BX BL &lt;br /&gt;CH CX CL &lt;br /&gt;OH OX OL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI &lt;br /&gt;01 &lt;br /&gt;BP &lt;br /&gt;sp &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment Registers &lt;br /&gt;15 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;EAX &lt;br /&gt;EBX &lt;br /&gt;ECX &lt;br /&gt;EOX &lt;br /&gt;ESI &lt;br /&gt;EOI &lt;br /&gt;EBP &lt;br /&gt;ESP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1--------1 CS Code segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1--------1~~}::~: :::::~: 1-_____ --1 FS &lt;br /&gt;L--_____ ...J GS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction Pointer &lt;br /&gt;31 16 15 0 &lt;br /&gt;L-I ____ --LI __ ...:.;.IP __ --II EIP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Flags Register &lt;br /&gt;'--____ ---'I ___ FLA_G_S_--', EFLAGS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-30 illustrates the basic internal structure of the 80486 microprocessor. If this is com-&lt;br /&gt;pared to the architecture of the 80386, no differences are observed. The most prominent differ-&lt;br /&gt;ence between the 80386 and the 80486 is that almost half of the 80486 instructions execute in &lt;br /&gt;one clocking period instead of the two clocking periods required for the 80386 to execute similar &lt;br /&gt;instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with the 80386, the 80486 contains eight general-purpose 32-bit registers: EAX, EBX, &lt;br /&gt;ECX, EDX, EBP, EDI, ESI, and ESP. These registers may be used as 8-, 16-, or 32-bit data reg-&lt;br /&gt;isters or to address a location in the memory system. The 16-bit registers are the same set as &lt;br /&gt;found in the 80286 and are assigned: AX, BX, CX, DX, BP, DI, SI, and SP. The 8-bit registers &lt;br /&gt;are AH, AL, BH, BL, CH, CL, DH, and DL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In addition to the general-purpose registers, the 80486 also contains the same segment reg-&lt;br /&gt;isters as the 80386, which are CS, DS, ES, SS, FS, and OS. Each are 16-bits wide, as in all ear-&lt;br /&gt;lier versions of the family. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The IP (instruction pointer) addresses the program located within the 1M byte of memory &lt;br /&gt;in combination with CS, or as EIP (extended instruction pointer) to address a program at any lo-&lt;br /&gt;cation within the 40-byte memory system. In protected mode operation, the segment registers &lt;br /&gt;function to hold selectors as they did in the 80286 and 80386 microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80486 also contains the global, local, and inten-upt descriptor table register and &lt;br /&gt;memory-management unit, as in the 80386. Although these registers are not illustrated in Figure &lt;br /&gt;16-30, they are present as they are in the 80386. The function of the MMU and its paging unit is &lt;br /&gt;described earlier in this chapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The extended flag register (EFLAOS) is illustrated in Figure 16-31. As with other family &lt;br /&gt;members, the rightmost flag bits perform the same functions for compatibility. The only new &lt;br /&gt;flag bit is the AC (alignment check), used to indicate that the microprocessor has accessed a &lt;br /&gt;word at an odd address or a doubleword stored at a non-doubleword boundary. Efficient soft-&lt;br /&gt;ware and execution require that data be stored at word or doubleword boundaries. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-7 INTRODUCTION TO THE 80486 MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EFLAGS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;3322222222221111111 &lt;br /&gt;1098765432109876542 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESERVED FOR INTEL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALIGNMENT CHECK-----...J &lt;br /&gt;VIRTUAL MODE --------' &lt;br /&gt;RESUME FLAG----------' &lt;br /&gt;NESTED TASK FLAG---------J &lt;br /&gt;1/0 PRIVILEGE LEVEL ---------.... &lt;br /&gt;OVERFLOW-------------.....I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLAGS &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;09876543210 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIRECTION FLAG ____________ .....J &lt;br /&gt;INTERRUPT ENABLE------------...J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: &lt;br /&gt;o indicates Intel Reserved: do not define; see Section 2.1.6. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-31 The EFLAG register of the 80486 (Courtesy of Intel Corporation) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 Memory System &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;671 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;240440-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory system for the 80486 is identical to the 80386 microprocessor. The 80486 contains &lt;br /&gt;40 bytes of memory beginning at location OOOOOOOOH and ending at location FFFFFFFFH. The &lt;br /&gt;major change to the memory system is internal to the 80486 in the form of an 8K-byte cache &lt;br /&gt;memory, which speeds the execution of instructions and the acquisition of data. Another addi-&lt;br /&gt;tion is the parity checker/generator built into the 80486 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Parity Checker/Generator. Parity is often used to determine if data are correctly read from a &lt;br /&gt;memory location. To facilitate this, Intel has incorporated an internal parity generator/detector. &lt;br /&gt;Parity is generated by the 80486 during each write cycle. Parity is generated as even parity, and &lt;br /&gt;a parity bit is provided for each byte of memory. The parity check bits appear on pins DPO-DP3, &lt;br /&gt;which are also parity inputs as well as outputs. These are typically stored in memory during each &lt;br /&gt;write cycle and read from memory during each read cycle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;On a read, the microprocessor checks parity and generates a parity check error, if it occurs, &lt;br /&gt;on the PCHK pin. A parity error causes no change in processing unless the user applies the &lt;br /&gt;PCHK signal to an interrupt input. Interrupts are often used to signal a parity error in DOS-based &lt;br /&gt;computer systems. Figure 16-32 shows the organization of the 80486 memory system that in-&lt;br /&gt;cludes parity storage. Note that this is the same as for the 80386, except for the parity bit storage. &lt;br /&gt;If parity is not used, Intel recommends that the DPO-DP3 pins be pulled-up to +5.0V. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-32 The organi-&lt;br /&gt;zation of the 80486 memory, &lt;br /&gt;showing parity &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P &lt;br /&gt;A &lt;br /&gt;R &lt;br /&gt;I &lt;br /&gt;T &lt;br /&gt;Y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1G x8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OP3 031 - 024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P &lt;br /&gt;A &lt;br /&gt;R 1Gx8 I &lt;br /&gt;T &lt;br /&gt;Y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OP2 023 - 016 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P P &lt;br /&gt;A A &lt;br /&gt;R 1G x 8 R 1G x8 I I &lt;br /&gt;T T &lt;br /&gt;Y Y &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OP1 015 - 08 OPO 07- 00 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;672 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cache Memory. The cache memory system caches (stores) data used by a program and also the &lt;br /&gt;instructions of the program. The cache is organized as a 4-way set associative cache with each &lt;br /&gt;location (line) containing 16 bytes or 4 doublewords of data. The cache operates as a write-&lt;br /&gt;through cache. Note that the cache changes only if a miss occurs. This means that data written to &lt;br /&gt;a memory location not already cached are not written to the cache. In many cases, much of the &lt;br /&gt;active portion of a program is found completely inside the cache memory. This causes execution &lt;br /&gt;to occur at the rate of one clock cycle for many of the instructions that are commonly used in a &lt;br /&gt;program. About the only way that these efficient instructions are slowe~ is when the micro-&lt;br /&gt;processor must fill a line in the cache. Data are also stored in the cache, but they have less of an &lt;br /&gt;impact on the execution speed of a program because data are not referenced repeatedly, as are &lt;br /&gt;many portions of a program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control register 0 (CRO) is used to control the cache with two new control bits not present &lt;br /&gt;in the 80386 microprocessor. (Refer to Figure 16-33 for C~O in the 80486 microprocessor.) The &lt;br /&gt;CD (cache disable) and NW (non-cache write-through) bits-are new to the 80486 and are used to &lt;br /&gt;control the 8K-byte cache. If the CD bit is a logic I, all cache operations are inhibited. This set-&lt;br /&gt;ting is only used for debugging software and normally renpins cleared. The NW bit is used to in-&lt;br /&gt;hibit cache write-through operation. As with CD, cache write-through is inhibited only for &lt;br /&gt;testing. For normal program operation, CD = 0 and NW = O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Because the cache is new to the 80486 microprocessor, and the cache is filled using burst &lt;br /&gt;cycles not present on the 80386, some detail is required to understand bus filling cycles. When a &lt;br /&gt;bus line is filled, the 80486 must acquire four 32-bit numbers from the memory system to fill a &lt;br /&gt;line in the cache. Filling is accomplished with a burst cycle. The burst cycle is a special memory &lt;br /&gt;where four 32-bit numbers are fetched from the memory system in five clocking periods. This &lt;br /&gt;assumes that the speed of the memory is sufficient and that no wait states are required. If the &lt;br /&gt;clock frequency of the 80486 is 33 MHz, we can fill a cache line in 167 ns, which is very effi-&lt;br /&gt;cient considering that a normal, non-burst 32-bit memory read operation requires two clocking &lt;br /&gt;periods. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory Read Timing. Figure 16-34 illustrates the read timing for the 80486 for a non-burst &lt;br /&gt;memory operation. Note that two clocking periods are used to transfer data. Clocking period TI &lt;br /&gt;provides the memory address and control signals, and clocking period T2 is where the data are &lt;br /&gt;transferred between the memory and the microprocessor. Note that the RDY must become a &lt;br /&gt;logic 0 to cause data to be transferred and to terminate the bus cycle. Access time for a non-burst &lt;br /&gt;access is determined by taking two clocking periods minus the time required for the address to &lt;br /&gt;appear on the address bus connection minus a setup time for the data bus connections. For the &lt;br /&gt;20 MHz version of the 80486, two clocking periods require 100 ns minus 28 ns for address setup &lt;br /&gt;time and 6ns for data setup time. This yields a non-burst access time of 100 ns - 34 ns, or 76 ns. &lt;br /&gt;Of course, if decoder time and delay times are inclu~ed, the access time allowed the memory is &lt;br /&gt;even less for no wait state operation. Also, if a higher-frequency version of the 80486 is used in &lt;br /&gt;a system, memory access time is still less. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80486 33 MHz, 66 MHz, and 100 MHz processors all access bus data at a 33 MHz &lt;br /&gt;rate. In other words, the microprocessor may operate at 100 MHz, but the system bus operates at &lt;br /&gt;33 MHz. Notice that the non-burst access timing for the 33 MHz system bus allows 60 ns - 24ns &lt;br /&gt;= 36 ns. It is obvious that wait states are required for operation with standard DRAM memory &lt;br /&gt;devices. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 24 23 16 15 8 7 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I~I~I~I I I I I I I I I I I~I I~I I I I I I I I I I I~I I~I~I~I~I &lt;br /&gt;FIGURE 16-33 Control register zero (CRO) for the 80486 microprocessor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-7 INTRODUCTION TO THE 80486 MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-34 The non-&lt;br /&gt;burst read timing for the &lt;br /&gt;80486 microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 T2 T1 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-: 1-1 . Addr::J] Xr---r----' ~I &lt;br /&gt;D.&amp;quot; Jj~mj3=t5lmmmd &lt;br /&gt;AD8l\\ I, ! \\ Ii ' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;673 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 16-35 illustrates the timing diagram for filling a cache line with four 32-bit num-&lt;br /&gt;bers using a burst. Notice that the addresses (A31-A4) appear during Tl and remain constant &lt;br /&gt;throughout the burst cycle. Also notice that A2 and A3 change during each T2 after the first to &lt;br /&gt;address four consecutive 32-bit numbers in the memory system. As mentioned, cache fills using &lt;br /&gt;bursts require only five clocking periods (one Tl and four T2s) to fill a cache line with four dou-&lt;br /&gt;blewords of data. Access time using a 20 MHz version of the 80486 for the second and subse-&lt;br /&gt;quent doublewords is 50 ns - 28 ns - 5 ns, or 17 ns assuming no delays in the system. To use &lt;br /&gt;burst mode transfers, we need high-speed memory. Because DRAM memory access times at &lt;br /&gt;best are 40 ns, we are forced to use SRAM for burst cycle transfers. The 33 MHz system allows &lt;br /&gt;an access time of 30 ns - 19 ns - 5 ns, or 6 ns for the second and subsequent bytes. If an external &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 T2 T2 T2 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Add&amp;quot;&amp;quot; =f i X X X'--------t-&lt;br /&gt;Data DÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·+Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·cDÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·cDÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·cDÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·-(I &lt;br /&gt;A081\\ Vi' i ! &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-35 A burst cycle reads four doublewords in five clocking periods. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;674 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;counter is used in place of address bits A2 and A3, the 19 ns can be eliminated and the access &lt;br /&gt;time becomes 30 ns - Sns, or 2S ns--enough time for even the slowest SRAM connected to the &lt;br /&gt;system as a cache. This circuit is often called a synchronous burst mode cache if SRAM cache is &lt;br /&gt;used with the system. Note that the BRDY pin acknowledges a burst transfer rather than the &lt;br /&gt;RDY pin that acknowledges a normal memory transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 Memory Management &lt;br /&gt;The 80486 contains the same memory-management system as the 80386. This includes a paging &lt;br /&gt;unit to allow any 4K-byte block of physical memory to be assigned to any 4K-byte block of &lt;br /&gt;linear memory. The descriptor types are exactly the same as for the 80386 microprocessor. In &lt;br /&gt;fact, the only difference between the 80386 memory-management system and the 80486 &lt;br /&gt;memory-management system is paging. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The 80486 paging system can disable caching for sections of translated memory pages, &lt;br /&gt;while the 80386 could not. Figure 16-36 illustrates the page table directory entry and the page &lt;br /&gt;table entry. If these are compared with the 80386 entries, the addition of two new control bits is &lt;br /&gt;observed (PWT and PCD). The page write-through (PWT) and page cache disable (PCD) bits &lt;br /&gt;control caching. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PWT controls how the cache functions for a write operation of the external cache &lt;br /&gt;memory. It does not control writing to the internal cache. The logic level of this bit is found on &lt;br /&gt;the PWT pin of the 80486 microprocessor. Externally, it can be used to dictate the write-though &lt;br /&gt;policy of the external cache. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The PCD bit controls the on-chip cache. If the PCD = 0, the on-chip cache is enabled for &lt;br /&gt;the current page of memory. Note that 80386 page table entries place a logic 0 in the PCD bit po-&lt;br /&gt;sition, enabling caching. If PCD = 1, the on-chip cache is disabled. Caching is disabled regard-&lt;br /&gt;less of the condition of KEN, CD, and NW. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cache Test Registers &lt;br /&gt;Although not instructions, the cache test registers are placed in this section to illustrate the use of &lt;br /&gt;the cache test registers and some software for the 80486 microprocessor. The 80486 cache test &lt;br /&gt;registers are TR3 (cache data register), TR4 (cache status test register), and TR5 (cache control &lt;br /&gt;test register), which are undefined for the 80386 microprocessor. These three registers are illus-&lt;br /&gt;trated in Figure 16-37. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The cache data register (TR3) is used to access either the cache fill buffer for a write test &lt;br /&gt;operation or the cache read buffer for a cache read test operation. This register is a window into &lt;br /&gt;the 8K-byte cache memory located within the 80486 and is used for testing the cache. In order to &lt;br /&gt;fill or read a cache line (128-bits wide), TR3 must be written or read four times. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The contents of the set select field in TRS determine which internal cache line is written or &lt;br /&gt;read through TR3. The 7-bit test field selects one of the 128 different 16-byte wide cache lines. &lt;br /&gt;The entry select bits of TRS select an entry in the set or the 32-bit location in the fill/read buffer. &lt;br /&gt;The control bits in TRS enable the fill buffer or read buffer operation (00), perform a cache write &lt;br /&gt;(01), perform a cache read (10), or flush the cache (11). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The cache status register (TR4) holds the cache tag, LRU bits, and a valid bit. This register &lt;br /&gt;is loaded with the tag and valid bit before a cache write operation and contains the tag, valid bit, &lt;br /&gt;LRU bits, and four valid bits on a cache test read. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 16-36 The page &lt;br /&gt;directory or page table entry &lt;br /&gt;for the 80486 microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 &lt;br /&gt;Page Table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or &lt;br /&gt;Page frame &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 11 10 9 8 7 6 5 4 3 2 1 0 &lt;br /&gt;OS P P UR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CW SWP &lt;br /&gt;Bits 00 DA DT &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-8 SUMMARY 675 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;Data ITR3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 11 10 9 8 7 6 543 2 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I Tag I! I LRU I Valid I I Bits Bits &lt;br /&gt;31 11 10 43210 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I Set select I E,nt I coni &lt;br /&gt;FIGURE 16-37 Cache test register of the 80486 microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The cache is tested each time that the microprocessor is reset if the AHOLD pin is high for &lt;br /&gt;two clocks prior to the RESET pin going low. This causes the 80486 to completely test itself &lt;br /&gt;with a built-in self-test or BIST. The BIST uses TR3, TR4, and TRS to completely test the in-&lt;br /&gt;ternal cache. Its outcome is reported in register EAX. If EAX is a zero, the microprocessor, co-&lt;br /&gt;processor, and cache have passed the self-test. The value of EAX can be tested after a reset to &lt;br /&gt;determine if an error is detected. In most cases, we do not directly access the test registers unless &lt;br /&gt;we wish to perform our own tests on the cache or TLB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;â¢ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. The 80386 microprocessor is an enhanced version of the 80286 microprocessor and includes &lt;br /&gt;a memory-management unit that is enhanced to provide memory paging. The 80386 also in-&lt;br /&gt;cludes 32-bit extended registers and a 32-bit address and data bus. A scaled-down version of &lt;br /&gt;the 80386DX with a 16-bit data and 24-bit address bus is available as the 80386SX micro-&lt;br /&gt;processor. The 80386EX is a complete AT-style personal computer on a chip. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The 80386 has a physical memory size of 40 bytes that can be addressed as a virtual &lt;br /&gt;memory with up to 64T bytes. The 80386 memory is 32-bits wide and is addressed as bytes, &lt;br /&gt;words, or doub1ewords. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. When the 80386 is operated in the pipelined mode, it sends the address of the next instruction &lt;br /&gt;or memory data to the memory system prior to completing the execution of the current in-&lt;br /&gt;struction. This allows the memory system to begin fetching the next instruction or data before &lt;br /&gt;the current is completed. This increases access time, thus reducing the speed of the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. A cache memory system allows data that are frequently read to be accessed in less time be-&lt;br /&gt;cause they are stored in high-speed semiconductor memory. If data are written to memory, &lt;br /&gt;they are also written to the cache so that the most current data are always present in the cache. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The I/O structure of the 80386 is almost identical to the 80286, except that I/O can be inhib-&lt;br /&gt;ited when the 80386 is operated in the protected mode through the I/O bit protection map &lt;br /&gt;stored with the TSS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. The register set of the 80386 contains extended versions of the registers introduced on the &lt;br /&gt;80286 microprocessor. These extended registers include EAX, EBX, ECX, EDX, EBP, &lt;br /&gt;ESP, EDI, ESI, ElP, and EFLAOS. In addition to the extended registers, two supplemental &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;676 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;segment registers (FS and GS) are added. Debug registers and control registers handle &lt;br /&gt;system debugging tasks and memory management in the protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. The instruction set of the 80386 is enhanced to include instructions that address the 32-bit &lt;br /&gt;extended register set. The enhancements also include additional addressing modes that &lt;br /&gt;allow any extended register to address memory data. Scaling has been added so that an index &lt;br /&gt;register can be multiplied by I, 2, 4, or 8. New instruction types include bit scan, string &lt;br /&gt;moves with sign- or zero-extension, set byte upon condition, and double-precision shifts. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. Interrupts, in the 80386 microprocessor, have been expanded to include additional prede-&lt;br /&gt;fined interrupts in the interrupt vector table. These additional interrupts are used with the &lt;br /&gt;memory-management system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The 80386 memory manager is similar to the 80286, except the physical addresses generated &lt;br /&gt;by the MMU are 32-bits wide instead of 24-bits. The 80386 MMU is also capable of paging. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The 80386 is operated in the real mode (8086 mode) when it is reset. The real mode allows &lt;br /&gt;the microprocessor to address data in the first 1M byte of memory. In the protected mode, &lt;br /&gt;the 80386 addresses any location in its 4G bytes of physical address space. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. A descriptor is a series of 8 bytes that specify how a code or data segment is used by the &lt;br /&gt;80386. The descriptor is selected by a selector that is stored in one of the segment registers. &lt;br /&gt;Descriptors are used only in the protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. Memory management is accomplished through a series of descriptors stored in descriptor ta-&lt;br /&gt;bles. To facilitate memory management, the 80386 uses three descriptor tables: the global &lt;br /&gt;descriptor table (GDT), the local descriptor table (LDT), and the interrupt descriptor table &lt;br /&gt;(IDT). The GDT and LDT each hold up to 8,192 descriptors, while the IDT holds up to 256 &lt;br /&gt;descriptors. The GDT and LDT describe code and data segments as well as tasks. The IDT &lt;br /&gt;describes the 256 different interrupt levels through interrupt gate descriptors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. The TSS (task state segment) contains infomlation about the current task and also the pre-&lt;br /&gt;vious task. Appended to the end of the TSS is an I/O bit protection map that inhibits selected &lt;br /&gt;I/O port addresses. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The memory paging mechanism allows any 4K-byte physical memory page to be mapped to &lt;br /&gt;any 4K-byte linear memory page. For example, memory location OOAOOOOOH can be as-&lt;br /&gt;signed memory location AOOOOOOOH through the paging mechanism. A page directory and &lt;br /&gt;page tables are used to assign any physical address to any linear address. The paging mech-&lt;br /&gt;anism can be used in the protected mode or the virtual-mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15. The 80486 microprocessor is an improved version of the 80386 microprocessor that con-&lt;br /&gt;tains an 8K-byte cache and an 80387 arithmetic coprocessor; it executes many instructions &lt;br /&gt;in one clocking period. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. The 80486 microprocessor executes a few new instructions that control the internal cache &lt;br /&gt;memory and allow addition (XADD) and comparison (CMPXCHG) with an exchange and a &lt;br /&gt;byte swap (BSW AP) operation. Other than these few additional instructions, the 80486 is &lt;br /&gt;100 percent upward compatible with the 80386 and 80387. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17. A new feature found in the 80486 is the BIST (built-in self-test) that tests the microprocessor, &lt;br /&gt;coprocessor, and cache at reset time. If the 80486 passes the test, EAX contains a zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. Additional test registers are added to the 80486 to allow the cache memory to be tested. &lt;br /&gt;These new test registers are TR3 (cache data), TR4 (cache status), and TR5 (cache control). &lt;br /&gt;Although we seldom use these registers, they are used by BIST each time that a BIST is per-&lt;br /&gt;formed after a reset operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. The 80386 microprocessor addresses ______ bytes of physical memory when oper-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ated in the protected mode. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;16-9 QUESTIONS AND PROBLEMS 677 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The 80386 microprocessor addresses _______ bytes of virtual memory through its &lt;br /&gt;memory-management unit. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. Describe the differences between the 80386DX and the 80386SX. &lt;br /&gt;4. Draw the memory map of the 80386 when operated in the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) protected ,node &lt;br /&gt;(b) real mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. How much current is available on various 80386 output pin connections? Compare these &lt;br /&gt;currents with the currents available at the output pin connection of an 8086 microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. Describe the 80386 memory system and explain the purpose and operation of the bank se-&lt;br /&gt;lection signals. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. Explain the action of a hardware reset on the address bus connections of the 80386. &lt;br /&gt;8. Explain how pipelining lengthens the access time for many memory references in the 80386 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessor-based system. &lt;br /&gt;9. Briefly describe how the cache memory system functions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. I/O ports in the 80386 start at I/O address and extend to I/O address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. What I/O ports communicate data between the 80386 and its companion 80387 coprocessor? &lt;br /&gt;12. Compare and contrast the memory and I/O connections found on the 80386 with those found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;in earlier microprocessors. &lt;br /&gt;13. If the 80386 operates at 20 MHz, what clocking frequency is applied to the CLK2 pin? &lt;br /&gt;14. What is the purpose of the BS 16 pin on the 80386 microprocessor? &lt;br /&gt;15. What two additional segment registers are found in the 80386 programming model that are &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;not present in the 8086? &lt;br /&gt;16. List the extended registers found in the 80386 microprocessor. &lt;br /&gt;17. List each 80386 flag register bit and describe its purpose. &lt;br /&gt;18. Define the purpose of each of the control registers (CRO, CRl, CR2, and CR3) found within &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the 80386. &lt;br /&gt;19. Define the purpose of each 80386 debug register. &lt;br /&gt;20. The debug registers cause which level of interrupt? &lt;br /&gt;21. Describe the operation of the bit scan forward instruction. &lt;br /&gt;22. Describe the operation of the bit scan reverse instruction. &lt;br /&gt;23. Describe the operation of the SHRD instruction. &lt;br /&gt;24. Write an instruction that accesses data in the FS segment at the location indirectly addressed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;by the DI register. The instruction should store the contents ofEAX into this memory location. &lt;br /&gt;25. What is scaled index addressing? &lt;br /&gt;26. Is the following instruction legal? MOV AX,[EBX+ECX] &lt;br /&gt;27. Explain how the following instructions calculate the memory address: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) ADD [EBX+8*ECX],AL &lt;br /&gt;(b) MOV DATA[EAX+EBX],CX &lt;br /&gt;(c) SUB EAX,DATA &lt;br /&gt;(d) MOV ECX,[EBX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28. What is the purpose of interrupt type number 7? &lt;br /&gt;29. Which interrupt vector type number is activated for a protection privilege violation? &lt;br /&gt;30. What is a double interrupt fault? &lt;br /&gt;31. If an interrupt occurs in the protected mode, what defines the interrupt vectors? &lt;br /&gt;32. What is a descriptor? &lt;br /&gt;33. What is a selector? &lt;br /&gt;34. How does the selector choose the local descriptor table? &lt;br /&gt;35. What register is used to address the global descriptor table? &lt;br /&gt;36. How many global descriptors can be stored in the GDT? &lt;br /&gt;37. Explain how the 80386 can address a virtual memory space of 64T bytes when the physical &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory contains only 4G bytes of memory. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;678 CHAPTER 16 THE 80386 AND 80486 MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38. What is the difference between a segment descriptor and a system descriptor? &lt;br /&gt;39. What is the task state segment (TSS)? &lt;br /&gt;40. How is the TSS addressed? &lt;br /&gt;41. Describe how the 80386 switches from the real mode to the protected mode. &lt;br /&gt;42. Describe how the 80386 switches from the protected mode to the real mode. &lt;br /&gt;43. What is virtual 8086 mode operation of the 80386 microprocessor? &lt;br /&gt;44. How is the paging directory located by the 80386? &lt;br /&gt;45. How many bytes are found in a page of memory? &lt;br /&gt;46. Explain how linear memory address DOOOOOOOH can be assigned to physical memory ad-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;dress COOOOOOOH with the paging unit of the 80386. &lt;br /&gt;47. What are the differences between an 80386 and 80486 microprocessor? &lt;br /&gt;48. What is the purpose of the FLUSH input pin on the 80486 microprocessor? &lt;br /&gt;49. Compare the register set of the 80386 with the 80486 microprocessor. &lt;br /&gt;50. What differences exist in the flags of the 80486 when compared to the 80386 micro-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;processor? &lt;br /&gt;51. What pins are used for parity checking on the 80486 microprocessor? &lt;br /&gt;52. The 80486 microprocessor uses parity. &lt;br /&gt;53. The cache inside the 80486 microprocessor is ______ K bytes. &lt;br /&gt;54. A cache line is filled by reading bytes from the memory system. &lt;br /&gt;55. What is ~ 80486 burst? &lt;br /&gt;56. Define the term cache write-through. &lt;br /&gt;57. What is a BIST? &lt;br /&gt;58. Can 80486 caching be disabled by software? Explain your answer. &lt;br /&gt;59. Explain how the XADD EBX,EDX instruction operates. &lt;br /&gt;60. The CMPXCHG CL,AL instruction compares CL with AL. What else occurs when this in-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;struction executes? &lt;br /&gt;61. Compare the INVD instruction with the WBINVD instruction. &lt;br /&gt;62. What is the purpose of the PCD bit in the page table directory or page table entry? &lt;br /&gt;63. Does the PWT bit in the page table directory or page table entry affect the on-chip cache? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CHAPTER 17 &lt;br /&gt;The Pentium and Pentium Pro &lt;br /&gt;Microprocessors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium microprocessor signals an improvement to the architecture found in the 80486 mi-&lt;br /&gt;croprocessor. The changes include an improved cache structure, a wider data bus width, a faster &lt;br /&gt;numeric coprocessor, a dual integer processor, and branch prediction logic. The cache has been &lt;br /&gt;reorganized to form two caches that are each 8K bytes in size, one for caching data, the other &lt;br /&gt;for instructions. The data bus width has been increased from 32-bits to 64-bits. The numeric co-&lt;br /&gt;processor operates about five times faster than the 80486 numeric coprocessor. The dual integer &lt;br /&gt;processor often allows two instructions per clock. Finally, the branch prediction logic allows &lt;br /&gt;programs that branch to execute more efficiently. Notice that these changes are internal to the &lt;br /&gt;Pentium, which makes software upward compatible from earlier Intel 80X86 microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium Pro is a still faster version of the Pentium and contains a modified internal &lt;br /&gt;architecture that can schedule up to five instructions for execution and even faster floating-&lt;br /&gt;point unit. The Pentium Pro also contains a 2S6K-byte or 5 12K-byte level two cache in addi-&lt;br /&gt;tional to the 16K-byte (8K for data and 8K for instruction) level one cache. Also added are four &lt;br /&gt;additional address lines, giving the Pentium Pro access to an astounding 64G bytes of directly &lt;br /&gt;addressable memory space. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER OBJECTIVES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Upon completion of this chapter, you will be able to: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1. Contrast the Pentium and Pentium Pro with the 80386 and 80486 microprocessors. &lt;br /&gt;2. Describe the organization and interface of the 64-bit wide Pentium memory system and its &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;variations. &lt;br /&gt;3. Contrast the changes in the memory-management unit and paging unit when compared to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the 80386 and 80486 microprocessors. &lt;br /&gt;4. Detail the new instructions found with the Pentium microprocessor. &lt;br /&gt;5. Explain how the superscaler dual integers units improve performance of the Pentium &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessor. &lt;br /&gt;6. Describe the operation of the branch prediction logic. &lt;br /&gt;7. Detail the improvements in the Pentium Pro when compared with the Pentium. &lt;br /&gt;8. Explain how the dynamic execution architecture of the Pentium Pro functions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;679 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;680 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION TO THE PENTIUM MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before the Pentium or any other microprocessor can be used in a system, the function of each pin &lt;br /&gt;must be understood. This section of the chapter details the operation of each pin, along with the &lt;br /&gt;external memory system and I/O structures of the Pentium microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 17-1 illustrates the pin-out of the Pentium microprocessor, which is packaged in a &lt;br /&gt;huge 237-pin PGA (pin grid array). Currently, the Pentium is available in two versions: the full-&lt;br /&gt;blown Pentium and the P24T version called the Pentium OverDrive. The P24T version contains &lt;br /&gt;a 32-bit data bus compatible for insertion into 80486 machines that contain the P24T socket. The &lt;br /&gt;P24T version also comes with a fan built into the unit. The most notable difference in the pin-out &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-1 The pin-out &lt;br /&gt;of the Pentium microprocessor A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A4 &lt;br /&gt;A5 &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;A10 &lt;br /&gt;A11 &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;A16 &lt;br /&gt;A17 &lt;br /&gt;A18 &lt;br /&gt;A19 &lt;br /&gt;A20 &lt;br /&gt;A21 &lt;br /&gt;A22 &lt;br /&gt;A23 &lt;br /&gt;A24 &lt;br /&gt;A25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 A26 &lt;br /&gt;A27 &lt;br /&gt;A28 &lt;br /&gt;A29 &lt;br /&gt;A30 &lt;br /&gt;A31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSCHK &lt;br /&gt;CACHE &lt;br /&gt;CLK &lt;br /&gt;D/C &lt;br /&gt;EADS &lt;br /&gt;EWBE &lt;br /&gt;FERR &lt;br /&gt;FLUSH &lt;br /&gt;FRCMC &lt;br /&gt;HIT &lt;br /&gt;HITM &lt;br /&gt;16T &lt;br /&gt;HLDA &lt;br /&gt;HOLD &lt;br /&gt;INTR &lt;br /&gt;NMI &lt;br /&gt;LOCK &lt;br /&gt;IERR &lt;br /&gt;IGNNE &lt;br /&gt;INIT &lt;br /&gt;RESET &lt;br /&gt;INV &lt;br /&gt;IU &lt;br /&gt;IV &lt;br /&gt;PMO/BPO &lt;br /&gt;PM1/6P1 &lt;br /&gt;PWT &lt;br /&gt;TCK &lt;br /&gt;TDI &lt;br /&gt;TDO &lt;br /&gt;TMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium &lt;br /&gt;DO &lt;br /&gt;D1 &lt;br /&gt;D2 &lt;br /&gt;D3 &lt;br /&gt;04 &lt;br /&gt;D5 &lt;br /&gt;D6 &lt;br /&gt;D7 &lt;br /&gt;D8 &lt;br /&gt;D9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D10 &lt;br /&gt;D11 &lt;br /&gt;D12 &lt;br /&gt;D13 &lt;br /&gt;D14 &lt;br /&gt;D15 &lt;br /&gt;D16 &lt;br /&gt;D17 &lt;br /&gt;D18 &lt;br /&gt;D19 &lt;br /&gt;D20 &lt;br /&gt;D21 &lt;br /&gt;D22 &lt;br /&gt;D23 &lt;br /&gt;024 &lt;br /&gt;D25 &lt;br /&gt;026 &lt;br /&gt;D27 &lt;br /&gt;D28 &lt;br /&gt;D29 &lt;br /&gt;D30 &lt;br /&gt;D31 &lt;br /&gt;D32 &lt;br /&gt;D33 &lt;br /&gt;D34 &lt;br /&gt;D35 &lt;br /&gt;D36 &lt;br /&gt;D37 &lt;br /&gt;D38 &lt;br /&gt;D39 &lt;br /&gt;D40 &lt;br /&gt;D41 &lt;br /&gt;D42 &lt;br /&gt;D43 &lt;br /&gt;D44 &lt;br /&gt;D45 &lt;br /&gt;D46 &lt;br /&gt;D47 &lt;br /&gt;D48 &lt;br /&gt;049 &lt;br /&gt;D50 &lt;br /&gt;D51 &lt;br /&gt;D52 &lt;br /&gt;D53 &lt;br /&gt;D54 &lt;br /&gt;D55 &lt;br /&gt;D56 &lt;br /&gt;D57 &lt;br /&gt;D58 &lt;br /&gt;D59 &lt;br /&gt;D60 &lt;br /&gt;D61 &lt;br /&gt;D62 &lt;br /&gt;D63 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCHK &lt;br /&gt;DPO &lt;br /&gt;DP1 &lt;br /&gt;DP2 &lt;br /&gt;DP3 &lt;br /&gt;DP4 &lt;br /&gt;DP5 &lt;br /&gt;DP6 &lt;br /&gt;DP7 &lt;br /&gt;W/R &lt;br /&gt;MilO &lt;br /&gt;KEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NA &lt;br /&gt;PCD &lt;br /&gt;PEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRDY &lt;br /&gt;RlS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCYC &lt;br /&gt;SMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SMIACT &lt;br /&gt;TRST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WB/WT &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-1 INTRODUCTION TO THE PENTIUM MICROPROCESSOR 681 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;of the Pentium when compared to earlier 80486 microprocessors is that there are 64 data bus &lt;br /&gt;connections instead of 32, which requires a larger physical footprint. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with earlier versions of the Intel family of microprocessors, the early versions of the &lt;br /&gt;Pentium require a single +S.OV power supply for operation. The power supply cunent averages &lt;br /&gt;3.3 A for the 66 MHz version of the Pentium, and 2S 1 A for the 60 MHz version. Because these &lt;br /&gt;cunents are significant, so are the power dissipations of these microprocessors: 13 W for the &lt;br /&gt;66 MHz version and 11.9 W for the 60 MHz version. The current versions of the Pentium, 90 MHz &lt;br /&gt;and above, use a 3.3V power supply with reduced current consumption. At present., a good heat &lt;br /&gt;sink with considerable airflow is required to keep the Pentium cool. The Pentium contains mul-&lt;br /&gt;tiple Vee and V ss connections that must all be connected to +S.OV or +3.3V and grounded for &lt;br /&gt;proper operation. Some of the pins are labeled N/C (no connection) and must not be connected. &lt;br /&gt;The latest versions of the Pentium have been improved to reduce the power dissipation. For &lt;br /&gt;example, the 133 MHz Pentium requires 3.4 A or cunent, which is only slightly more than the &lt;br /&gt;3.3 A required by the early 66 MHz version. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each Pentium output pin is capable of providing 4.0 mA of cunent at a logic 0 level and &lt;br /&gt;2.0 mA at a logic I level. This represents an increase in drive current compared to the 2.0 mA &lt;br /&gt;available on earlier 8086, 8088, and 80286 output pins. Each input pin represents a small load re-&lt;br /&gt;quiring only 15 !J.A of current. In some systems, except the smallest, these current levels require &lt;br /&gt;bus buffers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The function of each Pentium group of pins follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A31-A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AHOLD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;APCHK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BP[3:2] and &lt;br /&gt;PM/BP[1:0] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address A20 mask is an input that is asserted in the real mode to signal &lt;br /&gt;the Pentium to perform address wraparound, as in the 8086 microprocessor, &lt;br /&gt;for use of the HIMEN.SYS driver. &lt;br /&gt;Address bus connections address any of the SI2K x 64 memory locations &lt;br /&gt;found in the Pentium memory system. Note that AO, AI, and A2 are encoded &lt;br /&gt;in the bus enable (BE7-BEO) to select any or all of the eight bytes in a 64-&lt;br /&gt;bit wide memory location. &lt;br /&gt;The address data strobe becomes active whenever the Pentium has issued &lt;br /&gt;a valid memory or I/O address. This signal is combined with the W if{ and &lt;br /&gt;MilO signal to generate the separate read and write signals present in the &lt;br /&gt;earlier 8086-80286 microprocessor-based systems. &lt;br /&gt;Address hold is an input that causes the Pentium to hold the address and AP &lt;br /&gt;signals for the next clock. &lt;br /&gt;Address parity provides even parity for the memory address on all &lt;br /&gt;Pentium-initiated memory and I/O transfers. The AP pin must also be driven &lt;br /&gt;with even parity information on all inquire cycles in the same clocking &lt;br /&gt;period as the EADS signal. &lt;br /&gt;Address parity check becomes a logic 0 whenever the Pentium detects an &lt;br /&gt;address parity error. &lt;br /&gt;Bank enable signals select the access of a byte, word, doubleword, or quad-&lt;br /&gt;word of data. These signals are generated internally by the microprocessor &lt;br /&gt;from address bits AO, AI, and A2. &lt;br /&gt;The back-off input aborts all outstanding bus cycles and floats the Pentium &lt;br /&gt;buses until BOFF is negated. After BOFF is negated, the Pentium restarts all &lt;br /&gt;aborted bus cycles in their entirety. &lt;br /&gt;The breakpoint pins BP3-BPO indicate a breakpoint match when the &lt;br /&gt;debug registers are programmed to monitor for matches. The performance &lt;br /&gt;monitoring pins PM 1 and PMO indicate the settings of the performance &lt;br /&gt;monitoring bits in the debug mode control register. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;682 CHAPHR 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BREQ &lt;br /&gt;BT3-BTO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BUSCHK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CACHE &lt;br /&gt;eLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D63-DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D/e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DP7-DPO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLUSCH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRCMC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HOLD &lt;br /&gt;HLDA &lt;br /&gt;IBT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IGNNE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The burst ready input signals the Pentium that the external system has &lt;br /&gt;applied or extracted data from the data bus connections. This signal is used &lt;br /&gt;to insert wait states into the Pentium timing. &lt;br /&gt;The bus request output indicates that the Pentium has generated a bus request. &lt;br /&gt;The branch trace outputs provide bits 2-0 of the branch target linear &lt;br /&gt;address and the default operand size on BT3. These outputs become valid &lt;br /&gt;during a branch trace special message cycle. &lt;br /&gt;The bus check input allows the system to signal the Pentium that the bus &lt;br /&gt;transfer has been unsuccessful. &lt;br /&gt;The cache output indicates that the current Pentium cycle can cache data. &lt;br /&gt;The clock is driven by a clock signal that is at the operating frequency of the &lt;br /&gt;Pentium. For example, to operate the Pentium at 66 MHz, we apply a 66 &lt;br /&gt;MHz clock to this pin. &lt;br /&gt;Data bus connections transfer byte, word, doubleword, and quad word data &lt;br /&gt;between the microprocessor and its memory and I/O system. &lt;br /&gt;Data/control indicates that the data bus contains data for or from memory &lt;br /&gt;or I/O when a logic 1. If D/e is a logic 0, the microprocessor is either halted &lt;br /&gt;or is executing an interrupt acknowledge. &lt;br /&gt;Data parity is generated by the Pentium and detects its eight memory banks &lt;br /&gt;through these connections. &lt;br /&gt;The external address strobe input signals that the address bus contains an &lt;br /&gt;address for an inquire cycle. &lt;br /&gt;The external write buffer empty input indicates that a write cycle is pending &lt;br /&gt;in the external system. &lt;br /&gt;A floating-point error is comparable to the ERROR line in the 80386 and &lt;br /&gt;shows that the internal coprocessor has erred. &lt;br /&gt;The flush cache input causes the cache to flush all write-back lines and &lt;br /&gt;invalidate its internal caches. If the FLUSH input is a logic 0 during a reset &lt;br /&gt;operation, the Pentium enters its test mode. &lt;br /&gt;The functional redundancy check is sampled during a reset to configure &lt;br /&gt;the Pentium in the master (1) or checker mode (0). &lt;br /&gt;Hit shows that the internal cache contains valid data in the inquire mode. &lt;br /&gt;Hit modified shows that the inquire cycle has found a modified cache line. &lt;br /&gt;This output is used to inhibit other master units from accessing data until the &lt;br /&gt;cache line is written to memory. &lt;br /&gt;Hold requests a DMA action. &lt;br /&gt;Hold acknowledge indicates that the Pentium is currently in a hold condition. &lt;br /&gt;Instruction branch taken indicates that the Pentium has taken an instruc-&lt;br /&gt;tion branch. &lt;br /&gt;The internal error output shows that the Pentium has detected an internal &lt;br /&gt;parity error or functional redundancy error. &lt;br /&gt;The ignore nurr.tric error input causes the Pentium to ignore a numeric &lt;br /&gt;coprocessor enÂ·or. &lt;br /&gt;The initialization input performs a reset without initializing the caches, &lt;br /&gt;write-back buffers, and floating-point registers. This may not be used to &lt;br /&gt;reset the microprocessor in lieu of RESET after power-up. &lt;br /&gt;The interrupt request is used by external circuitry to request an interrupt. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-1 INTRODUCTION TO THE PENTIUM MICROPROCESSOR 683 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INV &lt;br /&gt;IV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M/IO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PWT &lt;br /&gt;R/S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The invalidation input detelmines the cache line state after an inquiry. &lt;br /&gt;The V-pipe instruction complete output shows that thc instruction in the &lt;br /&gt;V-pipe is complete. &lt;br /&gt;The V -pipe instruction complete output shows that the instruction in the &lt;br /&gt;V -pipe is complete. &lt;br /&gt;The cache enable input enables internal caching. &lt;br /&gt;LOCK becomes a logic 0 whenever an instruction is prefixed with the &lt;br /&gt;LOCK: prefix. This is most often used during DMA accesses. &lt;br /&gt;Memory/IO selects a memory device when a logic I or an I/O device when &lt;br /&gt;a logic O. During the I/O operation, the address bus contains a 16-bit I/O &lt;br /&gt;address on address connections AI5-A3. &lt;br /&gt;Next address indicates that the external memory system is ready to accept &lt;br /&gt;a new bus cycle. &lt;br /&gt;Non-maskable interrupt requests a non-maskable interrupt, just as on the &lt;br /&gt;earlier versions of the microprocessor. &lt;br /&gt;The page cache disable output shows that the internal page caching is &lt;br /&gt;disabled by reflecting the state of the CR3 PCD bit. &lt;br /&gt;The parity check output signals a parity check error for data read from &lt;br /&gt;memory or I/O. &lt;br /&gt;The parity enable input enables the machine check interrupt or exception. &lt;br /&gt;The probe ready output indicates that the probe mode has been entered for &lt;br /&gt;debugging. &lt;br /&gt;The page write-through output shows the state of the PWT bit in CR3. &lt;br /&gt;This pin is provided for use with the Intel Debugging Port and causes an &lt;br /&gt;interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET Reset initializes the Pentium, causing it to begin executing software at &lt;br /&gt;memory location FFFFFFFOH. The Pentium is reset to the real mode and the &lt;br /&gt;leftmost 12 address connections remain logic l's (FFFH) until a far jump or &lt;br /&gt;far call is executed. This allows compatibility with earlier microprocessors. &lt;br /&gt;Refer to Table 17-1 for the state of the Pentium after a hardware reset. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-1 State of the Pentium after a RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EAX &lt;br /&gt;EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESX, ECX, ESP, ESP, ESI, and EDI &lt;br /&gt;EFLAGS &lt;br /&gt;EIP &lt;br /&gt;CS &lt;br /&gt;OS, ES, FS, GS, and SS &lt;br /&gt;GDTR and TSS &lt;br /&gt;CRO &lt;br /&gt;CR2, CR3, and CR4 &lt;br /&gt;DRO-DR3 &lt;br /&gt;DR6 &lt;br /&gt;DR? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET Value &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;0500XXXXH &lt;br /&gt;o &lt;br /&gt;2 &lt;br /&gt;OOOOFFFOH &lt;br /&gt;FOOOH &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;60000010H &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;FFFFOFFOH &lt;br /&gt;00000400H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: BIST = built-in self-test; XXXX = Pentium version number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET + BIST Value &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o (if test passes) &lt;br /&gt;0500XXXXH &lt;br /&gt;o &lt;br /&gt;2 &lt;br /&gt;OOOOFFFOH &lt;br /&gt;FOOOH &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;60000010H &lt;br /&gt;o &lt;br /&gt;o &lt;br /&gt;FFFFOFFOH &lt;br /&gt;00000040H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;684 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCYC &lt;br /&gt;SMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SMIACT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TDO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WB/WT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The split cycle output signals a misaligned LOCKed bus cycle. &lt;br /&gt;The system management interrupt input causes the Pentium to enter the &lt;br /&gt;system management mode of operation. &lt;br /&gt;The system management interrupt active output shows that the Pentium is &lt;br /&gt;operating in the system management mode. &lt;br /&gt;The testability clock input selects the clocking function in accordance to the &lt;br /&gt;IEEE 1149.1 Boundary Scan interface. &lt;br /&gt;The test data input is used to test data clocked into the Pentium with the &lt;br /&gt;TCK signal. &lt;br /&gt;The test data output is used to gather test data and instructions shifted out of &lt;br /&gt;the Pentium with TCK. &lt;br /&gt;The test mode select input controls the operation of the Pentium in test &lt;br /&gt;mode. &lt;br /&gt;The test reset input allows the test mode to be reset. &lt;br /&gt;Write/read indicates that the current bus cycle is a write when a logic lora &lt;br /&gt;read when a logic O. &lt;br /&gt;Write-back/write-through selects the operation for the Pentium data cache. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Memory System &lt;br /&gt;The memory system for the Pentium microprocessor is 40 bytes in size, just as in the 80386DX &lt;br /&gt;and 80486 microprocessors. The difference lies in the width of the memory data bus. The Pen-&lt;br /&gt;tium uses a 64-bit data bus to address memory organized in eight banks that each contain S12M &lt;br /&gt;bytes of data. Refer to Figure 17-2 for the organization of the Pentium physical memory &lt;br /&gt;system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium memory system is divided into eight banks that each store a byte of data with &lt;br /&gt;a parity bit. Like the 80486, the Pentium employs internal parity generation and checking logic &lt;br /&gt;for the memory system data bus information. (Note that most Pentium systems do not use parity &lt;br /&gt;checks.) The 64-bit wide memory is important to double-precision floating-point data. Recall &lt;br /&gt;that a double-precision floating-point number is 64-bits wide. As with earlier Intel microproces-&lt;br /&gt;sors, the memory system is numbered in bytes from byte OOOOOOOOH to byte FFFFFFFFH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory selection is accomplished with the bank enable signals (BE7-BEO). These sepa-&lt;br /&gt;rate memory banks allow the Pentium to access any single byte, word, doubleword, or quad word &lt;br /&gt;with one memory transfer cycle. As with earlier memory selection logic, we often generate eight &lt;br /&gt;separate write strobes for writing to the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A new feature added to the Pentium is its ability to check and generate parity for the ad-&lt;br /&gt;dress bus (A3 I -AS) during certain operations. The AP pin provides the system with parity in-&lt;br /&gt;formation, and the APCHK indicates a bad parity check for the address bus. The Pentium takes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank 7 Bank 6 Bank 5 Bank 4 Bank 3 Bank2 Bank 1 Bank a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-2 The 8-byte wide memory banks of the Pentium microprocessor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-1 INTRODUCTION TO THE PENTIUM MICROPROCESSOR 685 &lt;br /&gt;PentlumD63-D32 ______________________ ....., &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PentIum D3t-D0 __________ -, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;....-------11--------..----- Memory D3t-DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BEO-1=::::~~~~ &lt;br /&gt;74F245 &lt;br /&gt;BE4-t=::::~~G~~J DIR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F245 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W/R----..... -----------...J &lt;br /&gt;FIGURE 17-3 A circuit that generates a 32-bit memory data bus from the 64-bit Pentium data bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;no action when an address parity error is detected. The error must be assessed by the system and &lt;br /&gt;the system must take appropriate action (an interrupt) if so desired. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;How is a 32-bit memory system connected to the Pentium? The Pentium can function with &lt;br /&gt;a 32-bit wide memory system by using a mUltiplexer to convert the 64-bit data bus to a 32-bit data &lt;br /&gt;bus. Figure 17-3 shows a set ofbi-directional multiplexers (bi-directional buffers are used as mul-&lt;br /&gt;tiplexers) used to convert the Pentium's 64-bit data bus into a 32-bit data bus. Care must be taken &lt;br /&gt;when using this arrangement because software could access a doubleword that crosses the &lt;br /&gt;boundary between the lower and upper halves of the data bus. All doublewords must be stored at &lt;br /&gt;doubleword boundaries. Note that a doubleword boundary is an address that is divisible by 4. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Input/Output System &lt;br /&gt;The input/output system of the Pentium is completely compatible with earlier Intel microproces-&lt;br /&gt;sors. The 110 port number appears on address lines A1S-A3, with the bank enable signals used &lt;br /&gt;to select the actual memory banks used for the 110 transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Beginning with the 80386 microprocessor, 110 privilege information is added to the TSS &lt;br /&gt;segment when the Pentium is operated in the protected mode. Recall that this allows 110 ports to &lt;br /&gt;be selectively inhibited. If the blocked 110 location is accessed, the Pentium generates a type 13 &lt;br /&gt;interrupt to signal an 110 privilege violation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;686 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;elK ~ I &lt;br /&gt;ADDR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W/R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System Timing &lt;br /&gt;As with any microprocessor, the system timing signals must be understood in order to interface &lt;br /&gt;the microprocessor. This portion of the text details the operation of the Pentium through its &lt;br /&gt;timing diagrams and also shows how to determine memory access times. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The basic Pentium, non-pipelined memory cycle consists of two clocking periods: TI and &lt;br /&gt;T2. Refer to Figure 17-4 for the basic non-pipelined read cycle. Notice from the timing diagram &lt;br /&gt;that the 66 MHz Pentium is capable of 33 million memory transfers per second. This assumes &lt;br /&gt;that the memory can operate at that speed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Also notice form the timing diagram that the W!R signal becomes valid if ADS is a logic 0 &lt;br /&gt;at the positive edge of the clock (end of TI). This clock must be used to qualify the cycle as a &lt;br /&gt;read or a write. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;During TI, the microprocessor issues the ADS, wiR, address, and M/IO signals. In order &lt;br /&gt;to qualify the W iR signal and generate appropriate MRDC and MWTC signals, we use a flip-&lt;br /&gt;flop to generate the wiR signal. Then we use a 2-line-to-l-line multiplexer to generate the &lt;br /&gt;memory and I/O control signals. Refer to Figure 17-5 for a circuit that generates the memory &lt;br /&gt;and I/O control signals for the Pentium microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;During T2, the data bus is sampled in synchronization with the end of T2 at the positive &lt;br /&gt;transition of the clock pulse. The setup time before the clock is given as 3.8 ns, and the hold time &lt;br /&gt;after the clock is given as 2.0 ns. This means that the data window around the clock is 5.8 ns. The &lt;br /&gt;address appears on the 8.0 ns maximum after the start of Tl. This means that the Pentium mi-&lt;br /&gt;croprocessor operating at 66 MHz allows 30.3 ns (two clocking periods) minus the address delay &lt;br /&gt;time of 8.0 ns and also minus the data setup time of 3.8 ns. Memory access time without any wait &lt;br /&gt;states is 30.3 - 8.0 - 3.8, or 18.5 ns. This is enough time to allow access to a SRAM, but not to &lt;br /&gt;any DRAM without inserting wait states into the timing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Wait states are inserted into the timing by controlling the BRDY input to the Pentium. &lt;br /&gt;The BRDY signal must become a logic 0 by the end of T2; otherwise additional T2 states are &lt;br /&gt;inserted into the timing. Refer to Figure 17-6 for a read cycle timing diagram that contains wait &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 T2 T1 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ /: \\ ). \\ ). I I \\/ &lt;br /&gt;X X &lt;br /&gt;\\ / \\ &lt;br /&gt;\\ !\\ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CD &lt;br /&gt;\\ :/ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I \\ &lt;br /&gt;FIGURE 17-4 The non-pipelined read cycle for the Pentium microprocessor &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;CLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-1 INTRODUCTION TO THE PENTIUM MICROPROCESSOR 687 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 Q 5 &lt;br /&gt;3 BHOY ---------&amp;quot;-1&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21A 1Y 4 MWTC &lt;br /&gt;1B 7 MROC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6 2A 2Y 1 2B 3Y IOWC 3A &lt;br /&gt;3B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;r'oRC 71~&amp;quot; 74F257 ___ ~HL~O~A~========================::~~ __ ~ M/iO &lt;br /&gt;FIGURE 17-5 A circuit that generates the memory and I/O control signals &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;states for slower memory. The effect of inserting wait states into the timing is to lengthen the &lt;br /&gt;timing, allowing additional time to the memory to access data. In the timing shown, the access &lt;br /&gt;time has been lengthened so standard 60 ns DRAM can be used in a system. Note that this re-&lt;br /&gt;quires the insertion of four wait states of 15.2 ns (one clocking period) each to lengthen the access &lt;br /&gt;time to 79.5 ns. This is enough time for the DRAM and any decoder in the system to function. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The BRDY signal is a synchronous signal generated using the system clock. Figure 17-7 &lt;br /&gt;illustrates a circuit that can be used to generate BRDY for inserting any number of wait states &lt;br /&gt;into the Pentium timing diagram. You may recall a similar circuit inserting wait states into the &lt;br /&gt;timing diagram of the 80386 microprocessor. The ADS signal is delayed between 0 and 7 &lt;br /&gt;clocking periods by the 74FI61 shift register to generate the BRDY signal. The exact number of &lt;br /&gt;wait states are selected by the 74FI51 8-line-to-l-Iine multiplexer. In this example. the multi-&lt;br /&gt;plexer selects the 4-wait output from the shift register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A more efficient method of reading memory data is via the burst cycle. The burst cycle in &lt;br /&gt;the Pentium transfers four 64-bit numbers per burst cycle in five clocking periods. A burst, &lt;br /&gt;without wait states. requires that the memory system transfers data every 15.2 ns. If a level 2 &lt;br /&gt;cache is in place, this speed is no problem, as long as the data are read from the cache. If the &lt;br /&gt;cache does not contain the data, then wait states must be inserted. which will reduce the data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AOOR ~~----~~---------r----------~--------~~----------~-------------r--&lt;br /&gt;W/R &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ / &lt;br /&gt;I ~------~--~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~---~--------------------------~-------&lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~~~---~~--~---~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ r &lt;br /&gt;FIGURE 17-6 The Pentium timing diagram with four wait states inserted for an access time of 79.5 ns &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;688 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;elK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;W/Po &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Vee &lt;br /&gt;fjl &lt;br /&gt;:&amp;gt; 10K &amp;gt; OW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;H-A QA 4 DO W~ B QB D1 5 QC D2 Y ADS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ClK &lt;br /&gt;QD 1 D3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 QE 1 D4 ClK QF 1 D5 &lt;br /&gt;~ ClR QG D6 QH D7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F164 7W ~ A B &lt;br /&gt;~ C G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74F151 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-7 A circuit that generates wait states by delaying ADS. This circuit is wired to &lt;br /&gt;generate four wait states. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;throughout. Refer to Figure 17-8 for the Pentium burst cycle transfer without wait states. As be-&lt;br /&gt;fore, wait states can be inserted to allow more time to the memory system for accesses. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Branch Prediction Logic &lt;br /&gt;The Pentium microprocessor uses a branch prediction logic to reduce the time required for a &lt;br /&gt;branch caused by internal delays. These delays are minimized because when a branch instruction &lt;br /&gt;(short or near only) is encountered, the microprocessor begins pre-fetch instructions at the &lt;br /&gt;branch address. The instructions are loaded into the instruction cache, so when the branch oc-&lt;br /&gt;curs, the instructions are present and allow the branch to execute in one clocking period. If for &lt;br /&gt;any reason the branch prediction logic errs, the branch requires an extra three clocking periods to &lt;br /&gt;execute. In most cases, the branch prediction is correct and no delay ensues. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cache Structure &lt;br /&gt;The cache in the Pentium has been changed from the one found in the 80486 microprocessor. &lt;br /&gt;The Pentium contains two 8K cache memories instead of one as in the 80486. There is an 8K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;=:x X &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---:\\ / \\ &lt;br /&gt;I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--:\\ I &lt;br /&gt;CJ CJ CJ CJ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;\\ I &lt;br /&gt;FIGURE 17-8 The Pentium burst cycle operation that transfers four 64-bit data between the microprocessor and &lt;br /&gt;memory &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-2 SPECIAL PENTIUM REGISTERS 689 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data cache and an 8K instruction cache. The instruction cache stores only instructions, while the &lt;br /&gt;data cache stores data used by instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 80486, a program that was data intensive quickly filled the cache, allowing little &lt;br /&gt;room for instructions. This slowed the execution speed of the 80486 microprocessor. In the Pen-&lt;br /&gt;ti urn, this cannot occur because of the separate instruction cache. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Superscaler Architecture &lt;br /&gt;The Pentium microprocessor is organized with three execution units. One executes floating-&lt;br /&gt;point instructions, and the other two (V-pipe and V -pipe) execute integer instructions. This &lt;br /&gt;means that it is possible to execute three instructions simultaneously. For example, the FADD &lt;br /&gt;ST,ST(2) instruction, MOV EAX,lOH instruction, and MOV EBX,12H instruction can all exe-&lt;br /&gt;cute simultaneously because none of these instructions depend on one another. The FADD &lt;br /&gt;ST,ST(2) instruction is executed by the coprocessor, the MOV EAX, IOH instruction is executed &lt;br /&gt;by the V-pipe, and the MOV EBX,12H instruction is executed by the V-pipe. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Software should be written to take advantage of this feature by looking at the instructions &lt;br /&gt;in a program, and modifying them when cases are discovered where dependent instructions can &lt;br /&gt;be separated by non-dependent instructions. These changes can result in up to a 40 percent exe-&lt;br /&gt;cution speed improvement in some software. Make sure that any new compiler or other applica-&lt;br /&gt;tion package takes advantage of this new superscaler feature of the Pentium. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SPECIAL PENTIUM REGISTERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium is essentially the same microprocessor as the 80386 and 80486, except that some &lt;br /&gt;additional features and changes to the control register set have occurred. This section highlights &lt;br /&gt;the differences between the 80386 control register structure and the flag register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control Registers &lt;br /&gt;Figure 17-9 shows the control register structure for the Pentium microprocessor. Notice that a &lt;br /&gt;new control register, CR4, has been added to the control register array. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the text explains only the new Pentium components in the control registers. &lt;br /&gt;Refer to Figure 16-13 on page 637 for a description and illustration of the 80386 control regis-&lt;br /&gt;ters. Following is a description of the new control bits and the new control register CR4: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VME &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cache disable controls the internal cache. If CD = 1, the cache will not fill with &lt;br /&gt;new data for cache misses, but it will continue to function for cache hits. If CD = 0, &lt;br /&gt;misses will cause the cache to fill with new data. &lt;br /&gt;Not write-through selects the mode of operation for the data cache. If NW = 1, the &lt;br /&gt;data cache is inhibited from cache write-through. &lt;br /&gt;Alignment mask enables alignment checking when set. Note that alignment check-&lt;br /&gt;ing occurs only for protected mode operation when the user is at privilege level 3. &lt;br /&gt;Write protect protects user level pages against supervisor level write operations. &lt;br /&gt;When WP = 1, the supervisor can write to user level segments. &lt;br /&gt;Numeric error enables standard numeric coprocessor error detection. If NE = I, &lt;br /&gt;the FERR pin becomes active for a numeric coprocessor error. If NE = 0, any &lt;br /&gt;coprocessor error is ignored. &lt;br /&gt;Virtual mode extension enables support for the virtual interrupt flag in protected &lt;br /&gt;mode. If VME = 0, virtual interrupt support is disabled. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;690 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-9 The structure &lt;br /&gt;of the Pentium control &lt;br /&gt;registers CR4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page directory base CR3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Page fault linear address CR2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reserved CR1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PVI Protected mode virtual interrupt enables support for the virtual interrupt flag in &lt;br /&gt;protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TSD &lt;br /&gt;DE &lt;br /&gt;PSE &lt;br /&gt;MCE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Time stamp disable controls the RDTSC instruction. &lt;br /&gt;Debugging extension enables 110 breakpoint debugging extensions when set. &lt;br /&gt;Page size extension enables 4M-byte memory pages when set. &lt;br /&gt;Machine check enable enables the machine checking interrupt. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium contains new features that are controlled by CR4 and a few bits in CRO. &lt;br /&gt;These new features are explained in later sections of the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EFLAG Register &lt;br /&gt;The extended flag (EFLAG) register has been changed in the Pentium microprocessor. Figure 17-10 &lt;br /&gt;pictures the contents of the EFLAG register. Notice that four new flag bits have been added to this &lt;br /&gt;register to control or indicate conditions about some of the new features in the Pentium. Following is &lt;br /&gt;a list of the four new flags and the function of each: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ID The identification flag is used to test for the CPUID instruction. If a program can &lt;br /&gt;set and clear the ID flag, the processor supports the CPUID instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIP Virtual interrupt pending indicates that a virtual interrupt is pending. &lt;br /&gt;VIF Virtual interrupt is the image of the virtual interrupt flag IF used with VIP. &lt;br /&gt;AC Alignment check indicates the state of the AM bit in control register O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Built-in Self-test (BIST) &lt;br /&gt;The built-in self-test (BIST) is accessed on power-up by placing a logic I on INIT while the &lt;br /&gt;RESET pin changes from 1 to 0. The BIST tests 70 percent of the internal structure of the Pentium &lt;br /&gt;in approximately 150 Jls. Upon completion of the BIST, the Pentium reports the outcome in reg-&lt;br /&gt;ister EAX. If EAX = 0, the BIST passed and the Pentium is ready for operation. If EAX contains &lt;br /&gt;any other value, the Pentium has malfunctioned and is faulty. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: The blank bits in the flag register are reserved for future use and must not be defined. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-10 The structure of the Pentium EFLAG register &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CR3 I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-3 PENTIUM MEMORY MANAGEMENT 691 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PENTIUM MEMORY MANAGEMENT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The memory-management unit within the Pentium is upward compatible with the 80386 and &lt;br /&gt;80486 microprocessors. M.llY of the features of these earlier microprocessors are basically &lt;br /&gt;unchanged in the Pentium. The main change is in the paging unit and a new system memory-&lt;br /&gt;management mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Paging Unit &lt;br /&gt;The paging mechanism functions with 4K-byte memory pages or with a new extension avaiiabie &lt;br /&gt;to the Pentium with 4M-byte memory pages. As detailed in Chapters 1 and 16, the size of the &lt;br /&gt;paging table structure can become large in a system that contains a large memory. Recall that to &lt;br /&gt;fully rep age 4G bytes of memory, earlier microprocessors require slightly over 4M bytes of &lt;br /&gt;memory just for the page tables. In the Pentium, with the new 4M-byte paging feature, this is &lt;br /&gt;dramatically reduced to just a single page table. The new 4M-byte page sizes are selected by the &lt;br /&gt;PSE bit in control register O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The main difference between 4K paging and 4M paging is that in the 4M paging scheme &lt;br /&gt;there is no page table entry in the linear address. Refer to Figure 17-11 for the 4M paging system &lt;br /&gt;in the Pentium microprocessor. Pay close attention to the way the linear address is used with this &lt;br /&gt;scheme. Notice that the leftmost lO-bits of the linear address select an entry in the page directory &lt;br /&gt;(just as with 4K pages). Unlike 4K pages, there are no page tables; instead, the page directory ad-&lt;br /&gt;dresses a 4M-byte memory page. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory-Management Mode &lt;br /&gt;The system memory-management mode (SMM) is on the same level as protected mode, real &lt;br /&gt;mode, and virtual mode, but is provided to function as a manager. The SMM is not intended to &lt;br /&gt;be used as an application or a system level feature. It is intended for high-level system functions &lt;br /&gt;such as power management and security. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Linear Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 22 21 o &lt;br /&gt;1 0000000010 100000000000000000000011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;Page Directory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-----------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~Jf 01000000 Root Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;~-.~-----------------------------&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â¥ Data &lt;br /&gt;01000002 &lt;br /&gt;01000001 &lt;br /&gt;01000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-11 The linear address 00200001 H repaged to memory location 01 000002H in 4M-byte pages. Note &lt;br /&gt;that there are no page tables. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;692 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Access to the SMM is accomplished via a new external hardware interrupt applied to the &lt;br /&gt;SMI pin on the Pentium. When the SMM interrupt is activated, the processor begins executing &lt;br /&gt;system level software in an area of memory called the system management RAM or SMRAM. The &lt;br /&gt;SMI interrupt disables all other interrupts normally handled by user applications and the oper-&lt;br /&gt;ating system. A return from the SMM interrupt is accomplished with a new instruction. RSM re-&lt;br /&gt;turns from the memory-management mode interrupt and returns to the interrupted program at the &lt;br /&gt;point of the interruption. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The SMM interrupt calls the software, initially stored at memory location 38000H, using &lt;br /&gt;CS = 3000H and EIP = 8000H. This initial state can be changed using a jump to any location &lt;br /&gt;within the first 1M byte of memory. An environment similar to real mode memory addressing is &lt;br /&gt;entered by the management mode interrupt, but different because instead of being able to address &lt;br /&gt;the fIrst 1M of memory, SMM mode allows the Pentium to treat the memory system as a flat 4G-&lt;br /&gt;byte system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In addition to executing software that begins at location 38000H, the SMM interrupt also &lt;br /&gt;stores the state of the Pentium in what is called a dump record. The dump record is stored at &lt;br /&gt;memory locations 3FFA8H through 3FFFFH, with an area at locations 3FEOOH through &lt;br /&gt;3FEF7H reserved by Intel. Table 17-2 lists the contents of the dump record. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The halt auto restart and I/O trap restarts are used when the SMM mode is exited by the RSM &lt;br /&gt;instruction. These data allow the RSM instruction to return to the halt state or return to the interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-2 Pentium SMM &lt;br /&gt;state dump record Offset Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFCH &lt;br /&gt;FFF8H &lt;br /&gt;FFF4H &lt;br /&gt;FFFOH &lt;br /&gt;FFECH &lt;br /&gt;FFE8H &lt;br /&gt;FFE4H &lt;br /&gt;FFEOH &lt;br /&gt;FFDCH &lt;br /&gt;FFD8H &lt;br /&gt;FFD4H &lt;br /&gt;FFDOH &lt;br /&gt;FFCCH &lt;br /&gt;FFC8H &lt;br /&gt;FFC4H &lt;br /&gt;FFCOH &lt;br /&gt;FFBCH &lt;br /&gt;FFB8H &lt;br /&gt;FFB4H &lt;br /&gt;FFBOH &lt;br /&gt;FFACH &lt;br /&gt;FFA8H &lt;br /&gt;FF04H-FFA?H &lt;br /&gt;FF02H &lt;br /&gt;FFOOH &lt;br /&gt;FEFCH &lt;br /&gt;FEF8H &lt;br /&gt;FEOOH-FEF?H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CRO &lt;br /&gt;CR3 &lt;br /&gt;EFLAGS &lt;br /&gt;EIP &lt;br /&gt;EDI &lt;br /&gt;ESI &lt;br /&gt;EBP &lt;br /&gt;ESP &lt;br /&gt;EBX &lt;br /&gt;EDX &lt;br /&gt;ECX &lt;br /&gt;EAX &lt;br /&gt;DR6 &lt;br /&gt;DR? &lt;br /&gt;TR &lt;br /&gt;LDTR &lt;br /&gt;GS &lt;br /&gt;FS &lt;br /&gt;DS &lt;br /&gt;SS &lt;br /&gt;CS &lt;br /&gt;ES &lt;br /&gt;Reserved &lt;br /&gt;Halt auto restart &lt;br /&gt;liD trap restart &lt;br /&gt;SMM revision identifier &lt;br /&gt;State dump base &lt;br /&gt;Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note: The offset addresses are initially located at &lt;br /&gt;base address 00003000H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-4 NEW PENTIUM INSTRUCTIONS 693 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I/O instruction. If neither a halt nor an I/O operation were in effect upon entering the SMM mode, &lt;br /&gt;the RSM instruction reloads the state of the machine from the state dump and returns to the point of &lt;br /&gt;interruption. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The SMM mode can be used by the system before the normal operating system is placed in &lt;br /&gt;the memory and executed. It can also peIl )dically be used to manage the system, provided &lt;br /&gt;normal software doesn't exist at locations 38000H-3FFFFH. If the system relocates the &lt;br /&gt;SMRAM before booting the normal operating system, it becomes available for use in addition to &lt;br /&gt;the normal system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The base address of the SMM mode SMRAM is changed by modifying the value in the &lt;br /&gt;state dump base address register (locations 3FEF8H through 3F3FBH) after the first memory-&lt;br /&gt;management mode interrupt. When the first RSM instruction is executed, returning control back &lt;br /&gt;to the interrupted system, the new value from these locations changes the base address of the &lt;br /&gt;SMM interrupt for all future uses. For example, if the state dump base address is changed to &lt;br /&gt;000E8000H, all subsequent SMM interrupts use locations E8000H-EFFFFH for the Pentium &lt;br /&gt;state dump. These locations are compatible with DOS and Windows. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEW PENTIUM INSTRUCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium contains only one new instruction that functions with normal system software; &lt;br /&gt;the remainder of the new instructions are added to control the memory-management mode fea-&lt;br /&gt;ture and to serialize instructions. Table 17-3 lists the new instructions added to the Pentium &lt;br /&gt;instruction set. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CMPXCHG8B instruction is an extension of the CMPXCHG instruction added to &lt;br /&gt;the 80486 instruction set. The CMPXCHG8B instruction compares the number 64-bit stored in &lt;br /&gt;EDX and EAX with the contents of a 64-bit memory location or register pair. For example, the &lt;br /&gt;CMPXCHG8B DATAl instruction compares the eight bytes stored in memory location DATAl &lt;br /&gt;with the 64-bit number in EDX and EAX. If DATAl equals EDX:EAX, the 64-bit number stored &lt;br /&gt;in ECX:EBX is stored in memory location DATA 1. If they are not equal, the contents of DATAl &lt;br /&gt;are stored into EDX:EAX. Note that the zero flag bit indicates that the contents of EDX:EAX are &lt;br /&gt;equal or not equal to DATAL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The CPUID instruction reads the CPU identification code and other information from &lt;br /&gt;the Pentium. Table 17-4 shows different information returned from the CPUID instruction for &lt;br /&gt;various input values for EAX. To use the CPUID instruction, first load EAX with the input &lt;br /&gt;value and then execute CPUID. The information is returned in the registers as indicated in the &lt;br /&gt;table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If a 0 is placed in EAX before executing the CPUlD instruction, the microprocessor re-&lt;br /&gt;turns the vendor identification in EBX, EDX, and EBX. For example, the Intel Pentium returns &lt;br /&gt;&amp;quot;Genuine Intel&amp;quot; in ASCII code with the &amp;quot;Genu&amp;quot; in the EBX, &amp;quot;ineI&amp;quot; in EDX, and &amp;quot;ntel&amp;quot; in ECX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-3 New Pentium &lt;br /&gt;instructions Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPXCHG88 &lt;br /&gt;CPUID &lt;br /&gt;RDTSC &lt;br /&gt;RDMSR &lt;br /&gt;WRMSR &lt;br /&gt;RSM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Compare and exchange eight bytes &lt;br /&gt;Return the CPU identification code &lt;br /&gt;Read time stamp counter &lt;br /&gt;Read model specific register &lt;br /&gt;Write model specific register &lt;br /&gt;Return from system management interrupt &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;694 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-4 CPUID &lt;br /&gt;instruction execution Input Value (EAX) Result after CPUID Executes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o EAX = 1 for all microprocessors &lt;br /&gt;E8X-EDX-ECX = vendor identification &lt;br /&gt;EAX (bits 3-0) = Stepping ID &lt;br /&gt;EAX (bits 7-4) = Model &lt;br /&gt;EAX (bits 11-8) = Family &lt;br /&gt;EAX (bits 13-12) = Type &lt;br /&gt;EAX (bits 31-14) = Reserved &lt;br /&gt;EDX ~bit 0) = CPU contains FPU &lt;br /&gt;EDX {bit 1) = Enhanced 8086 virtual mode supported &lt;br /&gt;EDX (bit 2) = lID breakpoints supported &lt;br /&gt;EDX (bit 3) = Page size extensions supported &lt;br /&gt;EDX (bit 4) = Time stamp counter TSC supported &lt;br /&gt;EDX (bit 5) = Pentium-style MSR supported &lt;br /&gt;EDX (bit 6) = Reserved &lt;br /&gt;EDX (bit 7) = Machine check exception supported &lt;br /&gt;EDX (bit 8) = CMPXCHG88 supported &lt;br /&gt;EDX (bit 9) = 3.3 V microprocessor &lt;br /&gt;EDX (bits 10-31) = Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The EDX register returns infonnation if EAX is loaded with a 1 before executing the CPUID &lt;br /&gt;instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 17-1 illustrates a short program that reads the vendor infonnation with the &lt;br /&gt;CPUID instruction. It then displays the infonnation on the video screen using the DISP macro. &lt;br /&gt;Note that this program works with a Pentium or any of the other Pentium clones that are on the &lt;br /&gt;market. It also works with the Pentium ~ro microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 17-1 &lt;br /&gt;.MODEL TINY &lt;br /&gt;.586 ;select the Pentium &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE &lt;br /&gt;DISP MACRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,2 &lt;br /&gt;MOV DL,BL &lt;br /&gt;INT 21H &lt;br /&gt;SHR EBX, 8 &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;0100 66/ B8 00000000 MOV EAX,O &lt;br /&gt;0106 OF A2 CPUID &lt;br /&gt;0108 66/ 52 PUSH EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0132 66/ 5B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP &lt;br /&gt;DISP &lt;br /&gt;DISP &lt;br /&gt;POP EBX &lt;br /&gt;DISP &lt;br /&gt;DISP &lt;br /&gt;DISF &lt;br /&gt;DISi' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;;display character macro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get ID from Pentium &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display first 4 letters &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;display next 4 letters &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015C 66/ 8B D9 MOV EBX,ECX ;display last 4 letters &lt;br /&gt;DISP &lt;br /&gt;DISP &lt;br /&gt;DISP &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-4 NEW PENTIUM INSTRUCTIONS 695 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP &lt;br /&gt;.EXIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The RDTSC instruction reads the time stamp counter into EDX:EAX. The time stamp counter &lt;br /&gt;counts CPU clocks from the time the microprocessor is reset, where the time stamp counter is cleared &lt;br /&gt;to zero. Because this is a 64-bit count, a 100 MHz microprocessor can accumulate a count of over &lt;br /&gt;5,800 years before the time stamp counter rolIs over. This instruction only functions in real mode or &lt;br /&gt;privilege level 0 in protected mode. If you are using a DOS sheil from Windows or operating with a &lt;br /&gt;memory manager, this instruction will not function and will cause a general protection error. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example 17-2 shows a macro sequence that times events to the microsecond. It uses the &lt;br /&gt;Pentium time stamp to time events and returns the elapsed time in microseconds in the EAX reg-&lt;br /&gt;ister. Note that there are three parameters associated with the macro. The first parameter passes &lt;br /&gt;the location of a quadword memory location used to store an image of the time stamp clock in &lt;br /&gt;the memory system. Make sure that this is defined with the DQ directive. The second parameter &lt;br /&gt;passes the clock frequency of the Pentium in MHz to the macro and determines if it is to start the &lt;br /&gt;clock or return the elapsed time. If the final parameter is START, the clock is started; if it is &lt;br /&gt;READ, the elapsed time is returned in EAX in microseconds. Note that this macro can only be &lt;br /&gt;used in real mode or privilege level 0 of protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE 17-2 &lt;br /&gt;EVENT MACRO WHERE,SPEED,OPER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH EDX ;save registers &lt;br /&gt;PUSH ECX &lt;br /&gt;:FIDN &amp;lt;OPER&amp;gt;, &amp;lt;START&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDTSC &lt;br /&gt;MOV DWORD PTR WHERE,EAX iisave current count &lt;br /&gt;MOV DWORD PTR WHERE+4,EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDIF &lt;br /&gt;IFIDN &amp;lt;OPER&amp;gt;, &amp;lt;READ&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDTSC &lt;br /&gt;SUB EAX,DWORD PTR WHERE ; ; (orm difference &lt;br /&gt;SBB EDX, DWORD PTR WHERE+4 &lt;br /&gt;MOV ECX, SPEED ;;convert to microseconds &lt;br /&gt;DIV ECX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENDIF &lt;br /&gt;POP ECX &lt;br /&gt;POP EDX &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The RDMSR and WRMSR instructions allow the model-specific registers to be read or &lt;br /&gt;written. The model-specific registers are unique to the Pentium and are used to trace, check per-&lt;br /&gt;formance, test, and check for machine errors. Both instructions use ECX to convey the register &lt;br /&gt;number to the microprocessor and use EDX:EAX for the 64-bit wide read or write. Note that the &lt;br /&gt;register addresses are OH-13H. Refer to Table 17-5 for a list of the Pentium model-specific reg-&lt;br /&gt;isters and their contents. As with the RDTSC instruction, these also operate only in the real mode &lt;br /&gt;or privilege level 0 of protected mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Never use an undefined value in ECX before using the RDMSR or WRMSR instructions. &lt;br /&gt;If ECX = 0 before the read or write machine-specific register instruction, the value returned &lt;br /&gt;EDX:EAX is the machine check exception address. If ECX = 1, the value is the machine check &lt;br /&gt;exception type; if ECX = OEH, the test register 12 (TR12) is accessed. Note that these are in-&lt;br /&gt;ternal registers designed for in-house testing. The contents of these registers are proprietary to &lt;br /&gt;Intel and should not be used during normal programming. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The RMS instruction returns form a memory-management mode interrupt. The memory-&lt;br /&gt;management mode interrupt is explained in Section 17-3. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;696 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-5 The Pentium &lt;br /&gt;model-specific registers Address (ECX) Size Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH 64-bits Machine check exception address &lt;br /&gt;01H 5-bits Machine check exception type &lt;br /&gt;02H 14-bits TR1 parity reversal test register &lt;br /&gt;03H &lt;br /&gt;04H 4-bits TR2 instruction cache end bits &lt;br /&gt;05H 32-bits TR3 cache data &lt;br /&gt;06H 32-bits TR4 cache tag &lt;br /&gt;07H 15-bits TR4 cache control &lt;br /&gt;08H 32-bits TR6 TLB command &lt;br /&gt;09H 32-bits TR7 TLB data &lt;br /&gt;OAH &lt;br /&gt;OBH 32-bits TR9 BTB tag &lt;br /&gt;OCH 32-bits TR10 BTB target &lt;br /&gt;ODH 12-bits TR11 BTB control &lt;br /&gt;OEH 10-bits TR12 new feature control &lt;br /&gt;OFH &lt;br /&gt;10H 64-bits Time stamp counter (can be written) &lt;br /&gt;11H 26-bits Events counter selection and control &lt;br /&gt;12H 40-bits Events counter 0 &lt;br /&gt;13H 40-bits Events counter 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTRODUCTION TO THE PENTIUM PRO MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before the Pentium Pro or any other microprocessor can be used in a system, the function of &lt;br /&gt;each pin must be understood. This section of the chapter details the operation of each pin, along &lt;br /&gt;with the external memory system and 110 structures of the Pentium Pro microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Figure 17-12 illustrates the pin-out of the Pentium Pro microprocessor, which is pack-&lt;br /&gt;aged in an immense 387-pin PGA (pin grid array). Currently, the Pentium Pro is available in &lt;br /&gt;two versions. One version contains a 256K level 2 cache; the other contains a 512K level 2 &lt;br /&gt;cache. The notable difference in the pin-out of the Pentium Pro when compared to the earlier &lt;br /&gt;Pentium is that there are provisions for a 36-bit address bus, which allows access to 64G bytes &lt;br /&gt;of memory. This is meant for future use because no system today contains anywhere near that &lt;br /&gt;amount of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;As with most recent versions of the Pentium microprocessor, the Pentium Pro requires a &lt;br /&gt;single +3.3V power supply for operation. The power supply current is a maximum of 9.9 A for &lt;br /&gt;the 150 MHz version of the Pentium Pro, which als~ has a maximum power dissipation of &lt;br /&gt;26.7 W. At present, a good heat sink with considerable airflow is required to keep the Pentium &lt;br /&gt;Pro cool. As with the Pentium, the Pentium Pro contains multiple Vee and V ss connections that &lt;br /&gt;must all be connected for proper operation. The Pentium Pro contains VeeP pins (primary Vee) &lt;br /&gt;that connect to +3.1 V, V ccS (secondary Vee) pins that connect to +3.3V, and V cc5 (standard &lt;br /&gt;Vee) pins that connect to +5.0V. There are also some pins that are labeled N/C (no connection) &lt;br /&gt;and must not be connected. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each Pentium Pro output pin is capable of providing an ample 48.0 rnA of current at a &lt;br /&gt;logic 0 level. This represents a considerable increase in drive current compared to the 2.0 rnA &lt;br /&gt;available on earlier microprocessor output pins. Each input pin represents a small load requiring &lt;br /&gt;only 15 llA of current. Because of the 48.0 rnA of drive current available on each output, only an &lt;br /&gt;extremely large system requires bus buffers. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-5 INTRODUCTION TO THE PENTIUM PRO MICROPROCESSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-12 The pin-out &lt;br /&gt;of the Pentium Pro micro-&lt;br /&gt;processor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 &lt;br /&gt;A4 &lt;br /&gt;AS &lt;br /&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;A8 &lt;br /&gt;A9 &lt;br /&gt;A10 &lt;br /&gt;A11 &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;A16 &lt;br /&gt;A17 &lt;br /&gt;A18 &lt;br /&gt;A19 &lt;br /&gt;A20 &lt;br /&gt;A21 &lt;br /&gt;A22 &lt;br /&gt;A23 &lt;br /&gt;A24 &lt;br /&gt;A25 &lt;br /&gt;A26 &lt;br /&gt;A27 &lt;br /&gt;A28 &lt;br /&gt;A29 &lt;br /&gt;A30 &lt;br /&gt;A31 &lt;br /&gt;A32 &lt;br /&gt;A33 &lt;br /&gt;A34 &lt;br /&gt;A35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADS &lt;br /&gt;AERR &lt;br /&gt;APO &lt;br /&gt;AP1 &lt;br /&gt;BCLK &lt;br /&gt;BERR &lt;br /&gt;BINIT &lt;br /&gt;BNR &lt;br /&gt;BP2 &lt;br /&gt;BP3 &lt;br /&gt;BPMO &lt;br /&gt;BPM1 &lt;br /&gt;BPR1 &lt;br /&gt;BRO &lt;br /&gt;BR1 &lt;br /&gt;BR2 &lt;br /&gt;BR3 &lt;br /&gt;CPU PRES &lt;br /&gt;DEFER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEPO &lt;br /&gt;OEP1 &lt;br /&gt;OEP2 &lt;br /&gt;OEP3 &lt;br /&gt;OEP4 &lt;br /&gt;OEP5 &lt;br /&gt;OEP6 &lt;br /&gt;OEP7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORDY &lt;br /&gt;FERR &lt;br /&gt;FLUSH &lt;br /&gt;FRCERR &lt;br /&gt;HIT &lt;br /&gt;HITM &lt;br /&gt;IERR &lt;br /&gt;IGNNE &lt;br /&gt;INIT &lt;br /&gt;LlNTO/INTR &lt;br /&gt;LINT1/NMI &lt;br /&gt;LOCK &lt;br /&gt;RESET &lt;br /&gt;RP &lt;br /&gt;RSO &lt;br /&gt;RSl &lt;br /&gt;RS2 &lt;br /&gt;RSP &lt;br /&gt;SMI &lt;br /&gt;TROY &lt;br /&gt;UP &lt;br /&gt;A20M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Internal Structure of the Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PENTIUM PRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;08 &lt;br /&gt;09 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010 &lt;br /&gt;011 &lt;br /&gt;012 &lt;br /&gt;013 &lt;br /&gt;014 &lt;br /&gt;015 &lt;br /&gt;016 &lt;br /&gt;017 &lt;br /&gt;018 &lt;br /&gt;019 &lt;br /&gt;020 &lt;br /&gt;021 &lt;br /&gt;022 &lt;br /&gt;D23 &lt;br /&gt;024 &lt;br /&gt;025 &lt;br /&gt;026 &lt;br /&gt;027 &lt;br /&gt;028 &lt;br /&gt;029 &lt;br /&gt;030 &lt;br /&gt;031 &lt;br /&gt;032 &lt;br /&gt;033 &lt;br /&gt;034 &lt;br /&gt;035 &lt;br /&gt;036 &lt;br /&gt;037 &lt;br /&gt;038 &lt;br /&gt;039 &lt;br /&gt;040 &lt;br /&gt;041 &lt;br /&gt;042 &lt;br /&gt;043 &lt;br /&gt;044 &lt;br /&gt;045 &lt;br /&gt;046 &lt;br /&gt;047 &lt;br /&gt;048 &lt;br /&gt;049 &lt;br /&gt;050 &lt;br /&gt;051 &lt;br /&gt;052 &lt;br /&gt;053 &lt;br /&gt;054 &lt;br /&gt;055 &lt;br /&gt;056 &lt;br /&gt;057 &lt;br /&gt;058 &lt;br /&gt;059 &lt;br /&gt;060 &lt;br /&gt;061 &lt;br /&gt;D62 &lt;br /&gt;063 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PICCLK &lt;br /&gt;PICoO &lt;br /&gt;PICol &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PLLl &lt;br /&gt;PLL2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PRoy &lt;br /&gt;PREO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PWRGOOo &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REOO &lt;br /&gt;REOl &lt;br /&gt;RE02 &lt;br /&gt;RE03 &lt;br /&gt;RE04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STPCLK &lt;br /&gt;TCK &lt;br /&gt;TOI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TOO &lt;br /&gt;THERTRIP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMS &lt;br /&gt;TRST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;697 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium Pro is structured differently than earlier microprocessors. Early microprocessors &lt;br /&gt;contained an execution unit and a bus interface unit with a small cache buffering the execution &lt;br /&gt;unit for the bus interface unit. This structure was modified in later microprocessors, but the mod-&lt;br /&gt;ifications were just additional stages within the microprocessors. The Pentium architecture is &lt;br /&gt;also a modification, but a more significant one than in earlier microprocessors. Figure 17-13 &lt;br /&gt;shows a block diagram of the internal structure of the Pentium Pro microprocessor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;698 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-13 The internal &lt;br /&gt;structure of the Pentium Pro &lt;br /&gt;microprocessor Instruction Pool &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.,,- --::.,. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;&amp;quot;-. '=-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Dispatch Instruction &lt;br /&gt;Retire Unit and Execute Fetch and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Unit Decode Unit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.,,:-&amp;quot; --;::... &lt;br /&gt;.&amp;quot;,--~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;-..... ..-?&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Level 1 Level 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8K Data Cache 8K Instruction &lt;br /&gt;Cache &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Q .,,-- -.......&amp;quot;.. &lt;br /&gt;Bus Interface Unit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 &lt;br /&gt;256K or 512K Level 2 Cache &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Q &lt;br /&gt;External Bus System &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The system buses, which communicate to the memory and UO, connect to an intemallevel &lt;br /&gt;2 cache that is often on the main board in most other microprocessor systems. The level 2 cache &lt;br /&gt;in the Pentium Pro is either 256K bytes or 5I2K bytes. The integration of the level 2 cache &lt;br /&gt;speeds processing and reduces the number of components in a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bus interface unit (BIU) controls the access to the system buses through the level 2 &lt;br /&gt;cache, as it does in most other microprocessors. Again, the differencr~ is that the level 2 cache is &lt;br /&gt;integrated. The BIU generates the memory address and control signals and passes and fetches &lt;br /&gt;data or instructions to either a level 1 data cache or a level 1 instruction cache. Each of these are &lt;br /&gt;presently 8K bytes in size and may be made larger in future versions of the microprocessor. Ear-&lt;br /&gt;lier versions of the Intel microprocessor contained a unified cache that held both instructions and &lt;br /&gt;data. The implementation of separate caches improves perfonnance, because data-intensive pro-&lt;br /&gt;grams no longer fill the cache with data. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-5 INTRODUCTION TO THE PENTIUM PRO MICROPROCESSOR 699 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The instruction cache is connected to the instruction fetch and decode unit (IFDU). Al-&lt;br /&gt;though not shown, the IFDU contains three separate instruction decoders that decode three in-&lt;br /&gt;structions simultaneously. Once decoded, the outputs of the three decoders are passed to the &lt;br /&gt;instruction pool, where they remain until the dispatch and execution unit or the retire unit obtains &lt;br /&gt;them. Also included within the IFDU is a branch prediction logic section, which looks ahead in &lt;br /&gt;code sequences that contain conditional jump instructions. If a conditional jump is located, the &lt;br /&gt;branch prediction logic tries to determine the next instruction in the flow of a program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once decoded, instructions are passed to the instruction pooi, where they are heid for pro-&lt;br /&gt;cessing. The instruction pool is a content-addressable memory, but Intel never states its size in &lt;br /&gt;the literature. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The dispatch and execute unit (DEU) retrieves decoded instructions from the instruction &lt;br /&gt;pool, when they are complete, and executes them. The internal structure of the DEU is illustrated &lt;br /&gt;in Figure l7-14. Notice that the DEU contains three instruction execution units: two for pro-&lt;br /&gt;cessing integer instructions, and one for floating-point instructions. This means that the Pentium &lt;br /&gt;Pro can process two integer instructions and one floating-point instruction simultaneously. The &lt;br /&gt;Pentium also contains three execution units, but the architecture is different, because the Pen-&lt;br /&gt;tium does not contain a jump execution unit or address generation units as does the Pentium Pro. &lt;br /&gt;The reservation station (RS) can schedule up to five events for execution and can process four si-&lt;br /&gt;multaneously. Note that there are two station components connected to one of the address gener-&lt;br /&gt;ation units that does not appear in the illustration of Figure l7 -14. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The last internal structure of the Pentium Pro is the retire unit (RU). The RU checks the in-&lt;br /&gt;struction pool and removes decoded instructions that have been executed. The RU can remove &lt;br /&gt;three decoded instructions per clock pulse. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pin Connections &lt;br /&gt;The number of pins has been increased from the 237 pins on the Pentium to 387 pins on the &lt;br /&gt;Pentium Pro. Following is a description of each pin or grouping of pins: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-14 The Pen-&lt;br /&gt;tium Pro dispatch and execu-&lt;br /&gt;tion unit (DEU) I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address A20 mask is an input that is asserted in the real mode to signal &lt;br /&gt;the Pentium Pro to perform address wraparound, as in the 8086 &lt;br /&gt;microprocessor, for use of the HIMEN.SYS driver. &lt;br /&gt;Address bus connections address any of the S12K x 64 memory locations &lt;br /&gt;found in the Pentium Pro memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Integer J Jump Unit Unit &lt;br /&gt;Floating Integer Address Address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Point Unit Generation Generation &lt;br /&gt;Unit Unit Unit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ ---&amp;quot;,.. ~ ---&amp;quot;,.. ~ &lt;br /&gt;---r.. ~ ----&amp;quot;.. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot;&amp;quot;&amp;quot;'--- ..--7 &amp;quot;&amp;quot;&amp;quot;--- ..--7 '&amp;quot;&amp;quot;'---~ &amp;quot;&amp;quot;&amp;quot;'--- ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reservation Station (RS) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;D &lt;br /&gt;Instruction Pool &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;700 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UNTt/NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-6 The memory &lt;br /&gt;size as dictated by ASZ pins ASZt ASZO Memory Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BINIT &lt;br /&gt;BNR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0-4G &lt;br /&gt;0 1 4G-64G &lt;br /&gt;1 X Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The address data strobe becomes active whenever the Pentium Pro has &lt;br /&gt;issued a valid memory or I/O address. &lt;br /&gt;Address parity provides even parity for the memory address on all Pentium &lt;br /&gt;Pro-initiated memory and I/O transfers. The APO output provides parity for &lt;br /&gt;address connections A23-A3, and the API output provides parity for &lt;br /&gt;address connections A35-A24. &lt;br /&gt;Address size inputs are driven to select the size of the memory access. &lt;br /&gt;Table 17-6 illustrates the size of the memory access for the binary bit &lt;br /&gt;patterns on these two inputs to the Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bus clock input determines the operating frequency of the Pentium Pro &lt;br /&gt;microprocessor. For example, if BCLK is 66 MHz, various internal clock-&lt;br /&gt;ing speeds are selected by the logic levels applied to the pins in Table 17-7. &lt;br /&gt;A BLCK frequency of 66 MHz runs the system bus at 66 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bus error input/output either signals a bus error along or is asserted by &lt;br /&gt;an external device to cause either a machine check interrupt or a non-&lt;br /&gt;maskable interrupt. &lt;br /&gt;Bus initialization is active on power up to initialize the bus system. &lt;br /&gt;Block next request is used to halt the system in a multiple microprocessor &lt;br /&gt;system. &lt;br /&gt;The break point status outputs indicate the status of the Pentium Pro break &lt;br /&gt;points. &lt;br /&gt;The break point monitor outputs indicate the status of the break points &lt;br /&gt;and programmable counters. &lt;br /&gt;Priority agent bus request is an input that causes the microprocessor to &lt;br /&gt;cease bus requests. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The BLCK signal and its effect on the Pentium Pro clock speed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;UNTO/INT Speed with Speed with &lt;br /&gt;R IGNNE A20M Ratio BCLK=50MHz BCLK= 66 MHz &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 2 100 MHz 133 MHz &lt;br /&gt;0 0 1 4 200 MHz 266 MHz &lt;br /&gt;0 1 0 3 150 MHz 200 MHz &lt;br /&gt;0 1 1 5 250 MHz 33'3 MHz &lt;br /&gt;1 0 0 5/2 125 MHz 1â¬0 MHz &lt;br /&gt;1 0 1 9/2 225 MHz 300 MHz &lt;br /&gt;1 1 0 7/2 175 MHz 233 MHz &lt;br /&gt;1 1 1 11/2 275 MHz 366 MHz &lt;br /&gt;1 1 1 2 100 MHz 133 MHz &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-5 INTRODUCTION TO THE PENTIUM PRO MICROPROCESSOR 701 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BR3-BRO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BREQ3-&lt;br /&gt;BREQO &lt;br /&gt;D63-DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IillSY &lt;br /&gt;DEFER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLUSH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FRCERR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HIT &lt;br /&gt;HITM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IGNNE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTR &lt;br /&gt;LEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The bus request inputs allow up to four Pentium Pro microprocessors to &lt;br /&gt;coexist on the same bus system. &lt;br /&gt;Bus request signals are used for multiple microprocessors on the same &lt;br /&gt;system bus. &lt;br /&gt;Data bus connections transfer byte, word, doubleword, and quadword data &lt;br /&gt;between the microprocessor and its memory and I/O system. &lt;br /&gt;Data bus busy is asserted to indicate that the data bus is busy transferring data. &lt;br /&gt;The defer input is asserted during the snoop phase to indicate that the &lt;br /&gt;transaction cannot be guaranteed in-order completion. &lt;br /&gt;The defer enable signal is driven to the bus on the second phase of a &lt;br /&gt;request phase. &lt;br /&gt;Data bus ECC protection signals provide error correction codes for &lt;br /&gt;correcting a single bit error and detecting a double bit error. &lt;br /&gt;Floating-point error is comparable to the ERROR line in the 80386 to &lt;br /&gt;show that the internal coprocessor has erred. &lt;br /&gt;The flush cache input causes the cache to flush all write-back lines and &lt;br /&gt;invalidate its internal caches. If the FLUSH input is a logic 0 during a reset &lt;br /&gt;operation, the Pentium enters its test mode. &lt;br /&gt;Functional redundancy check error is used if two Pentium Pro &lt;br /&gt;microprocessors are configured in a pair. &lt;br /&gt;Hit shows that the internal cache contains valid data in the inquire mode. &lt;br /&gt;Hit modified shows that the inquire cycle found a modified cache line. This &lt;br /&gt;output is used to inhibit other master units from accessing data until the &lt;br /&gt;cache line is written to memory. &lt;br /&gt;The internal error output shows that the Pentium Pro has detected an &lt;br /&gt;internal parity error or functional redundancy error. &lt;br /&gt;The ignore numeric error input causes the Pentium Pro to ignore a &lt;br /&gt;numeric coprocessor error. &lt;br /&gt;The initialization input performs a reset without initializing the caches, &lt;br /&gt;write-back buffers, and floating-point registers. This may not be used to &lt;br /&gt;reset the microprocessor in lieu of RESET after power-up. &lt;br /&gt;Interrupt request is used by external circuitry to request an interrupt. &lt;br /&gt;Length signals (bit 0 and 1) indicate the size of the data transfer, as &lt;br /&gt;illustrated in Table 17-8. &lt;br /&gt;The local interrupt inputs function as NMI and INTR and also set the &lt;br /&gt;clock divider frequency on reset. &lt;br /&gt;Lock becomes a logic 0 whenever an instruction is prefixed with the &lt;br /&gt;LOCK: prefix. This is most often used during DMA accesses. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The LEN bits &lt;br /&gt;show the size of a data LENt LENO Data Transfer Size &lt;br /&gt;transfer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0-8 bytes &lt;br /&gt;0 16 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 32 bytes &lt;br /&gt;1 Reserved &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;702 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-9 The function &lt;br /&gt;of the request signals in the RE04 RE03 RE02 REO 1 REOO Function &lt;br /&gt;first clocking period &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 0 0 0 Deferred reply &lt;br /&gt;0 0 0 0 1 Reserved &lt;br /&gt;0 1 0 0 0 Case 1&amp;quot; &lt;br /&gt;0 1 0 0 1 Case 2&amp;quot; &lt;br /&gt;1 0 0 0 0 liD read &lt;br /&gt;1 0 0 0 1 liD write &lt;br /&gt;X X 0 1 0 Memory read &lt;br /&gt;X X 0 1 1 Memory write &lt;br /&gt;X X 1 0 0 Memory code read &lt;br /&gt;X X 1 1 0 Memory data read &lt;br /&gt;X X 1 X 1 Memory write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'Note: See Table 17-10 for the second clock pulse for these codes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NMI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PICCLK &lt;br /&gt;PICD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PWRGOOD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The non-maskable interrupt requests a non-maskable interrupt, as it did &lt;br /&gt;on the earlier versions of the microprocessor. &lt;br /&gt;The clock signal input is used for synchronous data transfers. &lt;br /&gt;The processor interface serial data is used to transfer bi-directional serial &lt;br /&gt;messages between Pentium Pro microprocessors. &lt;br /&gt;Power good is an input that is placed at a logic 1 level when the power &lt;br /&gt;supply and clock have stabilized. &lt;br /&gt;Request signals (bits 0-4) define the type of data transfer operation, as &lt;br /&gt;illustrated in Tables 17-9 and 17-10. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reset initializes the Pentium Pro, causing it to begin executing software at &lt;br /&gt;memory location FFFFFFFOH. The Pentium Pro is reset to the real mode &lt;br /&gt;and the leftmost 12 address connections remain logic l's (FFFH) until a far &lt;br /&gt;jump or far call is executed. This allows compatibility with earlier &lt;br /&gt;microprocessors. &lt;br /&gt;Request parity provides a means of requesting that the Pentium Pro checks &lt;br /&gt;parity. &lt;br /&gt;The response status inputs cause the Pentium Pro to perform functions as &lt;br /&gt;listed in Table 17-11. &lt;br /&gt;The response parity input applies a parity error signal from an external &lt;br /&gt;parity checker. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-10 The second clock pulse and the request signals as they apply to case 1 and 2 &lt;br /&gt;from Table 17-9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Case RE04 RE03 RE02 REO 1 REOO Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 X X X 0 0 Interrupt acknowledge &lt;br /&gt;1 X X X 0 1 Special transactions &lt;br /&gt;1 X X X 1 X Reserved &lt;br /&gt;2 X X X 0 0 Branch trace message &lt;br /&gt;2 X X X 0 1 Reserved &lt;br /&gt;2 X X X 1 X Reserved &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-5 INTRODUCTION TO THE PENTIUM PRO MICROPROCESSOR 703 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE 17-11 The opera-&lt;br /&gt;tion of the Pentium Pro in RS2 RS1 RSO Function HITM DEFER &lt;br /&gt;response to the RS inputs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SMMEM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SPCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STPCLK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TDO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TMS &lt;br /&gt;TRDY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 Idle state X X &lt;br /&gt;0 Retry 0 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 Defer 0 1 &lt;br /&gt;Reserved 0 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 0 Hard failure X X &lt;br /&gt;0 i Normal, no data r'&amp;gt; 0 v &lt;br /&gt;1 0 Implicit write-back X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Normal with data 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The system management interrupt input causes the Pentium Pro to enter &lt;br /&gt;the system management mode of operation. &lt;br /&gt;The system memory-management mode signal becomes a logic 0 &lt;br /&gt;whenever the Pentium Pro is executing in the system memory-management &lt;br /&gt;mode interrupt and address space. &lt;br /&gt;The split lock signal is placed at a logic 0 level to indicate that the transfer &lt;br /&gt;will contain four locked transactions. &lt;br /&gt;Stop clock causes the Pentium Pro to enter the power-down state when &lt;br /&gt;placed at a logic 0 level. &lt;br /&gt;The testability clock input selects the clocking function in accordance to &lt;br /&gt;the IEEE 1149.1 Boundary Scan interface. &lt;br /&gt;The test data input is used to test data clocked into the Pentium with the &lt;br /&gt;TCK signal. &lt;br /&gt;The test data output is used to gather test data and instructions shifted out &lt;br /&gt;of the Pentium with TCK. &lt;br /&gt;The test mode select input controls the operation of the Pentium in test mode. &lt;br /&gt;The target ready input is asserted when the target is ready for a data &lt;br /&gt;transfer operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Memory System &lt;br /&gt;The memory system for the Pentium Pro microprocessor is 40 bytes in size, just as in the &lt;br /&gt;80386DX-Pentium microprocessors, but access to an area between 40 and 640 is made possible &lt;br /&gt;by additional address signals A32-A35. The Pentium Pro uses a 64-bit data bus to address &lt;br /&gt;memory organized in eight banks that each contain 80 bytes of data. Note that the additional &lt;br /&gt;memory is enabled with bit position 5 of CR4 and is accessible only when 2M paging is enabled. &lt;br /&gt;Note that 2M paging is new to the Pentium Pro to allow memory above 40 to be accessed. More &lt;br /&gt;information is presented on Pentium Pro paging later in this chapter. Refer to Figure 17-15 for &lt;br /&gt;the organization of the Pentium Pro physical memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium Pro memory system is divided into eight banks that each store a byte of data &lt;br /&gt;with a parity bit. Note that most Pentium and Pentium Pro microprocessor-based systems forgo &lt;br /&gt;the use of the parity bit. The Pentium Pro, like the 80486 and the Pentium, employs internal &lt;br /&gt;parity generation and checking logic for the memory system data bus information. The 64-bit &lt;br /&gt;wide memory is important to double-precision floating-point data. Recall that a double-precision &lt;br /&gt;noating-point number is 64-bits wide. As with earlier Intel microprocessors, the memory system &lt;br /&gt;is numbered in bytes from byte OOOOOOOOOH to byte FFFFFFFFFH. This nine-digit hexadecimal &lt;br /&gt;address is employed in a system that addresses 640 of memory. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;704 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bank 7 Bank 6 Bank 5 Bank4 Bank 3 Bank2 Bank 1 BankO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-15 The eight memory banks in the Pentium Pro system. Note each bank is 8-bits &lt;br /&gt;wide and 8G long if 36-bit addressing is enabled. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory selection is accomplished with the bank enable signals (BE7-BEO). In the Pen-&lt;br /&gt;tium Pro microprocessor, the bank enable signals are presented on the address bus (AlS-A8) &lt;br /&gt;during the second clock cycle of a memory or I/O access. These must be extracted from the ad-&lt;br /&gt;dress bus to access memory banks. The separate memory banks allow the Pentium Pro to access &lt;br /&gt;any single byte, word, doubleword, or quadword with one memory transfer cycle. As with earlier &lt;br /&gt;memory selection logic, we often generate eight separate write strobes for writing to the memory &lt;br /&gt;system. Note that the memory write information is provided on the request lines from the micro-&lt;br /&gt;processor during the second clock phase of a memory or I/O access. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A new feature added to the Pentium and Pentium Pro is the ability to check and generate &lt;br /&gt;parity for the address bus during certain operations. The AP pin (Pentium) or pins (Pentium Pro) &lt;br /&gt;provide the system with parity information, and the APCHK (Pentium) or AP pins (Pentium Pro) &lt;br /&gt;indicate a bad parity check for the address bus. The Pentium Pro takes no action when an address &lt;br /&gt;parity error is detected. The error must be assessed by the system and the system must take ap-&lt;br /&gt;propriate action (an interrupt) if so desired. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Input/Output System &lt;br /&gt;The input/output system of the Pentium Pro is completely compatible with earlier Intel micro-&lt;br /&gt;processors. The I/O port number appears on address lines A15-A3, with the bank enable signals &lt;br /&gt;used to select the actual memory banks used for the I/O transfer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Beginning with the 80386 microprocessor, I/O privilege information is added to the TSS &lt;br /&gt;segment when the Pentium is operated in the protected mode. Recall that this allows I/O ports to &lt;br /&gt;be selectively inhibited. If the blocked I/O location is accessed, the Pentium Pro generates a type &lt;br /&gt;13 interrupt to signal an I/O privilege violation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System Timing &lt;br /&gt;As with any microprocessor, the system timing signals must be understood in order to interface &lt;br /&gt;the microprocessor. This portion of the text details the operation of the Pentium Pro through its &lt;br /&gt;timing diagrams and also shows how to determine memory access times. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The basic Pentium Pro memory cycle consists of two sections: the address phase and the &lt;br /&gt;data phase. During the address phase, the Pentium Pro sends the address (Tl) to the memory and &lt;br /&gt;I/O system and also the control signals (T2). The control signals include the A TTR lines &lt;br /&gt;(A31-A24), the DID lines (A23-A 16), the bank enable signals (A15-Ag), and the EXF lines &lt;br /&gt;(A7-A3). Refer to Figure 17-16 for the basic timing cycle. The type of memory cycle appears on &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-6 SPECIAL PENTIUM PRO FEATURES 705 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-16 The basic &lt;br /&gt;Pentium Pro timing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Address Phase &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;66MHZ~ &lt;br /&gt;T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Data Phase &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T2 T2 T2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BCLK: : &lt;br /&gt;: : &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A35-A3 ~~_--:-c_o_n_tr_o_1 _-:--___ -:--___ -:.--&amp;gt;'( &lt;br /&gt;063-00 --;----~--_( &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the request pins. During the data phase, four 64-bit wide numbers are fetched or written to the &lt;br /&gt;memory. This operation is most common because data from the main memory are transferred be-&lt;br /&gt;tween the internal 2s6K or s12K write-back cache and the memory system. Operations that &lt;br /&gt;write a byte, word, or doubleword, such as I/O transfers, use the bank selection signals and have &lt;br /&gt;only one clock in the data transfer phase. Notice from the timing diagram that the 66 MHz Pen-&lt;br /&gt;tium Pro is capable of 33 million memory transfers per second. This assumes that the memory &lt;br /&gt;can operate at that speed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The setup time before the clock is given as 5.0 ns, and the hold time after the clock is given &lt;br /&gt;as 1.5 ns. This means that the data window around the clock is 6.5 ns. The address appears on the &lt;br /&gt;8.0 ns maximum after the start of T 1. This means that the Pentium Pro microprocessor operating &lt;br /&gt;at 66 MHz allows 30 ns (two clocking periods) minus the address delay time of 8.0 ns and also &lt;br /&gt;minus the data setup time of 5.0 ns. Memory access time without any wait states is 30 - 8.0 - 5.0, &lt;br /&gt;or 17.0 ns. This is enough time to allows access to a SRAM, but not to any DRAM without in-&lt;br /&gt;serting wait states into the timing. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Wait states are inserted into the timing by controlling the TRDY input to the Pentium Pro. &lt;br /&gt;The TRDY signal must become a logic 0 by the end of T2; otherwise, additional T2 states are in-&lt;br /&gt;serted into the timing. Note that 60 ns DRAM requires the insertion of four wait states of 15 ns &lt;br /&gt;(one clocking period) each to lengthen the access time to 77 ns. This is enough time for the &lt;br /&gt;DRAM and any decoder in the system to function. Because many EPROM memory devices re-&lt;br /&gt;quire an access time of 100 ns, EPROM requires the addition of seven wait states to lengthen ac-&lt;br /&gt;cess time to 122 ns. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SPECIAL PENTIUM PRO FEATURES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The Pentium Pro is essentially the same microprocessor as the 80386, 80486, and Pentium, ex-&lt;br /&gt;cept that some additional features and changes to the control register set have occurred. This sec-&lt;br /&gt;tion highlights the differences between the 80386 control register structure and the flag register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Control Register 4 &lt;br /&gt;Figure 17-17 shows control register 4 of the Pentium Pro microprocessor. Notice that CR4 has &lt;br /&gt;two new control bits that are added to the control register array. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This section of the text explains only the two new Pentium Pro components in the control &lt;br /&gt;register 4. Refer to Figure 17-9 for a description and illustration of the Pentium control registers. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;706 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 17-17 The new &lt;br /&gt;control register 4 (CR4) in the &lt;br /&gt;Pentium Pro microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31 765432 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Following is a description of the Pentium CR4 bits and the new Pentium Pro control bits in con-&lt;br /&gt;trol register CR4: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VME &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PVI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TSD &lt;br /&gt;DE &lt;br /&gt;PSE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PAE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MCE &lt;br /&gt;PGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Virtual mode extension enables support for the virtual interrupt flag in protected &lt;br /&gt;mode. If VME = 0, virtual interrupt support is disabled. &lt;br /&gt;Protected mode virtual interrupt enables support for the virtual interrupt flag in &lt;br /&gt;protected mode. &lt;br /&gt;Time stamp disable controls the RDTSC instruction. &lt;br /&gt;Debugging extension enables I/O breakpoint debugging extensions when set. &lt;br /&gt;Page size extension enables 4M-byte memory pages when set in the Pentium or &lt;br /&gt;2M-byte pages when set in the Pentium Pro. &lt;br /&gt;Page address extension enables address lines A35-A32 whenever a special new &lt;br /&gt;addressing mode, controlled by PSE, is enabled for the Pentium Pro. &lt;br /&gt;Machine check enable enables the machine checking interrupt. &lt;br /&gt;Page size extension controls the new, larger 64G addressing mode whenever it is &lt;br /&gt;set along with P AE and PSE. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I. The Pentium microprocessor is almost identical to the earlier 80386 and 80486 micro-&lt;br /&gt;processors. The main difference is that the Pentium has been modified internally to contain &lt;br /&gt;a dual cache (instruction and data) and a dual integer unit. The Pentium also operates at a &lt;br /&gt;higher clock speed of 66 MHz. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2. The 66 MHz Pentium requires 3.3 A of current, and the 60 MHz version requires 2.91 A. &lt;br /&gt;The power supply must be a +5.0V supply with a regulation of Â±5%. Newer versions of the &lt;br /&gt;Pentium require a 3.3V power supply. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3. The data bus on the Pentium is 64-bits wide and contains eight byte-wide memory banks se-&lt;br /&gt;lected with bank enable signals (BED-BE7). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. Memory access time, without wait states, is only about 18 ns in the 66 MHz Pentium. In &lt;br /&gt;many cases, this short access time requires wait states introduced by controlling the BRDY &lt;br /&gt;input to the Pentium. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5. The superscaler structure of the Pentium contains three independent processing units: a &lt;br /&gt;floating-point processor and two integer processing units labeled U and V by Intel. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. The cache structure of the Pentium is modified to include two caches. One 8K x 8 cache is &lt;br /&gt;designed as an instruction cache; the other 8K x 8 cache is a data cache. The data cache can &lt;br /&gt;be operated as either a write-through or a write-back cache. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7. A new mo,i'! of operation called the system memory-management (SMM) mode has been &lt;br /&gt;added to the Pentium. The SMM mode is accessed via the system memory management in-&lt;br /&gt;terrupt applied to the SMI input pin. In response to SMI, the Pentium begins executing soft-&lt;br /&gt;ware at memory location 38000H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. New instructions include the CMPXCHG8B, RSM, RDMSR, WRMSR, and CPUID. The &lt;br /&gt;CMPXCHG8B instruction is similar to the 80486 CMPXCHG instruction. The RSM instruc-&lt;br /&gt;tion returns from the system memory-management interrupt. The RDMSR and WRMSR &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;17-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17-8 QUESTIONS AND PROBLEMS 707 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;instructions read or write to the machine-specific registers. The CPUID instruction reads the &lt;br /&gt;CPU identification code from the Pentium. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9. The built-in self-test (BIST) allows the Pentium to be tested when power is first applied to &lt;br /&gt;the system. A normal power-up reset activates the RESET input to the Pentium. A BrST &lt;br /&gt;power-up reset activates rNIT and then deactivates the RESET pin. EAX is equal to a &lt;br /&gt;OOOOOOOOH in the BIST passes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. A new proprietary Intel modification to the paging unit allows 4M-byte memory pages in-&lt;br /&gt;stead of the 4K-byte pages. This is accomplished by using the page directory to address &lt;br /&gt;1,024 pages that each contain 4M of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11. The Pentium Pro is an enhanced version of the Pentium microprocessor that contains not &lt;br /&gt;only the level 1 caches found inside the Pentium, but the level 2 cache of 256K or 512K &lt;br /&gt;found on most main boards. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The Pentium Pro operates using the same 66 MHz bus speed as the Pentium and the 80486. &lt;br /&gt;It uses an internal clock generator to multiply the bus speed by various factors to obtain &lt;br /&gt;higher internal execution speeds. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13. The only significant software difference between the Pentium Pro and earlier microproces-&lt;br /&gt;sors is the addition of the FCMOV and CMOV instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The only hardware difference between the Pentium Pro and earlier microprocessors is the &lt;br /&gt;addition of 2M paging and four extra address lines that allow access to a memory address &lt;br /&gt;space of 64G bytes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;QUESTIONS AND PROBLEMS &lt;br /&gt;1. How much memory is accessible to the Pentium microprocessor? &lt;br /&gt;2. How much memory is accessible to the Pentium Pro microprocessor? &lt;br /&gt;3. The memory data bus width is in the Pentium. &lt;br /&gt;4. What is the purpose of the DPO-DP7 pins on the Pentium? &lt;br /&gt;5. If the Pentium operates at 66 MHz, what frequency clock signal is applied to the CLK pin? &lt;br /&gt;6. What is the purpose of the BRDY pin on the Pentium? &lt;br /&gt;7. What is the purpose of the AP pin on the Pentium? &lt;br /&gt;8. How much memory access time is allowed by the Pentium, without wait states, when it is &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;operated at 66 MHz? &lt;br /&gt;9. What Pentium pin is used to insert wait states into the timing? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. A wait state is an extra clocking period. &lt;br /&gt;11. Explain how two integer units allow the Pentium to execute two non-dependent instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;simultaneously. &lt;br /&gt;12. How many caches are found in the Pentium and what are their sizes? &lt;br /&gt;13. How wide is the Pentium memory data sample window for a memory read operation? &lt;br /&gt;14. Can the Pentium execute three instructions simultaneously? &lt;br /&gt;15. What is the purpose of the SMI pin? &lt;br /&gt;16. What is the system memory-management mode of operation for the Pentium? &lt;br /&gt;17. How is the system memory-management mode exited? &lt;br /&gt;18. Where does the Pentium begin to execute software for an SMI interrupt input? &lt;br /&gt;19. How can the system memory-management unit dump address be modified? &lt;br /&gt;20. Explain the operation of the CMPXCHG8B instruction. &lt;br /&gt;21. What information is returned in register EAX after the CPUID instruction executes with an &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;initial value of 0 in EAX? &lt;br /&gt;22. What new flag bits are added to the Pentium microprocessor? &lt;br /&gt;23. What new control register is added to the Pentium microprocessor? &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;708 CHAPTER 17 THE PENTIUM AND PENTIUM PRO MICROPROCESSORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24. Describe how the Pentium access 4M pages. &lt;br /&gt;25. Explain how the time stamp clock functions and how it can be used to time events. &lt;br /&gt;26. Contrast the Pentium with the Pentium Pro microprocessor. &lt;br /&gt;27. Where are the bank enable signals found in the Pentium Pro microprocessor? &lt;br /&gt;28. How many address lines are found in the Pentium Pro system? &lt;br /&gt;29. What changes have been made to CR4 in the Pentium Pro and for what purpose? &lt;br /&gt;30. Compare access times in the Pentium system with the Pentium Pro system. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX A &lt;br /&gt;The Assembler, Disk Operating System, &lt;br /&gt;Basic I/O System, Mouse, and &lt;br /&gt;DPMI Memory Manager &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This appendix is provided so the use of the assembler can be understood and also to show the &lt;br /&gt;DOS (disk operating system), BIOS (basic I/O system), and mouse function calls that are used &lt;br /&gt;by assembly language to control the personal computer. The function calls control everything &lt;br /&gt;from reading and writing disk data to managing the keyboard and displays to controlling the &lt;br /&gt;mouse. The assembler represented in this text is the Microsoft ML (Version 6.x) and MASM &lt;br /&gt;(version 5.10) MACRO assembler programs. It is fairly important that version 6.X be used in-&lt;br /&gt;stead of the dated version 5.10. Also presented is the DPMI memory manager used when &lt;br /&gt;shelling out of Windows. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASSEMBLER USAGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The assembler program requires that a symbolic program first be written, using a word &lt;br /&gt;processor, text editor, or the workbench program provided with the assembler package. The ed-&lt;br /&gt;itor provided with version 5.10 is M.EXE, and it is strictly a full-screen editor. The editor pro-&lt;br /&gt;vided with version 6.x is PWB.EXE, and it is a fully integrated development system that &lt;br /&gt;contains extensive help. Refer to the documentation that accompanies your assembler package &lt;br /&gt;for details on the operation of the editor program. If at all possible, use version 6.x of the as-&lt;br /&gt;sembler because it contains a detailed help file that guides the user through assembly language &lt;br /&gt;statements, directives, and even the DOS and BIOS interrupt function calls. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If you are using a word processor to develop your software, make sure that it is initialized &lt;br /&gt;to generate a pure ASCII file. The source file that you generate must use the extension .ASM that &lt;br /&gt;is required for the assembler to properly identify your source program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once your source file is prepared, it must be assembled. If you are using the workbench &lt;br /&gt;provided with version 6.X, assembling is accomplished by selecting the compile feature with &lt;br /&gt;your mouse. If you are using a word processor and DOS command lines with version 5.10, see &lt;br /&gt;Example A-I for the dialog for version 5.10 to assemble a file called FROG.ASM. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;709 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;710 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLEA-1 &lt;br /&gt;A&amp;gt;MASM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microsoft (R) Macro Assembler Version 5.10 &lt;br /&gt;Copyright (C) Microsoft Corp 1981, 1989. All rights reserved. &lt;br /&gt;Source filename [.ASM]:FROG &lt;br /&gt;Object filename [FROG.OBJ] : FROG &lt;br /&gt;List filename [NUL.LST] : FROG &lt;br /&gt;Cross reference [NUL.CRF] : FROG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Once a program is assembled, it must be linked before it can be executed. The linker con-&lt;br /&gt;verts the object file into an executable file (.EXE). Example A-2 shows the dialog required for &lt;br /&gt;the linker using an MASM version 5.10 object file. If the ML version 6.x assembler is in use, it &lt;br /&gt;automatically assembles and links a program using the COMPILE or BUILD command from &lt;br /&gt;workbench. After compiling with ML, workbench allows the program to be debugged with a de-&lt;br /&gt;bugging tool called code view. Code view is also available with MASM, but CV must be typed &lt;br /&gt;at the DOS command line to access it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLEA-2 &lt;br /&gt;A: \\&amp;gt;LINK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microsoft (R) Overlay Linker Version 3.64 &lt;br /&gt;Copyright (C) Microsoft Corp 1983-1988. All rights reserved. &lt;br /&gt;Object modules [.OBJ]:FROG &lt;br /&gt;Run file [FROG.EXE]:FROG &lt;br /&gt;List file [NUL.MAP] : FROG &lt;br /&gt;Libraries [.LIB] :SUBR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If MASM version 6.x is in use, the command line syntax differs from version 5.10. &lt;br /&gt;Example A-3 shows the command line syntax for ML, the assembler and linker for MASM &lt;br /&gt;version 6.x. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLEA-3 &lt;br /&gt;C:\\&amp;gt;ML /FITEST.LST TEST.ASM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microsoft (R) Macro Assembler Version 6.11 &lt;br /&gt;Copyright (C) Microsoft Corp 1981-1993. All rights reserved. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembling: TEST.ASM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Microsoft (R) Segmented-Executable Linker Version 5.13 &lt;br /&gt;Copyright (C) Microsoft Corp 1984-1993. All rights reserved. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Object Modules [.OBJ]: TEST.obj/t &lt;br /&gt;Run File [TEST.com]: &amp;quot;TEST. com&amp;quot; &lt;br /&gt;List File [NUL.MAP]: NUL &lt;br /&gt;Libraries [.LIB]: &lt;br /&gt;Definitions File [NUL.DEF]: ; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Version 6.x of the Microsoft MASM program contains the Programmer's Workbench &lt;br /&gt;program. Programmer's Workbench allows an as~;mbly language program to be developed with &lt;br /&gt;its full screen editor and tool bar. Figure A-I illustrates the display found with Programmer's &lt;br /&gt;Workbench. To access this program, type PWB at the DOS prompt. The make option allows a &lt;br /&gt;program to be automatically assembled and linked, making these tasks simple in comparison to &lt;br /&gt;version 5.10 of the assembler. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;ASSEMBLER MEMORY MODELS 711 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA SEGMENT &lt;br /&gt;33H ;position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POS DB .. , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA ENDS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CODE SEGMENT 'CODE' &lt;br /&gt;ASSUME CS:CODE,DS:DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PORTA EQU 40H ;port number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STEP PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,POS ;get position &lt;br /&gt;CMP CX,8000H &lt;br /&gt;JA RH ;if right-hand direction &lt;br /&gt;CMP CX,O &lt;br /&gt;JE STEP_OUT ;if no steps &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STEP1: &lt;br /&gt;ROL AL,1 ;step left &lt;br /&gt;OUT PORTA,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;N &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE A-1 The edit screen from Programmer's Workbench used to develop assembly lan-&lt;br /&gt;guage programs &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASSEMBLER MEMORY MODELS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory models and the .MODEL statement are introduced in Chapter 4 and used exclusively &lt;br /&gt;throughout the text. Here we completely define the memory models available for software devel-&lt;br /&gt;opment. Each model defines the way that a program is stored in the memory system. Table A-I &lt;br /&gt;describes the different models available with both MASM and ML. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Model Type &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tiny &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Small &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Medium &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Compact &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Large &lt;br /&gt;Huge &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Flat &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory models for the assembler &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Description &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;All data and code must fit into one segment. Tiny programs are written in .COM &lt;br /&gt;format, which means that the program must be originated at location 1 DOH. &lt;br /&gt;This model contains two segments: one data segment of 64K bytes and one &lt;br /&gt;code segment of 64K bytes. &lt;br /&gt;This model contains one data segment of 64K bytes and any number of code &lt;br /&gt;segments for large programs. &lt;br /&gt;One code segment contains the program, and any number of data segments &lt;br /&gt;contain the data. &lt;br /&gt;The large model allows any number of code and data segments. &lt;br /&gt;This model is the same as large, but the data segments may contain more &lt;br /&gt;than 64K bytes each. &lt;br /&gt;Only available to MASM 6.X. The flat model uses one segment of 512K bytes to &lt;br /&gt;store all data and code. Note that this model is mainly used with Windows NT. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;712 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note that the tiny model is used to create a .COM file instead of an execute file. The .COM &lt;br /&gt;file is different because all data and code fit into one code segment. A .COM file must use an &lt;br /&gt;origin of offset address 0 I OOR as the start of the program. A .COM file loads from the disk and &lt;br /&gt;executes faster than the normal execute (.EXE) file. For most applications, we normally use the &lt;br /&gt;execute file (.EXE) and the small memory model. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When models are used to create a program, certain defaults apply as illustrated in Table A-2. &lt;br /&gt;The directive in this table is used to start a particular type of segment for the models listed in the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLEA-2 Defaults for the .MODEL directive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Model Directives Name Align Combine . Class Group &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Tiny .CODE 3EXT word PUBLIC 'CODE' DGROUP &lt;br /&gt;.FARDATA FAR_DATA para private 'FAR_DATA' &lt;br /&gt;.FARDATA? FAR_BSS para private FAR_BSS &lt;br /&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA word PUBLIC DATA' DGROUP &lt;br /&gt;.CONST CONST word PUBLIC 'CONST' DGROUP &lt;br /&gt;. DATA? _BSS word PUBLIC 'BSS' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Small .CODE _TEXT word PUBLIC 'CODE' &lt;br /&gt;.FARDATA FAR_DATA para private 'FAR_DATA' &lt;br /&gt;.FARDATA? FAR_BSS para private 'FAR_BSS' &lt;br /&gt;. DATA _DATA word PUBLIC 'DATA' DGROUP &lt;br /&gt;.CONST CONST word PUBLIC 'CONST' DGROUP &lt;br /&gt;. DATA? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSS word PUBLIC 'BSS' DGROUP &lt;br /&gt;.STACK STACK para STACK 'STACK' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Medium CODE name_TEXT word PUBLIC 'CODE' &lt;br /&gt;.FARDATA FAR_DATA para private 'FAR_DATA' &lt;br /&gt;.FARDATA? FAR_BSS para private 'FAR_BSS' &lt;br /&gt;. DATA DATA word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUBLIC 'DATA' DGROUP &lt;br /&gt;.CONST CONST word PUBLIC 'CONST' DGROUP &lt;br /&gt;. DATA? _BSS word PUBLIC 'BS~' DGROUP &lt;br /&gt;.STACK STACK para STACK 'STACK' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Compact CODE 3EXT word PUBLIC 'CODE' &lt;br /&gt;.FARDATA FAR_DATA para private 'FAR_DATA' &lt;br /&gt;.FARDATA? FAR_BSS para private 'FAR_BSS' &lt;br /&gt;. DATA _DATA word PUBLIC 'DATA' DGROUP &lt;br /&gt;.CONST CONST word PUBLIC 'CONST' DGROUP &lt;br /&gt;. DATA? _BSS word PUBLIC 'BSS' DGROUP &lt;br /&gt;. STACK STACK para STACK 'STACK' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Large or CODE name_TEXT word PUBLIC &amp;quot; ODE' &lt;br /&gt;huge .FARDATA FAR_DATA para private '~AR_DATA' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.FARDATA? FAR_BSS para private 'FAR_BSS' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA _DATA word PUBLIC 'DATA' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CONST CONST word PUBLIC 'CONST' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA? _BSS word PUBLIC 'BSS' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STACK STACK para STACK 'STACK' DGROUP &lt;br /&gt;Flat CODE _TEXT dword PUBLIC 'CODE' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.FARDATA DATA dword PUBLIC 'DATA' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.FARDATA? _BSS dword PUBLIC 'FBSS' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA _DATA dword PUBLIC 'DATA' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CONST CONST dword PUBLIC 'CONST' DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA? &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSS dword PUBLIC 'BSS' DGROUP &lt;br /&gt;.STACK STACK dword STACK 'STACK' DGROUP &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;ASSEMBLER MEMORY MODELS 713 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;table. If the .CODE directive is placed in a program, it indicates the beginning of the code segment. &lt;br /&gt;Likewise, .DATA indicates the start of a data segment. The name column indicates the name of the &lt;br /&gt;segment. Align indicates whether the segment is aligned on a word, doubleword, or a 16-byte para-&lt;br /&gt;graph. Combine indicates the type of segment created. The class indicates the class of the segment, &lt;br /&gt;such as 'CODE' or 'DATA'. The group indicates the group type of the segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The directive from Table A-2 selects the type of information in a program. For example, &lt;br /&gt;.CODE is placed before the code. The name column is used if full-segment descriptions are &lt;br /&gt;mixed with the programming models for reference. The alignment specifies how the data in the &lt;br /&gt;segment are aligned. A para (paragraph) alignment starts a segment at the next paragraph, i.e., &lt;br /&gt;the next hexadecimal address ending in a DH. The combine column indicates how various seg-&lt;br /&gt;ments are combined and labeled (PUBLIC or private). The class is the actual segment name, and &lt;br /&gt;the group is the grouping of segments. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example A-4 shows a program that uses the small model. The small model is used for pro-&lt;br /&gt;grams that contain one DATA and one CODE segment. This applies to many programs that are &lt;br /&gt;developed. Notice that not only is the program listed, but so is all of the information generated by &lt;br /&gt;the assembler. Here the .DATA directive and .CODE directive indicate the start of each seg-&lt;br /&gt;ment. Also notice how the DS register is loaded in this program. As presented throughout the &lt;br /&gt;text, the .STARTUP directive can be used to load the data segment register, set up the stack, and &lt;br /&gt;define the starting address of a program. In this example, an alternate method (END BEGIN) is &lt;br /&gt;illustrated for loading the data segment register and defining the starting address of the program. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLEA-4 &lt;br /&gt;Microsoft (R) Macro Assembler Version 6.11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. MODEL SMALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STACK 100H &lt;br /&gt;0000 . DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 OA FROG DB 10 &lt;br /&gt;0001 0064 [ DATAl DB 100 DUP (2 ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 . CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 B8 - R BEGIN: MOV AX,DGROUP ;set up DS &lt;br /&gt;0003 8E D8 MOV DS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END BEGIN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segments and Groups: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;N a m e Size Length Align Combine Class &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DGROUP GROUP &lt;br /&gt;_DATA 16 Bit 0065 word Public 'DATA' &lt;br /&gt;STACK 16 Bit 0100 Para Stack 'STACK' &lt;br /&gt;_TEXT 16 Bit 0005 Word Public 'CODE' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Symbols: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;N a m e Type Value Attr &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;@CodeSize Number OOOOh &lt;br /&gt;@DataSize Number OOOOh &lt;br /&gt;@Interface Number OOOOh &lt;br /&gt;@Model Number 0002h &lt;br /&gt;@code Text _TEXT &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;714 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;@data &lt;br /&gt;@fardata? &lt;br /&gt;@fardata &lt;br /&gt;@stack &lt;br /&gt;BEGIN &lt;br /&gt;DATAl &lt;br /&gt;FROG . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o warnings &lt;br /&gt;o Errors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Text &lt;br /&gt;Text &lt;br /&gt;Text &lt;br /&gt;Text &lt;br /&gt;L Near &lt;br /&gt;Byte &lt;br /&gt;Byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DGROUP &lt;br /&gt;FAR_BSS &lt;br /&gt;FAR_DATA &lt;br /&gt;DGROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 _TEXT &lt;br /&gt;0001 _DATA &lt;br /&gt;0000 _DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example A-5 lists a program that uses the large model. Notice how it differs from the &lt;br /&gt;small model program of Example A-4. Models can be very useful in developing software, but &lt;br /&gt;often we use full segment descriptions as depicted in most examples in the text. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLEA-5 &lt;br /&gt;Microsoft (R) Macro Assembler Version 6.11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 00 &lt;br /&gt;0001 0064 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 54 68 69 73 20 &lt;br /&gt;73 20 61 20 63 &lt;br /&gt;61 72 61 63 74 &lt;br /&gt;72 20 73 74 72 &lt;br /&gt;6E 67 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001A 53 6F 20 69 73 &lt;br /&gt;74 68 69 73 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 OOOC &lt;br /&gt;0002 00C8 [ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 CB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segments and Groups: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DGROUP &lt;br /&gt;_DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;N a m e &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;69 &lt;br /&gt;68 &lt;br /&gt;65 &lt;br /&gt;69 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL LARGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.STACK 1000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.FARDATA? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FROG DB ? &lt;br /&gt;DATAl DW 100 DUP (?) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CONST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MES1 DB 'This is a character string' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MES2 DB 'So is this! ' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA2 DW 12 &lt;br /&gt;DATA3 DB 200 DUP (1) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FUNC PROC FAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FUNC ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;END FUNC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.' GROUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. 16 Bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Length Align Combine Class &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOCA Word Public 'DATA' &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 715 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STACK 16 Bit 1000 Para Stack 'STACK' &lt;br /&gt;CONST 16 Bit 0025 Word Public 'CONST' &lt;br /&gt;EeadOnly &lt;br /&gt;EZA_TEXT 16 Bit 0001 Word Public 'CODE' &lt;br /&gt;FAE_BSS 16 Bit 00C9 Para Private 'FAR_BSS' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXT 16 Bit 0000 Word Public 'CODE' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Procedures, parameters and locals: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~l a m e Type Val'-1e Attr &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FUNC P Far 0000 EXA_TEXT Length= 0001 Public &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Symbols: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;N a m e Type Value Attr &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;@CodeSize Number 0001h &lt;br /&gt;@DataSize Number 0001h &lt;br /&gt;@Interface Number OOOOh &lt;br /&gt;@Model Number 0005h &lt;br /&gt;@code Text EXA_TEXT &lt;br /&gt;@data Text DGROUP &lt;br /&gt;@fardata? Text FAR_BSS &lt;br /&gt;@fardata Text FAR_DATA &lt;br /&gt;@stack Text DGROUP &lt;br /&gt;DATAl Word 0001 FAR_BSS &lt;br /&gt;DATA2 Word 0000 DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA3 Byte 0002 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA &lt;br /&gt;FROG Byte 0000 FAR_BSS &lt;br /&gt;MES1 Byte 0000 CONST &lt;br /&gt;NES2 Byte 001A CONST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 Warnings &lt;br /&gt;0 Errors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOS FUNCTION CALLS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to use DOS function calls, always place the function number into register AH and load &lt;br /&gt;all other pertinent information into registers as described in the table as entry data. Once this is &lt;br /&gt;accomplished, follow with an INT 21H to execute the DOS function. Example A-6 shows how &lt;br /&gt;to display an ASCII A on the CRT screen at the current cursor position with a DOS function call. &lt;br /&gt;Table A-3 is a complete listing of the DOS function calls. Note that some function calls require &lt;br /&gt;a segment and offset address, indicated as DS:DI, for example. This means that the data segment &lt;br /&gt;is the segment address and DI is the offset address. All of the function calls use INT 21H, and &lt;br /&gt;AH contains the function call number. Note that functions marked with an @ should not be used &lt;br /&gt;unless DOS version 2.XX is in use. Also note that not all function numbers are implemented. As &lt;br /&gt;a rule, DOS function calls save all registers not used as exit data, but in certain cases some regis-&lt;br /&gt;ters may change. In order to prevent problems, it is advisable to save registers where problems &lt;br /&gt;occur. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLEA-6 &lt;br /&gt;0000 B4 06 &lt;br /&gt;0002 B2 41 &lt;br /&gt;0004 CD 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,6 &lt;br /&gt;MOV DL, 'A' &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;load function 06H &lt;br /&gt;select letter 'A' &lt;br /&gt;call DOS function &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;716 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-3 DOS function calls (pp. 716-738) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH TERMINATE A PROGRAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OOH &lt;br /&gt;CS = program segment prefix address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit DOS is entered &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01H READ THE KEYBOARD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =01H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = ASCII character &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes If AL = OOH the function call must be invoked again to read an &lt;br /&gt;extended ASCII character. Refer to Chapter 9, Table 9-1, for a &lt;br /&gt;listing of the extended ASCII keyboard codes. This function call &lt;br /&gt;automatically echoes whatever is typed to the video screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H WRITE TO STANDARD OUTPUT DEVICE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 02H &lt;br /&gt;DL = ASCII character to be displayed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function call normally displays data on the video display. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03H READ CHARACTER FROM COM1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 03H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = ASCII character read from the communications port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function call reads data from the serial communications port. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H WRITE TO COM1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry ~H= 04H &lt;br /&gt;DL = character to be sent out of COM1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function transmits data through the serial communications port. &lt;br /&gt;The COM port assignment can be changed to use other COM ports &lt;br /&gt;with functions 03H and 04H by using the DOS MODE command to &lt;br /&gt;reassign COM1 to another COM port. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 717 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSH WRITE TO LPT1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 05H &lt;br /&gt;CL = ASCII character to be printed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Prints DL on the line printer attached to LPT1. Note that the line &lt;br /&gt;printer port can be changed with the DOS MODE command. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSH DIRECT CONSOLE READIWRITE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =06H &lt;br /&gt;DL = OFFH or DL = ASCII character &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = ASCII character &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes If bL = OFFH on entry, then this function reads the console. If DL = &lt;br /&gt;ASCII character, then this function displays the ASCII character on &lt;br /&gt;the console (CON) video screen. &lt;br /&gt;If a character is read from the console keyboard, the zero flag (ZF) &lt;br /&gt;indicates whether a character was typed. A zero condition indicates &lt;br /&gt;no key was typed, and a not-zero condition indicates that AL contains &lt;br /&gt;the ASCII code of the key or a OOH. If AL = OOH, the function must &lt;br /&gt;again be invoked to read an extended ASCII character from the &lt;br /&gt;keyboard. Note that the key does not echo to the video screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07H DIRECT CONSOLE INPUT WITHOUT ECHO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 07H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = ASCII character &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This functions exactly as function number 06H with DL = OFFH, but it &lt;br /&gt;will not return from the function until the key is typed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;08H READ STANDARD INPUT WITHOUT ECHO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 08H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = ASCII character &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Performs as function 07H, except that it reads the standard input &lt;br /&gt;device. The standard input device can be assigned as either the &lt;br /&gt;keyboard or the COM port. This function also responds to a control-&lt;br /&gt;break, where function 06H and 07H do not. A control-break causes &lt;br /&gt;INT 23H to execute. By default, this functions as does function 07H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;718 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;09H DISPLAY A CHARACTER STRING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =09H &lt;br /&gt;OS:OX = address of the character string &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The character string must end with an ASCII $ (24H). The character &lt;br /&gt;string can be of any length and may contains control characters such &lt;br /&gt;as carriage return (OOH) and line feed (OAH). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAH BUFFERED KEYBOARD INPUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=OAH &lt;br /&gt;OS:OX = address of keyboard input buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The first byte of the buffer contains the size of the buffer (up to 255). &lt;br /&gt;The second byte is filled with the number of characters typed upon &lt;br /&gt;return. The third byte through the end of the buffer contains the &lt;br /&gt;character string typed followed by a carriage return (OOH). This &lt;br /&gt;function continues to read the keyboard (displaying data as typed) &lt;br /&gt;until either the specified number of characters are typed or until the &lt;br /&gt;enter key is typed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBH TEST STATUS OF THE STANDARD INPUT DEVICE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=OBH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = status of the input device &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function tests the standard input device to determine if data are &lt;br /&gt;available. If AL = 00, no data are available. If AL = OFFH, then data &lt;br /&gt;are available that must be input using function number OSH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH CLEAR KEYBOARD BUFFER AND INVOKE &lt;br /&gt;KEYBOARD FUNCTION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OCH &lt;br /&gt;AL = 01 H, 06H, 07H, or OAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit See exit for functions 01 H, 06H, 07H, or OAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The keyboard buffer holds keystrokes while programs execute other &lt;br /&gt;tasks. This function empties or clears the buffer and then invokes the &lt;br /&gt;keyboard function located in register AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH FLUSH DISK BUFFERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Erases all file names stored in disk buffers. This function does &lt;br /&gt;not close the files specified by the disk buffers, so care must be &lt;br /&gt;exercised in its usage. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 719 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEH SELECT DEFAULT DISK DRIVE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OEH &lt;br /&gt;DL = desired def;:lult disk drive numbet &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = the total number of drives present in the system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Drive A = OOH, drive B = 01 H, drive C = 02H, and so forth. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFH @OPEN FILE WITH FCB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OFH &lt;br /&gt;DS:DX = address of the unopened file control block (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if file found &lt;br /&gt;AL = OFFH if file not found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The file control block (FCB) is only used with early DOS software &lt;br /&gt;and should never be used with new programs. File control blocks &lt;br /&gt;do not allow path names as do the newer file access function codes &lt;br /&gt;presented later. Figure A-2 (p. 738) illustrates the structure of the &lt;br /&gt;FCB. To open a file, the file must either be present on the disk or be &lt;br /&gt;created with function call 16H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H @CLOSE FILE WITH FCB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 10H &lt;br /&gt;DS:DX = address of the opened file control block (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if file closed &lt;br /&gt;AL = OFFH if error found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Errors that occurs usually indicate either that the disk is full or the &lt;br /&gt;media is bad. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11H @SEARCH FOR FIRST MATCH (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 11H &lt;br /&gt;DS:DX = address of the file control block to be searched &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if file found &lt;br /&gt;AL = OFFH if file not found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Wild card characters (? or 0) may be used to search for a file name. &lt;br /&gt;The? wild card character matches any character and the 0 matches &lt;br /&gt;any name or extension. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;720 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12H @SEARCH FOR NEXT MATCH (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 12H &lt;br /&gt;DS:DX = address of the file control block to be searched &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if file found &lt;br /&gt;AL = OFFH if file not found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function is used after function 11 H finds the first matching file &lt;br /&gt;name, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13H @DELETE FILE USING FCB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 13H &lt;br /&gt;DS:DX = address of the file control block to be deleted &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if file deleted &lt;br /&gt;AL = OFFH if error occurred &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Errors that most often occur are defective media errors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14H @SEOUENTIAL READ (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 14H &lt;br /&gt;DS:DX = address of the file control block to be read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if read successful &lt;br /&gt;AL = 01 H if end of file reached &lt;br /&gt;AL = 02H if DT A had a segment wrap &lt;br /&gt;AL = 03H if less than 128 bytes were read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15H @SEOUENTIAL WRITE (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 15H &lt;br /&gt;DS:DX = address of the file control block to be written &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if write successful &lt;br /&gt;AL = 01 H if disk is full &lt;br /&gt;AL = 02H if DTA had a segment wrap &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16H @CREATE A FILE (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 16H &lt;br /&gt;DS:DX = address of an unopened file control block &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if file created &lt;br /&gt;AL = 01 H if disk is full &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 721 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17H @RENAME A FILE (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 17H &lt;br /&gt;DS:DX = address of a modified file control block &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if file renamed &lt;br /&gt;AL = 01 H if error occurred &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Refer to Figure A-3 (p. 738) for the modified FCB used to rename a file. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19H RETURN CURRENT DRIVE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 19H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = current drive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes AL = OOH for drive A, 01 H for drive B, and so forth. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1AH SET DISK TRANSFER AREA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 1AH &lt;br /&gt;DS:DX = address of new DTA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The disk transfer area is normally located within the program &lt;br /&gt;segment prefix at offset address 80H. The DTA is used by DOS &lt;br /&gt;for all disk data transfers using file control blocks. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1BH GET DEFAULT DRIVE FILE ALLOCATION TABLE &lt;br /&gt;(FAT) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 1BH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = number of sectors per cluster &lt;br /&gt;DS:BX = address of the media-descriptor &lt;br /&gt;CX = size of a sector in by1es &lt;br /&gt;OX = number of clusters on drive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Refer to Figure A-4 (p. 739) for the format of the media-descriptor &lt;br /&gt;by1e. The OS register is changed by this function, so make sure to &lt;br /&gt;save it before using this function. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1CH GET ANY DRIVE FILE ALLOCATION TABLE (FAT) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 1CH &lt;br /&gt;DL = disk drive number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = number of sectors per cluster &lt;br /&gt;DS:BX = address of the media-descriptor &lt;br /&gt;CX = size of a sector in bytes &lt;br /&gt;OX = number of clusters on drive &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;722 APPENDIX A THE ASSEMBLER, DiSK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21H @RANDOM READ USING FCB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 21H &lt;br /&gt;DS:DX = address of opened FeB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if read successful -&lt;br /&gt;AL = 01 H if end of file reached &lt;br /&gt;AL = 02H if the segment wrapped &lt;br /&gt;AL = 03H if less than 128 bytes read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22H @RANDOM WRITE USING FCB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=22H &lt;br /&gt;DS:DX = address of opened FeB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if write successful &lt;br /&gt;AL = 01 H if disk full &lt;br /&gt;AL = 02H if the segment wrapped &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;23H @RETURN NUMBER OF RECORDS (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =23H &lt;br /&gt;DS:DX = address of FeB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH number of records &lt;br /&gt;AL = OFFH if file not found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24H @SET RELATIVE RECORD SIZE (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 24H &lt;br /&gt;DS:DX = address of FeB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Sets the record field to the value contained in the FeB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;25H SET INTERRUPT VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =25H &lt;br /&gt;AL = interrupt vector number &lt;br /&gt;DS:DX = address of new interrupt procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Before changing the interrupt vector, it is suggested that the current &lt;br /&gt;interrupt vector first be saved using DOS function 35H. This allows a &lt;br /&gt;back-link so the original vector can later be restored. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26H CREATE NEW PROGRAM SEGMENT PREFIX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry :\\H = 26H &lt;br /&gt;OX = segment address of new PSP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Figure A-5 (p. 739) illustrates the structure of the program segment &lt;br /&gt;prefix. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 723 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27H @RANDOM FILE BLOCK READ (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 27H &lt;br /&gt;ex = the number of records &lt;br /&gt;DS:DX = address of opened FeB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if read successful &lt;br /&gt;AL = 01 H if end of file reached &lt;br /&gt;AL = 02H if the segment wrapped &lt;br /&gt;AL = 03H if less than 128 bytes read &lt;br /&gt;ex = the number of records read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28H @RANDOM FILE BLOCK WRITE (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =28H &lt;br /&gt;ex = the number of records &lt;br /&gt;DS:DX = address of opened FeB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if write successful &lt;br /&gt;AL = 01 H if disk full &lt;br /&gt;AL = 02H if the segment wrapped &lt;br /&gt;ex = the number of records written &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;29H @PARSE COMMAND LINE (FCB) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =29H &lt;br /&gt;AL = parse mask &lt;br /&gt;DS:SI = address of FeB &lt;br /&gt;DS:DI = address of command line &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if no file name characters found &lt;br /&gt;AL = 01 H if file name characters found &lt;br /&gt;AL = OFFH if drive specifier incorrect &lt;br /&gt;DS:SI = address of character after name &lt;br /&gt;DS:DI = address first byte of FeB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2AH READ SYSTEM DATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=2AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = day of the week &lt;br /&gt;ex = the year (1980-2099) &lt;br /&gt;DH = the month &lt;br /&gt;DL = day of the month &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The day of the week is encoded as Sunday = OOH through Saturday = &lt;br /&gt;06H. The year is a binary number equal to 1980 through 2099. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;724 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2BH SET SYSTEM DATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 2BH &lt;br /&gt;CX = the year (1980-2099) &lt;br /&gt;DH = the month &lt;br /&gt;DL = day of the month &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2CH READ SYSTEM TIME &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=2CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit CH = hours (0-23) &lt;br /&gt;CL= minutes &lt;br /&gt;DH = seconds &lt;br /&gt;DL = hundredths of seconds &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes All times are returned in binary form, and hundredths of seconds may &lt;br /&gt;not be available. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2DH SET SYSTEM TIME &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 2DH &lt;br /&gt;CH = hours &lt;br /&gt;CL = minutes &lt;br /&gt;DH = seconds &lt;br /&gt;DL = hundredths of seconds &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2EH DISK VERIFY WRITE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=2EH &lt;br /&gt;AL = OOH to disable verify on write &lt;br /&gt;AL = 01 H to enable verify on write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes By default, disk verify is disabled. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2FH READ DISK TRANSFER AREA ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 2FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit ES:BX = contains DTA address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30H READ DOS VERSION NUMBER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 30H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = fractional version number &lt;br /&gt;AL = whole number version number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes For example, DOS version number 3.2 is returned as a 3 in AL and a &lt;br /&gt;14H in AH. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 725 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;31H TERMINATE AND STAY RESIDENT (TSR) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 31H &lt;br /&gt;AL = the DOS return code &lt;br /&gt;OX = number of paragraphs to reserve for program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes A paragraph is 16 bytes and the DOS return code is read at the &lt;br /&gt;batch file level with ERRORCODE. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33H TEST CONTROL-BREAK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =33H &lt;br /&gt;AL = OOH to request current control-break &lt;br /&gt;AL = 01 H to change control-break &lt;br /&gt;DL = OOH to disable control-break &lt;br /&gt;DL = 01 H to enable control-break &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit DL = current control-break state &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34H GET ADDRESS OF InDOS FLAG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 34H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit ES:BX = address of InDOS flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The In DOS flag is available in DOS versions 3.2 or newer and &lt;br /&gt;indicates DOS activity. If InDOS = OOH, DOS is inactive or OFFH if &lt;br /&gt;DOS is active and pursuing another operation. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3SH REt\\b INTERRUPT VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =35H &lt;br /&gt;AL = interrupt vector number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit ES:BX = address stored at vector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This DOS function is used with function 25H to instalVremove &lt;br /&gt;interrupt handlers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3SH DETERMINE FREE DISK SPACE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 36H &lt;br /&gt;DL = drive number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = FFFFH if drive invalid &lt;br /&gt;AX = number of sectors per cluster &lt;br /&gt;BX = number of free clusters &lt;br /&gt;CX = bytes per sector &lt;br /&gt;OX = number of clusters on drive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The default disk drive is DL = OOH, drive A = 01 H, drive B = 02H, &lt;br /&gt;and so forth. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;726 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38H RETURN COUNTRY CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 38H &lt;br /&gt;AL = OOH for current country code &lt;br /&gt;BX = 16-bit country code &lt;br /&gt;DS:DX = data buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;BX = counter code &lt;br /&gt;DS:DX = data buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;39H CREATE SUB-DIRECTORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =39H &lt;br /&gt;DS:DX = address of ASCII-Z string sUbdirectory name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The ASCII-Z string is the name of the subdirectory in ASCII code &lt;br /&gt;ended with a OOH instead of a carriage return/line feed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3AH ERASE SUB-DIRECTORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=3AH &lt;br /&gt;DS:DX = address of ASCII-Z string subdirectory name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3SH CHANGE SUB-DIRECTORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH= 3BH , &lt;br /&gt;DS:DX = address of new ASCII-Z string subdirectory name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3CH CREATE A NEW FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=3CH &lt;br /&gt;CX = attribute word &lt;br /&gt;DS:DX = address of ASCII-Z string file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;AX = file handle if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The attribute word can contain any of the following (added together): &lt;br /&gt;01 H read-only access, 02H = hidden file or directory, 04H = system &lt;br /&gt;file, 08H = volume label, 10H = subdirectory, and 20H = archive bit. &lt;br /&gt;In most cases, a file is created with OOOOH. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 727 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3DH OPEN A FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 3DH &lt;br /&gt;AL = access code &lt;br /&gt;DS:DX = address of ASCII-Z string file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;AX = file handle if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The access code in AL = OOH for a read-only access, AL = 01 H &lt;br /&gt;for a write-only access, and AL = 02H fgr a read/write access. &lt;br /&gt;For shared files in a network envirof&amp;quot;!ment, bit 4 of AL = 1 will deny &lt;br /&gt;read/write access, bit 5 of AL = 1 wi!&amp;quot;1 deny a write access, bits 4 and &lt;br /&gt;5 of AL = 1 will deny read access, bit 6 of AL = 1 denies none, bit 7 &lt;br /&gt;of AL = 0 causes the file to be inherited by child; if bit 7 of AL = 1, &lt;br /&gt;file is restricted to current process. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3EH CLOSE A FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 3EH &lt;br /&gt;BX = file handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;3FH READ A FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 3FH &lt;br /&gt;BX = file handle &lt;br /&gt;CX = number of by1es to be read &lt;br /&gt;DS:DX = address of file buffer to hold data read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;AX = number of bytes read if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40H WRITE A FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =40H &lt;br /&gt;BX = file handle &lt;br /&gt;CX = number of by1es to write &lt;br /&gt;DS:DX = address of file bllffer that holds write data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;AX = number of bytes written if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;41H DELETE A FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 41H &lt;br /&gt;DS:DX = address of ASCII-Z string file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;728 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;42H MOVE FILE POINTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 42H &lt;br /&gt;AL = move technique &lt;br /&gt;BX = file handle &lt;br /&gt;CX:DX = number of bytes pOinter moved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;AX:DX = bytes pointer moved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The move technique causes the pointer to move from the start of the &lt;br /&gt;file if AL = OOH, from the current location if AL = 01 H, and from the &lt;br /&gt;end of the file if AL = 02H. The count is stored so DX contains the &lt;br /&gt;least-significant 16-bits and either CX or AX contains the most-&lt;br /&gt;significant 16-bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;43H READIWRITE FILE ATTRIBUTES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =43H &lt;br /&gt;AL = OOH to read attributes &lt;br /&gt;AL = 01 H to write attributes &lt;br /&gt;CX = attribute word (see function 3CH) &lt;br /&gt;DS:DX = address of ASCII-Z string file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;CX = attribute word of carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;44H I/O DEVICE CONTROL (IOTCL) &lt;br /&gt;Entry AH = 44H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL = sub function code (see notes) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code (see function 59H) if carry set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The sub function codes found in AL are as follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH = read device status &lt;br /&gt;Entry: BX = file handle &lt;br /&gt;Exit: DX = status &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 H = write device status &lt;br /&gt;Entry: BX = file handle, DH = 0, DL = device information &lt;br /&gt;Exit: AX = error code if carry set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H = read control data from character device &lt;br /&gt;Entry: BX = file handle, CX = number of bytes, DS:DX = 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;buffer address &lt;br /&gt;Exit: AX = number of bytes read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03H = write control data to character device &lt;br /&gt;Entry: BX = file handle, CX = number of bytes, DS:DX = 1/0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;buffer address &lt;br /&gt;Exit: AX = number of bytes written &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H = read control data from block device &lt;br /&gt;Entry: BL = drive number (0 = default, 1 = A, 2 = B, etc), &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CX = number of bytes, OS:OX = I/O buffer address &lt;br /&gt;Exit: AX = number of bytes read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSH = write control data to block device &lt;br /&gt;Entry: BL = drive number, CX = number of bytes, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS:OX = 110 buffer address &lt;br /&gt;Exit: AX = number of bytes written &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06H = check input status &lt;br /&gt;Entry: BX = file handle &lt;br /&gt;Exit: AL = OOH ready or FFH not ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07H = check output status &lt;br /&gt;Entry: BX = file handle &lt;br /&gt;Exit: AL = OOH ready or FFH not ready &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;08H = removable media? &lt;br /&gt;Entry: BL = drive number &lt;br /&gt;Exit: AL = OOH removable, 01 H fixed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;09H = network block device? &lt;br /&gt;Entry: BL = drive number &lt;br /&gt;Exit: bit 12 of OX set for network block device &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAH = local or network character device? &lt;br /&gt;Entry: BX = file handle &lt;br /&gt;Exit: bit 15 of OX set for network character device &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBH = change entry count (must have SHARE.EXE loaded) &lt;br /&gt;Entry: CX = delay loop count, OX = retry count &lt;br /&gt;Exit: AX = error code if carry set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH = generic 110 control for character devices &lt;br /&gt;Entry: BX = file handle, CH = category, CL = function &lt;br /&gt;Categories: OOH = unknown, 01 H = COM port, 02H = &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CON, OSH = LPT ports &lt;br /&gt;Function: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CL = 4SH; set iteration count &lt;br /&gt;CL = 4AH; select code page &lt;br /&gt;CL = 4CH; start code page preparation &lt;br /&gt;CL = 40H; end code page preparation &lt;br /&gt;CL = SFH; set display information &lt;br /&gt;CL = 6SH; get iteration count &lt;br /&gt;CL = 6AH; query selected code page &lt;br /&gt;CL = 6BH; query preparation list &lt;br /&gt;CL = 7FH; get display information &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH = generic 110 control for block devices &lt;br /&gt;Entry: BL = drive number, CH = category, CL = function, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OS:OX = address of parameter block &lt;br /&gt;Category: 08H = disk drive &lt;br /&gt;Function: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CL = 40H; set device parameters &lt;br /&gt;CL = 41H; write track &lt;br /&gt;CL = 42H; format and verify track &lt;br /&gt;CL = 46H, set media 10 code &lt;br /&gt;CL = 47H; set access flag &lt;br /&gt;CL = 60H; get device parameters &lt;br /&gt;CL = 61 H; read track &lt;br /&gt;CL = 62H; verify track &lt;br /&gt;CL = 66H; get media 10 code &lt;br /&gt;CL = 67H; get access code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;729 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;730 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEH = return logical device map &lt;br /&gt;Entry: BL = drive number &lt;br /&gt;Exit: AL = number of last device &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFH = change logical device map &lt;br /&gt;Entry: BL = drive number &lt;br /&gt;Exit: AL = number of last device &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;45H DUPLICATE FILE HANDLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=45H &lt;br /&gt;BX = current file handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;AX = duplicate file handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;46H FORCE DUPLICATE FILE HANDLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=46H &lt;br /&gt;BX = current file handle &lt;br /&gt;ex = new file handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function works like function 45H except that function 45H allows &lt;br /&gt;DOS to select the new handle, while this function allows the user to &lt;br /&gt;select the new handle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;47H READ CURRENT DIRECTORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =47H &lt;br /&gt;DL = drive number &lt;br /&gt;DS:SI = address of a 64 byte buffer for directory name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit DS:SI addresses current directory name if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Drive A = 00, drive B = 01, and so forth &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48H ALLOCATE MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=48H &lt;br /&gt;BX = number of paragraphs to allocate &lt;br /&gt;ex = new file handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = largest block available if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;49H RELEASE ALLOCATED MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =49H &lt;br /&gt;ES = segment address of block to be released &lt;br /&gt;ex = new file handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit earry indicates an error if set &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 731 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4AH MODIFY ALLOCATED MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 4AH &lt;br /&gt;BX = new block size in paragraphs &lt;br /&gt;ES = segment address of block to be modified &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = largest block availabie if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4BH LOAD OR EXECUTE A PROGRAM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =4BH &lt;br /&gt;AL = function code &lt;br /&gt;ES:BX = address of parameter block &lt;br /&gt;DS:DX = address ASCII-Z string command &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry indicates an error if set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The function codes are AL = OOH to load and execute a program, &lt;br /&gt;AL = 01 H to load a program but not execute it, AL = 03H to load a &lt;br /&gt;program overlay, and AL = OSH to enter the EXEC state. Figure A-6 &lt;br /&gt;(p. 740) shows the parameter block used with this function. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4CH TERMINATE A PROCESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =4CH &lt;br /&gt;AL = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Returns control to DOS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function returns control to DOS with the error code saved so &lt;br /&gt;it can be obtained using DOS ERROR LEVEL batch processing &lt;br /&gt;system. We normally use this function with an error code of OOH to &lt;br /&gt;return to DOS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4DH READ RETURN CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 4DH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = return error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function is used to obtain the return status code created by &lt;br /&gt;executing a program with DOS function 4BH. The return codes are &lt;br /&gt;AX = OOOOH for a normal-no error-termination, AX = 0001 H for a &lt;br /&gt;control-break termination, AX = 0002H for a critical device error, and &lt;br /&gt;AX = 0003H for a termination by an INT 31 H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;732 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 110 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4EH FIND FIRST MATCHING FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 4EH &lt;br /&gt;CX = file attributes &lt;br /&gt;OS:OX = address ASCII-Z string file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for file not found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function searches the current or named directory for the first &lt;br /&gt;matching file, Upon exit, the OTA contains the file information, See &lt;br /&gt;Figure A-7 (p, 740) for the disk transfer area (OTA), &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4FH FIND NEXT MATCHING FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 4FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for file not found &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function is used after the first file is found with function 4EH, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50H SET PROGRAM SEGMENT PREFIX (PSP) ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 50H &lt;br /&gt;BX = offset address of the new PSP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Extreme care must be used with this function because no error &lt;br /&gt;recovery is possible, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;51H GET PSP ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 51H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = current PSP segment address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;54H READ DISK VERIFY STATUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 54H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = OOH if verify off &lt;br /&gt;AL = 01 H if verify on &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;56H RENAME FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 56H &lt;br /&gt;ES:DI = address of ASCII-Z string containing new file name &lt;br /&gt;OS:DX = address of ASCII-Z string containing file to be renamed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 733 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;57H READ FILE'S DATE AND TIME STAMP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 57H &lt;br /&gt;AL = function code &lt;br /&gt;BX = file handle &lt;br /&gt;CX = new time &lt;br /&gt;OX = new date &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;ex = lime if carry cleaied &lt;br /&gt;OX = date if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes AL = OOH to read date and time or 01 H to write date and time. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;59H GET EXTENDED ERROR INFORMATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 59H &lt;br /&gt;BX = OOOOH for DOS version 3.X &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = extended error code &lt;br /&gt;BH = error class &lt;br /&gt;BL = recommended action &lt;br /&gt;CH = locus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Following are the extended error codes found in AX: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 H = invalid function number &lt;br /&gt;0002H = file not found &lt;br /&gt;0003H = path not found &lt;br /&gt;0004H = no file handles available &lt;br /&gt;0005H = access denied &lt;br /&gt;0006H = file handle invalid &lt;br /&gt;0007H = memory control block failure &lt;br /&gt;0008H = insufficient memory &lt;br /&gt;0009H = memory block address invalid &lt;br /&gt;OOOAH = environment failure &lt;br /&gt;OOOBH = format invalid &lt;br /&gt;OOOCH = access code invalid &lt;br /&gt;OOODH = data invalid &lt;br /&gt;OOOEH = unknown unit &lt;br /&gt;OOOFH = disk drive invalid &lt;br /&gt;0010H = attempted to remove current directory &lt;br /&gt;0011 H = not same device &lt;br /&gt;0012H = no more files &lt;br /&gt;0013H = disk write-protected &lt;br /&gt;0014H = unknown unit &lt;br /&gt;0~15H = drive not ready &lt;br /&gt;0016H = unknown command &lt;br /&gt;0017H = data error (CRC check error) &lt;br /&gt;OQ18H = bad request structure length &lt;br /&gt;0019H = seek error &lt;br /&gt;001AH = unknown media type &lt;br /&gt;001 BH = sector not found &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;734 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001 CH = printer out of paper &lt;br /&gt;001 DH = write fault &lt;br /&gt;001 EH = read fault &lt;br /&gt;001 FH = general failure &lt;br /&gt;0020H = sharing violation &lt;br /&gt;0021 H = lock violation &lt;br /&gt;0022H = disk change invalid &lt;br /&gt;0023H = FeB unavailable &lt;br /&gt;0024H = sharing buffer exceeded &lt;br /&gt;0025H = code page mismatch &lt;br /&gt;0026H = handle end of file operation not completed &lt;br /&gt;0027H = disk full &lt;br /&gt;0028H-0031 H reserved &lt;br /&gt;0032H = unsupported network request &lt;br /&gt;0033H = remote machine not listed &lt;br /&gt;0034H = duplicate name on network &lt;br /&gt;0035H = network name not found &lt;br /&gt;0036H = network busy &lt;br /&gt;0037H = device no longer exists on network &lt;br /&gt;0038H = netBIOS command limit exceeded &lt;br /&gt;0039H = error in network adapter hardware &lt;br /&gt;003AH = incorrect response from network &lt;br /&gt;003BH = unexpected network error &lt;br /&gt;003CH = remote adapter is incompatible &lt;br /&gt;003DH = print queue is full &lt;br /&gt;003EH = not enough room for print file &lt;br /&gt;003FH = print file was deleted &lt;br /&gt;0040H = network name deleted &lt;br /&gt;0041 H = network access denied &lt;br /&gt;0042H = incorrect network device type &lt;br /&gt;0043H = network name not found &lt;br /&gt;0044H = network name exceeded limit &lt;br /&gt;0045H = netBIOS session limit exceeded &lt;br /&gt;0046H = temporary pause &lt;br /&gt;0047H = network request not accepted &lt;br /&gt;0048H = print or disk redirection pause &lt;br /&gt;0049H-004FH reserved &lt;br /&gt;0050H = file already exists &lt;br /&gt;0051H = duplicate FCB &lt;br /&gt;0052H = cannot make directory &lt;br /&gt;0053H = failure in INT 24H (critical error) &lt;br /&gt;0054H = too many re-directions &lt;br /&gt;0055H = duplicate redirection &lt;br /&gt;0056H = invalid password &lt;br /&gt;0057H = invalid parameter &lt;br /&gt;0058H = network write failure &lt;br /&gt;0059H = function not supported by network &lt;br /&gt;005AH = required system component not installed &lt;br /&gt;0065H = device not selected &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Following are the error class codes as found in BH: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 H = no resources available &lt;br /&gt;02H = temporary error &lt;br /&gt;03H = authorization error &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 735 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H = internal software error &lt;br /&gt;05H = hardware error &lt;br /&gt;06H = system failure &lt;br /&gt;07H = application software error &lt;br /&gt;OSH = item not found &lt;br /&gt;09H = invalid format &lt;br /&gt;OAH = item blocked &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I OBH = media error OCH = item already exists ODH = unknown error &lt;br /&gt;Following is the recommended action as found in BL: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 H = retry operation &lt;br /&gt;02H = delay and retry operation &lt;br /&gt;03H = user retry &lt;br /&gt;04H = abort processing &lt;br /&gt;05H = immediate exit &lt;br /&gt;06H = ignore error &lt;br /&gt;07H = retry with user intervention &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Following is a list of locus in CH: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 H = unknown source &lt;br /&gt;02H = block device error &lt;br /&gt;03H = network area &lt;br /&gt;04H = serial device error &lt;br /&gt;05H = memory error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5AH CREATE UNIQUE FILE NAME &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =5AH &lt;br /&gt;CX = attribute code &lt;br /&gt;DS:DX = address of the ASCII-Z string directory path &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;AX = file handle if carry cleared &lt;br /&gt;DS:DX = address of the appended directory name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The ASCII-Z file directory path must end with a backslash (\\). On exit, &lt;br /&gt;the directory name is appended with a unique file name. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5BH CREATE A DOS FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =5BH &lt;br /&gt;CX = attribute code &lt;br /&gt;DS:DX = address of the ASCII-Z string contain the file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;AX = file handle if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The function only works in DOS version 3.X or higher. It is almost &lt;br /&gt;identical to function 3CH, except that function 3CH erases the file, if it &lt;br /&gt;already exists, while function 5BH reports that the file exists without &lt;br /&gt;erasing it. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;736 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5CH LOCK/UNLOCK FILE CONTENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 5CH &lt;br /&gt;BX = file handle &lt;br /&gt;CX:DX = offset address of locked/unlocked area &lt;br /&gt;SI:DI = number of bytes to lock or unlock beginning at offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50H SET EXTENDED ERROR INFORMATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=5DH &lt;br /&gt;AL= OAH &lt;br /&gt;DS:DX = address of the extended error data structure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function is used by DOS version 3.1 or higher to store extended &lt;br /&gt;error information. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5EH NETWORK/PRINTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 5EH &lt;br /&gt;AL = OOH (get network name) &lt;br /&gt;DS:DX = address of the ASCII-Z string containing network name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;CL = netBIOS number if carry cleared &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 5EH &lt;br /&gt;AL = 02H (define network printer) &lt;br /&gt;BX = redirection list &lt;br /&gt;CX = length of setup string &lt;br /&gt;DS:DX = address of printer setup buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 5EH &lt;br /&gt;AL = 03H (read network printer setup string) &lt;br /&gt;BX = redirection list &lt;br /&gt;DS:DX = address of printer setup buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;CX = length of setup string if carry cleared &lt;br /&gt;ES:DI = address of printer setup buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62H GET PSP ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 62H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = segment address of the current program &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The function only works in DOS version 3.0 or higher. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS 737 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;65H GET EXTENDED COUNTRY INFORMATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 65H &lt;br /&gt;AL = function code &lt;br /&gt;ES:DI = address of buffer to receive information &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;CX = length of country information &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The function only works in DOS version 3.3 or higher. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;66H GET/SET CODE PAGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 66H &lt;br /&gt;AL = function code &lt;br /&gt;BX = code page number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;BX = active code page number &lt;br /&gt;OX = default code page number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes A function code in AL of 01 H gets the code page number, and a code &lt;br /&gt;of 02H sets the code page number. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;67H SET HANDLE COUNT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 67H &lt;br /&gt;BX = number of handles desired &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function is available for DOS version 3.3 or higher. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;68H COMMIT FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 68H &lt;br /&gt;BX = handle number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry is set for error condition; otherwise, the date and time stamp is &lt;br /&gt;written to directory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function is available for DOS version 3.3 or higher. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;738 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6CH EXTENDED OPEN FILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 6CH &lt;br /&gt;AL= OOH &lt;br /&gt;BX = open mode &lt;br /&gt;CX = attributes &lt;br /&gt;OX = open flag &lt;br /&gt;DS:SI = address of ASCII-Z string file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = error code if carry is set &lt;br /&gt;AX = handle if carry is cleared &lt;br /&gt;CX = 0001 H file existed and was opened &lt;br /&gt;CX = 0002H file did not exist and was created &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function is available for DOS version 4.0 or higher. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGUREA-2 Contents of Offset Contents &lt;br /&gt;the file control block (FCB) OOH Drive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01H 8-character filename &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;09H 3-character file extension &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH Current block number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEH Record size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H File size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14H Creation date &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16H Reserved space &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20H Current record number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21H Relative record number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGUREA-3 Contents of Offset Contents &lt;br /&gt;the modified file control block OOH (FCB) Drive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01H 8-character filename &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;09H 3-character extension &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH Current block number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEH Record size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H File size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14H Creation date &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16H Second file name &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DOS FUNCTION CALLS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE A-4 Contents &lt;br /&gt;of the media-descriptor &lt;br /&gt;byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE A-5 Contents of &lt;br /&gt;the program segment prefix &lt;br /&gt;(PSP) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 6 5 4 3 &lt;br /&gt;? ? ? ? ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit 0 = 0 if not two-sided &lt;br /&gt;= 1 if two-sided &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;? ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit 1 = 0 if not eight sectors per track &lt;br /&gt;= 1 if eight sectors per track &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit 2 = 0 if nonremovable &lt;br /&gt;= 1 if removable &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Contents &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Top of memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH &lt;br /&gt;02H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;05H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAH &lt;br /&gt;Number of bytes in segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5CH &lt;br /&gt;6CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;81H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Terminate address &lt;br /&gt;(offset) &lt;br /&gt;Terminate address &lt;br /&gt;(segment) &lt;br /&gt;Control-break address &lt;br /&gt;(offset) &lt;br /&gt;Control-break address &lt;br /&gt;(segment) &lt;br /&gt;Critical error address &lt;br /&gt;(offset) &lt;br /&gt;Critical error address &lt;br /&gt;(segment) &lt;br /&gt;Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Environment address &lt;br /&gt;(segment) &lt;br /&gt;Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOS call &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;File control block 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;File control block 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Command line length &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Command line &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;739 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;740 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE A-6 The para-&lt;br /&gt;meter blocks used with func-&lt;br /&gt;tion 4BH (EXEC). (a) For &lt;br /&gt;function code OOH. (b) For &lt;br /&gt;function code 03H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE A-7 Data transfer &lt;br /&gt;area (DT A) used to find a file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIOS FUNCTION CALLS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset &lt;br /&gt;OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;08H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(a) &lt;br /&gt;Contents &lt;br /&gt;Environment address (segment) &lt;br /&gt;Command line address (offset) &lt;br /&gt;Command line address (segment) &lt;br /&gt;File control block 1 address (offset) &lt;br /&gt;File control block 1 address (segment) &lt;br /&gt;File control block 2 address (segment) &lt;br /&gt;File control block 2 address (offset) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) &lt;br /&gt;Offset Contents &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH Overlay destination segment address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H Relocation factor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15H &lt;br /&gt;16H &lt;br /&gt;18H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1AH &lt;br /&gt;1CH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Contents &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Attributes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Creation time &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Creation date &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Low word file size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;High word file size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Search file name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In addition to DOS function call INT 2lH, some other BIOS function calls are useful in control-&lt;br /&gt;ling the I/O environment of the computer. Unlike INT 2lH, which exists in the DOS program, &lt;br /&gt;the BIOS function calls are found stored in the system and video BIOS ROMs. These BIOS &lt;br /&gt;ROM functions directly control the I/O devices with or without DOS loaded into a system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 10H &lt;br /&gt;The INT IOH BIOS interrupt is often called the video services interrupt because it directly con-&lt;br /&gt;trols the video display in a system. The INT IOH instruction uses register AH to select the video &lt;br /&gt;service provided by this interrupt. The video BIOS ROM is located on the video board and varies &lt;br /&gt;from one video card to another. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Video Mode Selection. The mode of operatio;- for the video display is accomplished by placing &lt;br /&gt;a OOH into AH, followed by one of many mode numbers in AL. Table A-4lists the modes of op-&lt;br /&gt;eration found in video display systems using standard video modes. The VGA can use any mode &lt;br /&gt;listed, while the other displays are more restrictive in use. Additional higher resolution modes &lt;br /&gt;are explained later in this section. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;BIOS FUNCTION CALLS 741 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-4 Video display modes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode Type Columns Rows Resolution Standard Colors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH Text 40 25 320 x 200 eGA 2 &lt;br /&gt;OOH Text 40 25 320 x 250 EGA 2 &lt;br /&gt;OOH Text 40 25 360 x 400 VGA 2 &lt;br /&gt;01H Text 40 25 320 x 200 eGA 16 &lt;br /&gt;01H Text 40 25 320 x 350 EGA 16 &lt;br /&gt;01H Text 40 25 360 x 640 VGA 16 &lt;br /&gt;02H Text 80 25 640 x200 eGA &amp;quot; Co &lt;br /&gt;02H Text 80 25 640 x350 EGA 2 &lt;br /&gt;02H Text 80 25 720 x 400 VGA 2 &lt;br /&gt;03H Text 80 25 640 x 200 eGA 16 &lt;br /&gt;03H Text 80 25 640 x 350 EGA 16 &lt;br /&gt;03H Text 80 25 720 x 400 VGA 16 &lt;br /&gt;04H Graphics 80 25 320 x 200 eGA 4 &lt;br /&gt;05H Graphics 80 25 320 x 350 eGA 2 &lt;br /&gt;06H Graphics 80 25 640 x 200 eGA 2 &lt;br /&gt;07H Text 80 25 720 x 350 EGA 4 &lt;br /&gt;07H Text 80 25 720 x 400 VGA 4 &lt;br /&gt;OOH Graphics 80 25 320 x 200 eGA 16 &lt;br /&gt;OEH Graphics 80 25 640 x 200 eGA 16 &lt;br /&gt;OFH Graphics 80 25 640 x 350 EGA 4 &lt;br /&gt;10H Graphics 80 25 640 x 350 EGA 16 &lt;br /&gt;11 H Graphics 80 30 640 x 480 VGA 2 &lt;br /&gt;12H Graphics 80 30 640 x 480 VGA 16 &lt;br /&gt;13H Graphics 40 25 320 x 200 VGA 256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example A-7 lists a short sequence of instructions that place the video display into mode &lt;br /&gt;03H operation. This mode is available on CGA, EGA, and VGA displays. This mode allows the &lt;br /&gt;display to draw test data with 16 colors at various resolutions dependent upon the display adapter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE A-7 &lt;br /&gt;0000 B4 00 &lt;br /&gt;0002 BO 03 &lt;br /&gt;0004 CD 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,O &lt;br /&gt;MOV AL,3 &lt;br /&gt;INT 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;select mode &lt;br /&gt;;mode is 03H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Cursor Control and Other Standard Features. Table A-5 shows the function codes (placed in &lt;br /&gt;AH) used to control the cursor on the video display. These cursor control functions will work on &lt;br /&gt;any video display from the CGA display to the latest super VGA display. It also lists the func-&lt;br /&gt;tions used to display data and change to a different character set. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-5 Video BIOS (INT 10H) functions (pp. 741-744) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH SELECT VIDEO MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OOH &lt;br /&gt;AL = mode number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Mode changed and screen cleared &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;742 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01H SELECT CURSOR TYPE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =01H &lt;br /&gt;CH = starting line number &lt;br /&gt;CL = ending line number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Cursor size changed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H SELECT CURSOR POSITION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=02H &lt;br /&gt;BH = page number (usually 0) &lt;br /&gt;DH = row number (beginning with 0) &lt;br /&gt;DL = column number (beginning with 0) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Changes cursor to new position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03H READ CURSOR POSITION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =03H &lt;br /&gt;BH = page number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit CH = starting line (cursor size) &lt;br /&gt;CL = ending line (cursor size) &lt;br /&gt;DH = current row &lt;br /&gt;DL = current column &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H READ LIGHT PEN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 04H (not supported in VGA) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AH = 0, light pen triggered &lt;br /&gt;BX = pixel column &lt;br /&gt;CX = pixel row &lt;br /&gt;DH = character row &lt;br /&gt;DL = character column &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSH SELECT DISPLAY PAGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OSH &lt;br /&gt;AL = page number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Page number selected. Following are the valid page numbers: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Mode 0 and 1 support pages 0-7 &lt;br /&gt;Mode 2 and 3 support pages 0-7 &lt;br /&gt;Mode 4, 5, and 6 support page 0 &lt;br /&gt;Mode 7 and 0 support pages 0-7 &lt;br /&gt;Mode E supports pages 0-3 &lt;br /&gt;Mode F and 10 support pages 0-1 &lt;br /&gt;Mode 11, 12, and 13 support page 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Most modern displays use page 0 for most operations. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;BIOS FUNCTION CALLS 743 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06H SCROLL PAGE UP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 06H &lt;br /&gt;AL = number of lines to &amp;quot;,..roll (0 clears window) &lt;br /&gt;BH = character attribute for new lines &lt;br /&gt;CH = top row of scroll window &lt;br /&gt;CL = left column of scroll window &lt;br /&gt;DH = bottom row of scroll window &lt;br /&gt;DL = right column of scroll window &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Scrolls window from the bottom toward the top of the screen. Blank &lt;br /&gt;lines fill the bottom using the character attribute in BH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07H SCROLL PAGE DOWN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =07H &lt;br /&gt;AL = number of lines to scroll (0 clears window) &lt;br /&gt;BH = character attribute for new lines &lt;br /&gt;CH = top row of scroll window &lt;br /&gt;CL = left columnÂ· of scroll window &lt;br /&gt;DH = bottom row of scroll window &lt;br /&gt;DL = right column of scroll window &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Scrolls window from the top toward the bottom of the screen. Blank &lt;br /&gt;lines fill from the top using the character attribute in BH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;08H READ ATTRIBUTE/CHARACTER AT CURRENT &lt;br /&gt;CURSOR POSITION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =08H &lt;br /&gt;BH = page number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = ASCII character code &lt;br /&gt;AH = character attribute &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function does not advance the cursor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;09H WRITE ATTRIBUTE/CHARACTER AT CURRENT &lt;br /&gt;CURSOR POSITION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH =09H &lt;br /&gt;AL = ASCII character code &lt;br /&gt;BH = page number &lt;br /&gt;BL = character attribute &lt;br /&gt;CX = number of characters to write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function does not advance the cursor. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;744 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAH WRITE CHARACTER AT CURRENT CURSOR &lt;br /&gt;POSITION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH=OAH &lt;br /&gt;AL = ASCII character code &lt;br /&gt;BH = page number &lt;br /&gt;CX = number of characters to write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function does not advance the cursor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFH READ VIDEO MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = OFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AL = current video mode &lt;br /&gt;AH = number of character columns &lt;br /&gt;BH = page number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H SET VGA PALETTE REGISTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 10H &lt;br /&gt;AL = 10H &lt;br /&gt;BX = color number (0-255) &lt;br /&gt;CH = green (0-63) &lt;br /&gt;CL = blue (0-63) &lt;br /&gt;DH = red (0-63) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Palette register color is changed. Note: The first 16 colors (0-15) are &lt;br /&gt;used in the 16-color, VGA text mode and other modes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H READ VGA PALETTE REGISTER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 10H &lt;br /&gt;AL= 15H &lt;br /&gt;BX = color number (0-255) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit CH = green &lt;br /&gt;CL= blue &lt;br /&gt;DH = red &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11H GET ROM CHARACTER SET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AH = 11H &lt;br /&gt;AL=30H &lt;br /&gt;BH = 2 = ROM 8 x 14 character set &lt;br /&gt;BH = 3 = ROM 8 x 8 character set &lt;br /&gt;BH = 4 = ROM 8 x 8 extended character set &lt;br /&gt;BH = 5 = ROM 9 x 14 character set &lt;br /&gt;BH = 6 = ROM 8 x 16 character set &lt;br /&gt;BH = 7 = ROM 9 x 16 character set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit CX = bytes per character &lt;br /&gt;DL = rows per character &lt;br /&gt;ES:BP = address of character set &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;BIOS FUNCTION CALLS 745 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If an SVGA (super VGA), EVGA (extended VGA). or XVGA (also extended VGA) &lt;br /&gt;adapter is available. the super VGA mode is set by using INT IOH function cal1 AX = 4F02H &lt;br /&gt;with BX = to the VGA mode for these advanced display adapters. This confom1s to the VESA &lt;br /&gt;standard for VGA adaph;r~. Table A-6 shows the modes selected by register BX for this INT &lt;br /&gt;IOH function call. Most vidt 0 cards are equipped with a driver called VVESA.COM or &lt;br /&gt;VVESA.SYS that conforms the card to the VESA standard functions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 11 H &lt;br /&gt;This function is used to determine the type of equipment instal1ed in the system. To use this call, &lt;br /&gt;the AX register is loaded with an FFFFH, and then the INT IlH instruction is executed. In re-&lt;br /&gt;turn, an INT IlH provides information as listed in Figure A-8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 12H &lt;br /&gt;The memory size is returned by the INT 12H instruction. After executing the INT 12H instruc-&lt;br /&gt;tion, the AX register contains the number of lK-byte blocks of memory (conventional memory &lt;br /&gt;in the first 1M byte of address space) installed in the computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 13H &lt;br /&gt;This call controls the diskettes (5 1/.{' or 31h&amp;quot;) and also fixed or hard disk drives attached to the &lt;br /&gt;system. Table A-7 lists the functions available to this interrupt via register AH. The direct con-&lt;br /&gt;trol of a floppy disk or hard disk can lead to problems. Therefore, we only provide a listing of the &lt;br /&gt;functions without detail on their usage. Before using these functions, refer to the BIOS literature &lt;br /&gt;available from the company that produced your version of the BIOS ROM. Never use these &lt;br /&gt;functions for normal disk operations. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-6 Extended VGA &lt;br /&gt;functions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE A-8 The contents &lt;br /&gt;of AX as it indicates the &lt;br /&gt;equipment attached to the &lt;br /&gt;computer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ax Extended Mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100H 640 x 400 with 256 colors &lt;br /&gt;101 H 640 x 480 with 256 colors &lt;br /&gt;102H 800 x 600 with 16 colors &lt;br /&gt;103H 800 x 600 with 256 colors &lt;br /&gt;104H 1,024 x 768 with 16 colors &lt;br /&gt;105H 1,024 x 768 with 256 colors &lt;br /&gt;106H 1,280 x 1,024 with 16 colors &lt;br /&gt;107H 1,280 x 1,024 with 256 colors &lt;br /&gt;108H 80 x 60 in text mode &lt;br /&gt;109H 132 x 25 in text mode &lt;br /&gt;10AH 132 x 43 in text mode &lt;br /&gt;10SH 132 x 50 in text mode &lt;br /&gt;10CH 132 x 60 in text mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 &lt;br /&gt;IP11poI 1 G 1821811801021011 1 1 1 1 1 1 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;P1, PO = number of parallel ports &lt;br /&gt;G = 1 if game 1/0 attached &lt;br /&gt;82, 81, 80 = number of serial ports &lt;br /&gt;02, 01 = number of disk drives &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;746 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-7 Disk I/O func-&lt;br /&gt;tion via INT 13H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 14H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH Reset the system disk &lt;br /&gt;01 H Read disk status to AL &lt;br /&gt;02H Read sector &lt;br /&gt;03H Write sector &lt;br /&gt;04H Verify sector &lt;br /&gt;05H Format track &lt;br /&gt;06H FoÂ·rmat bad track &lt;br /&gt;07H Format drive &lt;br /&gt;OSH Get drive parameters &lt;br /&gt;09H Initialize fixed disk characteristics &lt;br /&gt;OAH Read long sector &lt;br /&gt;OBH Write long sector &lt;br /&gt;OCH Seek &lt;br /&gt;ODH Reset fixed disk system &lt;br /&gt;OEH Read sector buffer &lt;br /&gt;OFH Write sector buffer &lt;br /&gt;10H Get drive status &lt;br /&gt;11 H Re-calibrate drive &lt;br /&gt;12H Controller RAM diagnostics &lt;br /&gt;13H Controller drive diagnostics &lt;br /&gt;14H Controller internal diagnostics &lt;br /&gt;15H Get disk type &lt;br /&gt;16H Get disk changed status &lt;br /&gt;17H Set disk type &lt;br /&gt;iSH Set media type &lt;br /&gt;19H Park heads &lt;br /&gt;1 AH Format ESDI drive &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Interrupt 14H controls the serial COM (communications) ports attached to the computer. The &lt;br /&gt;computer system contains two COM ports, COM1 and COM2, unless you have a newer AT-&lt;br /&gt;style machine, where the number of communications ports are extended to COM3 and COM4. &lt;br /&gt;Communications ports are normally controlled with software packages that allow data transfer &lt;br /&gt;through a modem and the telephone lines. The INT 14H instruction controls these ports, as illus-&lt;br /&gt;trated in Table A-8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-a COM port &lt;br /&gt;interrupt INT 14H AH Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH Initialize communications port &lt;br /&gt;01 H Send character &lt;br /&gt;02H Receive character &lt;br /&gt;03H Get COM port status &lt;br /&gt;04H Extended initialize communications port &lt;br /&gt;05H Extended communications port control &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;BIOS FUNCTION CALLS 747 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 15H &lt;br /&gt;The INT I5H instruction controls many of the various I/O devices interfaced to the computer. &lt;br /&gt;It also allows access to protected mode operation and the extended memory system on an &lt;br /&gt;80286-Pentium Pro, but it is not recommended. Table A-9 lists the functions supported by &lt;br /&gt;INT I5H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 16H &lt;br /&gt;The INT I6H instruction is used as a keyboard interrupt. This interrupt is accessed by DOS in-&lt;br /&gt;terrupt INT 21H, but can be accessed directly. Table A-lO shows the functions performed by &lt;br /&gt;INT 16H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-9 The I/O sub-&lt;br /&gt;system interrupt INT 15H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-10 Keyboard &lt;br /&gt;interrupt INT 16H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH Cassette motor on &lt;br /&gt;01 H Cassette motor off &lt;br /&gt;02H Read cassette &lt;br /&gt;03H Write cassette &lt;br /&gt;OFH Format ESDI periodic interrupt &lt;br /&gt;21 H Keyboard intercept &lt;br /&gt;80H Device open &lt;br /&gt;81 H Device closed &lt;br /&gt;82H Process termination &lt;br /&gt;83H Event wait &lt;br /&gt;84H Read joystick &lt;br /&gt;85H System request key &lt;br /&gt;86H Delay &lt;br /&gt;87H Move extended block of memory &lt;br /&gt;88H Get extended memory size &lt;br /&gt;89H Enter protected mode &lt;br /&gt;90H Device wait &lt;br /&gt;91 H Device power on self test (POST) &lt;br /&gt;COH Get system environment &lt;br /&gt;C1 H Get address of extended BIOS data area &lt;br /&gt;C2H Mouse pointer &lt;br /&gt;C3H Set watchdog timer &lt;br /&gt;C4H Programmable option select &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AH Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH Read keyboard character &lt;br /&gt;01 H Get keyboard status &lt;br /&gt;02H Get keyboard flags &lt;br /&gt;03H Set repeat rate &lt;br /&gt;04H Set keyboard click &lt;br /&gt;05H Push character and scan code &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;748 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 110 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 17H &lt;br /&gt;The INT 17H instruction accesses the parallel printer port, usually labeled LPTI in most sys-&lt;br /&gt;tems, Table A-II lists the three functions available for the INT 17H instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DOS Low Memory Assignments &lt;br /&gt;Table A-12 shows the low memory assignments (OOOOOH-OOSFFH) for the DOS-based micro-&lt;br /&gt;processor system. This area of memory contains the interrupt vectors, BIOS data area, and the &lt;br /&gt;DOSIBIOS data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-11 Parallel print-&lt;br /&gt;er interrupt INT 17H AH Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH Print character &lt;br /&gt;01 H Initialize printer &lt;br /&gt;02H Get printer status &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-12 DOS low memory assignments &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Location Purpose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000H-002FFH &lt;br /&gt;00300H-Q03FFH &lt;br /&gt;00400H-Q0407H &lt;br /&gt;00408H-0040FH &lt;br /&gt;00410H-Q0411H &lt;br /&gt;00412H &lt;br /&gt;00413H-00414H &lt;br /&gt;00415H-Q0416H &lt;br /&gt;00417H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00418H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;System interrupt vectors &lt;br /&gt;System interrupt vectors, power on, and bootstrap area &lt;br /&gt;COM1-COM4110 port base addresses &lt;br /&gt;LPT1-LPT4 liD port base addresses &lt;br /&gt;Equipment flag word, returned in AX by INT 11 H (refer to Figure A-8) &lt;br /&gt;Reserved &lt;br /&gt;Memory size in K byte (0-640K) &lt;br /&gt;Reserved &lt;br /&gt;Keyboard control byte &lt;br /&gt;Bit Purpose &lt;br /&gt;7 I nsert locked &lt;br /&gt;6 Caps locked &lt;br /&gt;5 Numbers locked &lt;br /&gt;4 Scroll locked &lt;br /&gt;3 Alternate key pressed &lt;br /&gt;2 Control key pressed &lt;br /&gt;1 Left shift key pressed &lt;br /&gt;o Right shift key pressed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Keyboard control byte &lt;br /&gt;Bit Purpose &lt;br /&gt;7 Insert key pressed &lt;br /&gt;6 Caps lock key pressed &lt;br /&gt;5 Numbers lock key pressed &lt;br /&gt;4 Scroll lock key pressed &lt;br /&gt;3 Pause key pressed &lt;br /&gt;2 System request key pressed &lt;br /&gt;1 Left alternate key pressed &lt;br /&gt;o Right control key pressed &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;MOUSE FUNCTIONS 749 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-12 (continued) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Location Purpose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00419H &lt;br /&gt;0041 AH-0041 BH &lt;br /&gt;0041 CH-0041 DH &lt;br /&gt;0041 EH-0043DH &lt;br /&gt;0043EH-00448H &lt;br /&gt;00449H-00466H &lt;br /&gt;00467H-0046BH &lt;br /&gt;0046CH-0046FH &lt;br /&gt;00470H &lt;br /&gt;00471H &lt;br /&gt;00472H-00473H &lt;br /&gt;00474H-00477H &lt;br /&gt;004 78H-004 7BH &lt;br /&gt;0047CH-0047FH &lt;br /&gt;00480H-00481H &lt;br /&gt;00482H-00483H &lt;br /&gt;00484H-0048AH &lt;br /&gt;0048BH-00495H &lt;br /&gt;00496H &lt;br /&gt;00497H &lt;br /&gt;00498H-00499H &lt;br /&gt;0049AH-0049BH &lt;br /&gt;0049CH-0049FH &lt;br /&gt;004AOH &lt;br /&gt;004A1H-004A7H &lt;br /&gt;004A8H-004ABH &lt;br /&gt;004ACH-004EFH &lt;br /&gt;004FOH-004FFH &lt;br /&gt;00500H &lt;br /&gt;00501H-00503H &lt;br /&gt;00504H &lt;br /&gt;00505H-0050FH &lt;br /&gt;0051 OH-00521 H &lt;br /&gt;00522H-0052FH &lt;br /&gt;00530H-00533H &lt;br /&gt;00534H-005FFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOUSE FUNCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Alternate keyboard entry &lt;br /&gt;Keyboard buffer header pointer &lt;br /&gt;Keyboard buffer tail pointer &lt;br /&gt;32-byte keyboard buffer area &lt;br /&gt;Disk drive control area &lt;br /&gt;Video control area &lt;br /&gt;Reserved &lt;br /&gt;Timer counter &lt;br /&gt;Timer overflow &lt;br /&gt;Break key state &lt;br /&gt;Reset flag &lt;br /&gt;Hard disk drive data area &lt;br /&gt;LPT1-LPT4 time-out area &lt;br /&gt;COM1-COM4 time-out area &lt;br /&gt;Keyboard buffer start offset pointer &lt;br /&gt;Keyboard buffer end offset pointer &lt;br /&gt;Video control data area &lt;br /&gt;Hard disk control area &lt;br /&gt;Keyboard mode, state, and type flag &lt;br /&gt;Keyboard LED flags &lt;br /&gt;Offset address of user wait complete flag &lt;br /&gt;Segment address of user wait complete flag &lt;br /&gt;User wait count &lt;br /&gt;Wait active flag &lt;br /&gt;Reserved &lt;br /&gt;Pointer to video parameters &lt;br /&gt;Reserved &lt;br /&gt;Applications program communications area &lt;br /&gt;~rint screen status &lt;br /&gt;Reserved &lt;br /&gt;Single drive mode status &lt;br /&gt;Reserved &lt;br /&gt;Used by ROM BASIC &lt;br /&gt;Used by DOS for disk initialization &lt;br /&gt;Used by the MODE command &lt;br /&gt;Reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The mouse is controlled and adjusted with INT 33H function call instructions. These functions &lt;br /&gt;provide complete control over the mouse and information provided by the mouse driver pro-&lt;br /&gt;gram. Table A-13 lists the mouse INT 33H functions by number and details the parameters re-&lt;br /&gt;quired and any notes needed to use them. Refer to Chapter 7 for a discussion of the mouse driver &lt;br /&gt;and some example programs that access the mouse functions through INT 33H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;750 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-13 The mouse (INT 33H) functions (pp. 750-761) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH RESET MOUSE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = number of mouse buttons &lt;br /&gt;Both software and hardware are reset to their default values &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The default values are listed below: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CRT Page=O &lt;br /&gt;Cursor = off &lt;br /&gt;Current cursor position = center of screen &lt;br /&gt;Minimum horizontal position = 0 &lt;br /&gt;Minimum vertical position = 0 &lt;br /&gt;Maximum horizontal position = maximum for display mode &lt;br /&gt;Maximum vertical position = maximum for display mode &lt;br /&gt;Horizontal mickey-to-pixel ratio = 1 to 1 &lt;br /&gt;Vertical mickey-to-pixel ration = 2 to 1 &lt;br /&gt;Double-speed threshold = 64 per second &lt;br /&gt;Graphics cursor = arrow &lt;br /&gt;Text cursor = reverse block &lt;br /&gt;Light-pen emulation = on &lt;br /&gt;Interrupt call mask = 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01H SHOW MOUSE CURSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 01H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Displays the mouse cursor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;02H HIDE MOUSE CURSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 02H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Hides the mouse cursor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes When displaying data on the screen, it is important to hide the mouse &lt;br /&gt;cursor. Â·If you don't, problems with the display will occur and the &lt;br /&gt;computer may reset and reboot. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03H READ MOUSE STATUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 03H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = button status &lt;br /&gt;CX = horizontal c Irsor position &lt;br /&gt;DX = vertical cursor position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The right bit (bit 0) of BX contains the status of the left mouse button &lt;br /&gt;and bit 1 contains the status of the right mouse button. A logic 1 &lt;br /&gt;indicates the button is active. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;MOUSE FUNCTIONS 751 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;04H SET MOUSE CURSOR POSITION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 04H &lt;br /&gt;ex = horizontal position . &lt;br /&gt;OX = vertical position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSH GET BUnON PRESS INFORMATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=05H &lt;br /&gt;BX = desired button (0 for left and 1 for right) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = button status &lt;br /&gt;BX = number of presses &lt;br /&gt;ex = horizontal position of last press &lt;br /&gt;OX = vertical position of last press &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06H GET BUTTON RELEASE INFORMATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL =06H &lt;br /&gt;BX = desired button &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = button status &lt;br /&gt;BX = number of releases &lt;br /&gt;ex = horizontal position of last release &lt;br /&gt;OX = vertical position of last release &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07H SET HORIZONTAL BOUNDARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=07H &lt;br /&gt;ex = minimum horizontal position &lt;br /&gt;OX = maximum horizontal position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Horizontal boundary is changed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OSH SET VERTICAL BOUNDARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=08H &lt;br /&gt;ex ,;, minimum vertical position &lt;br /&gt;OX = maximum vertical position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Vertical boundary is changed. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;752 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;09H SET GRAPHICS CURSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=09H &lt;br /&gt;BX = horizontal center &lt;br /&gt;CX = vertical center &lt;br /&gt;ES:OX = address of 16 x 16 bit map of cursor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit New graphics cursor installed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The center is where the mouse pointer position is set. For example, a &lt;br /&gt;center of 0,0 is the upper left comer and 15,15 is the lower right comer. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The pixel bit map mask is stored at the address passed through &lt;br /&gt;ES:OX and is a 16 x 16 array. Following the pixel bit mask is the &lt;br /&gt;cursor mask, also 16 x 16. The contents of the bit map mask are &lt;br /&gt;AN Oed with a 16 x 16 portion of the video display, after which the &lt;br /&gt;contents of the cursor mask are Exclusive-ORed with a 16 x 16 &lt;br /&gt;portion of the video display to produce a cursor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAH SET TEXT CURSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=OAH &lt;br /&gt;BX = cursor type (0 = software, 1 = hardware) &lt;br /&gt;CX = pixel bit mask or beginning scan line &lt;br /&gt;OX = cursor mask or ending scan line &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Changes the text cursor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBH READ MOTION COUNTERS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= OBH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit CX = horizontal distance &lt;br /&gt;OX = vertical distance &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Returns the distance traveled by the mouse since the last call to this &lt;br /&gt;function. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;MOUSE FUNCTIONS 753 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCH SET INTERRUPT SUBROUTINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=OCH &lt;br /&gt;CX = interrupt mask &lt;br /&gt;E5:0X = address of interrupt service procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit New interrupt handler is installed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The interrupt mask defines the actions that request the installed &lt;br /&gt;interrupt handler. Following is a list of the actions that cause the &lt;br /&gt;interrupt when placed in the interrupt mask. Note that these actions &lt;br /&gt;can appear singly or in combination. For example, an interrupt mask &lt;br /&gt;of 8 plus 2 or 10 (OAH) causes an interrupt for either the left or right &lt;br /&gt;mouse buttons. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 = any change in cursor position &lt;br /&gt;2 = left mouse button pressed &lt;br /&gt;4 = left mouse button released &lt;br /&gt;8 = right mouse button pressed &lt;br /&gt;16 = right mouse button released &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After the installation, interrupt is called by one of the selected &lt;br /&gt;changes. The following registers contain information about the &lt;br /&gt;mouse: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX = interrupt mask &lt;br /&gt;BX = button status &lt;br /&gt;CX = horizontal position &lt;br /&gt;OX = vertical position &lt;br /&gt;51 = horizontal change &lt;br /&gt;01 = vertical change &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH ENABLE LIGHT-PEN EMULATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= OOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit light-pen emulation is enabled. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used whenever the mouse must replace the action of a light-pen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEH DISABLE LIGHT-PEN EMULATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = OEH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit light-pen emulation is disabled. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used to disable light-pen emulation. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;754 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OFH SET MICKEY-TO-PIXEL RATIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= OFH &lt;br /&gt;CX = horizontal ratio &lt;br /&gt;OX = vertical ratio &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Mickey-to-pixel ratio changed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function allows the screen-tracking speed of the mouse cursor &lt;br /&gt;to be changed. The default value is 1. If it is changed to 2, the normal &lt;br /&gt;speed will be reduced by half. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10H BLANK MOUSE CURSOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 10H &lt;br /&gt;CX = left comer &lt;br /&gt;OX = upper position &lt;br /&gt;SI = right comer &lt;br /&gt;01 = bottom position &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Blanks the cursor in the window specified. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The mouse pOinter is blanked in the area of the screen selected by &lt;br /&gt;registers CX, OX, SI, and 01. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;13H SET DOUBLE-SPEED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 13H &lt;br /&gt;OX = threshold value &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Changes the threshold for double-speed pointer movement. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The default threshold value for mouse pointer acceleration is 64. This &lt;br /&gt;default threshold is changed by this function to any other value. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14H SWAP INTERRUPTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 14H &lt;br /&gt;CX = interrupt mask &lt;br /&gt;ES:OX = interrupt service procedure address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit CX = old interrupt mask &lt;br /&gt;ES:OX = old interrupt service procedure address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes As with mouse INT 33H function OCH, function 14H also installs a &lt;br /&gt;new interrupt handler. The difference is that function 14H replaces the &lt;br /&gt;handler already installed with function OCH. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;MOUSE FUNCTIONS 755 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;15H GET MOUSE STATE SIZE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 15H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = size of buffer required to store mouse state &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Indicates the amount of memory required to store the state of the &lt;br /&gt;mouse with mouse function INT 33H number 16H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16H SAVE MOUSE STATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 16H &lt;br /&gt;ES:OX = address where state of mouse is stored &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Saves the current state of the mouse. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17H RELOAD MOUSE STATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 17H &lt;br /&gt;ES:OX = address where state of mouse is stored &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Reloads the saved state of the mouse. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18H SET ALTERNATE INTERRUPT SUBROUTINE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 18H &lt;br /&gt;CX = alternate interrupt mask &lt;br /&gt;ES:OX = address of alternate interrupt service procedure &lt;br /&gt;Carry = 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Alternate interrupt handler is installed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The alternate interrupt handler is accessed after the primary handler. &lt;br /&gt;The alternate interrupt mask defines the actions that request the &lt;br /&gt;altemate interrupt handler. Following is a list of the actions that cause &lt;br /&gt;an altemate interrupt when placed in the alternate interrupt mask: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 = any change in cursor position &lt;br /&gt;2 = left mouse button pressed &lt;br /&gt;4 = left mouse button released &lt;br /&gt;8 = right mouse button pressed &lt;br /&gt;16 = right mouse button released &lt;br /&gt;32 = shift key with mouse button &lt;br /&gt;64 = control key with mouse button &lt;br /&gt;128 = alternate key with mouse button &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After the installation, interrupt is called by one of the selected changes. &lt;br /&gt;The following registers contain information about the mouse: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 &lt;br /&gt;AX = interrupt mask (see function OCH) &lt;br /&gt;BX = button status &lt;br /&gt;CX = horizontal position &lt;br /&gt;OX = vertical position &lt;br /&gt;SI = horizontal change &lt;br /&gt;01 = vertical change &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;756 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19H GET ALTERNATE INTERRUPT ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 19H &lt;br /&gt;CX = alternate interrupt mask &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = -1 if unsuccessful &lt;br /&gt;ES:OX = address of interrupt service procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used to read the address of the alternate interrupt handler. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1AH SET MOUSE SENSITIVITY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 1AH &lt;br /&gt;BX = horizontal sensitivity &lt;br /&gt;CX = vertical sensitivity &lt;br /&gt;OX = double-speed threshold &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Sensitivity is changed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The default values for vertical and horizontal sensitivity are both 50. &lt;br /&gt;The default value for the double-speed threshold is 64. The values for &lt;br /&gt;sensitivity range between 1 and 100, which represent ratios of &lt;br /&gt;between 33 to 350 percent. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1BH GET MOUSE SENSITIVITY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 1BH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = horizontal sensitivity &lt;br /&gt;CX = vertical sensitivity &lt;br /&gt;OX = double-speed threshold &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1CH SET INTERRUPT RATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 1CH &lt;br /&gt;BX = number of interrupts per second &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Changes the interrupt rate for the InPort mouse only. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The default value is 30 interrupts per second, but this can be changed &lt;br /&gt;to any value listed: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a = interrupt off &lt;br /&gt;1 = 30 interrupts per second &lt;br /&gt;2 = 50 interrupts per second &lt;br /&gt;3 = 100 interrupts per second &lt;br /&gt;4 = 200 interrupts per second &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;MOUSE FUNCTIONS 757 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1DH SET CRT PAGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 1DH &lt;br /&gt;ax = CRT page number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Changes to a new CRT page for mouse cursor support. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1EH GET CRT PAGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 1EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = CRT page &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1FH DISABLE MOUSE DRIVER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 1FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = -1 if unsuccessful &lt;br /&gt;ES:BX = address of mouse driver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;quot; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20H ENABLE MOUSE DRIVER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit The mouse driver is enabled. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21H SOFTWARE RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = OFFFFH if successful &lt;br /&gt;BX = 2 if successful &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22H SET LANGUAGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=22H &lt;br /&gt;BX = language number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Language is changed only with the Intemational version. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The languages selected by BX are as follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0= English &lt;br /&gt;1 = French &lt;br /&gt;2 = Dutch &lt;br /&gt;3 = German &lt;br /&gt;4 = Swedish &lt;br /&gt;5 = Finnish &lt;br /&gt;6 = Spanish &lt;br /&gt;7 = Portuguese &lt;br /&gt;8 = Italian &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;758 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;23H GET LANGUAGE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 23H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = language number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24H GET DRIVER VERSION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 24H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BH = major version number &lt;br /&gt;BL = minor version number &lt;br /&gt;CH = mouse type &lt;br /&gt;CL = interrupt request number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;25H GET DRIVER INFORMATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 25H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX contains the following driver information in the bits indicated. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bits 13,12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 = software text cursor active &lt;br /&gt;01 = hardware text cursor active &lt;br /&gt;1 X = graphics cursor active &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o = non-integrated mouse display driver &lt;br /&gt;1 = integrated mouse display driver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o = driver is a .SYS file &lt;br /&gt;1 = driver is a .COM file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26H GET MAXIMUM VIRTUAL COORDINATES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 26H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX = mouse driver status &lt;br /&gt;CX = maximum horizontal coordinate &lt;br /&gt;DX = maximum vertical coordinate &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;MOUSE FUNCTIONS 759 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;27H GET CURSOR MASKS AND COUNTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 27H &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = screen mask or beginning scanning line &lt;br /&gt;BX = cursor mask or ending scan line &lt;br /&gt;ex = horizontal mickey count &lt;br /&gt;OX = vertical mickey count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28H SET VIDEO MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=28H &lt;br /&gt;ex = video mode &lt;br /&gt;OX = font size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit ex = 0 if successful &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;29H GET SUPPORTED VIDEO MODES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 29H &lt;br /&gt;ex = search flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit BX:OX = address of ASCII description of video mode &lt;br /&gt;ex = mode number or 0 if unsuccessful &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The search flag is 0 to search for the first video mode, and non-zero &lt;br /&gt;to search for the next video mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2AH GET CURSOR HOT SPOT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 2AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = display flag &lt;br /&gt;BX = horizontal hot spot &lt;br /&gt;ex = vertical hot spot &lt;br /&gt;OX = mouse type &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The hot spot is the position on the cursor that is returned when a &lt;br /&gt;mouse button is clicked. AX (display flag) indicates that the cursor is &lt;br /&gt;active (0) or inactive (1). &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;760 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2BH SET ACCELERATION CURVE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=2BH &lt;br /&gt;BX = curve number &lt;br /&gt;ES:SI = address of the acceleration curve &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = 0 if successful &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Following are the contents of the acceleration curve table that &lt;br /&gt;contains curves 1 through 4: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset Meaning &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOH = curve 1 counts &lt;br /&gt;01 H = curve 2 counts &lt;br /&gt;02H = curve 3 counts &lt;br /&gt;03H = curve 4 counts &lt;br /&gt;04H = curve 1 mouse count and threshold &lt;br /&gt;24H = curve 2 mouse count and threshold &lt;br /&gt;44H = curve 3 mouse count and threshold &lt;br /&gt;64H = curve 4 mouse count and threshold &lt;br /&gt;84H = curve 1 scale factor array &lt;br /&gt;A4H = curve 2 scale factor array &lt;br /&gt;C4H = curve 3 scale factor array &lt;br /&gt;E4H = curve 4 scale factor array &lt;br /&gt;104H = curve 1 name &lt;br /&gt;114H = curve 2 name &lt;br /&gt;124H = curve 3 name &lt;br /&gt;134H = curve 4 name &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2CH GET ACCELERATION CURVE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=2CH &lt;br /&gt;BX = current curve &lt;br /&gt;ES:SI = address of current acceleration curves &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = 0 if successful &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2DH GET ACTIVE ACCELERATION CURVE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=2DH &lt;br /&gt;BX = curve number or -1 for current &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = 0 if successful &lt;br /&gt;BX = curve number &lt;br /&gt;ES:SI = address of acceleration curves &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2FH MOUSE HARDWARE RESET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 2FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = 0 if u[1successful &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;MOUSE FUNCTIONS 761 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30H SET/GET BALLPOINT INFORMATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 30H &lt;br /&gt;BX = rotation angle (+32K) &lt;br /&gt;ex = command (0 for read and 1 for write) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I Exit AX = FFFFH if unsuccessful or button state BX = rotation angle ex = button masks &lt;br /&gt;31H GET VIRTUAL COORDINATES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 31H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = minimum horizontal &lt;br /&gt;BX = minimum vertical &lt;br /&gt;ex = maximum horizontal &lt;br /&gt;DX = maximum vertical &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32H GET ACTIVE ADVANCED FUNCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL= 32H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = function flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The function flags indicate which INT 33H advanced functions are &lt;br /&gt;available. The leftmost bit indicates function 25H through the &lt;br /&gt;rightmost bit that indicates function 34H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;33H GET SWITCH SETTING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL=33H &lt;br /&gt;ex = buffer length &lt;br /&gt;ES:DI = address of buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX=O &lt;br /&gt;ex = byte in buffer &lt;br /&gt;ES:DI = address of buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34H GET MOUSE.INI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AL = 34H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX=O &lt;br /&gt;ES:DX = buffer address &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;762 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS &lt;br /&gt;The DPMI (DOS protected mode interface) provides DOS and WINDOWS applications with ac-&lt;br /&gt;cess to protected mode and also access to real and extended memory. Four functions are ac-&lt;br /&gt;cessed through the DOS multiplex interrupt (INT 2FH), and the remaining functions are &lt;br /&gt;accessed via INT 3IH. The functions accessed by the INT 2FH interrupt release a time slice (AX &lt;br /&gt;= I680H), get the CPU mode (AX = I686H), get the mode switch entry point (AX = I687H), &lt;br /&gt;and get the API entry point (AX = I68AH). The INT 2FH functions are listed in Table A-I4 and &lt;br /&gt;the INT 3IH functions appear in Table A-I5. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE A-14 The INT 2FH, DPMI functions (pp. 762-763) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80H RELEASE TIME SLICE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 1680H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = OOOOH if successful &lt;br /&gt;AX &amp;lt;&amp;gt; 1680H if unsuccessful &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes A time slice is a portion of time allowed to an application. If the &lt;br /&gt;application is idle, it should release the remaining portion of its time &lt;br /&gt;slice to other applications using this function. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8SH GET CPU MODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 1686H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = OOOOH if CPU in protected mode &lt;br /&gt;AX &amp;lt;&amp;gt; OOOOH if CPU in real or virtual mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;87H GET MODE ENTRY POINT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 1687H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = OOOOH if successful &lt;br /&gt;AX &amp;lt;&amp;gt; OOOOH if unsuccessful &lt;br /&gt;BX = support flag &lt;br /&gt;CL = processor type &lt;br /&gt;OX = DPMI version number &lt;br /&gt;SI = private paragraph count &lt;br /&gt;ES:DI = protected mode entry point &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used to locate the entry point required to switch the CPU into &lt;br /&gt;the protected mode using OPMI. BX is a logic 1 if 32-bit support is &lt;br /&gt;provided by OPMI. CL indicates the microprocessor (2,3,4, or 5 for &lt;br /&gt;the 80286, 80386, 8043&amp;quot;;, or Pentium/Pentium Pro). OX = the DPMI &lt;br /&gt;version number returned binary value in OH (major) and DL (minor). &lt;br /&gt;SI = the number of paragraphs required by OPMI for proper operation. &lt;br /&gt;ES:DI = the address used to switch to protected mode. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 763 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8AH GET API ENTRY POINT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 168AH &lt;br /&gt;DS:DI = address of vendor name (ASCII-Z) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = OOOOH if successful &lt;br /&gt;AX = 168AH if unsuccessful &lt;br /&gt;ES:DI = API extensions entry point &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used to reference a specific vendor's extensions to the DPMI &lt;br /&gt;interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table A-15 The INT 31H, DPMI functions (pp. 763-782) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOH ALLOCATE LDT DESCRIPTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =OOOOH &lt;br /&gt;CX = number of descriptors needed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit AX = base selector, carry = 0 &lt;br /&gt;AX = error code, carry = 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Allocates one or more local descriptors, with the base or starting &lt;br /&gt;descriptor number returned in AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0OO1H RELEASE LDT DESCRIPTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =OOO1H &lt;br /&gt;BX = selector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Releases one descriptor selected by the selector placed in BX on the &lt;br /&gt;call to the INT 31 H function. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0OO2H MAP REAL SEGMENT TO DESCRIPTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =OOO2H &lt;br /&gt;BX = segment address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, AX = selector &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Maps a real mode segment to a protected mode descriptor. This &lt;br /&gt;cannot be released and should only be used to map the start of the &lt;br /&gt;descriptor table or other global protected mode segments. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;764 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC liD SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0OO3H GET SEGMENT INCREMENT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0OO3H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, AX = increment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used with function AX = OOOOH to determine the increment of the &lt;br /&gt;selector returned as the base selector. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0OO6H GET SEGMENT BASE ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0006H &lt;br /&gt;BX = selector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;CX:OX = base address of segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Returns the segment address as selected by BX in CX:OX where &lt;br /&gt;CX = the high-order word and OX = the low-order word expressed &lt;br /&gt;as a 32-bit linear address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0OO7H SET SEGMENT BASE ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 0OO7H &lt;br /&gt;BX = selector &lt;br /&gt;CX:OX = linear base address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Sets the base address to the 32-bit linear address found in CX:OX &lt;br /&gt;where CX = high-order word and OX = low-order word. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0OO8H SET SEGMENT LIMIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =OOO8H &lt;br /&gt;BX = selector &lt;br /&gt;CX:OX = segment limit in bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 765 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0OO9H SET DESCRIPTOR ACCESS RIGHTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0009H &lt;br /&gt;BX = selector &lt;br /&gt;CX = access rights &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The access rights determines how a segment is accessed in the &lt;br /&gt;protected mode. The definition of each bit of CX follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Rights &lt;br /&gt;0 Descriptor access (1) &lt;br /&gt;1 Read/write (1) or Read-only (0) &lt;br /&gt;2 Expand segment up (0) or expand segment down (1) &lt;br /&gt;3 Code segment (1) or data segment (0) &lt;br /&gt;4 Must be 1 &lt;br /&gt;5,6 Descriptor desired privilege level &lt;br /&gt;7 Present (1) or not present (0) &lt;br /&gt;8-13 Must be 000000 &lt;br /&gt;14 32-bit instruction mode (1) or 16-bit mode (0) &lt;br /&gt;15 Granularity bit is 0 for 1 X multiplier and 1 for 4K multiplier &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;for limit field &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bits 15-8 must be 0000 0000 for the 80286 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOAH CREATE ALIAS DESCRIPTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OOOAH &lt;br /&gt;BX = selector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, AX = alias selector &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Creates a new &amp;quot;carbon copy&amp;quot; as an alias local descriptor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOBH GET DESCRIPTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OOOBH &lt;br /&gt;BX = selector &lt;br /&gt;ES:DI = address of buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Copies the 8-byte descriptor into the buffer addressed by ES:DI. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;766 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOCH SET DESCRIPTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OOOCH &lt;br /&gt;BX = selector &lt;br /&gt;ES:DI = address of buffer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Copies the a-byte descriptor from the buffer to the descriptor table. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOODH ALLOCATE SPECIFIC LDT DESCRIPTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OOODH &lt;br /&gt;BX = selector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Creates a descriptor based in the selector of your choice (4-7CH) &lt;br /&gt;with as many as 16 assigned by this function. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOEH GET MULTIPLE DESCRIPTORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= OOOEH &lt;br /&gt;BX = number to get &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, CX = number copied to buffer &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Copies multiple descriptors to a buffer addressed by ES:DI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOFH SET MULTIPLE DESCRIPTORS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= OOOFH &lt;br /&gt;BX = number to set &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, number copied from buffer &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Creates descriptors from the buffer at the location addressed by &lt;br /&gt;ES:DI. Each entry is 10 bytes in length with the first 2 bytes containing &lt;br /&gt;the selector number, followed by a bytes for descriptor data. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 767 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0100H ALLOCATE DOS MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0100H &lt;br /&gt;DX = paragraphs to allocate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;AX = real mode segment &lt;br /&gt;DX = selector of descriptor for memory block &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful &lt;br /&gt;AX = error code &lt;br /&gt;BX = size of available block &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Allocates a local descriptor for the DOS memory block. Releases &lt;br /&gt;with function 0101 H only. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0101H RELEASE DOS MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0101H &lt;br /&gt;DX = selector &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0200H GET REAL MODE INTERRUPT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0200H &lt;br /&gt;BX = interrupt number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit CX = vector segment &lt;br /&gt;DX = vector offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Releases one descriptor selected by the selector placed in BX on the &lt;br /&gt;call to the INT 31H function. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0201H SET REAL MODE INTERRUPT VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0201H &lt;br /&gt;BX = interrupt number &lt;br /&gt;CX = vector segment &lt;br /&gt;DX = vector offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0202H GET EXCEPTION HANDLER VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0202H &lt;br /&gt;BX = exception number 0-1 FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;CX = handler selector &lt;br /&gt;DX = handler offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful &lt;br /&gt;AX = error code &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;768 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0203H SET EXCEPTION HANDLER VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 0203H &lt;br /&gt;BX = exception number 0-1 FH &lt;br /&gt;CX = handler selector &lt;br /&gt;DX = handler offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0204H GET PROTECTED MODE INTERRUPT VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX=0204H &lt;br /&gt;BX = interrupt number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;CX = handler selector &lt;br /&gt;DX = handler offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful &lt;br /&gt;AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0205H SET PROTECTED MODE INTERRUPT VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0205H &lt;br /&gt;BX = interrupt number &lt;br /&gt;CX = handler selector &lt;br /&gt;DX = handler offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0210H GET EXTENDED REAL EXCEPTION HANDLER &lt;br /&gt;VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0210H &lt;br /&gt;BX = exception number 0-1 FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;CX = handler selector &lt;br /&gt;DX = handler offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful &lt;br /&gt;AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0211H GET EXTENDED PROTECTED EXCEPTION &lt;br /&gt;HANDLER VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0211H &lt;br /&gt;BX = exception number 0-1 FH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;CX = handler selector &lt;br /&gt;DX = handler offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful &lt;br /&gt;AX = error code &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 769 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0212H SET EXTENDED PROTECTED EXCEPTION &lt;br /&gt;HANDLER VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0212H &lt;br /&gt;BX = exception number 0-1 FH &lt;br /&gt;CX = handler selector &lt;br /&gt;OX .:::: handler offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0213H SET EXTENDED REAL EXCEPTION HANDLER &lt;br /&gt;VECTOR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0213H &lt;br /&gt;BX = exception number 0-1 FH &lt;br /&gt;CX = handler selector &lt;br /&gt;OX = handler offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0300H EMULATE REAL MODE INTERRUPT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0300H &lt;br /&gt;BX = interrupt number &lt;br /&gt;CX = word copy count &lt;br /&gt;ES:OI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, ES:OI = buffer address &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Copies the number of words (CX) from the protected mode'stack to &lt;br /&gt;the real mode stack. The ES:OI register combination addresses a &lt;br /&gt;memory buffer that specifies the contents of the register when the &lt;br /&gt;switch to the real mode interrupt occurs. The register set is stored as: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset Size Register &lt;br /&gt;OOH doubleword EOI &lt;br /&gt;04H doubleword ESI &lt;br /&gt;08H doubleword EBP &lt;br /&gt;OCH doubleword must be OOOOOOOOH &lt;br /&gt;10H doubleword EBX &lt;br /&gt;14H doubleword EDX &lt;br /&gt;18H doubleword ECX &lt;br /&gt;1CH doubleword EAX &lt;br /&gt;20H word flags &lt;br /&gt;22H word ES &lt;br /&gt;24H word OS &lt;br /&gt;26H word FS &lt;br /&gt;28H word GS &lt;br /&gt;2AH word IP &lt;br /&gt;2CH word CS &lt;br /&gt;2EH word SP &lt;br /&gt;30H word SS &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;770 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 110 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0301H CALL FAR REAL MODE PROCEDURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0301H &lt;br /&gt;BH = OOH &lt;br /&gt;CX = word copy count &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, ES:DI = buffer address &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Calls a real mode procedure from protected mode. The buffer &lt;br /&gt;contains the register set as defined for function 0300H, which is &lt;br /&gt;loaded on the switch to real mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0302H CALL REAL MODE INTERRUPT PROCEDURE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0302H &lt;br /&gt;BH =OOH &lt;br /&gt;CX = word copy count &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, ES:DI = buffer address &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Calls the real mode interrupt procedure from protected mode. The &lt;br /&gt;buffer contains the register set as defined for function 0300H, which &lt;br /&gt;is loaded on the switch to real mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0303H ALLOCATE REAL MODE CALLBACK ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0303H &lt;br /&gt;DS:SI = protected mode procedure address &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, CX:DX = callback address &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Calls a protected mode procedure from the real mode. The real mode &lt;br /&gt;address is found in CX (segment) and DX (offset). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0304H RELEASE REAL MODE CALLBACK ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0304H &lt;br /&gt;CX:DX = callback address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Releases the callback address allocated by function 0303H. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0305H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0306H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0400H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GET STATE SAVE AND RESTORE ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX = 0305H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 0 if successful &lt;br /&gt;AX = buffer size &lt;br /&gt;~ , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;= &lt;br /&gt;' -- - -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;- --BX.vX real &amp;quot;,ode procedure add,e&amp;quot;&amp;quot; &lt;br /&gt;SI:OI = protected mode procedure address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The procedure addresses returned by this function save the real or &lt;br /&gt;protected mode registers in memory before switching modes. If in the &lt;br /&gt;real mode, BX:CX contain the far address or a procedure that saves &lt;br /&gt;the protected mode registers. Likewise, if operating in the protected &lt;br /&gt;mode, save the real mode register with a call to the protected mode &lt;br /&gt;address in SI:OI. The value of AL dictates how the procedure called &lt;br /&gt;by the procedure address functions. If AL = 0, the registers are saved. &lt;br /&gt;If AL = 1, the registers are restored. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GET RAW CPU MODE SWITCH ADDRESS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX = 0306H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 0 if successful &lt;br /&gt;BX:CX = switch to protected mode address &lt;br /&gt;SI:OI = switch to real mode address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;To switch to protected mode from real mode, use a far JMP to the &lt;br /&gt;address found in BX:CX. To switch to real mode from protected &lt;br /&gt;mode, use a JMP to the address found in SI:OI. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The register must be pre-loaded as follows before jumping to the &lt;br /&gt;switch address: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX = new OS &lt;br /&gt;BX=newSP &lt;br /&gt;CX= new ES &lt;br /&gt;OX= new 58 &lt;br /&gt;51 = new CS &lt;br /&gt;01 = new IP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GET DPMI VERSION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX = 0400H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 0 if successful &lt;br /&gt;AX = OPMI version number &lt;br /&gt;BX = implementation flag &lt;br /&gt;CL = processor type &lt;br /&gt;OH = master interrupt controller base address &lt;br /&gt;OL = slave interrupt controller base address &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The interrupt controller vector numbers are usually returned as OSH &lt;br /&gt;for the master and 70H for the slave. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;771 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;772 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 110 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0401H GET DPMI CAPABILITIES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 0401H &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, AX = capabilities &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function is supported under version 1.0 of DPMI and uses AX to &lt;br /&gt;return the following capabilities: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Purpose &lt;br /&gt;6 write-protect host (DPMI) &lt;br /&gt;5 write-protect client (DOSIWINDOWS) &lt;br /&gt;4 demand zero fill &lt;br /&gt;3 conventional memory mapping &lt;br /&gt;2 device mapping &lt;br /&gt;1 exceptions can be restarted &lt;br /&gt;0 page dirty &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0500H GET FREE MEMORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= OSOOH &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Information about the system memory is returned by this function in &lt;br /&gt;the buffer addressed by the buffer address. The contents of the buffer &lt;br /&gt;are: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset Size Purpose &lt;br /&gt;OOH doubleword largest free block in bytes &lt;br /&gt;04H doubleword maximum unlocked pages &lt;br /&gt;OSH doubleword maximum locked pages &lt;br /&gt;OCH doubleword linear address in pages &lt;br /&gt;10H doubleword total unlocked pages &lt;br /&gt;14H doubleword total free pages &lt;br /&gt;1SH doubleword total physical pages &lt;br /&gt;1CH doubleword free linear pages &lt;br /&gt;20H doubleword size of paging file in pages &lt;br /&gt;24H 12 bytes reserved &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 773 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0501H ALLOCATE MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX=0501H &lt;br /&gt;BX:CX = memory block size in bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;BX:CX = linear base address of block &lt;br /&gt;SI:OI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Allocates a block of memory whose size in bytes is in BX:CX on the &lt;br /&gt;call to this function. On the return, BX:CX = the starting address of &lt;br /&gt;the memory block and SI:OI contains the block handle. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0502H RELEASE MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 0502H &lt;br /&gt;SI:OI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0503H RESIZE MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0503H &lt;br /&gt;BX:CX = new memory block size in bytes &lt;br /&gt;SI:OI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;BX:CX = linear base address of block &lt;br /&gt;SI:OI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0504H ALLOCATE LINEAR MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0504H &lt;br /&gt;EBX = desired linear base address &lt;br /&gt;ECX = block size in bytes &lt;br /&gt;EDX = action code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;EBX = linear base address of block &lt;br /&gt;ESI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used with a 32-bit OPMI host to allocate a linear memory block. The &lt;br /&gt;action code is 0 to create an uncommitted block and 1 to create a &lt;br /&gt;committed block. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;774 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC I/O SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0505H RESIZE LINEAR MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0505H &lt;br /&gt;ES:EBX = buffer address &lt;br /&gt;ECX = block size in bytes &lt;br /&gt;EOX = action code (see function 0504H) &lt;br /&gt;ESI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;BX:CX = linear base address of block &lt;br /&gt;SI:OI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0506H GET PAGE ATTRIBUTES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 0506H &lt;br /&gt;EBX = page offset within memory block &lt;br /&gt;ECX = page count &lt;br /&gt;ES:EOX = buffer address &lt;br /&gt;ESI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The memory buffer contains a word of attribute information for each &lt;br /&gt;page in the memory block. The attribute word stored in the buffer &lt;br /&gt;indicates the following information: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Function &lt;br /&gt;0 0= uncommitted and 1 = committed &lt;br /&gt;1 1 = mapped &lt;br /&gt;3 o = read-only and 1 = read/write &lt;br /&gt;4 o = dirty bit invalid and 1 = dirty bit valid &lt;br /&gt;5 o = page unaccessed and 1 = page accessed &lt;br /&gt;6 o = page unmodified and 1 = page modified &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 775 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0507H SET PAGE ATIRIBUTES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0507H &lt;br /&gt;EBX = page offset within memory bl1ck &lt;br /&gt;ECX = page count &lt;br /&gt;ES:EDX = buller address &lt;br /&gt;ESI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes As with function 0506H, the memory buller contains a word for each &lt;br /&gt;page that defines the attribute for each page. Following is the &lt;br /&gt;meaning of the bits in the page attribute word: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Function &lt;br /&gt;0 o = make uncommitted and 1 = make committed &lt;br /&gt;1 1 = modify attributes, but not page type &lt;br /&gt;3 o = make read-only and 1 = make read/write &lt;br /&gt;4 1 = modify dirty bit &lt;br /&gt;5 1 = mark page accessed &lt;br /&gt;6 1 = mark page modified &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0508H MAP DEVICE IN MEMORY BLOCK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 0508H &lt;br /&gt;EBX = page offset within memory block &lt;br /&gt;ECX = page count &lt;br /&gt;EDX = device address &lt;br /&gt;ESI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Assigns the physical address of a device (EDX) to a linear address in &lt;br /&gt;a memory block. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0509H MAP CONVENTIONAL MEMORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0509H &lt;br /&gt;EBX = page offset within memory block &lt;br /&gt;ECX = page count &lt;br /&gt;EDX = linear address of conventional memory &lt;br /&gt;ESI = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes A!locates a linear (real) address to a memory block. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;776 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;050AH GETMEMORYBLOCKS~E &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 050AH &lt;br /&gt;81:01 = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;81:01 = memory block size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;050BH GET MEMORY INFORMATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 050BH &lt;br /&gt;01:81 = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This function fills a 128-byte buffer addressed by 01:81 with &lt;br /&gt;information about the memory. Following is the contents of the buffer: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset Size Function &lt;br /&gt;OOH doubleword allocated physical memory &lt;br /&gt;04H doubleword allocated virtual memory (host) &lt;br /&gt;08H doubleword available virtual memory (host) &lt;br /&gt;OCH doubleword allocated virtual memory (machine) &lt;br /&gt;10H doubleword available virtual memory (machine) &lt;br /&gt;14H doubleword allocated virtual memory (client) &lt;br /&gt;18H doubleword available virtual memory (Client) &lt;br /&gt;1CH doubleword locked memory (client) &lt;br /&gt;20H doubleword maximum locked memory (client) &lt;br /&gt;24H doubleword maximum linear address (client) &lt;br /&gt;28H doubleword maximum free memory block size &lt;br /&gt;2CH doubleword minimum allocation unit &lt;br /&gt;30H doubleword allocation alignment unit &lt;br /&gt;34H 76 bytes reserved &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0600H LOCK LINEAR REGION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0600H &lt;br /&gt;BX:CX = linear address of memory to lock &lt;br /&gt;81:01 = number of bytes to lock &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0601H UNLOCK LINEAR REGION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0601H &lt;br /&gt;BX:CX = linear address of memory to unlock &lt;br /&gt;81:01 = number of bytes to unlock &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 777 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0602H MARK REAL MODE REGION PAGABLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0602H &lt;br /&gt;BX:CX = linear address of memory to mark &lt;br /&gt;81:01 = number of bytes in region &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0603H RELOCK REAL MODE REGION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0603H &lt;br /&gt;BX:CX = linear address to re-Iock &lt;br /&gt;81:01 = number of bytes to re-Iock &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0604H GET PAGE SIZE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0604H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;BX:CX = page size in bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0702H MARK PAGE AS DEMAND PAGING CANDIDATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0702H &lt;br /&gt;BX:CX = linear address of memory region &lt;br /&gt;81:01 = number of bytes in region &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0703H DISCARD PAGE CONTENTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0703H &lt;br /&gt;BX:CX = linear address of memory region &lt;br /&gt;81:01 = number of bytes in region &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes This releases the memory for other uses by OPMI. A discarded page &lt;br /&gt;still contains data, but it is undefined. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;778 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0800H PHYSICAL ADDRESS MAPPING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 0800H &lt;br /&gt;BX:CX = base physical address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;BX:CX = base linear address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Converts a physical address to a linear address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0801H RELEASE PHYSICAL ADDRESS MAPPING &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0801H &lt;br /&gt;BX:CX = linear address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0900H GET AND DISABLE VIRTUAL INTERRUPT STATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= 0900H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0901H GET AND ENABLE VIRTUAL INTERRUPT STATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0901H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0902H GET VIRTUAL INTERRUPT STATE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0902H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, AL = 0 if disabled &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAOOH GET API ENTRY POINT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= OAOOH &lt;br /&gt;DS:SI = vendor ASCII offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful, AL = 0 if disabled &lt;br /&gt;ES:DI = entry point address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 779 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OBOOH SET DEBUG WATCH-POINT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OBOOH &lt;br /&gt;BX:CX = linear watch-point address &lt;br /&gt;DH = watch-point type &lt;br /&gt;DL = watch-point size &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;BX = watch-point handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The BX:CX register provides the watch-point address to the function. &lt;br /&gt;The DH register provides the type of watch'point (0 = instruction &lt;br /&gt;executed at watch-point address, 1 = memory write to watch-point &lt;br /&gt;address, and 2 = a read or write to watch-point address). The DL &lt;br /&gt;register holds the size in byte of the watch-point address for types 1 &lt;br /&gt;and 2. When the watch-point is triggered, function AX = OB02H is &lt;br /&gt;used to test for the trigger. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OB01H CLEAR DEBUG WATCH-POINT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OB01H &lt;br /&gt;BX = watch-point handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Erase a watch-point assigned with function OBOOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OB02H GET STATE OF DEBUG WATCH-POINT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OB02H &lt;br /&gt;BX = watch-point handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;AX = watch-point status &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used to detect a watch-point trigger. A status of 0 indicates that a &lt;br /&gt;watch-point has not been detected, and 1 indicates that it has. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OB03H RESET DEBUG WATCH-POINT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OB03H &lt;br /&gt;BX = watch-point handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Clears the watch-point status, but does not erase the watch-point. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;780 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC 1/0 SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OCOOH INSTALL RESIDENT SERVICE PROVIDER &lt;br /&gt;CALLBACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = OCOOH &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes Used for a protected mode TSR to notify the DPMI to call the TSR &lt;br /&gt;whenever another machine is in the same virtual memory. The buffer &lt;br /&gt;contains the following information for DPMI: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset Size Function &lt;br /&gt;OOH quadword 16-bit data segment descriptor &lt;br /&gt;08H quadword 16-bit code segment descriptor &lt;br /&gt;10H word 16-bit callback procedure offset &lt;br /&gt;12H word reserved &lt;br /&gt;14H quadword 32-bit data segment descriptor &lt;br /&gt;1CH quadword 32-bit code segment descriptor &lt;br /&gt;24H doubleword 32-bit callback procedure offset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OC01H TERMINATE AND STAY RESIDENT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= OC01H &lt;br /&gt;BL = exit code &lt;br /&gt;DX = number of paragraphs to reserve &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit None &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOH ALLOCATE SHARED MEMORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = ODOOH &lt;br /&gt;ES:DI = buffer address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The buffer contains information for DPMI used to allocate shared &lt;br /&gt;memory. Its contents follow: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Offset Size Function &lt;br /&gt;OOH doubleword desired block size in bytes &lt;br /&gt;04H doubleword actual memory block size in bytes &lt;br /&gt;08H doubleword memory block handle &lt;br /&gt;OCH doubleword linear address of memory block &lt;br /&gt;10H doubleword offset of ASCII-Z string name &lt;br /&gt;14H word selector of ASCII-Z string name &lt;br /&gt;16H word reserved &lt;br /&gt;18H doubleword must be set to OOOOOOOOH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DPMI CONTROL FUNCTIONS 781 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OD01H RELEASE SHARED MEMORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0001H &lt;br /&gt;81:01 = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OD02H SERIALIZE ON SHARED MEMORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =0002H &lt;br /&gt;OX = option flag &lt;br /&gt;81:01 = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OD03H RELEASE SERIALIZATION ON SHARED MEMORY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX = 0003H &lt;br /&gt;OX = option flag &lt;br /&gt;81:01 = memory block handle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The OX register contains the option code as follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Function &lt;br /&gt;0 o = suspend until serialization and 1 = return error code &lt;br /&gt;1 o = exclusive serialization and 1 = shared serialization &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OEOOH GET COPROCESSOR STATUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX =OEOOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;AX = status code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The following is the coprocessor status: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Function &lt;br /&gt;0 1 = coprocessor enabled &lt;br /&gt;1 1 = emulation of coprocessor enabled for client &lt;br /&gt;2 1 = coprocessor present &lt;br /&gt;3 1 = emulation of coprocessor enabled for host &lt;br /&gt;4-7 0000 = no coprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001 = 80287 present &lt;br /&gt;0010 = 80387 present &lt;br /&gt;0011 = 80487/Pentium present &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;782 APPENDIX A THE ASSEMBLER, DISK OPERATING SYSTEM, BASIC liD SYSTEM, MOUSE, AND DPMI MEMORY MANAGER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE01H SET COPROCESSOR EMULATION &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Entry AX= OE01H &lt;br /&gt;BX = action code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Exit Carry = 0 if successful &lt;br /&gt;Carry = 1 if unsuccessful, AX = error code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes The contents of register BX follows: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Bit Function &lt;br /&gt;0 1 = enable coprocessor for client &lt;br /&gt;1 1 = client will supply emulation &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B &lt;br /&gt;Instruction Set Summary &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The instruction set summary contains a complete alphabetical listing of the entire 8086-Pentium &lt;br /&gt;Pro instruction set. The coprocessor instructions are listed in Chapter 13 and are not repeated in &lt;br /&gt;this appendix. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Each instruction entry lists the mnemonic opcode plus a brief description of the purpose of &lt;br /&gt;the instruction. Also listed is the binary machine language coding of each instruction, plus any &lt;br /&gt;other data required to form the instruction, such as the displacement or immediate data. Listed to &lt;br /&gt;the right of each binary machine language version of the instruction are the flag bits and any &lt;br /&gt;change that might occur for the instruction. The flags are described in the following manner: a &lt;br /&gt;blank indicates no effect or change, a ? indicates a change with an unpredictable outcome, a * in-&lt;br /&gt;dicates a change with a predictable outcome, a I indicates that the flag is set, and a 0 indicates &lt;br /&gt;that the flag is cleared. If the flag bits ODITSZAPC are not illustrated with an instruction, the in-&lt;br /&gt;struction does not modify any of these flags. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Before the instruction listing begins, some information about the bit settings in binary ma-&lt;br /&gt;chine language versions of the instructions is presented. Table B-1 lists the modifier bits, coded &lt;br /&gt;as 00 in the instruction listings. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table B-2 lists the memory-addressing modes available using a register field coding of &lt;br /&gt;mmm. This table applies to all versions of the microprocessor as long as the operating mode is &lt;br /&gt;16-bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table B-3 lists the register selections provided by the rrr field in an instruction. This table &lt;br /&gt;includes the register selections for 8-, 16-, and 32-bit registers. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE B-1 The modifier &lt;br /&gt;bits, coded as 00 in the &lt;br /&gt;instruction listing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Function &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;If mmm = 110, then a displacement follows the opcode; otherwise, &lt;br /&gt;no displacement is used &lt;br /&gt;An 8-bit signed displacement follows the opcode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 A 16-bit signed displacement follows the opcode (unless it is a &lt;br /&gt;32-bit displacement) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 mmm specifies a register instead of an addresing mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;783 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;784 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE B-2 The 16-bit &lt;br /&gt;register/memory (mmm) field mmm Function &lt;br /&gt;description &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 DS:[BX+SI) &lt;br /&gt;001 DS:[BX+DI) &lt;br /&gt;010 SS:[BP+SI) &lt;br /&gt;011 SS:[BP+DI) &lt;br /&gt;100 DS:[SI) &lt;br /&gt;101 DS:[DI) &lt;br /&gt;110 SS:[BP) &lt;br /&gt;111 DS:[BX) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE B-3 The register &lt;br /&gt;field (rrr) assignment rrr W=o W=1 (16-bit) W= 1 (32-bit) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 AL AX EAX &lt;br /&gt;001 CL CX ECX &lt;br /&gt;010 DL DX EDX &lt;br /&gt;011 BL BX EBX &lt;br /&gt;100 AH SP ESP &lt;br /&gt;101 CH BP EBP &lt;br /&gt;110 DH SI ESI &lt;br /&gt;111 BH DI EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Table B-4 lists the segment register bit assignment (rrr) found with the MOV, PUSH, and &lt;br /&gt;POP instructions. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;When the 80386-Pentium Pro are used, some of the definitions provided in Tables B-1 &lt;br /&gt;through B-3 change. Refer to Tables B-5 and B-6 for these changes as they apply to the &lt;br /&gt;80386-Pentium Pro microprocessors. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE B-4 Register field &lt;br /&gt;assignments (rrr) for the &lt;br /&gt;segment registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE B-5 Index register &lt;br /&gt;specified with rrr for the &lt;br /&gt;advanced addressing mode &lt;br /&gt;found in the 80386-Pentium &lt;br /&gt;Pro microproceStors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rrr &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 &lt;br /&gt;001 &lt;br /&gt;010 &lt;br /&gt;011 &lt;br /&gt;100 &lt;br /&gt;101 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rrr &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000 &lt;br /&gt;001 &lt;br /&gt;010 &lt;br /&gt;011 &lt;br /&gt;100 &lt;br /&gt;101 &lt;br /&gt;110 &lt;br /&gt;111 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Segment Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES &lt;br /&gt;CS &lt;br /&gt;SS &lt;br /&gt;DS &lt;br /&gt;FS &lt;br /&gt;GS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Index Register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DS:[EAX) &lt;br /&gt;DS:[ECX) &lt;br /&gt;DS:[EDX) &lt;br /&gt;DS:[EBX) &lt;br /&gt;No index (see Table B-6) &lt;br /&gt;SS:[EBP) &lt;br /&gt;DS:[ESI) &lt;br /&gt;DS:[EDI) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 785 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE B-6 Possible combinations of 00, mmm, and rrr for the 8038B-Pentium Pro &lt;br /&gt;microprocessors using 32-bit addressing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 mmm rrr (base in scaled index byte) Addressing Mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00 000 DS:[EAX] &lt;br /&gt;00 001 DS:[ECX] &lt;br /&gt;00 010 DS:[EDX] &lt;br /&gt;00 011 DS:[EBX] &lt;br /&gt;00 100 000 DS:[EAX+scaled index] &lt;br /&gt;00 100 001 DS:[ECX+scaled index] &lt;br /&gt;00 100 010 DS:[EDX+scaled index] &lt;br /&gt;00 100 011 DS:[EBX+scaled index] &lt;br /&gt;00 100 100 SS:[ESP+scaled index] &lt;br /&gt;00 100 101 DS:[disp32+scaled index] &lt;br /&gt;00 100 110 DS:[ESI+scaled index] &lt;br /&gt;00 100 111 DS:[EDI+scaled index] &lt;br /&gt;00 101 DS:disp32 &lt;br /&gt;00 110 DS:[ESI] &lt;br /&gt;00 111 DS:[EDI] &lt;br /&gt;01 000 DS:[EAX+disp8] &lt;br /&gt;01 001 DS:[ECX+disp8] &lt;br /&gt;01 010 DS:[EDX+disp8] &lt;br /&gt;01 011 DS:[EBX+disp8] &lt;br /&gt;01 100 000 DS:[EAX+scaled index+disp8] &lt;br /&gt;01 100 001 DS:[ECX+scaled index+disp8] &lt;br /&gt;01 100 010 DS:[EDX+scaled index+disp8] &lt;br /&gt;01 100 011 DS:[EBX+scaled index+disp8] &lt;br /&gt;01 100 100 SS:[ESP+scaled index+disp8] &lt;br /&gt;01 100 101 SS:[EBP+scaled index+disp8] &lt;br /&gt;01 100 110 DS:[ESI+scaled index+disp8] &lt;br /&gt;01 100 111 DS:[EDI+scaled index+disp8] &lt;br /&gt;01 101 SS:[EBP+disp8] &lt;br /&gt;01 110 DS:[ESI+disp8] &lt;br /&gt;01 111 DS:[EDI+disp8] &lt;br /&gt;10 000 DS:[EAX+disp32] &lt;br /&gt;10 001 DS:[ECX+disp32] &lt;br /&gt;10 010 DS:[EDX+disp32] &lt;br /&gt;10 011 DS:[EBX+disp32] &lt;br /&gt;10 100 000 DS:[EAX+scaled index+disp32] &lt;br /&gt;10 100 001 DS:[ECX+scaled index+disp32] &lt;br /&gt;10 100 010 DS:[EDX+scaled index+disp32] &lt;br /&gt;10 100 011 DS:[EBX+scaled index+disp32] &lt;br /&gt;10 100 100 SS:[ESP+scaled index+disp32] &lt;br /&gt;10 100 101 SS:[EBP+scaled index+disp32] &lt;br /&gt;10 100 110 DS:[ESI+scaled index+disp32] &lt;br /&gt;10 100 111 DS:[EDI+scaled index+disp32] &lt;br /&gt;10 101 SS:[EBP+disp32] &lt;br /&gt;10 110 DS:[ESI+disp32] &lt;br /&gt;10 111 DS:[EDI+disp32] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Notes: disp8 = 8-bit displacement and disp32 = 32-bit displacement. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;786 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In order to use the scaled index addressing modes listed in Table B-6, code 00 and mmm &lt;br /&gt;in the second byte of the opcode. The scaled index byte is usually the third byte and contains &lt;br /&gt;three fields. The leftmost 2-bits determine the scaling factor (00 = Xl, 01 = X2, 10 = X4, or 11 = &lt;br /&gt;X8) The next three bits toward the right contain the scaled index register number (this is obtained &lt;br /&gt;from Table B-5). The rightmost 3-bits are from the m field listed in Table B-6. For example, the &lt;br /&gt;MOV AL,[EBX+2*ECX] instruction has a scaled index byte of 01 001 011 where 01 = X2, 001 &lt;br /&gt;= ECX, and 011 = EBX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Some instructions are prefixed to change the default segment or to override the instruction &lt;br /&gt;mode. Table B-7 lists the segment and instruction mode override prefixes with append at the be-&lt;br /&gt;ginning of an instruction if they are used to form the instruction. For example, the MOV &lt;br /&gt;AL,ES: [BX] instruction uses the extra segment because of the override prefix ES:. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In the 8086 and 8088 microprocessors the effective address calculation requires additional &lt;br /&gt;clocks that are added to the times in the instruction set summary. These additional times are &lt;br /&gt;listed in Table B-8. No such times are added to the 80286-Pentium Pro. Note that Intel has not &lt;br /&gt;released clock times for the Pentium Pro. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE B-7 Override &lt;br /&gt;prefixes Prefix Byte Purpose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26H ES: segment override prefix &lt;br /&gt;2EH CS: segment override prefix &lt;br /&gt;36H SS: segment override prefix &lt;br /&gt;3EH DS: segment override prefix &lt;br /&gt;64H FS: segment override prefix &lt;br /&gt;65H GS: segment override prefix &lt;br /&gt;66H Operand size instruction mode override &lt;br /&gt;67H Register size instruction mode override &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TABLE B-8 Effective &lt;br /&gt;address calculations for &lt;br /&gt;the 8086 and 8088 micro-&lt;br /&gt;processors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Type &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Base or index &lt;br /&gt;Displacement &lt;br /&gt;Base plus index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;5 &lt;br /&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CL,[DI] &lt;br /&gt;MOV AL,DATA1 &lt;br /&gt;MOV AL,[BP+SI] &lt;br /&gt;MOV DH,[DI+20H] &lt;br /&gt;MOV CL,[BX+DI+2] &lt;br /&gt;MOV AL,ED:[DI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement plus base or index &lt;br /&gt;Base plus index plus displacement &lt;br /&gt;Segment override &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 &lt;br /&gt;9 &lt;br /&gt;11 &lt;br /&gt;ea+2 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 787 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INSTRUCTION SET SUMMARY (pp. 787-870) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAA ASCII adjust AL after addition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00110111 o 0 I T S ZAP C &lt;br /&gt;? ? ? . ? . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAA 8086 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAD ASCII adjust AX before division &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101010100001010 o 0 I T S ZAP C &lt;br /&gt;? . . ? . ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAD 8086 60 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 60 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAM ASCII adjust AX after multiplication &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101010000001010 o 0 I T S ZAP C &lt;br /&gt;? . . ? . ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAM 8086 83 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 83 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;788 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAS ASCII adjust AL after subtraction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00111111 o 0 I T S ZAP C &lt;br /&gt;? ? ? * ? * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAS 8086 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC Addition with carry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000100dw oorrrmmm disp o 0 I T S ZAP C &lt;br /&gt;* * * * * * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC reg,reg ADCAX,BX 8086 3 &lt;br /&gt;ADC AL,BL &lt;br /&gt;ADC EAX,EBX 8088 3 &lt;br /&gt;ADCCX,SI 80286 3 &lt;br /&gt;ADC ESI,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC mem,reg ADC DATAY,AL 8086 16+ea &lt;br /&gt;ADC LlST,SI &lt;br /&gt;ADC DATA2[Dlj,CL 8088 24+ea &lt;br /&gt;ADC [EAXj,BL 80286 7 &lt;br /&gt;ADC [EBX+2*ECXj,EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 789 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC reg,mem ADC BL,DATA1 8086 9 + ea &lt;br /&gt;ADC SI,LlST1 &lt;br /&gt;ADC CL,DATA2[SI) 8088 13 + ea &lt;br /&gt;ADC CX,[ESI) 8028R 7 &lt;br /&gt;ADC ESI,[2*ECX) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000sw oo010mmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC reg,imm ADCCX,3 8086 4 &lt;br /&gt;ADC DI,1AH &lt;br /&gt;ADC DL,34H 8088 4 &lt;br /&gt;ADC EAX,12345 80286 3 &lt;br /&gt;ADC CX,1234H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADCmem,imm ADC DAT A4,33 8086 17 + ea &lt;br /&gt;ADC LlST,'A' &lt;br /&gt;ADC DATA3[DI),2 8088 23 +ea &lt;br /&gt;ADC BYTE PTR[EBX),3 80286 7 &lt;br /&gt;ADC WORD PTR[DI),669H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADCacc,imm ADCAX,3 8086 4 &lt;br /&gt;ADC AL,1AH &lt;br /&gt;ADCAH,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC EAX,2 80286 3 &lt;br /&gt;ADCAL,'Z' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;790 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD Addition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOOOOdw oorrrmmm disp o 0 I T S Z A P C &lt;br /&gt;. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* * * * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD reg,reg ADD AX,BX 8086 3 &lt;br /&gt;ADD AL,BL &lt;br /&gt;ADD EAX,EBX 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD CX,SI 80286 2 &lt;br /&gt;ADD ESI,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD mem,reg ADD DATAY,AL 8086 16 + ea &lt;br /&gt;ADD LlST,SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. ADD DATA6[DI),CL 8088 24+ ea &lt;br /&gt;ADD [EAX),CL 80286 7 &lt;br /&gt;ADD [EDX+4*ECX),EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD reg,mem ADD BL,DATA2 8086 9 + ea &lt;br /&gt;ADD SI,LlST3 &lt;br /&gt;ADD CL,DATA2[DI) 8088 13 + ea &lt;br /&gt;ADD CX,[EDI) 80286 7 &lt;br /&gt;ADD ESI,[ECX+200H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000sw ooOOOmmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD reg,imm ADD CX,3 8086 4 &lt;br /&gt;ADD DI,1AH &lt;br /&gt;ADD DL,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD EDX,1345H 80286 3 &lt;br /&gt;ADD CX,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 791 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADDmem,imm ADD DATA4,33 8086 17 + ea &lt;br /&gt;ADD LlST,'A' &lt;br /&gt;ADD DATA3[DI],2 8088 23 +ea &lt;br /&gt;ADD BYTE PTR[EBX],3 80286 7 &lt;br /&gt;ADD WORD PTR[Dlj,669H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD acc,imm ADD AX,3 8086 4 &lt;br /&gt;ADDAL,1AH &lt;br /&gt;ADD AH,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD EAX,2 80286 3 &lt;br /&gt;ADDAL,'Z' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND Logical AND &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001000dw oorrrmmm disp o 0 I T S ZAP C &lt;br /&gt;0 * * ? * 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND reg,reg AND CX,BX 8086 3 &lt;br /&gt;AND DL,BL &lt;br /&gt;AND ECX,EBX 8088 3 &lt;br /&gt;AND BP,SI 80286 2 &lt;br /&gt;AND EDX,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND mem,reg AND BIT,AL 8086 16 + ea &lt;br /&gt;AND LlST,DI &lt;br /&gt;AND DATAZ[BXj,CL 8088 24 + ea &lt;br /&gt;AND [EAXj,BL 80286 7 &lt;br /&gt;AND [ESI+4*ECXj,EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;792 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND reg,mem AND BL,DATAW 8086 9 + ea &lt;br /&gt;AND SI,LlST &lt;br /&gt;AND CL,DATAQ[SI) 8088 13 +ea &lt;br /&gt;AND CX,[EAX) 80286 7 &lt;br /&gt;AND ESI,[ECX+43H) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000sw oo100mmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND reg,imm AND BP,1 8086 4 &lt;br /&gt;AND DI,10H &lt;br /&gt;AND DL,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND EBP,1345H 80286 3 &lt;br /&gt;AND SP,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ANDmem,imm AND OAT A4,33 8086 17+ ea &lt;br /&gt;AND LlST,'A' &lt;br /&gt;AND DATA3[DIJ,2 8088 23 + ea &lt;br /&gt;AND BYTE PTR[EBXJ,3 80286 7 &lt;br /&gt;AND DWORD PTR[DI),66H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ANDacc,imm AND AX,3 808~ 4 &lt;br /&gt;AND AL,1AH &lt;br /&gt;ANDAH,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND EAX,2 80286 3 &lt;br /&gt;AND AL,'r' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 793 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARPL Adjust requested privilege level &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01100011 oorrrmmm disp o D I T S ZAP C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARPL reg,reg ARPLAX,BX 8086 -&lt;br /&gt;ARPL BX,SI &lt;br /&gt;ARPLAX,DX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARPL BX,AX 80286 10 &lt;br /&gt;ARPLSI,DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARPL mem,reg ARPL DATAY,AX 8086 -&lt;br /&gt;ARPL LlST,DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 ARPL DATA3[Dlj,CX -&lt;br /&gt;ARPL [EBXj,AX 80286 11 &lt;br /&gt;ARPL [EDX+4*ECXj,BP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOUND Check array against boundary &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01100010 oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BOUND reg,mem BOUND AX,BETS 8086 -&lt;br /&gt;BOUND BP,LlSTG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BOUND CX,DATAX -&lt;br /&gt;BOUND BX,[Dlj 80286 13 &lt;br /&gt;BOUND SI,[BX+2] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;794 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSF Bit scan forward &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10111100 oorrrmmm disp o D I T S Z A P C &lt;br /&gt;? ? * ? ? ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSF reg,reg BSFAX,BX 8086 -&lt;br /&gt;BSF BX,SI &lt;br /&gt;BSF EAX,EDX 8088 -&lt;br /&gt;BSF EBX,EAX 80286 -&lt;br /&gt;BSFSI,DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 + 3n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6-42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 6-42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSF reg,mem BSF AX,DATAY 8086 -&lt;br /&gt;BSF SI,L1ST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BSF CX,DATA3[DI] -&lt;br /&gt;BSF EAX,[EBX] 80286 -&lt;br /&gt;BSF EBP,[EDX+4*ECX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 + 3n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7-43 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 6-43 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSR Bit scan reverse &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10111101 oorrrmmm disp o D I T S Z A P C &lt;br /&gt;? ? * ? ? ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSR reg,reg BSRAX,BX 8086 -&lt;br /&gt;BSR BX,SI &lt;br /&gt;BSR EAX,EDX 8088 -&lt;br /&gt;BSR EBX,EAX 80286 -&lt;br /&gt;BSRSI,DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 + 3n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6-103 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7-71 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 795 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSR reg,mem BSR AX,DATAY 8086 -&lt;br /&gt;BSR SI,LlST &lt;br /&gt;BSR CX,DATA3[Dlj 8088 -&lt;br /&gt;BSR EAX,[EBXj 80286 -&lt;br /&gt;BSR EBP,[EDX+4*ECXj &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 + 3n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7-104 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7-72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSWAP Byte swap &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000111111001rrr &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSWAP reg32 BSWAP EAX 8086 -&lt;br /&gt;BSWAP EBX &lt;br /&gt;BSWAP EDX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BSWAP ECX 80286 -&lt;br /&gt;BSWAP ESI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BT Bit test &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10111010 oo100mmm disp data o D I T S ZAP C &lt;br /&gt;* &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BT reg,imm8 BT AX,2 8086 -&lt;br /&gt;BTCX,4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTBP,10H -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTCX,8 80286 -&lt;br /&gt;BT BX,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;796 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTmem,imm8 BT DATA 1 ,2 8086 -&lt;br /&gt;BT LlST,2 &lt;br /&gt;BT DATA2[DI),3 8088 -&lt;br /&gt;BT [EAX),1 80286 -&lt;br /&gt;BTFROG,6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10100011 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BT reg,reg BTAX,CX 8086 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTCX,DX &lt;br /&gt;BTBP,AX 8088 -&lt;br /&gt;BTSI,CX 80286 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTEAX,EBX &lt;br /&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 or 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BT mem,reg BTDATA4,AX 8086 -&lt;br /&gt;BT LlST,BX &lt;br /&gt;BT DATA3[DI),CX 8088 -&lt;br /&gt;BT[EBX),DX 80286 -&lt;br /&gt;BT[DI),DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4or9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 797 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTC Bit test and complement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10111010 oo111mmm disp data o D I T S Z A P C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTC reg, imm8 BTC AX,2 8086 -&lt;br /&gt;BTCCX,4 &lt;br /&gt;BTC BP,10H 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTC CX,8 80286 -&lt;br /&gt;BTC BX,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTC mem,imm8 BTC DATA1,2 8086 -&lt;br /&gt;BTC LlST,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTC DATA2[DI),3 -&lt;br /&gt;BTC[EAX),1 80286 -&lt;br /&gt;BTC FROG,6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 or 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10111011 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTC reg, reg BTCAX,CX 8086 -&lt;br /&gt;BTCCX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTCBP,AX -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTCSI,CX 80286 -&lt;br /&gt;BTC EAX,EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTC mem,reg BTC DATA4,AX 8086 -&lt;br /&gt;BTC LlST,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTC DATA3[DIJ,CX -&lt;br /&gt;BTC [EBX),DX 80286 -&lt;br /&gt;BTC[DI],DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;798 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTR Bit test and reset &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10111010 oo110mmm disp data o 0 I T S Z A P C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTR reg,imm8 BTR AX,2 8086 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTR CX,4 &lt;br /&gt;8088 BTR BP,10H -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTRCX,8 80286 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTR BX,2 &lt;br /&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTR mem,imm8 BTR OATA1,2 8086 -&lt;br /&gt;BTR LlST,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTR OATA2[01],3 -&lt;br /&gt;BTR [EAX],1 80286 -&lt;br /&gt;BTR FROG,6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7or8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000111110110011 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTR reg,reg BTRAX,CX 8086 -&lt;br /&gt;BTRCX,OX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTRBP,AX -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTRSI,CX 80286 -&lt;br /&gt;BTR EAX,EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTR mem,reg BTR OATA4,AX 8086 -&lt;br /&gt;BTR LlST,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTR OATA3[01],CX -&lt;br /&gt;BTR [EBX],OX 80286 -&lt;br /&gt;BTR [01],01 &lt;br /&gt;BTC[OI],OI 80386 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX 8 INSTRUCTION SET SUMMARY 799 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTS Bit test and set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10111010 00101 mmm disp data o D I T S ZAP C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTS reg,imm8 BTS AX,2 8086 -&lt;br /&gt;BTS CX,4 &lt;br /&gt;BTS BP,10H 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTS CX,8 80286 -&lt;br /&gt;BTS BX,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTS mem,imm8 BTS DATA1,2 8086 -&lt;br /&gt;BTS LlST,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTS DATA2[DIJ,3 -&lt;br /&gt;BT8. [EAXJ,1 80286 -&lt;br /&gt;BTS FROG,6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7or8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10101011 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTS reg,reg BTS AX,CX 8086 -&lt;br /&gt;BTS CX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTS BP,AX -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTS SI,CX 80286 -&lt;br /&gt;BTS EAX,EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BTS mem,reg BTS DAT A4,AX 8086 -&lt;br /&gt;BTS LlST,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 BTS DATA3[DIJ,CX -&lt;br /&gt;BTS [EBXJ,DX 80286 -&lt;br /&gt;BTS [DI].DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 or 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;800 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL Call procedure (subroutine) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11101000 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL label CALL FOR_FUN 8086 19 &lt;br /&gt;(near) CALL HOME &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALLET 8088 23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL WAITING 80286 -., &lt;br /&gt;CALL SOMEONE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011010 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL label CALL FAR PTR DATES 8086 28 &lt;br /&gt;(far) CALL WHAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL WHERE 8088 36 &lt;br /&gt;CALL FARCE 80286 13 &lt;br /&gt;CALL WHOM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111111 oo010mmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL reg CALL AX 8086 16 &lt;br /&gt;(near) CALL BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALLCX 8088 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL 01 80286 7 &lt;br /&gt;CALL SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX 8 INSTRUCTION SET SUMMARY 801 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL mem CALL ADDRESS 8086 21 + ea &lt;br /&gt;(near) CALL NEAR PTR [01] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 29 + ea CALL DATA1 &lt;br /&gt;CALL FROG 80286 11 &lt;br /&gt;CALL ME_NOW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111111 00011 mmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALLmem CALL FAR_LlST[SI] 8086 16 &lt;br /&gt;(far) CALL FROM_HERE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL TO_THERE 8088 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALLSIXX 80286 7 &lt;br /&gt;CALL OCT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CBW Convert byte to word (AL ~ AX) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011000 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CBW 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;802 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COO Convert doubleword to quadword &lt;br /&gt;(EAX =&amp;gt; EDX:EAX) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101010000001010 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CDa 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLC Clear carry flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111000 o D I T S ZAP C &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLC 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLO Clear direction flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111100 o D I T S ZAP C &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 803 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLI Clear interrupt flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111010 o D I T S ZAP C &lt;br /&gt;0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLI 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLTS Clear task switched flag (CRO) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000110 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLTS 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMC Complement carry flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011000 o D I T S ZAP C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMC 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;804 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMOVcondition Conditional move &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 0100cccc oorrrmmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMOVcc reg,mem CMOVNZ AX,FROG 8086 -&lt;br /&gt;CMOVC EAX,[EDI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 CMOVNC BX,DATA1 -&lt;br /&gt;CMOVP EBX,WAITING 80286 -&lt;br /&gt;CMOVNE DI,[81] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Condition &lt;br /&gt;Codes Mnemonic Flag Description &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 CMOVO 0=1 Move if overflow &lt;br /&gt;0001 CMOVNO 0=0 Move if no overflow &lt;br /&gt;0010 CMOVB C = 1 Move if below &lt;br /&gt;0011 CMOVAE C=O Move if above or equal &lt;br /&gt;0100 CMOVE Z=1 Move if equal/zero &lt;br /&gt;0101 CMOVNE Z=O Move if not equal/zero &lt;br /&gt;0110 CMOVBE C=1+Z=1 Move if below or equal &lt;br /&gt;0111 CMOVA C=OÂ·Z=O Move if above &lt;br /&gt;1000 CMOV8 8=1 Move if sign &lt;br /&gt;1001 CMOVN8 8=0 Move if no sign &lt;br /&gt;1010 CMOVP P=1 Move if parity &lt;br /&gt;1011 CMOVNP P=O Move if no parity &lt;br /&gt;1100 CMOVL 8.0 Move if less than &lt;br /&gt;1101 CMOVGE 8=0 Move if greater than or equal &lt;br /&gt;1110 CMOVLE Z=1+8Â·0 Move if less than or equal &lt;br /&gt;1111 CMOVG Z=0+8=0 Move if greater than &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP Compare &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;001110dw oorrrmmm disp o D I T 8 Z A P C &lt;br /&gt;. . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP reg,reg CMPAX,BX 8086 3 &lt;br /&gt;CMP AL,BL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 3 CMP EAX,EBX &lt;br /&gt;CMP CX,81 80286 2 &lt;br /&gt;CMP E81,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 805 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP mem,reg CMP DATAY,AL 8086 9 + ea &lt;br /&gt;CMP LlST,SI &lt;br /&gt;CMP DATA6[DI],CL 8088 13 + ea &lt;br /&gt;CMP [EAX],CL 80286 7 &lt;br /&gt;CMP [EDX+4*ECX],EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP reg,mem CMP BL,DATA2 8086 9 +ea &lt;br /&gt;CMP SI,LlST3 &lt;br /&gt;CMP CL,DATA2[DI] 8088 13 + ea &lt;br /&gt;CMP CX,[EDI] 80286 6 &lt;br /&gt;CMP ESI,[ECX+200H] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000sw 00111 mmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP reg,imm CMPCX,3 8086 4 &lt;br /&gt;CMP DI,1AH &lt;br /&gt;CMP DL,34H 8088 4 &lt;br /&gt;CMP EDX,1345H 80286 3 &lt;br /&gt;CMP CX,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPmem,imm CMPDATAS,3 8086 10+ea &lt;br /&gt;CMP BYTE PTR[EDI],1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 14+ea CMP DADDY,34H &lt;br /&gt;CMP LlST,'A' 80286 6 &lt;br /&gt;CMP TOAD,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;806 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001111w data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPacc,imm CMPAX,3 8086 4 &lt;br /&gt;CMP AL,1AH &lt;br /&gt;CMPAH,34H 8088 4 &lt;br /&gt;CMP EAX,1345H 80286 3 &lt;br /&gt;CMPAL,'Y' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPS Compare strings &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1010011w o D I T S ZAP C &lt;br /&gt;. . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPSB CMPSB 8086 32 &lt;br /&gt;CMPSW CMPSW &lt;br /&gt;CMPSD CMPSD 8088 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPSB DATA1,DATA2 80286 8 &lt;br /&gt;REPE CMPSB &lt;br /&gt;REPNE CMPSW 80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPXCHG Compare and exchange &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 1011 OOOw 11 rrrrrr o D I T S ZAP C &lt;br /&gt;. . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPXCHG CMPXCHG EAX,EBX 8086 -&lt;br /&gt;reg,reg CMPXCHG ECX,EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 807 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001111 w data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPXCHG CMPXCHG DATAD,EAX 8086 -&lt;br /&gt;mem,reg CMPXCHG DATA2,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPXCHG 88 Compare and exchange 8 bytes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 11000111 oorrrmmm o D I T S Z A P C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMPXCHG8B CMPXCHG8B DATA3 8086 -&lt;br /&gt;mem64 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CPUID CPU identification code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10100010 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CPUID 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;808 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CWO Convert word to doubleword (AX ~ DX:AX) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011000 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CWD BOB6 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80B8 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B02B6 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;803B6 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CWOE Convert word to extended doubleword &lt;br /&gt;(AX ~ EAX) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011000 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CWDE 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;803B6 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B0486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OAA Decimal adjust AL after addition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00100111 o D I T S ZAP C &lt;br /&gt;? . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAA B086 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 809 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAS Decimal adjust AL after subtraction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00101111 o D I T S ZAP C &lt;br /&gt;? . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAS 8086 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC Decrement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111111w oo001mmm disp o D I T S ZAP C &lt;br /&gt;. . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC reg8 DECBL 8086 3 &lt;br /&gt;DECBH &lt;br /&gt;DECCL 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DECDH 80286 2 &lt;br /&gt;DECAH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC mem DEC DATAY 8086 15 + ea &lt;br /&gt;DEC LIST &lt;br /&gt;DEC DATA6[DI] 8088 23 + ea &lt;br /&gt;DEC BYTE PTR [BX] 80286 7 &lt;br /&gt;DEC WORD PTR [EBX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;810 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 001 rrr &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC reg16 DECCX 8086 3 &lt;br /&gt;DEC reg32 DEC 01 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DECEDX 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC ECX 80286 2 &lt;br /&gt;DECBP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIV Divide &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111011w oo110mmm disp o 0 I T S ZAP C &lt;br /&gt;? ? ? ? ? ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIVreg DIVBL 8086 162 &lt;br /&gt;DIVBH &lt;br /&gt;DIV ECX 8088 162 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIVDH 80286 22 &lt;br /&gt;DIVCX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 40 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 17-41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIVmem DIV DATAY 8086 168 &lt;br /&gt;DIV LIST &lt;br /&gt;DIV DATA6[DI] 8088 176 &lt;br /&gt;DIV BYTE PTR [BX] 80286 25 &lt;br /&gt;DIV WORD PTR [EBX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 40 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 17-41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 811 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENTER Create a stack frame &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001000 data &lt;br /&gt;Format Exam~les Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENTER imm,O ENTER 4,0 8086 -&lt;br /&gt;ENTER 8,0 &lt;br /&gt;ENTER 100,0 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENTER 200,0 80286 11 &lt;br /&gt;ENTER 1024,0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENTER imm,1 ENTER 4,1 8086 -&lt;br /&gt;ENTER 10,1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ENTER imm,imm ENTER 3,6 8086 -&lt;br /&gt;ENTER 100,3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 15 + 2n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESC Escape (obsolete-see coprocessor) &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;812 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HLT Halt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11110100 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HLT 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium varies &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IDIV Integer (signed) division &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111011w oo111mmm disp o D I T S ZAP C &lt;br /&gt;? ? ? ? ? ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IDIV reg IDIVBL 8086 184 &lt;br /&gt;IDIVBH &lt;br /&gt;IDIVECX 8088 184 &lt;br /&gt;IDIVDH 80286 25 &lt;br /&gt;IDIVCX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 43 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 43 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 22-46 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IDIVmem IDIV DATAY 8086 190 &lt;br /&gt;IDIV LIST &lt;br /&gt;IDIV DATA6[DI] 8088 194 &lt;br /&gt;IDIV BYTE PTR [8X] 80286 28 &lt;br /&gt;IDIV WORD PTR [EBX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 46 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 44 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 22-46 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 813 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL Integer (signed) multiplication &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111011w oo101mmm disp o D I T S ZAP C &lt;br /&gt;. ? ? ? ? . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL reg IMUL BL 8086 154 &lt;br /&gt;IMULCX &lt;br /&gt;IMUL ECX 8088 154 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMULDH 80286 21 &lt;br /&gt;IMULAL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10-11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMULmem IMULDATAY 8086 160 &lt;br /&gt;IMUL LIST &lt;br /&gt;IMUL DATA6[DI] 8088 164 &lt;br /&gt;IMUL BYTE PTR [BX] 80286 24 &lt;br /&gt;IMUL WORD PTR [EBX] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10-11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;011010s1 oorrmmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL reg,imm IMULCX,16 8086 -&lt;br /&gt;IMUL 01,100 &lt;br /&gt;IMUL EOX,20 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL IMUL DX,AX,2 8086 -&lt;br /&gt;reg,reg,imm IMUL CX,OX,3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL BX,AX,33 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;814 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL IMUL CX,DATAY,99 8086 -&lt;br /&gt;reg,mem,imm &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10101111 oorrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL reg,reg IMULCX,DX 8086 -&lt;br /&gt;IMULDI,BX &lt;br /&gt;IMUL EDX,EBX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL reg,mem IMUL DX,DATAY 8086 -&lt;br /&gt;IMUL CX,L1ST &lt;br /&gt;IMUL ECX,DATA6[DI) 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN Input data from port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1110010w port# &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN acc,pt IN AL,12H 8086 10 &lt;br /&gt;IN AX,12H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 14 IN AL,OFFH &lt;br /&gt;IN AX,OAOH 80286 5 &lt;br /&gt;IN EAX,10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 815 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1110110w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IN acc,DX IN Al,DX 8086 8 &lt;br /&gt;IN AX,DX &lt;br /&gt;IN EAX,DX 8088 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I 80386 13 80486 14 &lt;br /&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC Increment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111111w ooOOOmmm disp o D I T S Z A P C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* * * * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC reg8 INC Bl 8086 3 &lt;br /&gt;INCBH &lt;br /&gt;INCAl 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INCAH 80286 2 &lt;br /&gt;INC DH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC mem INC DATA3 8086 15 + ea &lt;br /&gt;INC LIST &lt;br /&gt;INC COUNT 8088 23 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC BYTE PTR [DIJ 80286 7 &lt;br /&gt;INC WORD PTR [ECXl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC reg16 INCCX 8086 3 &lt;br /&gt;INC reg32 INCDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC BP 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC ECX 80286 2 &lt;br /&gt;INC ESP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;816 APPENDIX 8 INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INS Input string from port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0110110w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INSB INSB 8086 -&lt;br /&gt;INSW INSW &lt;br /&gt;INSD INSD 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INS DATA2 80286 5 &lt;br /&gt;REPINSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT Interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001101 type &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTtype INT12H 8086 51 &lt;br /&gt;INT15H &lt;br /&gt;INT 21H 8088 71 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT 2FH 80286 23 &lt;br /&gt;INT 10H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 37 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 30 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 16-82 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT3 Interrupt 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001100 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT3 8086 52 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 72 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 13-56 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX 8 INSTRUCTION SET SUMMARY 817 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTO Interrupt on overflow &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001110 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTO 8086 53 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 73 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 35 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 28 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 13-56 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INVD Invalidate data cache &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000111100001000 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTVD 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRET/IRETD Return from interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001101 data o 0 I T S ZAP C &lt;br /&gt;. . . . . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRET IRET 8086 32 &lt;br /&gt;IRETD IRETD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRET 100 8088 44 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8-27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;818 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Jcondition Conditional jump &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0111 cccc disp &lt;br /&gt;Fonnat Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Jcnd label JAABOVE 8086 16/4 &lt;br /&gt;(8-bit disp) JBBELOW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JG GREATER 8088 16/4 &lt;br /&gt;JE EQUAL 80286 7/3 &lt;br /&gt;JZZERO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7/3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3/1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 1000cccc disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Jcnd label JNE NOT_MORE 8086 -&lt;br /&gt;(16-bit disp) JLE LESS_OR_SO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7/3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 311 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Condition &lt;br /&gt;Codes Mnemonic Flag Description &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 JO 0=1 Jump if overflow &lt;br /&gt;0001 JNO 0=0 Jump if no overflow &lt;br /&gt;0010 . JB/NAE C = 1 Jump if below &lt;br /&gt;0011 JAElJNB C=O Jump if above or equal &lt;br /&gt;0100 JElJZ Z=1 Jump if equal/zero &lt;br /&gt;0101 JNE/JNZ Z=O Jump if not equal/zero &lt;br /&gt;0110 JBE/JNA C=1 +Z=1 Jump if below or equal &lt;br /&gt;0111 JAlJNBE C=OÂ·Z=O Jump if above &lt;br /&gt;1000 JS S = 1 Jump if sign &lt;br /&gt;1001 JNS S=O Jump if no sign &lt;br /&gt;1010 JP/JPE P = 1 Jump if parity &lt;br /&gt;1011 JNP/JPO P=O Jump if no parity &lt;br /&gt;1100 JUJNGE SÂ·O Jump if less than &lt;br /&gt;1101 JGElJNL S=O Jump if greater than or equal &lt;br /&gt;1110 JLElJNG Z=1+SÂ·0 Jump if less than or equal &lt;br /&gt;1111 JG/JNLE Z=O+S=O Jump if greater than &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 819 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JCXZlJECXZ Jump if CX (ECX) equals zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11100011 &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JCXZ label JCXZABOVE 8086 18/6 &lt;br /&gt;JECXZlabel JCXZBELOW &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JECXZ GREATER 8088 18/6 &lt;br /&gt;JECXZEQUAL 80286 8/4 &lt;br /&gt;JCXZ NEXT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 9/5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 8/5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 6/5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP Jump &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11101011 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP label JMP SHORT UP 8086 15 &lt;br /&gt;(short) JMP SHORT DOWN &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP SHORT OVER 8088 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP SHORT CIRCUIT 80286 7 &lt;br /&gt;JMP SHORT JOKE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11101001 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP label JMP VERS 8086 15 &lt;br /&gt;(near) JMP FROG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP UNDER 8088 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP NEAR PTR OVER 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;820 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11101010 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP label JMP NOT_MORE 8086 15 &lt;br /&gt;(far) JMP UNDER &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMPAGAIN 8088 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP FAR PTR THERE 80286 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111111oo100mmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP reg JMPAX 8086 11 &lt;br /&gt;(near) JMP EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMPCX 8088 11 &lt;br /&gt;JMPDX 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP mem JMP VERS 8086 18+ea &lt;br /&gt;(near) JMP FROG &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP CS:UNDER 8088 18+ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP DATA1[DI+2] 80286 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111111oo101mmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP mem JMPWAY_OFF 8086 24+ea &lt;br /&gt;(far) JMP TABLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMPUP 8088 24+ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JMP OUT_OF _HERE 80286 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 821 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LAHF Load AH from flags &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011111 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LAHF 8086 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LAR Load access rights byte &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000010 oorrrmmm disp o 0 I T S ZAP C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LAR reg, reg LARAX,BX 8086 -&lt;br /&gt;LARCX,DX &lt;br /&gt;LAR ECX,EDX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LAR reg,mem LAR CX,DATA1 8086 -&lt;br /&gt;LAR AX,LlST3 &lt;br /&gt;LAR ECX,TOAD 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;822 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOS Load far pointer to OS and register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11000101 oorrrmmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOS reg,mem LOS OI,OATA3 8086 16+ea &lt;br /&gt;LOS SI,LlST2 &lt;br /&gt;LOS BX,ARRAY _PTR 8088 24+ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOSCX,PNTR 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEA Load effective address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10001101 oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEA reg,mem LEA OI,OATA3 8086 2 +ea &lt;br /&gt;LEA SI,LlST2 &lt;br /&gt;LEA BX,ARRAY _PTR 8088 2 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEACX,PNTR 80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEAVE Leave high-level procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001001 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEAVE 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 823 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LES Load far pointer to ES and register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1100010000rrrmmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LES reg,mem LES DI,DATA3 8086 16 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;LES SI,LlST2 &lt;br /&gt;LES BX,ARRAY_PTR 8088 24 + ea &lt;br /&gt;LES CX,PNTR 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LFS Load far pointer to FS and register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10110100 oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LFS reg,mem LFS DI,DATA3 8086 -&lt;br /&gt;LFS SI,LlST2 &lt;br /&gt;LFS BX,ARRA Y _PTR 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LFS CX,PNTR 80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LGDT Load global descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000001 00010mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LGDTmem64 LGDT DESCRIP 8086 -&lt;br /&gt;LGDTTABLED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;824 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LGS Load far pointer to GS and register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10110101 oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LGS reg,mem LGS DI,DATA3 8086 -&lt;br /&gt;LGS SI,L1ST2 &lt;br /&gt;LGS BX,ARRAY_PTR 8088 -&lt;br /&gt;LGSCX,PNTR 80286 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LIDT Load interrupt descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000001 00011 mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;L1DTmem64 L1DTDATA3 8086 -&lt;br /&gt;L1DT L1ST2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LLDT Load local descriptor table &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000000 00010mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LLDT reg LLDT BX 8086 -&lt;br /&gt;LLDT DX &lt;br /&gt;LLDTCX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 825 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LLDTmem LLDTDATA1 8086 -&lt;br /&gt;LLDT LlST3 &lt;br /&gt;LLDTTOAD 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LMSW Load machine status word (80286 only) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000001 oo110mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LMSW reg LMSWBX 8086 -&lt;br /&gt;LMSWDX &lt;br /&gt;LMSWCX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LMSWmem LMSWDATA1 8086 -&lt;br /&gt;LMSW LlST3 &lt;br /&gt;LMSWTOAD 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;826 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOCK Lock the bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11110000 &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOCK:inst LOCK:XCHG AX,BX 8086 2 &lt;br /&gt;LOCK:AOO AL,3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LODS Load string operand &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1010110w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOSB LOOSB 8086 12 &lt;br /&gt;LOOSW LOOSW &lt;br /&gt;LOOSO LOOSO 8088 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOS OATA3 80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOP/LOOPD Loop until CX = 0 or ECX = 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11100010 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOP label LOOP NEXT 8086 17/5 &lt;br /&gt;LOOPO label LOOP BACK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPO LOOPS 8088 17/5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 8/4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7/6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 5/6 &lt;br /&gt;1--. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ptmtium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 827 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPE/LOOPED Loop while equal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11100001 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPE label LOOPEAGAIN 8086 18/6 &lt;br /&gt;LOOPED label LOOPED UNTIL &lt;br /&gt;LOOPZ label LOOPZZORRO 8088 18/6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPZD label LOOPZDWOW 80286 814 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 9/6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7/8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPNEILOOPNED Loop while not equal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11100000 disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPNE label LOOPNE FORWARD 8086 19/5 &lt;br /&gt;LOOPNED label LOOPNEDUPS &lt;br /&gt;LOOPNZ label LOOPNZ TRY_AGAIN 8088 19/5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPNZD label LOOPNZDWOO 80286 8/4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 9/6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7/8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSL Load segment limit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000011 oorrrmmm disp o 0 I T S ZAP C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSL reg,reg LSLAX,BX 8086 -&lt;br /&gt;LSLCX,BX &lt;br /&gt;LSL EDX,EAX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;828 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSL reg,mem LSL AX,LlMIT 8086 -&lt;br /&gt;LSLEAX,NUM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSS Load far pointer to 88 and register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10110010 oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSS reg,mem LSS DI,DATA1 8086 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSS SP,STACK_TOP &lt;br /&gt;LSS CX,ARRAY 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LTR Load task register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000000 00001 mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LTR reg LTRAX 8086 -&lt;br /&gt;LTRCX &lt;br /&gt;LTRDX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX 8 INSTRUCTION SET SUMMARY 829 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LTR mem16 LTR TASK 8086 -&lt;br /&gt;LTR NUM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVE Move data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100010dw oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVreg,reg MOVCL,CH 8086 2 &lt;br /&gt;MOVBH,CL &lt;br /&gt;MOVCX,DX 8088 2 &lt;br /&gt;MOVEAX,EBP 80286 2 &lt;br /&gt;MOV ESP,ESI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVmem,reg MOV DATA7,DL 8086 9 + ea &lt;br /&gt;MOVNUMB,CX &lt;br /&gt;MOV TEMP,EBX 8088 13+ ea &lt;br /&gt;MOV [ECX),BL 80286 3 &lt;br /&gt;MOV[Dlj,DH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVreg,mem MOV DL,DATA8 8086 10+ea &lt;br /&gt;MOV DX,NUMB &lt;br /&gt;MOV EBX,TEMP+3 8088 12 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CH,TEMP[EDI) 80286 5 &lt;br /&gt;MOV CL,DATA2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;830 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1100011w ooOOOmmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVmem,imm MOV OATAF,23H 8086 10 + ea &lt;br /&gt;MOV LlST,12H &lt;br /&gt;MOV BYTE PTR [01],2 8088 14+ea &lt;br /&gt;MOV NUMB,234H 80286 3 &lt;br /&gt;MOV OWORO PTR[ECX],1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1011 wrrr data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVreg,imm MOVBX,22H 8086 4 &lt;br /&gt;MOVCX,12H &lt;br /&gt;MOVCL,2 8088 4 &lt;br /&gt;MOV ECX,123456H 80286 3 &lt;br /&gt;MOV 01,100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101000dw disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVmem,acc MOV OATAF,AL 8086 10 &lt;br /&gt;MOV LlST,AX &lt;br /&gt;MOV NUMB,EAX 8088 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVacc,mem MOVAL,OATAE 8086 10 &lt;br /&gt;MOVAX,LlST &lt;br /&gt;MOV EAX,LUTE 8088 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 831 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100011dO oosssmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV seg,reg MOVSS,AX 8086 2 &lt;br /&gt;MOV DS,DX r-----&lt;br /&gt;MOV ES,CX 8088 2 &lt;br /&gt;MOV FS,BX 80286 2 &lt;br /&gt;MOV GS,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV seg,mem MOV SS,STACK_TOP 8086 8+ ea &lt;br /&gt;MOV DS,DATAS &lt;br /&gt;MOV ES,TEMP1 8088 12 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV reg,seg MOV BX,DS 8086 2 &lt;br /&gt;MOVCX,FS &lt;br /&gt;MOVCX,ES 8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVmem,seg MOV DATA2,CS 8086 9 + ea &lt;br /&gt;MOVTEMP,DS &lt;br /&gt;MOV NUMB1,SS 8088 13+ ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV TEMP2,GS 80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;832 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 001000dO 11 rrrmmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV reg,cr MOV EBX,CRO 8086 -&lt;br /&gt;MOV ECX,CR2 &lt;br /&gt;MOV EBX,CR3 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV cr,reg MOVCRO,EAX 8086 -&lt;br /&gt;MOVCR1,EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 MOVCR3,EDX -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 12-46 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111001000d111rrrmmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV reg,dr MOV EBX,DR6 8086 -&lt;br /&gt;MOV ECX,DR7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 MOV EBX,DR1 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV dr,reg MOV DRO,EAX 8086 -&lt;br /&gt;MOV DR1,EBX &lt;br /&gt;MOV DR3,EDX 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 22 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 833 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 001001dO 11rrrmmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV reg,tr MOV EBX,TR6 8086 -&lt;br /&gt;MOV ECX,TR7 I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVtr,reg MOVTR6,EAX 8086 -&lt;br /&gt;MOVTR7,EBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVS Move string data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1010010w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVSB MOVSB 8086 18 &lt;br /&gt;MOVSW MOVSW &lt;br /&gt;MOVSD MOVSD 8088 26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVS DATA1,DATA2 80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;834 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVSX Move with sign extend &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 1011111 W oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVSX reg,reg MOVSX BX,AL 8086 -&lt;br /&gt;MOVSX EAX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVSX reg,mem MOVSX AX,DATA34 8086 -&lt;br /&gt;MOVSX EAX,NUMB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVZX Move with zero extend &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 1011011w oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVZX reg,reg MOVZX BX,AL 8086 -&lt;br /&gt;MOVZX EAX,DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOVZX reg,mem MOVZX AX,DATA34 8086 -&lt;br /&gt;MOVZX EAX,NUMB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 835 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MUL Multiply &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111011w oo100mmm disp o 0 I T S Z A P C &lt;br /&gt;. ? ? ? ? * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MUL reg MULBL 8086 118 &lt;br /&gt;MULCX &lt;br /&gt;MULEDX 8088 143 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10 or 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MULmem MULDATA9 8086 139 &lt;br /&gt;MUL WOAD PTA [ESI] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 143 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 41 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 42 , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEG Negate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111011w oo011mmm disp o 0 I T S Z A P C &lt;br /&gt;. . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEG reg NEGBL 8086 3 &lt;br /&gt;NEGCX &lt;br /&gt;NEG EDI 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;836 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEG mem NEG DATA9 8086 16+ea &lt;br /&gt;NEG WORD PTR [ESI) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 24 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOP No operation &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10010000 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOP 8086 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOT One's complement &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111011w 00010mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOT reg NOTBL 8086 3 &lt;br /&gt;NOTCX &lt;br /&gt;NOTEDI 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10r3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOTmem NOTDATA9 8086 16 + ea &lt;br /&gt;NOT WORD PTR [ESI) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 24 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 837 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR Inclusive-OR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000010dw oorrrmmm disp o 0 I T S ZAP C &lt;br /&gt;0 . . ? . 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR reg,reg OR AX,BX 8086 3 &lt;br /&gt;ORAL,BL &lt;br /&gt;OR EAX,EBX 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORCX,SI 80286 2 &lt;br /&gt;OR ESI,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR mem,reg OR DATAY,AL 8086 16 + ea &lt;br /&gt;OR LlST,SI &lt;br /&gt;OR DATA2[DI1,CL 8088 24+ ea &lt;br /&gt;OR [EAX1,BL 80286 7 &lt;br /&gt;OR [EBX+2'ECX],EDX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR reg,mem OR BL,DATA1 8086 9+ ea &lt;br /&gt;OR SI,LlST1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 13+ ea OR CL,DATA2[Sll &lt;br /&gt;ORCX,[ESll 80286 7 &lt;br /&gt;OR ESI,[2'ECXl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 10r3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000sw 00001 mmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR reg,imm ORCX,3 8086 4 &lt;br /&gt;OR DI,1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 OR DL,34H &lt;br /&gt;OR EDX,1345H 80286 3 &lt;br /&gt;OR CX,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;838 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORmem,imm OR DATAS,3 8086 17 + ea &lt;br /&gt;OR BYTE PTR[EDI], 1 AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 25 +ea OR DADDY,34H &lt;br /&gt;OR LlST,'A' 80286 7 &lt;br /&gt;OR TOAD,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000110w data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ORacc,imm OR AX,3 8086 4 &lt;br /&gt;OR AL,1AH &lt;br /&gt;ORAH,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR EAX,1345H 80286 3 &lt;br /&gt;ORAL,'Y' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT Output data to port &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111Q011w port# &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTpt,acc OUT 12H,AL 8086 10 &lt;br /&gt;OUT 12H,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 14 OUTOFFH,AL &lt;br /&gt;OUTOAOH,AX 80286 3 &lt;br /&gt;OUT 10H,EAX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 12-26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1110111w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT DX,acc OUT DX,AL 8086 8 &lt;br /&gt;OUT DX,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 12 OUT DX,EAX &lt;br /&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 12-26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 839 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTS Output string to port &lt;br /&gt;-~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0110111w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTSB OUTSB 8086 -&lt;br /&gt;OUTSW OUTSW &lt;br /&gt;OUTSD OUTSD 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUTS DATA2 80286 5 &lt;br /&gt;REP OUTSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 13--:27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP POp data from stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01011rrr &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POP reg POPCX 8086 8 &lt;br /&gt;POP AX &lt;br /&gt;POP EDI 8088 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10001111 ooOOOmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPmem POP DATA1 8086 17 + ea &lt;br /&gt;POP LISTS &lt;br /&gt;POP NUMBS 8088 25 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;840 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00sss111 &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPseg POPDS 8086 8 &lt;br /&gt;POPES &lt;br /&gt;POPSS 8088 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10sss001 &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPseg POPFS 8086 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPGS &lt;br /&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPA/POPAD POp all registers from stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01100001 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPA 8086 -&lt;br /&gt;POPAD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 841 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPF/POPFD POp flags from stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10010000 o D I T S Z A P C &lt;br /&gt;. . . . . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POPF 8086 8 &lt;br /&gt;POPFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4or6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH Push data onto stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01010rrr &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH reg PUSH CX 8086 11 &lt;br /&gt;PUSH AX &lt;br /&gt;PUSH EDI 8088 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111111 0011 Ommm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH mem PUSH DATA1 8086 16 + ea &lt;br /&gt;PUSH LISTS &lt;br /&gt;PUSH NUMBS 8088 24 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;842 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00ss110 &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH seg PUSH ES 8086 10 &lt;br /&gt;PUSHCS &lt;br /&gt;PUSH OS 8088 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10sssooo &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH seg PUSH FS 8086 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHGS &lt;br /&gt;8088 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;011010s0 data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHimm PUSH2000H 8086 -&lt;br /&gt;PUSH 53220 &lt;br /&gt;PUSHW 10H 8088 -&lt;br /&gt;PUSH',' 80286 3 &lt;br /&gt;PUSHO 100000H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 843 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHAIPUSHAD Push all registers onto stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01100000 &lt;br /&gt;Example Micro~,rocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PU8HA 8086 -&lt;br /&gt;PU8HAD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSHF/PUSHFD Push flags onto stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011100 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PU8HF 8086 10 &lt;br /&gt;PU8HFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 30r4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCLJRCRlROLJROR Rotate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101000w ooTITmmm disp o D I T 8 ZAP C &lt;br /&gt;. . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TIT = 000 = ROL, TIT = 001 = ROR, TIT = 010 = RCL, and TIT = 011 = RCR &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL reg,1 ROL CL,1 8086 2 &lt;br /&gt;ROR reg,1 ROL DX,1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RORCH,1 8088 2 &lt;br /&gt;ROR 81,1 80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;844 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCL reg,1 RCL CL,1 8086 2 &lt;br /&gt;RCR reg,1 RCL 81,1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 RCR AH,1 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCR EBX,1 80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROLmem,1 ROLDATAY,1 8086 15+ ea &lt;br /&gt;RORmem,1 ROL LlST,1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 23+ea ROA DATA2[Dlj,1 &lt;br /&gt;ROR BYTE PTR [EAXj,1 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCL mem,1 RCL DATA 1 ,1 8086 15+ea &lt;br /&gt;RCRmem,1 RCL Ll8T,1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 RCR DATA2[8Ij,1 23+ ea &lt;br /&gt;RCR WORD PTR [E8Ij,1 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101001w ooTTTmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL reg,CL ROLCH,CL 8086 8 +4n &lt;br /&gt;ROR reg,CL ROLDX,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RORAL,CL 8088 8+4n &lt;br /&gt;ROR E81,CL 80286 5+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 845 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCL reg,CL RCL CH,CL 8086 8 + 4n &lt;br /&gt;RCR reg,CL RCL SI,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCR AH,CL 8088 8 + 4n &lt;br /&gt;RCR EBX,CL 80286 5 + r, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7-27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL mem,CL ROL DATAY,CL 8086 20 + 4n &lt;br /&gt;ROR mem,CL ROL LlST,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROR DATA2[Dlj,CL 8088 28 + 4n &lt;br /&gt;ROR BYTE PTR [EAX],CL 80286 8+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCLmem,CL RCLDATA1,CL 8086 20 + 4n &lt;br /&gt;RCR mem,CL RCL LlST,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCR DATA2[SI],CL 8088 28 + 4n &lt;br /&gt;RCR WORD PTR [ESI],CL 80286 8+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9-26 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1100000w ooTTTmmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL reg,imm ROLCH,4 8086 -&lt;br /&gt;ROR reg,imm ROL DX,5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROR AL,2 8088 -&lt;br /&gt;ROR ESI,14 80286 5+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;846 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCL reg,imm RCL CL,2 8086 -&lt;br /&gt;RCR reg,imm RCL SI,12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 RCRAH,5 -&lt;br /&gt;RCR EBX,18 80286 5+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8-27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROLmem,imm ROL DATAY,4 8086 -&lt;br /&gt;RORmem,imm ROL LlST,3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROR DATA2[Dlj,7 8088 -&lt;br /&gt;ROR BYTE PTR [EAXj,11 80286 8+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1or3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCLmem,imm RCL DATA1,5 8086 -&lt;br /&gt;RCRmem,imm RCL LlST,3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCR DATA2[Slj,9 8088 -&lt;br /&gt;RCR WORD PTR [ESlj,8 80286 8+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8-27 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDMSR Read model specific register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00110010 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RDMSR 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 20-24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 847 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REP Repeat prefix &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111100111010010w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REP MOVS REP MOVSB 8086 9 + 17n &lt;br /&gt;REP MOVSW &lt;br /&gt;REP MOVSD 8088 9 +25n &lt;br /&gt;REP MOVS DATA1,DATA2 80286 5 + 4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 8 +4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 12 + 3n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 13 + n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111100111010101w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPSTOS REP STOSB 8086 9 + 10n &lt;br /&gt;REPSTOSW &lt;br /&gt;REP STOSD 8088 9 + 14n &lt;br /&gt;REP STOS ARRAY 80286 4 + 3n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 + 5n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7 + 4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111100110110110w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REP INS REPINSB 8086 -&lt;br /&gt;REP INSW &lt;br /&gt;REP INSD 8088 -&lt;br /&gt;REP INS ARRAY 80286 5 + 4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 12 + 5n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 17 + 5n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 25 + 3n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;848 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111100110110111w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REP OUTS REPOUTSB 8086 -&lt;br /&gt;REPOUTSW &lt;br /&gt;REPOUTSD 8088 -&lt;br /&gt;REP OUTS ARRAY 80286 5+4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 12 + 5n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 17 + 5n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 25 +4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPEIREPNE Repeat conditional &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111100-11 1010011w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPE CMPS REPE CMPSB 8086 9+ 22n &lt;br /&gt;REPE CMPSW &lt;br /&gt;REPE CMPSD 8088 9+ 30n &lt;br /&gt;REPE CMPS DATA1.DATA2 80286 5+ 9n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5+ 9n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7+ 7n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9+4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111100111010111w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPE SCAS REPE SCASB 8086 9 + 15n &lt;br /&gt;REPE SCASW &lt;br /&gt;REPE SCASD 8088 9 + 19n &lt;br /&gt;REPE SCAS ARRAY 80286 5+ 8n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5+ 8n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7+ 5n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9+ 4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX 8 INSTRUCTION SET SUMMARY 849 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;111100101010011w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPNECMPS REPNECMPSB 8086 9 + 22n &lt;br /&gt;REPNECMPSW &lt;br /&gt;REPNECMPSD B088 9 + 30n &lt;br /&gt;REPNE CMPS ARRAY,L1ST B02B6 5 + 9n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B03B6 5 + 9n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 7 +7n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 8 + 4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11110010101011w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPNE SCAS REPNE SCASB 8086 9 + 15n &lt;br /&gt;REPNE SCASW &lt;br /&gt;REPNE SCASD B088 9+ 19N &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPNE SCAS ARRAY B02B6 5 + 8n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 + Bn &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B0486 7 + 5n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 9 + 4n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET Return from procedure &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11000011 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET B086 16 &lt;br /&gt;(near) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;B0486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;850 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11000010 data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RETimm RET4 8086 20 &lt;br /&gt;(near) RET100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001011 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET 8086 26 &lt;br /&gt;(far) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 34 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4-23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11001010 data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RETimm RET4 8086 25 &lt;br /&gt;(far) RET 100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 33 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4-23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 851 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RSM Resume from system management mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10101010 o 0 I T S Z A P C &lt;br /&gt;. . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· Â· &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· Â· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RSM 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I 8088 -80286 -&lt;br /&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 83 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAHF Store AH into flags &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011110 o 0 I T S Z A P C &lt;br /&gt;Â· Â· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· Â· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAHF 8086 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAUSARISHUSHR Shift &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101000w ooTTTmmm disp 0 0 I T S Z A P C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Â· Â· &lt;br /&gt;? &lt;br /&gt;Â· Â· &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TTT = 100 = SHUSAL, TTT = 101 = SHR, and TTT = 111 = SAR &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAL reg,1 SALCL,1 8086 2 &lt;br /&gt;SHL reg,1 SHL DX,1 &lt;br /&gt;SHR reg,1 SAR CH,1 8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAR reg,1 SHR SI,1 80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;852 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAL mem,1 SAL DATA1,1 8086 15 + ea &lt;br /&gt;SHLmem,1 SHL BYTE PTR [DI],1 &lt;br /&gt;SHR mem,1 SAR NUMB,1 8088 23+ea &lt;br /&gt;SARmem,1 SHR WORD PTR[EDI],1 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101001w ooTTTmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SALreg,CL SALCH,CL 8086 8+4n &lt;br /&gt;SHL reg,CL SHLDX,CL &lt;br /&gt;SAR reg,CL SARAL,CL 8088 8+4n &lt;br /&gt;SHR reg,CL SHR ESI,CL 80286 5+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SALmem,CL SAL DATAU,CL 8086 20 +4n &lt;br /&gt;SHLmem,CL SHL BYTE PTR [ESI],CL &lt;br /&gt;SARmem,CL SAR NUMB,CL 8088 28 +4n &lt;br /&gt;SHR mem,CL SHRTEMP,CL 80286 8+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1100000w ooTTTmmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAL reg,imm SALCH,4 8086 -&lt;br /&gt;SHLreg,imm SHL DX,10 &lt;br /&gt;SAR reg,imm SAR AL,2 8088 -&lt;br /&gt;SHR reg,imm SHR ESI,23 80286 5+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;., &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX 8 INSTRUCTION SET SUMMARY 853 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SALmem,imm SAL DATAU,3 8086 -&lt;br /&gt;SHLmem,imm SHL BYTE PTR [ESll,15 &lt;br /&gt;SAR mem,imm SAR NUMB,3 8088 -&lt;br /&gt;SHRmem,imm SHRTEMP,5 80286 8+n &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB Subtract with borrow &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000110dw oorrrmmm disp o D I T S ZAP C &lt;br /&gt;. . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB reg,reg SBB CL,DL 8086 3 &lt;br /&gt;SBB AX,DX &lt;br /&gt;SBB CH,CL 8088 3 &lt;br /&gt;SBB EAX,EBX 80286 2 &lt;br /&gt;SBB ESI,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB mem,reg SBB DATAJ,CL 8086 16 + ea &lt;br /&gt;SBB BYTES,CX &lt;br /&gt;SBB NUMBS,ECX 8088 24 + ea &lt;br /&gt;SBB [EAXl,CX 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB reg,mem SBB CL,DATAL 8086 9 + ea &lt;br /&gt;SBB CX,BYTES &lt;br /&gt;SBB ECX,NUMBS 8088 13 +ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB DX,[EBX+EDll 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;854 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000sw 00011 mmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB reg,imm SBB CX,3 8086 4 &lt;br /&gt;SBB DI,1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 SBB DL,34H &lt;br /&gt;SBB EDX,1345H 80286 3 &lt;br /&gt;SBB CX,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBBmem,imm SBBDATAS,3 8086 17 + ea &lt;br /&gt;SBB BYTE PTR[EDI1,1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 25 + ea SBB DADDV,34H &lt;br /&gt;SBB LlST,'A' 80286 7 &lt;br /&gt;SBB TOAD,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0001110w data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB acc,imm SBB AX,3 8086 4 &lt;br /&gt;SBB AL,1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 SBB AH,34H &lt;br /&gt;SBB EAX,1345H 80286 3 &lt;br /&gt;SBB AL,'V' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SeAS Scan string &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1010111w o D I T S Z A P C &lt;br /&gt;. . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCASB SCASB 8086 15 &lt;br /&gt;SCASW SCASW &lt;br /&gt;SCASD SCASD 8088 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCAS DATAF 80286 7 &lt;br /&gt;REP SCASB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 855 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SETcondition Conditional set &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 1001 cccc ooOOOmmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SETcnd reg8 SETA BL 8086 -&lt;br /&gt;SETBCH &lt;br /&gt;SETG DL 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SETE BH 80286 -&lt;br /&gt;SETZAL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SETcnd mem8 SETE DATAK 8086 -&lt;br /&gt;SETAE LESS_OR_SO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Condition &lt;br /&gt;Codes Mnemonic Flag Description &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0000 SETO 0=1 Set if overflow &lt;br /&gt;0001 SETNO 0=0 Set if no overflow &lt;br /&gt;0010 SETB/SETAE C = 1 Set if below &lt;br /&gt;0011 SETAEISETNB C=O Set if above or equal &lt;br /&gt;0100 SETE/SETZ Z=1 Set if equaVzero &lt;br /&gt;0101 SETNEISETNZ Z=O Set if not equaVzero &lt;br /&gt;0110 SETBE/SETNA C=1+Z=1 Set if below or equal &lt;br /&gt;0111 SETAISETNBE C=OÂ·Z=O Set if above &lt;br /&gt;1000 SETS S = 1 Set if sign &lt;br /&gt;1001 SETNS S=O Set if no sign &lt;br /&gt;1010 SETP/SETPE P = 1 Set if parity &lt;br /&gt;1011 SETNP/SETPO P=O Set if no parity &lt;br /&gt;1100 SETUSETNGE SÂ·O Set if less than &lt;br /&gt;1101 SETGE/SETNL S=O Set if greater than or equal &lt;br /&gt;1110 SETLE/SETNG Z=1+SÂ·0 Set if less than or equal &lt;br /&gt;1111 SETG/SETNLE Z=O+S=O Set if greater than &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;856 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SGDT/SIDT/SLDT Store descriptor table registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000001 ooOOOmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SGOTmem SGOTMEMORY 8086 -&lt;br /&gt;SGOTGLOBAL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PentiLm 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000001 00001 mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SIOTmem SlOT OATAS 8086 -&lt;br /&gt;SlOT INTERRUPT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000000 ooOOOmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SLOT reg SLOT CX 8086 -&lt;br /&gt;SLOT OX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286Â· 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SLOTmem SLOT NUMBS 8086 -&lt;br /&gt;SLOT LOCALS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 857 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHLD/SHRD Double precision shift &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10100100 oorrrmmm disp data o D I T S Z A P C &lt;br /&gt;? * * ? * * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHLD SHLD AX,CX,10 8086 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;reg,reg,imm SHLD DX,BX,8 &lt;br /&gt;SHLD CX,DX,2 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHLD SHLD DATAQ,CX,8 8086 -&lt;br /&gt;mem,reg,imm &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10101100 oorrrmmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHRD SHRD CX,DX,2 8086 -&lt;br /&gt;reg,reg,imm &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHRD SHRD DATAZ,DX,4 8086 -&lt;br /&gt;mem,reg,imm &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;858 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000011111010010100rrrmmmdisp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHLD SHLD BX,DX,CL 8086 -&lt;br /&gt;reg,reg,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4or5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHLD SHLD DATAZ,DX,CL 8086 -&lt;br /&gt;mem,reg,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 40r 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 10101101 oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHRD SHRD AX,DX,CL 8086 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;reg,reg,CL &lt;br /&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4or5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHRD SHRD DATAZ,DX,CL 8086 -&lt;br /&gt;mem,reg,CL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 &lt;br /&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 or5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 859 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SMSW Store machine status word (80286) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000001 oo100mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SMSW reg SMSWAX 8086 -&lt;br /&gt;SMSWDX &lt;br /&gt;SMSWBP 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SMSWmem SMSWDATAQ 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STC Set carry flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111001 o 0 I T S ZAP C &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STC 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;860 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STD Set direction flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111101 o D I T S ZAP C &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STD 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STI Set interrupt flag &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11111011 o D I T S ZAP C &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STI 8086 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOS Store string data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1010101w &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOSB STOSB 8086 11 &lt;br /&gt;STOSW STOSW &lt;br /&gt;STOSD STOSD 8088 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOS DATA_LIST 80286 3 &lt;br /&gt;REPSTOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 40 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 861 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STR Store task register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000000 00001 mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STR reg STRAX 8086 -&lt;br /&gt;STRDX &lt;br /&gt;STRBP 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STR mem STR DATA3 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB Subtract &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000101 dw oorrrmmm disp o 0 I T S ZAP C &lt;br /&gt;. . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB reg,reg SUB CL,DL 8086 3 &lt;br /&gt;SUB AX,DX &lt;br /&gt;SUBCH,CL 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB EAX,EBX 80286 2 &lt;br /&gt;SUB ESI,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;862 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB mem,reg SUB DATAJ,CL 8086 16 + ea &lt;br /&gt;SUB BYTES,CX &lt;br /&gt;SUB NUMBS,ECX 8088 24 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB [EAXJ,CX 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB reg,mem SUB CL,DATAL 8086 9 +ea &lt;br /&gt;SUB CX,BYTES &lt;br /&gt;SUB ECX,NUMBS 8088 13+ ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB DX,[EBX+EDIJ 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000sw oo101mmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB reg,imm SUB CX,3 8086 4 &lt;br /&gt;SUB DI,1AH &lt;br /&gt;SUB DL,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB EDX,1345H 80286 3 &lt;br /&gt;SUB CX,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUBmem,imm SUB DATAS,3 8086 17+ ea &lt;br /&gt;SUB BYTE PTR[EDIJ,1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 25 + ea SUB DADDY,34H &lt;br /&gt;SUB LlST,'A' 80286 7 &lt;br /&gt;SUB TOAD,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 863 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010110w data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUF3 acc,imm SUB AL,3 8086 4 &lt;br /&gt;SUB AX,lAH &lt;br /&gt;SUB EAX,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST Test operands (logical compare) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1000001w oorrrmmm disp o 0 I T S ZAP C &lt;br /&gt;0 . . ? . 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST reg,reg TEST CL,DL 8086 5 &lt;br /&gt;TEST BX,DX &lt;br /&gt;TESTDH,CL 8088 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST EBP,EBX 80286 2 &lt;br /&gt;TEST EAX,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium lor 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST mem,reg TEST DATAJ,CL 8086 9 + ea &lt;br /&gt;reg,mem TEST BYTES,CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 13 + ea TEST NUMBS,ECX &lt;br /&gt;TEST [EAXj,CX 80286 6 &lt;br /&gt;TEST CL,POPS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium lor 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;864 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1111011 sw ooOOOmmm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST reg,imm TEST BX,3 8086 4 &lt;br /&gt;TEST DI,1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 TEST DH,44H &lt;br /&gt;TEST EDX,1 AB345H 80286 3 &lt;br /&gt;TEST SI,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST mem,imm TEST DATAS,3 8086 11 + ea &lt;br /&gt;TEST BYTE PTR[EDI1,1AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 11 + ea TEST DADDY,34H &lt;br /&gt;TEST LlST,'A' 80286 6 &lt;br /&gt;TEST TOAD,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1010100w data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST acc,imm TEST AL,3 8086 4 &lt;br /&gt;TEST AX,1AH &lt;br /&gt;TEST EAX,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 865 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VERRNERW Verify read/write &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000000 00100mmm disp o 0 I T S ZAP C &lt;br /&gt;. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VERR reg VERR CX 8086 -&lt;br /&gt;VERR OX &lt;br /&gt;VERR 01 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VERRmem VERR OATAJ 8086 -&lt;br /&gt;VERR TESTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00000000 00101 mmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VERW reg VERWCX 8086 -&lt;br /&gt;VERW OX &lt;br /&gt;VERWDI 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VERWmem VERWDATAJ 8086 -&lt;br /&gt;VERWTESTS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;866 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT Wait for coprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10011011 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT 8086 4 &lt;br /&gt;FWAIT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WBINVD Write-back cache invalidate data cache &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00001001 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WBINVD 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2000+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WRMSR' Write to model specific register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 00110000 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WRMSR 8086 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 30-45 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 867 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XADD Exchange and add &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 1100000w 11 rrrrrr o 0 I T S Z A P C &lt;br /&gt;. . . . . . &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XADD reg,reg XADD EBX,ECX 8086 -&lt;br /&gt;XADD EDX,EAX &lt;br /&gt;XADD EDI,EBP 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 30r4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00001111 1100000w oorrrmmm disp &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XADD mem,reg XADD DATA5,ECX 8086 -&lt;br /&gt;XADD [EBX],EAX &lt;br /&gt;XADD[ECX+4],EBP 8088 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 -&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 30r4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG Exchange &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1000011 W oorrrmmm &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG reg,reg XCHG CL,DL 8086 4 &lt;br /&gt;XCHG BX,DX &lt;br /&gt;XCHG DH,CL 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG EBP,EBX 80286 3 &lt;br /&gt;XCHG EAX,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;868 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG mem,reg XCHG DATAJ,CL 8086 17 + ea &lt;br /&gt;reg,mem XCHG BYTES,CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG NUMBS,ECX 8088 25 + ea &lt;br /&gt;XCHG [EAXJ,CX 80286 5 &lt;br /&gt;XCHG CL,POPS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10010reg &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG acc,reg XCHG BX,AX 8086 3 &lt;br /&gt;reg,acc XCHGAX,DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG DH,AL 8088 3 &lt;br /&gt;XCHG EDX,EAX 80286 3 &lt;br /&gt;XCHG SI,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XLAT Translate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11010111 &lt;br /&gt;Example Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XLAT 8086 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8088 11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX B INSTRUCTION SET SUMMARY 869 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR Exclusive-OR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;000110dw oorrrmmm disp o 0 I T S Z A P C &lt;br /&gt;0 . . ? . 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR reg,reg XOR CL,DL 8086 3 &lt;br /&gt;XORAX,DX &lt;br /&gt;XORCH,CL 8088 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR EAX,EBX 80286 2 &lt;br /&gt;XOR ESI,EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR mem,reg XOR DATAJ,CL 8086 16 + ea &lt;br /&gt;XOR BYTES,CX &lt;br /&gt;XOR NUMBS,ECX 8088 24 + ea &lt;br /&gt;XOR [EAX),CX 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR reg,mem XOR CL,DATAL 8086 9 + ea &lt;br /&gt;XOR CX,BYTES &lt;br /&gt;XOR ECX,NUMBS 8088 13 + ea &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR DX,[EBX+EDI) 80286 7 &lt;br /&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;100000sw 0011 Ommm disp data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR reg,imm XORCX,3 8086 4 &lt;br /&gt;XOR DI,1AH &lt;br /&gt;XOR DL,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR EDX,1345H 80286 3 &lt;br /&gt;XOR CX,1834H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;870 APPENDIX B INSTRUCTION SET SUMMARY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XORmem,imm XOR DATAS,3 8086 17 + ea &lt;br /&gt;XOR BYTE PTR[EDI],1AH &lt;br /&gt;XOR DADDY,34H 8088 25 + ea &lt;br /&gt;XOR LlST,'A' &lt;br /&gt;XOR TOAD,1834H 80286 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 or 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0010101w data &lt;br /&gt;Format Examples Microprocessor Clocks &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XOR acc,imm XORAL,3 8086 4 &lt;br /&gt;XOR AX,1AH &lt;br /&gt;XOR EAX,34H 8088 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80286 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80386 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80486 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium Pro &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIXC &lt;br /&gt;Flag-Bit Changes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This appendix shows only the instructions that actually change the flag bits. Any instruction not &lt;br /&gt;listed does not affect any of the flag bits. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction 0 D T S Z A P C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAA ? ? ? ? &lt;br /&gt;AAD ? ? ? &lt;br /&gt;AAM ? ? ? &lt;br /&gt;AAS ? ? ? ? &lt;br /&gt;ADC &lt;br /&gt;ADD &lt;br /&gt;AND 0 ? 0 &lt;br /&gt;ARPL &lt;br /&gt;BSF &lt;br /&gt;BSR &lt;br /&gt;BT &lt;br /&gt;BTC &lt;br /&gt;BTR &lt;br /&gt;BTS &lt;br /&gt;CLC 0 &lt;br /&gt;CLD 0 &lt;br /&gt;CLI 0 &lt;br /&gt;CMC &lt;br /&gt;CMP &lt;br /&gt;CMPS &lt;br /&gt;CMPXCHG &lt;br /&gt;CMPXCHG8B &lt;br /&gt;DAA ? &lt;br /&gt;DAS ? &lt;br /&gt;DEC &lt;br /&gt;DIV ? ? ? ? ? ? &lt;br /&gt;IDIV ? ? ? ? ? ? &lt;br /&gt;IMUL ? ? ? ? &lt;br /&gt;INC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Continued on next page) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;871 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;872 APPENDIX C FLAG-BIT CHANGES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Instruction 0 D T S Z A P C &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRET &lt;br /&gt;LAR &lt;br /&gt;LSL &lt;br /&gt;MUL ? ? ? ? &lt;br /&gt;NEG * &lt;br /&gt;OR 0 ? 0 &lt;br /&gt;POPF &lt;br /&gt;RCURCR &lt;br /&gt;REPE/REPNE &lt;br /&gt;ROUROR &lt;br /&gt;SAHF &lt;br /&gt;SAUSAR ? &lt;br /&gt;SHUSHR ? &lt;br /&gt;SBB &lt;br /&gt;SCAS &lt;br /&gt;SHLD/SHRD ? * ? &lt;br /&gt;STC &lt;br /&gt;STD &lt;br /&gt;STI &lt;br /&gt;SUB &lt;br /&gt;TEST 0 ? 0 &lt;br /&gt;VERRNERW &lt;br /&gt;XADD &lt;br /&gt;XOR 0 ? 0 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D &lt;br /&gt;Answers to Selected Even-Numbered &lt;br /&gt;Questions and Problems &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 1 &lt;br /&gt;2. Herman Hollerith &lt;br /&gt;4. Konrad Zuse &lt;br /&gt;6. ENIAC &lt;br /&gt;8. Augusta Ada Bryon &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. A machine that stores its program in the memory system. &lt;br /&gt;12. over 100,000,000 &lt;br /&gt;14. 16M &lt;br /&gt;16. 1993 &lt;br /&gt;18. Pentium Pro &lt;br /&gt;20. Complex instruction computer system &lt;br /&gt;22. 1,024 &lt;br /&gt;24. 1,024M &lt;br /&gt;26. TPA and systems &lt;br /&gt;28. 384K &lt;br /&gt;30. 16M &lt;br /&gt;32. extended memory &lt;br /&gt;34. DOS is the disk oper~ting system that controls the personal computer system. &lt;br /&gt;36. The VESA local bus is a peripheral bus in the personal computer system. &lt;br /&gt;38. XMS is the extended memory system (the area of memory above the first 1M byte of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory). &lt;br /&gt;40. upper memory area or the TP A &lt;br /&gt;42. A TSR is accessed either through an interrupt or a hot-key. &lt;br /&gt;44. The AUTOEXEC.BAT program relieves the user from entering the same commands each &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;time that the computer system is started. &lt;br /&gt;46. 64K &lt;br /&gt;48. CONFIG.SYS &lt;br /&gt;50. The video BIOS is located at location COOOOH-C7FFFH &lt;br /&gt;52. The microprocessor is the controlling element that performs data transfers, arithmetic, logic, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and makes decisions. &lt;br /&gt;54. The address bus. &lt;br /&gt;56. The 10RC signal informs the I/O device that it is time to read data from the I/O device into &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the microprocessor. &lt;br /&gt;58. (a) 13.25 (b) 57.1875 (c) 43.3125 (d) 7.0625 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;873 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;874 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;60. (a) 163.1875 (b) 297.75 (c) 172.859375 (d) 4,011.1875 (e) 3,00010578125 &lt;br /&gt;62. (a) 0.101 2,0.58, and 0.D16 (b) 0.00000001 2, 0.0028, and 0.01 16 (c) 0.10100001 2, 0.5028, and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0.Al'6 (d) 0.11 2, 0.68, and 0,C16 (e) 0.1111 2, 0.748, and 0.F16 &lt;br /&gt;64. (a) C2 (b) lOFD (c) B.C Cd) 10 (e) 8BA &lt;br /&gt;66. (a) 0111 1111 (b) 0101 0100 (c) 0101 0001 (d) 10000000 &lt;br /&gt;68. (a) 4652 4F 47 (b) 41 72 63 (c) 57 61 746572 (d) 57 65 6C 6C &lt;br /&gt;70. MESS DB 'What time is itT &lt;br /&gt;72. (a) 000000111110 1000 (b) 111111111000 1000 (c) 00000011 0010 0000 (d) 1111 0011 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0111 0100 &lt;br /&gt;74. (a) 3412 (b) 22 Al (c) 00 Bl &lt;br /&gt;76. DATA2 DW 123AH &lt;br /&gt;78. (a) -128 (b) +51 (c) -110 (d) -118 &lt;br /&gt;80. (a) 001111111 10000000000000000000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) 1 10000010 01010100000000000000000 &lt;br /&gt;(c) 0 10000101 10010001000000000000000 &lt;br /&gt;(d) 1 10001001 00101100000000000000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 2 &lt;br /&gt;2. 16-bits &lt;br /&gt;4. EBX &lt;br /&gt;6. The instruction pointer is used by the microprocessor to locate the next instruction in a program. &lt;br /&gt;8. No &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The interrupt flag (I) &lt;br /&gt;12. The segment register locates the start of a 64K memory segment. &lt;br /&gt;14. (a) 12000H (b) 21000H (c) 24AOOH (d) 25000H (e) 3F120H &lt;br /&gt;16. ES:DI and DS:SI &lt;br /&gt;18. Stack segment plus the stack offset. &lt;br /&gt;20. (a) 12000H (b) 21002H (c) 26200H (d) A1000H (e) 2CAOOH &lt;br /&gt;22. Any location between and including OOooOOH-FFFFFFH &lt;br /&gt;24. The segment register contains a selector that chooses a descriptor from either the local or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;global descriptor table. It also contains the requested privilege level. &lt;br /&gt;26. AOOOOOH-A01000H &lt;br /&gt;28. Base address = 00280000H and end address = 00290000H &lt;br /&gt;30. 3 &lt;br /&gt;32. 64K bytes &lt;br /&gt;34. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;03 10 &lt;br /&gt;09 00 &lt;br /&gt;00 00 &lt;br /&gt;30 00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36. The LDT is addressed through the local descriptor table register. &lt;br /&gt;38. The program invisible registers are the cache portion of the segment register, the task reg-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ister, and the descriptor table register &lt;br /&gt;40. 4K bytes &lt;br /&gt;42. 1,024 &lt;br /&gt;44. Page directory OOOH and page table entry 200H &lt;br /&gt;46. The TLB stores the last 22 linear-to-physical address translations from the paging unit. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVENÂ·NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 3 &lt;br /&gt;2. AH, AL, BH, BL, CH, CL, DH, and DL &lt;br /&gt;4. EAX, EBX, ECX, EDX, ESP, EBP, EDI, and ESI &lt;br /&gt;6. You may not mix register sizes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;875 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. (a) MOV EDX,EBX (b) MOV CL,BL (c) MOV BX,SI (d) MOV AX,DS (e) MOV AH,AL &lt;br /&gt;10. # &lt;br /&gt;12 .. CODE &lt;br /&gt;14. Opcode field &lt;br /&gt;16. This is an assembly language directive that returns control to DOS. &lt;br /&gt;18. The .STARTUP directive loads the DS register with the segment address of the data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;segment. &lt;br /&gt;20. The [ ] symbols denote indirect addressing. &lt;br /&gt;22. Memory-to-memory transfers are not allowed. &lt;br /&gt;24. MOV WORD PTR [DI],3 &lt;br /&gt;26. The MOV BX,DATA instruction copies the contents of a data segment memory location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DATA into BX, while the MOV BX,OFFSET DATA instruction loads BX with the offset &lt;br /&gt;address of DATA. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28. Nothing is wrong with this instruction. &lt;br /&gt;30. (a) 11750H (b) 11950H (c) 11700H &lt;br /&gt;32. BPIEBP &lt;br /&gt;34. FIELDS STRUC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Fl DW ? &lt;br /&gt;F2 DW ? &lt;br /&gt;F3 DW ? &lt;br /&gt;F4 DW ? &lt;br /&gt;FS DW ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIELDS ENDS &lt;br /&gt;36. Direct, indirect, and stack. &lt;br /&gt;38. The intrasegment jump is within a segment, while the intersegment jump is to any location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;in the memory system. &lt;br /&gt;40. 32~bit &lt;br /&gt;42. Short &lt;br /&gt;44. JMPBX &lt;br /&gt;46. Two bytes are stored for a 16-bit PUSH and four by a 32-bit PUSH. &lt;br /&gt;48. AX, CX, DX, BX, SP, BP, DI and SL &lt;br /&gt;50. PUSHFD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 4 &lt;br /&gt;2. The W -bit selects either a byte (W = 0) or a wordldoubleword (W = 1). The D-bit selects the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;direction of flow between the register field and the register/memory field. &lt;br /&gt;4. DL &lt;br /&gt;6. DS:[BX+DI] &lt;br /&gt;8. MOV AX,DI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. 8B 77 02 &lt;br /&gt;12. You should never change CS without also changing IP. This instruction would most likely &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cause the system to crash because only the segment portion of the address of the next in-&lt;br /&gt;struction is changed. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. 16-bit &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;876 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. AX, CX, DX, BX, SP, BP, SI, and DI &lt;br /&gt;18. (a) The PUSH AX instruction pushes the contents of AX onto the stack. (b) The POP ESI in-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;struction removes a 32-bit number from the stack and places it into ESI. (c) The PUSH [BX] &lt;br /&gt;instruction pushes the l6-bit contents of the data segment memory location addressed by BX &lt;br /&gt;onto the stack. (d) The PUSHFD instruction pushes the EFLAG register onto the stack. (e) &lt;br /&gt;The POP DS instruction removes a l6-bit number from the stack and places it into the DS &lt;br /&gt;register. (f) The PUSHD 4 instruction places a 32-bit number 4 onto the stack. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. The PUSH EAX instruction places bits 31-24 of EAX into memory location 20FFH, bits &lt;br /&gt;23-16 into 20FEH, bits 15-8 into 20FDH, and bits 7-0 into 20FCH. After the data are &lt;br /&gt;stored, the contents of SP are decremented to four, which results in 20FCH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;22. One possibility is 200H in both registers. &lt;br /&gt;24. The MOV using the OFFSET is more efficient than the LEA instruction for all micro-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;processors prior to the Pentium. &lt;br /&gt;26. This instruction loads DS and BX with the 32-bit number stored at memory location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NUMB. &lt;br /&gt;28_ MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;,NUMB &lt;br /&gt;DX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV sr,BX &lt;br /&gt;30. The CLD instruction clears direction, and the STD instruction sets it. &lt;br /&gt;32. The LODSB instruction copies the contents of the data segment memory location addressed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;by SI into AL. Next, the contents of SI are either incremented or decremented by a 1, de-&lt;br /&gt;pending on the state of the direction flag. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. The OUTSB instruction outputs the contents of the data segment memory location ad-&lt;br /&gt;dressed by SI to the I/O port addressed by DX. Next, the contents of SI are either incre-&lt;br /&gt;mented or decremented by 1, depending on the state of the direction flag. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36. MOV sr, OFFSET SOURCE &lt;br /&gt;MOV Dr,OFFSET DEST &lt;br /&gt;MOV CX,12 &lt;br /&gt;CLD &lt;br /&gt;REP MOVSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38. XCHG EBX,ESI &lt;br /&gt;40. The XLAT instruction adds the contents of AL to the contents of BX to form a data segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;offset address that loads a byte of data from a table into AL. &lt;br /&gt;42. The IN AL,12H instruction inputs a byte of data from I/O port 0012H into AL. &lt;br /&gt;44. The segment override prefix allows the default segment to be changed to any other segment. &lt;br /&gt;46. XCHG AX, BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG ECX,EDX &lt;br /&gt;XCHG sr,m &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48. This instruction must be encoded as a series of DB (define bytes) definitions. &lt;br /&gt;50. The DB directive is used to define or store bytes, DW defines words, and DD defines dou-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;blewords. &lt;br /&gt;52. The EQU directive allows one label to be equated to another or a constant. &lt;br /&gt;54. The .MODEL directive identifies the type of memory model used to generate a program. &lt;br /&gt;56. Full-segment definitions &lt;br /&gt;58. The PROC directive indicates the start of a procedure, and the ENDP directive indicates the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;end of a procedure. &lt;br /&gt;60. The directive USE16 is placed on the line following the SEGMENT directive for full-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;segment definitions. If model is in effect, the .486 switch;' r,llows the model statement to se-&lt;br /&gt;lect the l6-bit instruction mode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62. COPS PROC FAR &lt;br /&gt;MOV AX,CS:DATAl &lt;br /&gt;MOV BX,AX &lt;br /&gt;MOV CX,AX &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,AX &lt;br /&gt;MOV S1,AX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;COPS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 5 &lt;br /&gt;2. You may not mix register sizes. &lt;br /&gt;4. Sum = 3100H, C = 0, A = 1, S = 0, Z = 0, and 0 = O. &lt;br /&gt;6. ADD AX,BX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AX,CX &lt;br /&gt;ADD A.X,DX &lt;br /&gt;ADD AX, SP &lt;br /&gt;MOV D1,AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. ADCDX,BX &lt;br /&gt;10. The assembler cannot determine if the memory location is a byte, word, or doubleword. &lt;br /&gt;12. Difference = 81H, C = 0, A = 0, S = 1, Z = 0, and 0 = O. &lt;br /&gt;14. DECEBX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;877 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. Both instructions are identical except that the CMP instruction does not change the destination. &lt;br /&gt;18. The product is found in DX:AX where DX is the most-significant part. &lt;br /&gt;20. EDX:EAX &lt;br /&gt;22. DX is multiplied by 100H and the l6-bt signed product is found in BX. &lt;br /&gt;24. AL &lt;br /&gt;26. If an overflow or divide by zero error occurs, the microprocessor executes a divide-error &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interrupt. &lt;br /&gt;28. AH &lt;br /&gt;30. DAA (BCD addition) and DAS (BCD subtraction) &lt;br /&gt;32. AAM converts AX to BCD by dividing it by a 10. The result (00-99) is found in AH and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL. &lt;br /&gt;34. PUSH AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,BL &lt;br /&gt;ADD AL,DL &lt;br /&gt;DM &lt;br /&gt;MOV DL,AL &lt;br /&gt;MOV AL,BH &lt;br /&gt;ADC AL,DH &lt;br /&gt;DM &lt;br /&gt;MOV DH,AL &lt;br /&gt;POP AX &lt;br /&gt;ADC AL,CL &lt;br /&gt;DM &lt;br /&gt;MOV CL,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;ADC AL,CH &lt;br /&gt;DM &lt;br /&gt;MOV CH,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36. MOV BH,DH &lt;br /&gt;AND BH,lFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38. MOV S1,D1 &lt;br /&gt;OR S1,lFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40. OR AX,OFH &lt;br /&gt;AND AX,lFFFH &lt;br /&gt;XOR AX,OEOH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;42. TEST CH,4 or BT CH,2 &lt;br /&gt;44. (a) SHR DJ,3 (b) SHL AL,l (c) ROL AL,3 (d) RCR EDX,I (e) SAR DH,l &lt;br /&gt;46. extra &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;878 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48. The REPE prefix continues to compare while an equal outcome from the comparison occurs &lt;br /&gt;or while CX is not equal to a zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50. The CMPS instruction compares the contents of two memory locations. &lt;br /&gt;52. The letter C is displayed on the video screen. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 6 &lt;br /&gt;2. A nearJMP &lt;br /&gt;4. AfarJMP &lt;br /&gt;6. (a) near (b) short (c) far &lt;br /&gt;8. EIP/IP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The JMP AX instruction is a near jump to the offset address loaded in AX. &lt;br /&gt;12. The JMP [DI] instruction is a near jump that obtains the jump address from the data segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory location addressed by DI. The other JMP is a far jump. &lt;br /&gt;14. JA is the jump above instruction that jumps if the destination is above the source. &lt;br /&gt;16. JE, JNE, JG, JGE, JL, and JLE &lt;br /&gt;18. JBE and JA &lt;br /&gt;20. SETZ &lt;br /&gt;22. ECX &lt;br /&gt;24. MOV DI,OFFSET DATA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AGAIN: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;?OOOO: &lt;br /&gt;28. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOSB &lt;br /&gt;LOOP &lt;br /&gt;CMP &lt;br /&gt;JNE &lt;br /&gt;ADD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;CLD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CX,150H &lt;br /&gt;AL,O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AGAIN &lt;br /&gt;AL,3 &lt;br /&gt;?OOOO &lt;br /&gt;AL,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI,OFFSET BLOCKA &lt;br /&gt;Dr,OFFSET BLOCKB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;LODSB &lt;br /&gt;STOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL AL==O &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;CLD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI,OFFSET BLOCKA &lt;br /&gt;DI,OFFSET BLOCKB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,O &lt;br /&gt;.WHILE AL!=12H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LODSB &lt;br /&gt;ADD AL,ES: [Dr] &lt;br /&gt;STOSB &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;32. Both instructions store the return address on the stack and then jump to the procedure. Note &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;that the return address for a near CALL is EIP/IP, and the return address for a far CALL is &lt;br /&gt;EIP/IP and CS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. RET &lt;br /&gt;36. By using NEAR or FAR to the right of the PROC directive. &lt;br /&gt;38. CUBE PROC NEAR USES AX DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,CX &lt;br /&gt;MUL CX &lt;br /&gt;MUL CX &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CUBE ENDP &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVENÂ·NUMBERED QUESTIONS AND PROBLEMS 879 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40. MOV EDI, a &lt;br /&gt;ADD EAX,EBX &lt;br /&gt;.IF CARRY? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EDI,l &lt;br /&gt;.ENDIF &lt;br /&gt;ADD EAX,EO; &lt;br /&gt;.IF CARRY? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EDI,l &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD EAX,EDX &lt;br /&gt;.IF CARRY? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EDI,l &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;42. INT &lt;br /&gt;44. Interrupt vector number 2 is used with the NMI (nonÂ·maskable interrupt) pin. &lt;br /&gt;46. The IRET pops the return address from the stack, as docs a RET, but it also pops the flags, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;which RET does not. &lt;br /&gt;48. INTO interrupts a program if the overflow flag is set. &lt;br /&gt;50. The STI instruction enables the INTR pin, and the CLI instruction disables INTR. &lt;br /&gt;52. Interrupt vector number 9 &lt;br /&gt;54. The interrupt occurs when the boundary (in a 16Â· or 32Â·bit register) is outside of the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;boundary set by a pair of words or doublewords stored in the memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 7 &lt;br /&gt;2. The result depends on the options set for the assembler, but the TEST.OBJ file is always &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;generated, whereas the TEST.LST and TEST.CRF files can also be generated. &lt;br /&gt;4. PUBLIC is used to declare that a label or even an entire segment is public to other modules. &lt;br /&gt;6. NEAR PTR, FAR PTR, BYTE, WORD, or DWORD &lt;br /&gt;8. The MACRO directive starts a macro, and the ENDM ends it. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Parameters are indicated next to the MACRO statement and then are placed in a program &lt;br /&gt;next to the name of the macro as operands. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The LOCAL directive must immediately follow the MACRO statement and must contain all &lt;br /&gt;labels used within the macro sequence. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. ADDM M..1I.CRO LIST,LENGTH &lt;br /&gt;MOV CX,LENGTH &lt;br /&gt;MOV SI,OFFSET LIST &lt;br /&gt;MOV AX,a &lt;br /&gt;CLD &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AX, lSI] &lt;br /&gt;ADD SI,2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. RANDOM MACRO &lt;br /&gt;LOCAL Rl &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Rl: &lt;br /&gt;INC CL &lt;br /&gt;MOV AH,6 &lt;br /&gt;MOV DL,-l &lt;br /&gt;INT 21H &lt;br /&gt;JZ Rl &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. DISP MACRO PARA &lt;br /&gt;IFB &amp;lt;PARA&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH/o &lt;br /&gt;MOV DL,13 &lt;br /&gt;INT 21H &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;880 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. DIPS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,lO &lt;br /&gt;ENDIF &lt;br /&gt;IFNB &amp;lt;PARA&amp;gt; &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,PARA &lt;br /&gt;ENDIF &lt;br /&gt;MOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;PROC NEAR &lt;br /&gt;MOV AH,6 &lt;br /&gt;MOV DL,-l &lt;br /&gt;INT 21H &lt;br /&gt;JZ DISP &lt;br /&gt;.IF AL==O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUSH AX &lt;br /&gt;SHR AL,4 &lt;br /&gt;ADD AL,30H &lt;br /&gt;_IF AL&amp;gt;'9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,6 &lt;br /&gt;MOV DL,AL &lt;br /&gt;INT 21H &lt;br /&gt;POP AX &lt;br /&gt;AND AL,OFH &lt;br /&gt;ADD AL,30H &lt;br /&gt;.IF AL&amp;gt;'9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AH,6 &lt;br /&gt;MOV DL,AL &lt;br /&gt;INT 21H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP ENDP &lt;br /&gt;22. INT 33H &lt;br /&gt;24. If AH loaded with a 24H before INT 33H executes, the mouse type is returned in CH. &lt;br /&gt;26. If not disabled, the mouse driver can at worst lock up the computer; at best, it will display re-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;peated mouse arrows all over the video screen. &lt;br /&gt;28. A large number is converted by repeatedly dividing by 10. &lt;br /&gt;30. 30H &lt;br /&gt;32. A 30H is first subtracted from each digit, then the most-significant digit is multiplied by 100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and the middle digit is multiplied by 10. The three are then summed to generate a binary &lt;br /&gt;value. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. HEXAS PROC &lt;br /&gt;AND &lt;br /&gt;MOV &lt;br /&gt;XLAT &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HEXAS ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEAR ;AL is converted &lt;br /&gt;AL,OFH &lt;br /&gt;BX,OFFSET LOOK &lt;br /&gt;CS:LOOK &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOK DB 30H,31H,32H,33H &lt;br /&gt;DB 34H,35H,36H,37H &lt;br /&gt;DB 38H,39H,41H,42H &lt;br /&gt;DB 43H,44H,45H,46H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36. XLAT SS:LOOK &lt;br /&gt;38. Boot sector contains a program that loads DOS into the memory system. The FAT (file allo-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cation table) holds information that indicates which clusters are in use and which are free. &lt;br /&gt;The root directory is the main directory on the disk drive. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40. The bootstrap loader is a program, located in the boot sector, that loads DOS into memory. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS 881 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;42. The attribute byte indicates the type of directory entry such as directory name, file name, &lt;br /&gt;volume name, and so forth. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;44. 40 bytes &lt;br /&gt;46. RRNAM PROC NEAR USES DS ES &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,CS &lt;br /&gt;MOV DS,AX &lt;br /&gt;MOV ES,AX &lt;br /&gt;MOV DI,OFFSET NEW1 &lt;br /&gt;MOV SI,OFFSET OLD1 &lt;br /&gt;MOV AH,56H &lt;br /&gt;INT 21H &lt;br /&gt;REI' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RRNAM ENDP &lt;br /&gt;NEW1 DB 'TEST.LIS' ,0 &lt;br /&gt;OLD1 DB 'TEST.LST',O &lt;br /&gt;.MODEL TINY &lt;br /&gt;. CODE &lt;br /&gt;DISP MACRO PARA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,PARA &lt;br /&gt;MOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,8 &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP 13 &lt;br /&gt;DISP 10 &lt;br /&gt;DISP &lt;br /&gt;MOV AL,8 &lt;br /&gt;SUB AL,CL &lt;br /&gt;ADD AL,30H &lt;br /&gt;DISP AL &lt;br /&gt;DISP 13 &lt;br /&gt;DISP 10 &lt;br /&gt;DISP '2' &lt;br /&gt;DISP &lt;br /&gt;DISP '=' &lt;br /&gt;MOV AX,100H &lt;br /&gt;SHR AX,CL &lt;br /&gt;.IF AL&amp;gt;99 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP '1' &lt;br /&gt;SUB AL,100 &lt;br /&gt;AAM &lt;br /&gt;ADD AX,3030H &lt;br /&gt;DISP AH &lt;br /&gt;DISP AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. ELSE &lt;br /&gt;AAM &lt;br /&gt;.IF AHl=O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AH,30H &lt;br /&gt;DISP AH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;ADD AL,30H &lt;br /&gt;DISP AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF &lt;br /&gt;.UNTILCXZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50. MODEL TINY &lt;br /&gt;.386 &lt;br /&gt;. CODE &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;882 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;CALL GETADR &lt;br /&gt;CALL DISPA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. EXIT &lt;br /&gt;DISP MACRO PARA &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL,PARA &lt;br /&gt;MOV AH,6 &lt;br /&gt;INT 21H &lt;br /&gt;ENDM &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETADR PROC NEAR &lt;br /&gt;MOV EDI,O &lt;br /&gt;MOV /ESI, Â° &lt;br /&gt;.WHILE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL GETN &lt;br /&gt;.BREAK IF AL==13 &lt;br /&gt;SHL EDI,4 &lt;br /&gt;MOV AH,O &lt;br /&gt;ADD DI,AX &lt;br /&gt;ADD AL,30H &lt;br /&gt;.IF AL&amp;gt; '9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;DISP AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;MOV &lt;br /&gt;AND &lt;br /&gt;SHR &lt;br /&gt;MOV &lt;br /&gt;SHL &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI,DI &lt;br /&gt;SI,OFH &lt;br /&gt;EDI,4 &lt;br /&gt;DS,DI &lt;br /&gt;EDI,4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GETADR ENDP &lt;br /&gt;DISPA PROC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;CALL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEAR &lt;br /&gt;CX,256 &lt;br /&gt;ADR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;LODSB &lt;br /&gt;ADD AX,3030H &lt;br /&gt;.IF AH&amp;gt; '9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AH,7 &lt;br /&gt;.ENDIF &lt;br /&gt;.IF AL&amp;gt; '9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;DISP AH &lt;br /&gt;DISP AL &lt;br /&gt;DISP &lt;br /&gt;MOV AX,SI &lt;br /&gt;AND AX,15 &lt;br /&gt;.IF ZERO? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CALL ADR &lt;br /&gt;.ENDIF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISPA ENDP &lt;br /&gt;ADR PROC NEAR USES CX EDI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DISP 13 &lt;br /&gt;DISP 10 &lt;br /&gt;MOV CX,5 &lt;br /&gt;ADD EDI,ESI &lt;br /&gt;ROL EDI,12 &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL EDI,4 &lt;br /&gt;MOV AX,DI &lt;br /&gt;AND AL,OFH &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,30H &lt;br /&gt;.IF AL&amp;gt; '9' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,7 &lt;br /&gt;.ENDIF &lt;br /&gt;DISP AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;DISP &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADR ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 8 &lt;br /&gt;2. As long as you don't exceed a logic 0 current of 2.0 rnA, they are TTL compatible. &lt;br /&gt;4. Address bits A7-AO. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;883 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. A logic 0 on RD indicates that the microprocessor is either reading data from memory or I/O. &lt;br /&gt;8. The CLK input must be a TTL-compatible square-wave. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The WR signal indicates that the microprocessor has placed data on its data bus to be written &lt;br /&gt;to the memory or an I/O device. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. IfDT/R is a logic 1, it indicates that the microprocessor's data bus is transmitting data to the &lt;br /&gt;memory or I/O. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. S2-S0 &lt;br /&gt;16. The queue tracking status bits indicate the condition of the queue within the microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;for the arithmetic coprocessor. &lt;br /&gt;18. Three &lt;br /&gt;20. 2.33 MHz &lt;br /&gt;22. AD19-ADO &lt;br /&gt;24. An 8-bit transparent latch (74LS373) &lt;br /&gt;26. Buffers are required because of the drive current (2.0 rnA) available at the output pins of the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;microprocessor. &lt;br /&gt;28. Four &lt;br /&gt;30. A read or a write &lt;br /&gt;32. (a) State T1 is used by the microprocessor to provide the memory or I/O with the address. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(b) State T2 provides access time to the memory and also is where the READY input is sam-&lt;br /&gt;pled. (c) State T3 is where the data are sampled or sent to the memory or I/O. (d) State T4 is &lt;br /&gt;used to deactivate the control signals. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. 400 ns (2 clocks) &lt;br /&gt;36. This input is used to request wait states. &lt;br /&gt;38. Minimum mode is used unless the system contains the arithmetic coprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 9 &lt;br /&gt;2. (a) 256 (b) 2,048 (c) 4,096 (d) 8,192 &lt;br /&gt;4. The CS or CE pin on a memory device is used to select or enable the device so it can per-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;form a read or a write operation. &lt;br /&gt;6. The WE pin causes the memory to perform a write operation, provided the CS or CE pin is &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;also active. &lt;br /&gt;8. The 5 MHz version of the 8088 allows 460 ns of time for the memory to access data. A 450 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ns memory device will only function if the amount of time required for the address decoder &lt;br /&gt;and buffers in a system is less than 10 ns, which is unlikely. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The SRAM (static RAM) is a device that retains data for as long as power is applied to the &lt;br /&gt;memory device. The SRAM can be read or written. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. 250 ns &lt;br /&gt;14. The address inputs to most DRAM devices are mUltiplexed. This allows a 16-bit address to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;be sent to the DRAM through eight address input pins. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;884 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. 2-4 ms &lt;br /&gt;18. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS04 1 U2 &lt;br /&gt;A19----------------------~~~ &lt;br /&gt;A18----------------------~~ A16----------------------~4~ A15----------------------~~~-------Â­&lt;br /&gt;A14----------------------~~ A13-----------------------7.7~ A12----------------------~10~ A11----------------------~11~------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10iM &lt;br /&gt;3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS04 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12 &lt;br /&gt;13 &lt;br /&gt;14 &lt;br /&gt;15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS133 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. One of the eight outputs becomes a logic 0 as dictated by the A, B, and C address inputs. &lt;br /&gt;22. U2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A13 1 A 40000H-41 FFFH &lt;br /&gt;A14 2 B 42000H-43FFFH 3 44000H-45FFFH A15 C 46000H-47FFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48000H-49FFFH &lt;br /&gt;A18 4AOOOH-4BFFFH &lt;br /&gt;A19 4COOOH-4DFFFH 4EOOOH-4FFFFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1A &lt;br /&gt;A17 &lt;br /&gt;A16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS32 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24. The PROM address decoder is more suited to memory address decoding than the 74LS138 &lt;br /&gt;in many cases. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OE A8 A7 A6 A5 A4 A3 A2 A1 AO 00 01 02 03 04 05 06 07 &lt;br /&gt;0 0 0 0 0 1 1 0 0 0 0 1 1 1 1 1 1 &lt;br /&gt;0 0 0 0 0 1 1 0 0 1 1 0 1 1 1 1 1 &lt;br /&gt;0 0 0 0 0 1 1 0 1 0 1 1 0 1 1 1 1 1 &lt;br /&gt;0 0 0 0 0 1 1 0 1 1 1 1 1 0 1 1 1 1 &lt;br /&gt;0 0 0 0 0 1 1 1 0 0 1 1 1 0 1 1 1 &lt;br /&gt;0 0 0 0 0 1 1 1 0 1 1 1 1 1 0 1 1 &lt;br /&gt;0 0 0 0 0 1 1 1 1 0 1 1 1 1 1 0 1 &lt;br /&gt;0 0 0 0 0 1 1 1 1 1 1 1 1 1 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28. EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/01 = A19 * /A18 * Al7 * A16 * /A15 * /A14 * /Al3 &lt;br /&gt;/02 = A19 * /A18 * AI? * A16 * /A15 * /A14 * Al3 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;103 A19 * IA18 * A17 &lt;br /&gt;104 A19 * IA18 * A17 &lt;br /&gt;lOS A19 * IA18 * A17 &lt;br /&gt;106 A19 * IA18 * A17 &lt;br /&gt;107 A19 * IA18 * A17 &lt;br /&gt;108 A19 * IA18 * A17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101M &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A18:------------' &lt;br /&gt;A17------------' &lt;br /&gt;A15------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* A16 * IA15 * A14 &lt;br /&gt;* A16 * IA15 â¢ A14 &lt;br /&gt;* A16 * A15 * IA14 &lt;br /&gt;* A16 * A15 . /A14 &lt;br /&gt;* A16 * A15 â¢ A14 &lt;br /&gt;* A16 * A15 * A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'&amp;quot;'~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT--------------------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. 5 &lt;br /&gt;36. One &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* lAD &lt;br /&gt;â¢ ,;13 &lt;br /&gt;â¢ lAD &lt;br /&gt;â¢ A13 &lt;br /&gt;. lAD &lt;br /&gt;â¢ i,13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38. The BHE selects the upper memo!), bank, and the AD (BLE) signal selects the lower &lt;br /&gt;memory banle &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;40. Either separate decoders or separate write control signals &lt;br /&gt;42. Low &lt;br /&gt;46. &lt;br /&gt;D7-OO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;015-08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;023-016 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;031--024 ------------------, &lt;br /&gt;A2-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;07-00 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01s.-08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;023-016 &lt;br /&gt;031-024 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A2-A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~---------,_--1:~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ATB &lt;br /&gt;A17 &lt;br /&gt;AI. &lt;br /&gt;AI' &lt;br /&gt;A20 &lt;br /&gt;A2T &lt;br /&gt;A22 &lt;br /&gt;A23 &lt;br /&gt;A24 &lt;br /&gt;A25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~~~ A2. A29 A30 &lt;br /&gt;A31 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;885 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;886 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48. The RAS cycle selects a new row address, but does not select the DRAM for a read or a &lt;br /&gt;write. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;50. 15.6251ls &lt;br /&gt;52. The BS pin selects a bank of memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 10 &lt;br /&gt;2. The fixed I/O port is stored in the memory immediately following the opcode. &lt;br /&gt;4. Register DX &lt;br /&gt;6. The OUTSB instruction copies the contents of the data segment memory location addressed &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;by SI to the data bus, where it is written to the I/O device addressed by DX. After the &lt;br /&gt;transfer, the contents of SI are incremented or decremented as dictated by the direction flag. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. The difference between the memory-mapped I/O and the isolated I/O is that with isolated &lt;br /&gt;I/O all memory locations are available to the system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The basic output interface is a latch that holds data output from the microprocessor. &lt;br /&gt;12. Low bank &lt;br /&gt;14. r=U.=;.2 __ ---, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1A &lt;br /&gt;BLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AS 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;74ALS32 74ALS13S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1B &lt;br /&gt;A5 S &lt;br /&gt;A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. U1 &lt;br /&gt;M/iO 11 01 1000H-1001H A1 12 02 1 002H-1 003H A2 13 03 1004H-1005H A3 14 04 1 00SH-1 007H A4 15 05 1 00SH-1 009H A5 IS OS 1 00AH-1 OOBH AS 17 07 1 00CH-1OODH A7 IS OS 1 00EH-1OOFH AS 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;110 &lt;br /&gt;1SLS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;A9 11 01 A10 12 02 A11 13 03 A12 14 04 A13 15 05 A14 IS OS A15 17 07 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;9 IS OS 19 11 110 &lt;br /&gt;1SLS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-6 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;; Equations for U1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;101 IU2 * IA4 * &lt;br /&gt;/02 /U2 * IA4 * &lt;br /&gt;/03 IU2 * IA4 * &lt;br /&gt;/04 IU2 * IA4 * &lt;br /&gt;/05 IU2 * /A4 * &lt;br /&gt;106 IU2 * IA4 * &lt;br /&gt;107 /U2 * /A4 * &lt;br /&gt;108 /U2 * IA4 * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Equation for U2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BHE &lt;br /&gt;A4 &lt;br /&gt;A10 &lt;br /&gt;A11 &lt;br /&gt;A12 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;2 &lt;br /&gt;3 &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;6 &lt;br /&gt;7 &lt;br /&gt;8 &lt;br /&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;2 &lt;br /&gt;3 &lt;br /&gt;4 &lt;br /&gt;5 &lt;br /&gt;6 &lt;br /&gt;7 &lt;br /&gt;8 &lt;br /&gt;9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 &lt;br /&gt;12 &lt;br /&gt;13 &lt;br /&gt;14 &lt;br /&gt;15 &lt;br /&gt;16 &lt;br /&gt;17 &lt;br /&gt;18 &lt;br /&gt;19 &lt;br /&gt;110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;11 &lt;br /&gt;12 &lt;br /&gt;13 &lt;br /&gt;14 &lt;br /&gt;15 &lt;br /&gt;16 &lt;br /&gt;17 &lt;br /&gt;18 &lt;br /&gt;19 &lt;br /&gt;110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;01 &lt;br /&gt;02 &lt;br /&gt;03 &lt;br /&gt;04 &lt;br /&gt;05 &lt;br /&gt;06 &lt;br /&gt;07 &lt;br /&gt;08 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;Equations for U1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IA5 * &lt;br /&gt;IA5 * &lt;br /&gt;IA5 * &lt;br /&gt;IA5 * &lt;br /&gt;IA5 * &lt;br /&gt;IA5 * &lt;br /&gt;IA5 * &lt;br /&gt;IA5 * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IA6 * IA7 * AS * IA3 * /A2 * IAl &lt;br /&gt;/A6 * IA7 * A8 * /A3 * /A2 * Al &lt;br /&gt;IA6 * /A7 * A8 * /A3 * A2 * IAl &lt;br /&gt;IA6 * IA7 * A8 * IA3 * A2 * Al * &lt;br /&gt;/A6 * IA7 * A8 * A3 * /A2 * /Al &lt;br /&gt;IA6 * /A7 * A8 * A3 * /A2 * A1 * &lt;br /&gt;/A6 * / &amp;quot;_7 * A8 * A3 * A2 * IAl * &lt;br /&gt;/A6 * IA7 * A8 * A3 * A2 * A1 * &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;300DH &lt;br /&gt;300BH &lt;br /&gt;1005H &lt;br /&gt;1007H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;* IMIO &lt;br /&gt;* IMIO &lt;br /&gt;* MIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/MIO &lt;br /&gt;* IMIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMIO &lt;br /&gt;IMIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/MIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS/01 = IU2 * IA9 * IA5 * IA6 * IA7 * A8 * A3 * A2 * IA1 * &lt;br /&gt;IMIO &lt;br /&gt;102 IU2 * IA9 * lAS * IA6 * IA7 * A8 * A3 * /A2 * A1 * IMIO &lt;br /&gt;103 = IU2 * A9 * /AS * IA6 * IA7 * A8 * IA3 * A2 * IA1 * MIO &lt;br /&gt;104 = IU2 * A9 * lAS * /A6 * /A7 * A8 * IA3 * A2 * Al * /MIO &lt;br /&gt;;Equation for U2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/U2 = /BHE * IA4 * /A10 * IA1l * /A12 * IA13 * IA14 * /A15 &lt;br /&gt;20. O7-DO &lt;br /&gt;22. 24 &lt;br /&gt;24. Al and AO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;887 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;888 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26. D~D7----------------------------, &lt;br /&gt;21 &lt;br /&gt;DO PAO &lt;br /&gt;D1 PA1 &lt;br /&gt;D2 PA2 &lt;br /&gt;D3 PA3 &lt;br /&gt;D4 PM &lt;br /&gt;D5 PA5 &lt;br /&gt;D6 PA6 &lt;br /&gt;D7 PA7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AD PBO &lt;br /&gt;\\VA PB1 &lt;br /&gt;AO PB2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 A1 PB3 &lt;br /&gt;A3 ~SET PB4 11 01 PB5 A4 12 02 PB6 A5 13 03 PB7 A6 14 04 A7 15 05 PCO A8 16 06 PC1 A9 17 07 PC2 A10 18 08 PC3 A11 19 PC4 A12 110 PC5 &lt;br /&gt;M/iO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 pce PC'1 &lt;br /&gt;AO 82C55 &lt;br /&gt;A13 &lt;br /&gt;A14 &lt;br /&gt;A15 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATION &lt;br /&gt;/CS = /A15*/A14*/A13*/A12*/All*/AIO*A9*A8*A7*/A6*/A5*/A4*/A3*/MIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28. Latched I/O (mode 0), strobed I/O (mode 1), and bi-directionall/O (mQ(~e 2) &lt;br /&gt;30. Whenever a coil is energized, the current causes the permanent magnet armature to step &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(move) to the next position. &lt;br /&gt;32. MOV AL,OFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT COMMAND,AL &lt;br /&gt;34. The ACK signal is an output that signals that the data have been removed from the port. &lt;br /&gt;36. IN AL, PORTC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST AL,16 &lt;br /&gt;JNZ FOR_A_ONE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38. PCD-PC2 &lt;br /&gt;40. 10 ms to 20 ms &lt;br /&gt;42. 2 wait states &lt;br /&gt;44. An overrun error occurs if the internal FIFO fills before the data are input to the microprocessor. &lt;br /&gt;46. D~D7------------~------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;DBO RLO &lt;br /&gt;DB1 RL1 &lt;br /&gt;DB2 RL2 &lt;br /&gt;DB3 RL3 &lt;br /&gt;DB4 RL4 &lt;br /&gt;DB5 RL5 &lt;br /&gt;DB6 RL6 &lt;br /&gt;DB7 RL7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 AD SHFT WFi CNiST A7 cs BD &lt;br /&gt;M/iO CLK RESET SLO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AO SL1 &lt;br /&gt;IRQ SL2 A6 SL3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BLE OAO &lt;br /&gt;OA1 &lt;br /&gt;OA2 &lt;br /&gt;OA3 &lt;br /&gt;OBO &lt;br /&gt;OB1 &lt;br /&gt;OB2 &lt;br /&gt;OB3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8279 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-9 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48. lOMHz &lt;br /&gt;50. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8MHz--------------________________________________ , &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1A &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0~07----------------________ __, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A6 &lt;br /&gt;A7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;A4 &lt;br /&gt;M/iO ___ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WR R5 ____ ~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 &lt;br /&gt;DO &lt;br /&gt;01 &lt;br /&gt;02 ClKO &lt;br /&gt;03 GO &lt;br /&gt;04 OUTO &lt;br /&gt;05 &lt;br /&gt;06 ClK1 &lt;br /&gt;07 G1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ oun ClK2 &lt;br /&gt;AO G2 &lt;br /&gt;A1 OUT2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CS &lt;br /&gt;8254 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,OB6H &lt;br /&gt;OUT 16H,AL &lt;br /&gt;MOV AL,64H &lt;br /&gt;OUT 14H,AL &lt;br /&gt;MOV AL,OOH &lt;br /&gt;OUT 14H,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;52. Least-significant &lt;br /&gt;54. ;using a 1 MHz clock &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,74H &lt;br /&gt;OUT CONTROL,AL &lt;br /&gt;MOV AL,65H ;count of 101 &lt;br /&gt;OUT TIMER1,AL &lt;br /&gt;MOV AL,O &lt;br /&gt;OUT TIMER1,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;56. Asynchronous serial data are data that are sent without a clock pulse. &lt;br /&gt;58. LINE EQU 023H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSB EQU 020H &lt;br /&gt;MSB EQU 021H &lt;br /&gt;FIFO EQU 022H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,10001010B &lt;br /&gt;LINE,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,60 &lt;br /&gt;LSB,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,O &lt;br /&gt;OUT MSB,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,OOOllOOlB &lt;br /&gt;LINE,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;enable Baud divisor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program Baud rate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;program 7-data, odd &lt;br /&gt;;parity, one stop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,OOOOOlllB ;enable transmitter and &lt;br /&gt;OUT FIFO,AL ;and receiver &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18 &lt;br /&gt;16 &lt;br /&gt;17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;889 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;vcc &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;60. Simplex = sending or receiving, but not both. Half duplex = sending and receiving, but only &lt;br /&gt;one direction at a time. Full duplex = sending and receiving simultaneously. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;890 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;62. SENDS PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,16 &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT &lt;br /&gt;IN &lt;br /&gt;TEST &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL,LSTAT &lt;br /&gt;AL,20H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL !ZERO? &lt;br /&gt;LODSB &lt;br /&gt;OUT DATA,AL &lt;br /&gt;.UNTILCXZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SENDS ENDP &lt;br /&gt;64. O.OlV &lt;br /&gt;66. .MODEL TINY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. CODE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. STARTUP &lt;br /&gt;MOV DX,400H &lt;br /&gt;.WHILE 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX,256 &lt;br /&gt;MOV AL,O &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT DX,AL &lt;br /&gt;INC AL-&lt;br /&gt;CALL DELAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;MOV CX,256 &lt;br /&gt;. REPEAT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT DX,AL &lt;br /&gt;DEC AL &lt;br /&gt;CALL DELAY &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW &lt;br /&gt;DELAY PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;39 microsecond time delay &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DELAY ENDP &lt;br /&gt;END &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get line status register &lt;br /&gt;;test TH bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;get data &lt;br /&gt;;transmit data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;68. The INTR pin indicates that the converter has completed a conversion. &lt;br /&gt;70. D~D7------------------------------~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3 &lt;br /&gt;Al VI+ 6 A2 DBO &lt;br /&gt;A3 DBl &lt;br /&gt;A4 DB2 7 &lt;br /&gt;AS DB3 VI-&lt;br /&gt;A6 DB4 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ul DB5 CLKR &lt;br /&gt;BLE 1 19 DB6 11 01 DB7 A7 2 12 02 18 eLK 4 A8 3 13 03 17 CS A9 4 14 04 16 ~~ VREF Al0 15 05 1 All 16 06 INTR AGND 8 A12 17 07 A13 18 08 12 ADC0804 A14 9 19 A15 11 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DO 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-11 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS 891 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;;equations for U1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQUATIONS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;/01 = &lt;br /&gt;/A15*/A14*/A13*/A12*/A11*/A10*A9*/Aa~/A7*A6*A5*/A4*/A3*/A2*/A1*/BLE &lt;br /&gt;/OS = &lt;br /&gt;/A15*/A14*/A13*/A12*/A11*/A10*A9*/AS-/A7*A6*A5*A4*/A3*/A2*/A1*/BLE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 11 &lt;br /&gt;2. An interrupt is a hardware-initiated subroutine call. &lt;br /&gt;4. Interrupts free processing time because the only time the processor is used is when the inter-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;rupt is active. This means that no time is wasted polling an I/O device. &lt;br /&gt;6. INT, INTO, IRET, CLI, STI &lt;br /&gt;8. In the first lK byte at location OOOOOOOOH-000003FFH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. Vectors OOH-lFH are reserved, even though some are used in the personal computer for &lt;br /&gt;other purposes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. The interrupt descriptor table is located anywhere in the memory system, as addressed by &lt;br /&gt;the interrupt descriptor table register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The main difference is the location of the interrupt vector. The real mode interrupt uses a &lt;br /&gt;vector from a table in the bottom lK byte of memory, while the protected mode interrupt &lt;br /&gt;uses a descriptor from any location in the memory system. The other difference is that the &lt;br /&gt;protected mode interrupt service procedure can be placed anywhere in the memory system. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. The INTO instruction interrupts a program only if the overflow flag bit is set. &lt;br /&gt;18. The IRET instruction functions as a far RET except that before the return occurs, data from &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the stack are popped into the flag register. &lt;br /&gt;20. The flags are pushed onto the stack, the I and T flag bits are cleared to zero, and the interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;service procedure is called using a vector from the interrupt vector table. &lt;br /&gt;22. The trace flag is set to enable tracing. Tracing is an interrupt that occurs after each instruc-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tion is executed to allow software to trace through a program. &lt;br /&gt;24. The only way to clear or set the trace flag is to obtain an image of the flag register and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;change the trace bit to a zero or a one before returning the value back to the flag register. &lt;br /&gt;There is no instruction to set or clear the trace flag. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26. The lNTA signal is only active in response to an lNTR input. &lt;br /&gt;28. The NMI input is both level and edge sensitive. &lt;br /&gt;30. Type or vector number. &lt;br /&gt;32. vee &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U1 &lt;br /&gt;2 1A1 1Y1 18 07 4 1A2 H2 16 06 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1A3 1Y3 14 05 8 1A4 1Y4 12 04 11 2A1 2Y1 9 03 3 2A2 2Y2 7 02 15 2A3 2Y3 5 01 17 2A4 2Y4 3 DO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1G &lt;br /&gt;2G &lt;br /&gt;74ALS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-12 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;892 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. A daisy chain is a method of connecting interrupt so that any active interrupt causes a logic &lt;br /&gt;1 to be placed on the INTR input to the microprocessor. The daisy chain interrupt requires &lt;br /&gt;software to determine which interrupt is active. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;36. The 8259A is a programmable interrupt controller that adds eight interrupt inputs to the &lt;br /&gt;microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38. The IR inputs are the interrupt request inputs to the 8259A. &lt;br /&gt;40. The slave !NT pin connects to any IR pin on the master 8259A. &lt;br /&gt;42. The OCW is an operational command word used to control the 8259A once it has been ini-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tialized by the ICW. &lt;br /&gt;44.ICW2 &lt;br /&gt;46. Among other things, ICWl selects the level or edge triggering for the 8259A. &lt;br /&gt;48. The priority rotation algorithm places the most recently serviced interrupt at the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lowest priority level. &lt;br /&gt;50. Ports 20H and 2lH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 12 &lt;br /&gt;2. Whenever HOLD is placed at a logic 1 level, the microprocessor (a) stops executing a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;program within a few clocks, (b) places its address, data, and control buses at their high-&lt;br /&gt;impedance states, and.( c) places a logic 1 on the HLDA to signal that the HOLD is in effect. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. A DMA write transfers data from I/O to the memory. &lt;br /&gt;6.DACK &lt;br /&gt;8. If both HOLD and HLDA are a logic 1 level, the microprocessor is in its hold state. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10.4 &lt;br /&gt;12. The command register &lt;br /&gt;14. LATCHB EQU lOH ;latch B &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLEAR_F EQU 7CH ; F /L flip flop &lt;br /&gt;;channel 0 address &lt;br /&gt;;channel 1 address &lt;br /&gt;;channel 1 count &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHO_A &lt;br /&gt;CH1_A &lt;br /&gt;CH1_C &lt;br /&gt;MODE &lt;br /&gt;CMMD &lt;br /&gt;MASKS &lt;br /&gt;REQ &lt;br /&gt;STATUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EQU &lt;br /&gt;EQU &lt;br /&gt;EQU &lt;br /&gt;EQU &lt;br /&gt;EQU &lt;br /&gt;EQU &lt;br /&gt;EQU &lt;br /&gt;EQU &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;70H &lt;br /&gt;72H &lt;br /&gt;73H &lt;br /&gt;7BH ;mode &lt;br /&gt;78H ; command &lt;br /&gt;7FH ;masks &lt;br /&gt;79H ;request register &lt;br /&gt;78H ;status register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRANS PROC FAR USES AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,20H &lt;br /&gt;SHR AL,4 &lt;br /&gt;OUT LATCHB,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OUT CLEAR_F,AL ;clear F/L flip-flop &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,lOOOH ;program source address &lt;br /&gt;OUT CHO_A,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;OUT CHO_A,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,OOOOH ;program destination address &lt;br /&gt;OUT CHl_A,AL &lt;br /&gt;MOV AL,AH &lt;br /&gt;OUT CH1_A,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,OOFFH ;program count &lt;br /&gt;OUT CH1_C,AL &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS 893 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,AH &lt;br /&gt;OUT CH1_C,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,88H ;program mode &lt;br /&gt;OUT MODE,AL &lt;br /&gt;MOV AL,85H &lt;br /&gt;OUT MODE,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,l ;enable block transfer &lt;br /&gt;OUT CMMD,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,OEH ;unmask channel 0 &lt;br /&gt;OUT MASKS,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,4 ;start DMA transfer &lt;br /&gt;OUT REQ,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. REPEAT ;wait until DMA complete &lt;br /&gt;IN AL,STATUS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;. UNTIL AL &amp;amp;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TRANS ENDP &lt;br /&gt;16. Mini &lt;br /&gt;18. Tracks &lt;br /&gt;20. Cylinder &lt;br /&gt;22. 1 0 0 0 0 0 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;24. The flying head is the name given to the head inside a hard disk drive because it floats on a &lt;br /&gt;cushion of air created by the spinning disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;26. The stepper is not very accurate, whereas the voice coil is, because of feedback obtained &lt;br /&gt;from a timing track on the disk. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28. The CD-ROM is a device that stores data in pits on the surface of a plastic-coated metal &lt;br /&gt;disk. The pits are read by an optical system that uses a small LED laser diode. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30. Red, green, and blue &lt;br /&gt;32. A pixel is the smallest picture element in a video display. &lt;br /&gt;34. The TIL level RGB monitor displays 16 levels because there is a high-intensity signal to the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;monitor to modify the eight colors sent through the R, G, and B video lines. &lt;br /&gt;36. 128 levels &lt;br /&gt;38. 560 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 13 &lt;br /&gt;2. 16-bit (Â±32K), 32-bit (Â±2 G), and 64-bit (Â±9 x 101~) &lt;br /&gt;4. Short (32-bits), long (64-bits), and extended (64-bits) &lt;br /&gt;6. (a) -7.5 (b) +0.5625 (c) +320 (d) +2.0 (e) +10 (f) +0.0 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;894 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. The microprocessor is free to obtain and execute normal microprocessor instructions while &lt;br /&gt;the coprocessor executes a coprocessor instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. The FSTSW AX copies the status register into the AX register. &lt;br /&gt;12. After executing the FCOMP ST(2) and FSTSW AX instructions, the SAHF instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;copies the AH register into the flag register (F7-FO). This allows the condition jump in-&lt;br /&gt;struction JE to be used to test for equality. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. FSTSW AX &lt;br /&gt;16. Data are stored in eight 80-bit wide registers that are formed into a stack. &lt;br /&gt;18. ST(O) &lt;br /&gt;20. Affine allows positive or negative infinity, while projective does not. &lt;br /&gt;22. Double-precision (64-bits) &lt;br /&gt;24. The FST DATA instruction copies (does not pop) data from ST(O) into memory location &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data as a 64-bit floating-point number. &lt;br /&gt;26. FADD ST,ST(3) &lt;br /&gt;28. FSUB ST(2),ST &lt;br /&gt;30. Forward division divides the operand into the top of the stack, while reverse division divides &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the top of the stack into the operand. If no operand appears, forward division divides ST(O) &lt;br /&gt;into ST(1), while reversion division divides ST(O) into ST(I). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32. The instruction does a move only if below. &lt;br /&gt;34. RECEP PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV TEMP,EAX &lt;br /&gt;FLDl &lt;br /&gt;FLD TEMP &lt;br /&gt;FDIVR &lt;br /&gt;FSTP TEMP &lt;br /&gt;MOV EAX,TEMP &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEMP DD ? &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RECEP ENDP &lt;br /&gt;36. The F2XMI instruction raises 2 to the integer power located at the stack top, then a 1 is sub-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tracted from the result before it replaces the power at the top of the stack. &lt;br /&gt;38. FLDPI &lt;br /&gt;40. It clears the contents of ST(2) &lt;br /&gt;42. The FSA VE instruction saves all of the registers in the coprocessor to memory. &lt;br /&gt;44. REAC PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDPI &lt;br /&gt;FADD ST, ST(O) &lt;br /&gt;FMUL F &lt;br /&gt;FMUL Cl &lt;br /&gt;FLDl &lt;br /&gt;FDIVR &lt;br /&gt;FSTP XC &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REAC ENDP &lt;br /&gt;46. The FW AIT instruction is used to cause the microprocessor to wait for the coprocessor to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;complete its operation and is used before processing floating-point data. &lt;br /&gt;48. TOT PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FLDl &lt;br /&gt;FDIV R2 &lt;br /&gt;FLDl &lt;br /&gt;FDIV R3 &lt;br /&gt;FLDl &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS 895 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FDIV R4 &lt;br /&gt;FADD &lt;br /&gt;FADD &lt;br /&gt;FLD1 &lt;br /&gt;FDIVR &lt;br /&gt;F}\\DD R1 &lt;br /&gt;FSTP RT &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TOT ENDP &lt;br /&gt;50. ARRAY 1 DQ 100 DUP (7 ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ARRAY 2 DQ 100 DUP (? ) &lt;br /&gt;ARRAY 3 DQ 100 DUP (? ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROD PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV EBX, OFFSET ARRAYl-8 &lt;br /&gt;MOV EDX, OFFSET ARRAY2-8 &lt;br /&gt;MOV ESI,OFFSET ARRAY3-8 &lt;br /&gt;MOV ECX, 100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AGAIN: &lt;br /&gt;FLD QWORD PTR [EBX+8*ECX] &lt;br /&gt;FMUL QWORD PTR [EDX+8*ECX] &lt;br /&gt;FSTP QWORD PTR [ESI+8*ECX] &lt;br /&gt;LOOPD AGAIN &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PROD ENDP &lt;br /&gt;52. pow PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV TEMP,EBX &lt;br /&gt;FLD TEMP &lt;br /&gt;F2XM1 &lt;br /&gt;FLD1 &lt;br /&gt;FADD &lt;br /&gt;MOV TEMP,EAX &lt;br /&gt;FLD TEMP &lt;br /&gt;FYL2X &lt;br /&gt;FSTP TEMP &lt;br /&gt;MOV ECX, TEMP &lt;br /&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;POW ENDP &lt;br /&gt;54. VOUT DD 100 DUP (7 ) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VIN DD 100 DUP (7 ) &lt;br /&gt;DBG DD 100 DUP (7) &lt;br /&gt;TWEN DD 20.0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GAIN PROC NEAR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LEA EBX,VOUT-4 &lt;br /&gt;LEA EDX,VIN-4 &lt;br /&gt;LEA ESI,DBG-4 &lt;br /&gt;MOV ECX,100 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AGAIN: &lt;br /&gt;FLD DWORD PTR [EBX+4*ECX] &lt;br /&gt;FDIV DWORD PTR [EDX+4*ECX] &lt;br /&gt;CALL LOG10 &lt;br /&gt;FMUL TWEN &lt;br /&gt;FSTP DWORD PTR [ESI+4*ECX] &lt;br /&gt;LOOPD AGAIN &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;896 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;GAIN ENDP &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 14 &lt;br /&gt;2. The early ISA bus supports only 8-bit transfers, while the newest supports either 8- or 16-bit &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;transfers. &lt;br /&gt;4. U2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SOO 34 DO PAO &lt;br /&gt;S01 33 01 PA1 &lt;br /&gt;S02 3 02 PA2 &lt;br /&gt;S03 1 03 PA3 &lt;br /&gt;S04 30 04 PM &lt;br /&gt;SOS 29 05 PAS &lt;br /&gt;S06 8 os PA6 &lt;br /&gt;S07 27 07 PA7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I~~ 5 AD PBO 9 WR PB1 SAO AO PB2 &lt;br /&gt;SA1 A1 PB3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RESET RESET PB4 ~ PBS &lt;br /&gt;U1 PB6 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SA2 &lt;br /&gt;PB7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;11 01 &lt;br /&gt;SA3 12 02 PCO &lt;br /&gt;SA4 13 03 PC1 &lt;br /&gt;SAS 14 04 PC2 &lt;br /&gt;SA6 15 05 PC3 &lt;br /&gt;SA7 16 06 PC4 &lt;br /&gt;SA8 17 07 PCS &lt;br /&gt;SA9 18 08 PC6 &lt;br /&gt;SA10 11 19 PC7 SA11 110 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;82CSS &lt;br /&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SA12 &lt;br /&gt;SA13 &lt;br /&gt;SA14 &lt;br /&gt;SA1S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;6. S07 S06 &lt;br /&gt;SOS &lt;br /&gt;S04 &lt;br /&gt;S03 &lt;br /&gt;S02 &lt;br /&gt;S01 &lt;br /&gt;SOO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAO &lt;br /&gt;SA1 &lt;br /&gt;SA2 &lt;br /&gt;SA3 &lt;br /&gt;SA4 &lt;br /&gt;SAS &lt;br /&gt;SA6 &lt;br /&gt;SA7 &lt;br /&gt;SA8 &lt;br /&gt;SAg &lt;br /&gt;SA10 &lt;br /&gt;SA11 &lt;br /&gt;SA12 &lt;br /&gt;SA13 &lt;br /&gt;SA14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;10 AO OO~ 9 A1 01 &lt;br /&gt;_B_ A2 02 13 7 A3 03 ~ 6 A4 04 16 5 AS 05 17 4 A6 06 1 3 A7 07 1 25 A8 24 A9 21 A10 23 A11 2 A12 26 A13 27 A14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SMEMR &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SA1S &lt;br /&gt;SA16 &lt;br /&gt;SA17 &lt;br /&gt;SA18 &lt;br /&gt;SA19 &lt;br /&gt;LA20 &lt;br /&gt;LA21 &lt;br /&gt;LA22 &lt;br /&gt;LA23 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20 ; 22 &lt;br /&gt;J &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 vpp &lt;br /&gt;U1 27C256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;--+ 11 01 19 &lt;br /&gt;---+ 12 02 ~ 10K &lt;br /&gt;-+ 13 03 &amp;quot;*-&lt;br /&gt;----4- 14 04 ~ &lt;br /&gt;---+ 15 05 &lt;br /&gt;---+ 16 06 0-#---&lt;br /&gt;-+ 17 07 ~ VCC &lt;br /&gt;==;t 18 08 ,..J.L 19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;---'-'- 110 &lt;br /&gt;16L8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-15 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SD &lt;br /&gt;SD &lt;br /&gt;SD &lt;br /&gt;so &lt;br /&gt;SD &lt;br /&gt;SD &lt;br /&gt;SD &lt;br /&gt;so &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;O~ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;!t ~-.-!.L &lt;br /&gt;Ul &lt;br /&gt;lAl &lt;br /&gt;lA2 &lt;br /&gt;lA3 &lt;br /&gt;lA4 &lt;br /&gt;2Al &lt;br /&gt;2A2 &lt;br /&gt;2A3 &lt;br /&gt;2A4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19 2G &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;lYl 18 &lt;br /&gt;lY2 16 &lt;br /&gt;lY3 14 &lt;br /&gt;lY4 12 &lt;br /&gt;2Yl &lt;br /&gt;2Y2 7 &lt;br /&gt;2Y3 &lt;br /&gt;2Y4 3 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~'G&lt;br /&gt;~ 74P.,LS244 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAO &lt;br /&gt;SAl &lt;br /&gt;SA2 &lt;br /&gt;SA3 &lt;br /&gt;SA4 &lt;br /&gt;SAS &lt;br /&gt;SA6 &lt;br /&gt;SA7 &lt;br /&gt;SA8 &lt;br /&gt;SA9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAlO &lt;br /&gt;SAll &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;=+ &lt;br /&gt;==! &lt;br /&gt;-+ &lt;br /&gt;-4 &lt;br /&gt;-----+ &lt;br /&gt;-4 &lt;br /&gt;==rt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U2 &lt;br /&gt;11 &lt;br /&gt;12 &lt;br /&gt;13 &lt;br /&gt;14 &lt;br /&gt;15 &lt;br /&gt;16 &lt;br /&gt;17 &lt;br /&gt;18 &lt;br /&gt;19 &lt;br /&gt;110 &lt;br /&gt;1618 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;19 01 1 &lt;br /&gt;02 17 03 16 04 &lt;br /&gt;05 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;06 ~ 07 &lt;br /&gt;08 o-lL-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U3A SA12 &lt;br /&gt;SA13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SA14 &lt;br /&gt;SA1S &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;'r-41 &lt;br /&gt;74ALS20 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;VCC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10K &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;gt; 9 U38 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ ~ 12 13 &lt;br /&gt;74ALS2Q &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE D-16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;12. 32-bits &lt;br /&gt;14. 33 MHz &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7 &lt;br /&gt;6 &lt;br /&gt;5 &lt;br /&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;1 &lt;br /&gt;14 &lt;br /&gt;13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I &lt;br /&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;&amp;gt;---+ &lt;br /&gt;5 &lt;br /&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;1 &lt;br /&gt;14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;In &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ 6 &lt;br /&gt;5 &lt;br /&gt;4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16 &lt;br /&gt;15 &lt;br /&gt;14 &lt;br /&gt;13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;~ &lt;br /&gt;--+ &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4 &lt;br /&gt;16 &lt;br /&gt;15 &lt;br /&gt;14 &lt;br /&gt;13 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;17 &lt;br /&gt;19 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;US &lt;br /&gt;CS &lt;br /&gt;WRl VREF f--1L-WR2 &lt;br /&gt;010 &lt;br /&gt;DI1 RF8 9 &lt;br /&gt;012 &lt;br /&gt;013 &lt;br /&gt;014 IOUT2 1&amp;gt; &lt;br /&gt;015 &lt;br /&gt;016 loun 11 &lt;br /&gt;017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XFER &lt;br /&gt;IlE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;oGNO AGNo ~ &lt;br /&gt;DAC0830 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U6 &lt;br /&gt;CS fJ-WRl VREF WR2 &lt;br /&gt;010 9 Oil RFB &lt;br /&gt;012 &lt;br /&gt;013 &lt;br /&gt;014 IOUT2 1&amp;gt; &lt;br /&gt;015 &lt;br /&gt;DI6 100Tl &lt;br /&gt;017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XFER &lt;br /&gt;ILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;oGNO AGND f--J--, &lt;br /&gt;OAC0830 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U7 &lt;br /&gt;CS &lt;br /&gt;WRl VREF -'L.. &lt;br /&gt;WR2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;010 9 Oil RFB &lt;br /&gt;012 &lt;br /&gt;013 &lt;br /&gt;014 IOUT2 12 &lt;br /&gt;015 &lt;br /&gt;016 10UTl 11 &lt;br /&gt;017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XFER &lt;br /&gt;ILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;oGNo AGNo 2-., &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAC0830 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U8 &lt;br /&gt;CS &lt;br /&gt;WRl VREF -'L.. &lt;br /&gt;WR2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DID 9 DI1 RFB &lt;br /&gt;012 &lt;br /&gt;DI3 &lt;br /&gt;014 IOUT2 12 &lt;br /&gt;015 &lt;br /&gt;016 IOUTl 11 &lt;br /&gt;017 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XFER &lt;br /&gt;ILE &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OGNO AGNo ~ &lt;br /&gt;OAC0830 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;897 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I JUS U9 1 &lt;br /&gt;,I. 6 Channel800H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;741 &lt;br /&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JlJ5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;,I. &lt;br /&gt;U~O 1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Channel 81 OH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;741 &lt;br /&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2~tr &lt;br /&gt;31. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U:' j &lt;br /&gt;Channel 820H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;741 &lt;br /&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I I I &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;2~JJ &lt;br /&gt;, I. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;U12 I &lt;br /&gt;Channel 830H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;741 &lt;br /&gt;7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16. The main difference is that the PCI bus supports either a 32- or 64-bit data bus, which makes &lt;br /&gt;it suited to the Pentium or Pentium Pro microprocessor. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. The configuration memory allows software to determine what board is plugged into a PCI &lt;br /&gt;slot so the software can automatically set up the system for the PCI interface. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. These pins are used to transfer the command to the PCI interface and also to select the &lt;br /&gt;memory or I/O bank. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;898 !Â·PPENDIX 0 ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 15 &lt;br /&gt;.... The 80186/80188 contain an internal clock generator, chip-selection logic, timers, program-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mable interrupt controller, DMA controller, power-down mode, serial interfaces, and par-&lt;br /&gt;allel interfaces. Note that not all versions contain all features. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4. 10MHz &lt;br /&gt;6. Is 2.0mA &lt;br /&gt;8. The ALE signal appears 1/2 clock earlier in the 80186/80188. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. 417 ns &lt;br /&gt;12. MOV AX,1100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFFFEH &lt;br /&gt;OUT DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. 10 on most versions of the 80186/80188 &lt;br /&gt;16. The interrupt controller registers each control a single interrupt input to the 80186/80188 in-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;terrupt controller. &lt;br /&gt;18. The difference is that reading the interrupt poll register acknowledges the interrupt, while &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;reading the interrupt poll status register does not. &lt;br /&gt;20. 3 &lt;br /&gt;22. Timer 2 &lt;br /&gt;24. The INH bit must be set to allow the EN bit to change. &lt;br /&gt;26. Alternate operation using the two compare or maximum count registers. &lt;br /&gt;28. MOV AX,123 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,OFF5AH &lt;br /&gt;OUT DX,AL &lt;br /&gt;MOV AX,23 &lt;br /&gt;ADD &lt;br /&gt;OUT &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;30. 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,2 &lt;br /&gt;DX,AL &lt;br /&gt;AX,8007H &lt;br /&gt;DX,OFF58H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;32. The channel is started by software control (control register) or by hardware control (timer 2 &lt;br /&gt;or the DRQ input). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;34. 7 &lt;br /&gt;36. Base &lt;br /&gt;38. 0 and 15 &lt;br /&gt;40. It selects the operation of the PCS5/AO and PCS6/A1 pins. &lt;br /&gt;42. MOV DX,OFF90H .. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX, lOOlH . &lt;br /&gt;OUT &lt;br /&gt;MOV &lt;br /&gt;MOV &lt;br /&gt;OUT &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;44. 10 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DX,AL &lt;br /&gt;DX,ORF92H &lt;br /&gt;AX,l008H &lt;br /&gt;DX,AL &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;46. It verifies that a protected mode segment can be read. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 16 &lt;br /&gt;2.64T &lt;br /&gt;4. See Figure D-17 (top of next page) &lt;br /&gt;6. The memory map for the 80386 contains 40 bytes of memory that is physically organized &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;into a 32-bit-wide memory system. Each of the four 8-bit-wide memory banks is selected &lt;br /&gt;using a bank enable signal labeled BEG-BE3. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8. The pipeline allows the microprocessor to send out an address while the data from a prior &lt;br /&gt;operation are being fetched. This allows the memOlY additional time for accessing the data. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. OOOOH-FFFFH &lt;br /&gt;12. The only differences are a wider data bus (32-bits) and a wider address bus (32-bits). &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OOOFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FIGURE 0-17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Real Mode &lt;br /&gt;Memory Map &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FFFFFFFF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;00000000 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Protected &lt;br /&gt;Mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Memory &lt;br /&gt;Map &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;14. The BS 16 pin configures the microprocessor to operate with a 16-bit data bus. &lt;br /&gt;16. EAX, EBX, ECX, EDX, WSP, EBP, ESI, EDI, EIP, and EFLAGS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;899 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;18. CRO = selects paging and enters or leaves the protected mode, CRI = reserved for the future, &lt;br /&gt;CR2 = holds the linear address of any fault, and CR3 = holds the base address of the page &lt;br /&gt;directory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;20. Interrupt type 1 &lt;br /&gt;22. The BSR instruction scans a number from the left toward the right. If a 1 is found, the zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;flag is set and the bit position of the logic 1 is placed into the destination register. &lt;br /&gt;24. MOV FS:[DI],EAX &lt;br /&gt;26. Yes &lt;br /&gt;28. Interrupt type number 7 is used to emulate the arithmetic coprocessor. &lt;br /&gt;30. A double fault interrupt occurs whenever more than one interrupt occurs within the micro-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;processor. &lt;br /&gt;32. A descriptor is a sequence of eight bytes that describe the location, length, and attributes of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;a protected mode memory segment. &lt;br /&gt;34. If the table indicator is a logic 1, the local descriptor table is chosen by the segment register. &lt;br /&gt;36. 8,192 &lt;br /&gt;38. The segment descriptor describes a data, code, or stack segment, while the system descriptor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;describes a CALL or interrupt gate or a task. &lt;br /&gt;40. The TSS is addressed by a special descriptor that is accessed by the task register. &lt;br /&gt;42. The 803786 is switched between real and protected mode by setting or clearing the right-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;most bit of CRO. &lt;br /&gt;44. CR3 holds the base address of the paging directory. &lt;br /&gt;46. Linear address DOOOOOOOH addresses a physical page by accessing page directory entry &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;1101000000. In this entry, the address of the page table that describes 4M of memory is lo-&lt;br /&gt;cated. Page table entry 0000000000 holds memory address COOOOOOOH to translate linear &lt;br /&gt;addresses DOOOOOOOH to COOOOOOOH. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;48. The FLUSH input erases the internal 80486 cache. &lt;br /&gt;50. None except for the 80486SX, which contains an alignment check flag used by the arith-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;metic coprocessor (80487). &lt;br /&gt;52. Even parity &lt;br /&gt;54. 16 &lt;br /&gt;56. A cache write-through occurs when the microprocessor writes data to the cache and to the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory system. &lt;br /&gt;58. If paging is in effect, caching can be turned on and off for different page translations. &lt;br /&gt;60. This instruction does nothing if AL = CL, but if AL * CL then CL is copied into AL. &lt;br /&gt;62. If PCD = 0, the cache is enabled for the current memory page. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;900 APPENDIX D ANSWERS TO SELECTED EVEN-NUMBERED QUESTIONS AND PROBLEMS &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CHAPTER 17 &lt;br /&gt;2. Up to 640 bytes &lt;br /&gt;4. These pins both generate parity for the ninth bit per byte and also check parity. &lt;br /&gt;6. This pin signals the microprocessor that the bus is ready and is used to insert wait states into &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the timing. &lt;br /&gt;8. 18.2 ns &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;10. T2 &lt;br /&gt;12. Two 8K-byte caches, one for data and the other for instructions. &lt;br /&gt;14. Yes, as long as they are not dependent on each other. &lt;br /&gt;16. The memory-management mode is a special mode accessed through the memory-management &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interrupt input to the Pentium and Pentium Pro. &lt;br /&gt;18. 38000H &lt;br /&gt;20. This instruction compares eight bytes of data stored in memory with EDX:EAX. &lt;br /&gt;22. ID, VIF, and VIP. &lt;br /&gt;24. The Pentium and Pentium Pro access 4M-byte pages by using the page directory to store the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;base page address of a 4M-byte memory page instead of the address of a page table. &lt;br /&gt;26. The Pentium and the Pentium Pro differ in address bus size (32-bits versus 36- on the Pen-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;tium Pro), the FCMOV and CMOV instructions are added to the Pentium Pro, and the Pen-&lt;br /&gt;tium Pro contains the level 2 cache with a size of either 256K or 512K bytes. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;28. A35-A3 &lt;br /&gt;30. The access times are essentially the same on both microprocessors if operated with the same &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;frequency bus clock. &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;.386, 118 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.387,521 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.BREAK,194 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CODE,77 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INDEX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.COM file, 216 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.CONTINUE, 194 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.DATA,77 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ELSE,193 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDIF,191 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.ENDW, 183 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXE file, 216 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.EXIT, 77, 135,235 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.IF, 191 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.LlB,218-220 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.MODEL, 77, 118, 135,521 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.REPEAT,196 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.STACK,115 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.STARTUP, 77,135 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTIL,196 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.UNTILCXZ, 196 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;.WHILE,193 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAA,161 &lt;br /&gt;AAD,161-162 &lt;br /&gt;AAM, 162-163 &lt;br /&gt;AAS, 163 &lt;br /&gt;abacus, 2 &lt;br /&gt;access &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188,591 &lt;br /&gt;rights byte, 57, 641 &lt;br /&gt;time, 300 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;accumulator, 47 &lt;br /&gt;ADA,4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC, 149 &lt;br /&gt;ADD,146 &lt;br /&gt;addition, 145-150 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;with carry, 149 &lt;br /&gt;address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;code, 53 &lt;br /&gt;decoding, 324-325, 369 &lt;br /&gt;linear, 60, 660 &lt;br /&gt;memory, 14 &lt;br /&gt;offset, 51 &lt;br /&gt;physical, 60, 660 &lt;br /&gt;segment, 51 &lt;br /&gt;size prefix, 103 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addressing modes, 68-95 &lt;br /&gt;arithmetic coprocessor, 529 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ALGOL,4 &lt;br /&gt;ALIGN,132 &lt;br /&gt;alignment check flag, 50 &lt;br /&gt;Altair 8800, 6 &lt;br /&gt;analog-to-digita1 conversion, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;421-424 &lt;br /&gt;analytical engine, 2 &lt;br /&gt;AND,163-164 &lt;br /&gt;arithmetic and logic instructions, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;144-175 &lt;br /&gt;arithmetic coprocessor, 517-558 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addressing modes, 529 &lt;br /&gt;instructions, 529-530 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCII,31-33 &lt;br /&gt;arithmetic, 161-163 &lt;br /&gt;null string, 256 &lt;br /&gt;Z string, 256 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;assembler &lt;br /&gt;directive, 79, 130-134 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;command line, 216 &lt;br /&gt;flow control instructions, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;190-197 &lt;br /&gt;assembly language, 4 &lt;br /&gt;ASSUME,132 &lt;br /&gt;asynchronous serial data, 412 &lt;br /&gt;AT,12 &lt;br /&gt;AUTOEXEC.BAT,20-21 &lt;br /&gt;auxiliary carry, 48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Babbage, Charles, 2, 4 &lt;br /&gt;back-link, 645 &lt;br /&gt;base &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;address, 56, 640 &lt;br /&gt;index register, 47 &lt;br /&gt;plus index addressing, 81-82 &lt;br /&gt;pointer register, 47 &lt;br /&gt;relative-plus-index addressing, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;84 &lt;br /&gt;Baud rate, 416 &lt;br /&gt;BCD, 33, 519 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;arithmetic, 160-161 &lt;br /&gt;for coprocessor, 519, 528 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;biased exponent, 37 &lt;br /&gt;binary, 25 &lt;br /&gt;BIOS, 14, 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCI,580-581 &lt;br /&gt;video, 16 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BIST,690 &lt;br /&gt;bit, 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;scan instructions, 173 &lt;br /&gt;test instructions, 168-169 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;block diagram of computer, 12, &lt;br /&gt;23,575,586 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;901 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;902 INDEX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;booting, 18 &lt;br /&gt;bootstrap loader, 254 &lt;br /&gt;BOUND, 208, 434 &lt;br /&gt;BSF and BSR, 173 &lt;br /&gt;BSWAP, 128 &lt;br /&gt;BT, BTC, BTR, and BTS, 168 &lt;br /&gt;buffered system, 295-298, 627 &lt;br /&gt;buffers, 294-298 &lt;br /&gt;bus, 11,22-25 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;address, 22, 287 &lt;br /&gt;address/data, 287 &lt;br /&gt;address/status, 28.8 &lt;br /&gt;arbiter, 484-487 &lt;br /&gt;buffers, 294-298 &lt;br /&gt;control,24 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;functions, 290 &lt;br /&gt;cycle status, 290 &lt;br /&gt;data, 23 &lt;br /&gt;EISA, 569-573 &lt;br /&gt;ISA, 562-569 &lt;br /&gt;local, 13, 483 &lt;br /&gt;master, 484 &lt;br /&gt;operation, 299 &lt;br /&gt;PCI, 573-582 &lt;br /&gt;shared,483 &lt;br /&gt;timing, 299-304 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Byron, Augusta Ada, 2, 4 &lt;br /&gt;byte, 5, 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sized data, 34-35 &lt;br /&gt;BYTE PTR, 79, 130, 148, 152 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cache, 8, 672 &lt;br /&gt;test registers, 674-675 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CAD, 7 &lt;br /&gt;CALL, 198-201 &lt;br /&gt;carry, 48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;controlling, 206 &lt;br /&gt;holds borrow, 152-153 &lt;br /&gt;with multiplication, 155 &lt;br /&gt;with rotates, 172 &lt;br /&gt;with shifts, 170 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CBW, 158 &lt;br /&gt;CD-ROM, 15, 507-508 &lt;br /&gt;CDQ,159 &lt;br /&gt;CE,314 &lt;br /&gt;CGA, 509 &lt;br /&gt;chip enable, 314 &lt;br /&gt;chip select, 314 &lt;br /&gt;CISC,6 &lt;br /&gt;CLC,206 &lt;br /&gt;CLI,205,436 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;clock &lt;br /&gt;generator, 291-294 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188,586-587 &lt;br /&gt;real-time, 463 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188,604-606 &lt;br /&gt;cluster, 254, 505 &lt;br /&gt;CMC,206 &lt;br /&gt;CMOV, 128-129 &lt;br /&gt;CMP, 154 &lt;br /&gt;CMPS,174-175 &lt;br /&gt;CMPXCI{G, 154-155 &lt;br /&gt;CMPXCHG8B,154-155 &lt;br /&gt;COBAL,4 &lt;br /&gt;code &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;segment, 53 &lt;br /&gt;segment register, 50 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;cold start location, 333 &lt;br /&gt;colors, video, 510 &lt;br /&gt;Colossus, 3 &lt;br /&gt;command file (.COM), 216 &lt;br /&gt;COMMAND. COM, 15, 20, 254 &lt;br /&gt;comment, 75 &lt;br /&gt;comparisons, 153-155 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;arithmetic coprocessor, 531 &lt;br /&gt;complements, 30-31, 34, 169 &lt;br /&gt;conditional &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;jumps, 186-188 &lt;br /&gt;loop instructions, 190 &lt;br /&gt;repeat instructions, 174 &lt;br /&gt;set instructions, 188-190 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CONFIG.SYS, 19-20 &lt;br /&gt;connectors &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CENT36 parallel port, 368 &lt;br /&gt;DB-9 video, 510 &lt;br /&gt;DB-15 video, 511 &lt;br /&gt;DB-25 parallel port, 368 &lt;br /&gt;EISA, 574 &lt;br /&gt;ISA bus &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bit, 563 &lt;br /&gt;16-bit, 569 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PCI,576 &lt;br /&gt;RS-232C (serial), 462 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;constants, 532 &lt;br /&gt;control &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;bus, 24 &lt;br /&gt;instructions for coprocessor, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;532-534 &lt;br /&gt;registers, 61, 636-637 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;for numeric coprocessor, 525 &lt;br /&gt;Pentium, 690 &lt;br /&gt;Pentium Pro, 705-706 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;controller, DRAM, 354 &lt;br /&gt;conventional memory, 51 &lt;br /&gt;conversion &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ASCII to binary, 245-246 &lt;br /&gt;BCD to 7 -segment code, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;248-249 &lt;br /&gt;binary-coded hexadecimal, 29 &lt;br /&gt;binary to ASCII, 243-245 &lt;br /&gt;floating-point, 520-521 &lt;br /&gt;fractions, 28 &lt;br /&gt;decimal from any radix, 27-29 &lt;br /&gt;BCD using AAM, 162 &lt;br /&gt;count register, 47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Countess of Lovelace, 2 &lt;br /&gt;CPU, 21 &lt;br /&gt;CPUJD, 693-694 &lt;br /&gt;CS,314 &lt;br /&gt;CWD,159 &lt;br /&gt;cylinder, 501 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAA,160 &lt;br /&gt;daisy-chain, 447 &lt;br /&gt;DAS, 161 &lt;br /&gt;data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addressing, 75 &lt;br /&gt;asynchronous serial, 412 &lt;br /&gt;BCD, 519 &lt;br /&gt;constant, 73 &lt;br /&gt;conversions, 243-253 &lt;br /&gt;floating-point, 519 &lt;br /&gt;formats, 31-38 &lt;br /&gt;immediate, 73 &lt;br /&gt;movement instructions, 10 1-139 &lt;br /&gt;register, 47 &lt;br /&gt;segment, 78 &lt;br /&gt;signed integer, 518 &lt;br /&gt;structures, 88-90 &lt;br /&gt;variable, 73 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DB,35,130 &lt;br /&gt;DC motor control, 409 &lt;br /&gt;DD,36,130 &lt;br /&gt;debug and test registers, 637-639 &lt;br /&gt;DEC, 152 &lt;br /&gt;decoder &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;I/O &lt;br /&gt;8-bit,369-37\\' &lt;br /&gt;16-bit, 370-371 &lt;br /&gt;32-bit, 373-375 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory &lt;br /&gt;2-to-4 line, 327 &lt;br /&gt;3-to-8 line, 325-327 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;INDEX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NAND gate, 324-325 &lt;br /&gt;PLD, 329-332 &lt;br /&gt;PROM, 327-329 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;decrement, 152 &lt;br /&gt;demuItiplexing, 294 &lt;br /&gt;descriptor, 56, 639 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;gate, 645 &lt;br /&gt;table, 59, 640, 643-645 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;destination, 69 &lt;br /&gt;index register, 47 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;digital-to-analog conversion &lt;br /&gt;419-421,511-512 ' &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;digits, 25-26 &lt;br /&gt;DIP, 286 &lt;br /&gt;direct &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data addressing mode, 75-77 &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;access, 467-469 &lt;br /&gt;controller (8237), 469-481 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;direction &lt;br /&gt;bit, 103 &lt;br /&gt;flag, 49, 118-119 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;directory, 255 &lt;br /&gt;disk &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;directory, 255 &lt;br /&gt;files, 253-263 &lt;br /&gt;hard, 504-507 &lt;br /&gt;optical, 507-508 &lt;br /&gt;organization, 254-256 &lt;br /&gt;systems, 500-508 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;displacement, 181 &lt;br /&gt;addressing, 75 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;distributed processing, 485 &lt;br /&gt;DIY, 158 &lt;br /&gt;division, 157-160 &lt;br /&gt;DMA, 467-469 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;controller, 469-481 &lt;br /&gt;do-while loops, 193-196 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;conditional in macros, 225-226 &lt;br /&gt;DOS, 14, 18-21 &lt;br /&gt;double-clocked, 8 &lt;br /&gt;doubleword,21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sized data, 36 &lt;br /&gt;DQ, 38,130 &lt;br /&gt;DR-DOS, 6 &lt;br /&gt;DRAM, 317-323, 353-358 &lt;br /&gt;driver, 15, 20 &lt;br /&gt;DSDD,501 &lt;br /&gt;DT,130 &lt;br /&gt;DUP,132 &lt;br /&gt;DYD,508 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DW, 36,130 &lt;br /&gt;DWORD PTR, 79, 148, 152 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EDO,354 &lt;br /&gt;EEPROM, 14,312,315 &lt;br /&gt;EFLAGS,48 &lt;br /&gt;EGA, 511 &lt;br /&gt;EISA, 12,569-573 &lt;br /&gt;ELSE, 222, 227-229 &lt;br /&gt;embedded PC, 7 &lt;br /&gt;EMM386.EXE, 17, 19,61 &lt;br /&gt;EMS, 16 &lt;br /&gt;END, 77, 135, 137 &lt;br /&gt;ENDIF, 222, 227-229 &lt;br /&gt;ENDM,220 &lt;br /&gt;ENDP, 133, 197 &lt;br /&gt;ENDS, 88, 136 &lt;br /&gt;endian formats, 35 &lt;br /&gt;ENIAC,3 &lt;br /&gt;Enigma machine, 3 &lt;br /&gt;ENTER, 208 &lt;br /&gt;environment space, 20 &lt;br /&gt;EPROM, 15,312,314 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;timing diagram, 316 &lt;br /&gt;EQU, 132-133 &lt;br /&gt;error correction, 339 &lt;br /&gt;ESC, 208 &lt;br /&gt;ESDI, 506 &lt;br /&gt;exclusive-OR, 166-167 &lt;br /&gt;execution file (.EXE), 216 &lt;br /&gt;exponent, 37 &lt;br /&gt;extended high-density disk, 504 &lt;br /&gt;external, 184 &lt;br /&gt;extra segment, 120 &lt;br /&gt;EXTRN, 217-218 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;far &lt;br /&gt;call, 198 &lt;br /&gt;jump, 183-184 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;FAR, 133 &lt;br /&gt;FAR PTR, 117, 186 &lt;br /&gt;FAT (file allocation table), 253 &lt;br /&gt;FCMOY.528 &lt;br /&gt;FIFO. 445. 459 &lt;br /&gt;file &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;creation. 256-257 &lt;br /&gt;opening, 258 &lt;br /&gt;pointer. 258 &lt;br /&gt;random access, 261-263 &lt;br /&gt;reading, 258 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sequential access, 256-261 &lt;br /&gt;writing to, 257 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;fixed port, 126 &lt;br /&gt;flags, 48-50, 145, 151,436 &lt;br /&gt;flash memory, 14,312.325 &lt;br /&gt;floating-point &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;903 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data transfer instruction, 527 &lt;br /&gt;numbers, 37-38. 519-522 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;floppy disk. 500-502 &lt;br /&gt;FLOW -MA TIC, 4 &lt;br /&gt;flying head, 504 &lt;br /&gt;FM.501 &lt;br /&gt;FOR statement in macros, 226-227 &lt;br /&gt;FORTRAN. 4 &lt;br /&gt;fraction, 37 &lt;br /&gt;free pointer. 54 &lt;br /&gt;FSTSW AX, 125. 523, 525 &lt;br /&gt;full segment definitions, 135-137 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;G,7 &lt;br /&gt;gate descriptor, 645 &lt;br /&gt;Gates, Bill, 6 &lt;br /&gt;granularity bit. 57. 640 &lt;br /&gt;GUI,7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;handshaking, 368 &lt;br /&gt;hexadecimal. 14. 29 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;displaying and reading, 246-248 &lt;br /&gt;high &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;density disk, 502 &lt;br /&gt;memory. 19.52 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;HIMEM.SYS, 19.52 &lt;br /&gt;HLDA,468 &lt;br /&gt;HLT.207-208 &lt;br /&gt;Hoff. Marcian E., 3 &lt;br /&gt;HOLD. 468 &lt;br /&gt;Hollerith, Herman. 3 &lt;br /&gt;hot-key. 270 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IBM, 3 &lt;br /&gt;iCOMP index. 11 &lt;br /&gt;ID flag. 50 &lt;br /&gt;IDE. 507 &lt;br /&gt;IDlY. 158 &lt;br /&gt;IF, 222.227-229 &lt;br /&gt;immediate &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addition, 145 &lt;br /&gt;addressing, 73-75 &lt;br /&gt;data, 73 &lt;br /&gt;multiplication, 156 &lt;br /&gt;subtraction, 151 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;904 INDEX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;implied one-bit, 37, 520 &lt;br /&gt;IMUL,155 &lt;br /&gt;IN, 126-127,363 &lt;br /&gt;INC, 148 &lt;br /&gt;INCLUDE, 222 &lt;br /&gt;increment, 148 &lt;br /&gt;index hole, 501 &lt;br /&gt;indirect &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addressing, 77-81 &lt;br /&gt;calls, 200-201 &lt;br /&gt;jumps, 184--186 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;initialization command word, 450 &lt;br /&gt;input characteristics, 287 &lt;br /&gt;INS, 122-123,363 &lt;br /&gt;instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;pointer register, 48, 53 &lt;br /&gt;set for arithmetic coprocessor, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;527-551 &lt;br /&gt;INT, 203-204,434 &lt;br /&gt;INT 3, 205, 434 &lt;br /&gt;INTA, 439, 441 &lt;br /&gt;integer &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data transfer instructions, 527 &lt;br /&gt;signed, 518 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interface, basic, 365-366 &lt;br /&gt;interleaved memory system, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;626-630 &lt;br /&gt;interrupt &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;control, 205-206 &lt;br /&gt;80186/80188,595 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;controller (8259), 448 &lt;br /&gt;80186/80188,595-601 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;descriptor, protected mode, 435 &lt;br /&gt;division, 157 &lt;br /&gt;expansion, 445-462 &lt;br /&gt;flag, 49,431 &lt;br /&gt;hardware, 439-448 &lt;br /&gt;hooks, 270-281 &lt;br /&gt;introduction to, 203-206 &lt;br /&gt;keyboard, 443-445 &lt;br /&gt;purpose of, 430-431 &lt;br /&gt;reserved types, 431-434 &lt;br /&gt;request, 434 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16550 UART, 457 &lt;br /&gt;service procedure, 205, 431, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;443 &lt;br /&gt;system memory management &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(Pentium), 692 &lt;br /&gt;vectors, 203, 431 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;in the microprocessor, 204 &lt;br /&gt;in the personal computer, 207 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;intersegmentjump,90. 181 &lt;br /&gt;INTO, 205, 434 &lt;br /&gt;INTR, 439, 441, 468 &lt;br /&gt;intrasegmentjump, 91, 181 &lt;br /&gt;I/O &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;devices, 17 &lt;br /&gt;instructions, 363-364 &lt;br /&gt;map, 364 &lt;br /&gt;map of PC, 18 &lt;br /&gt;peripheral bus, 487 &lt;br /&gt;port address, 17, 126 &lt;br /&gt;privilege level flag, 49 &lt;br /&gt;programmable peripheral inter-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;face, 375 &lt;br /&gt;10.SYS,15 &lt;br /&gt;101M, 289 &lt;br /&gt;IRET, 205, 434 &lt;br /&gt;ISA, 12,562-569 &lt;br /&gt;isolated I/O, 364 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;jump, 90, 180-188 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;K,5 &lt;br /&gt;keyboard &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;and display interface, 394-402 &lt;br /&gt;interrupt, 443~5 &lt;br /&gt;matrix, 384--387 &lt;br /&gt;scan codes, 230-231 &lt;br /&gt;software, 229-233 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Kilby, Jack, 3 &lt;br /&gt;KIP, 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;label, 74, 91,181,184 &lt;br /&gt;LAHF,125 &lt;br /&gt;latch, 294 &lt;br /&gt;LDS, LES, LFS, LGS, and LSS, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;116-118 &lt;br /&gt;LEA, 115-116 &lt;br /&gt;LEAVE, 208 &lt;br /&gt;libraries (.LIB), 218-220 &lt;br /&gt;LIFO, 92 &lt;br /&gt;LIM 4.0,17 &lt;br /&gt;limit, 640 &lt;br /&gt;linker program, 216 &lt;br /&gt;linear address, 60 &lt;br /&gt;load effective address, 115-118 &lt;br /&gt;local bus, 13 &lt;br /&gt;LOCK, 208 &lt;br /&gt;LODS,119 &lt;br /&gt;logic instructions, 163-169 &lt;br /&gt;lookup table, 125,248-250 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOP, 189 &lt;br /&gt;LOOPE and LOOPNE, 190 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;M, 6 &lt;br /&gt;machine language, 4, 102-110 &lt;br /&gt;MACRO, 220 &lt;br /&gt;macros, 220-229 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;conditional statements, &lt;br /&gt;222-229 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;local variables, 221 &lt;br /&gt;modules, 222 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mantissa, 37 &lt;br /&gt;maximum mode, 307-308 &lt;br /&gt;memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;address &lt;br /&gt;connections, 313 &lt;br /&gt;decoding, 324--325 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;control connections, 314 &lt;br /&gt;conventional, 51 &lt;br /&gt;data connections, 313-314 &lt;br /&gt;devices, 312-323 &lt;br /&gt;dynamic RAM, 317-323, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;353-358 &lt;br /&gt;EDO,354 &lt;br /&gt;expanded, 16 &lt;br /&gt;extended, 12 &lt;br /&gt;high, 19,52 &lt;br /&gt;interface &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8-bit, 332-340 &lt;br /&gt;16-bit,340-346 &lt;br /&gt;32-bit, 347-350 &lt;br /&gt;64-bit, 350-353 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interleaved, 626-630 &lt;br /&gt;management, 639-647 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mode (Pentium), 691-693 &lt;br /&gt;map &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;personal computer, 13 &lt;br /&gt;system area, 16 &lt;br /&gt;TPA,14 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mapped 1/0,364 &lt;br /&gt;organization, 134--137 &lt;br /&gt;paging, 60-64 &lt;br /&gt;read only, 314--316 &lt;br /&gt;real, 12,51 &lt;br /&gt;static RAM, 316-317 &lt;br /&gt;upper, 17 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MFM,501 &lt;br /&gt;micro-floppy disk, 500 &lt;br /&gt;microprocessor &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;architecture, 45-64, 584--593 &lt;br /&gt;Pentium Pro, 696-699 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;INDEX 905 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;based personal computer, number systems, 25-31 80286,617 &lt;br /&gt;11-25 numeric execution unit, 523 80386DX/80386SX, 623 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DC characteristics, 286-287 80486, 666 &lt;br /&gt;description of, 21-22 object file, 216 8208,356 &lt;br /&gt;direct memory access, 467-469 octal, 25 8237,469 &lt;br /&gt;interrupts, 439-448 OE,314 8253/8254, 403 &lt;br /&gt;power requirements, 268 OEM,508 8255,376 &lt;br /&gt;types OFFSET, 79, 115-116 8259A,449 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;4004,4 offset address, 51 8279,395 &lt;br /&gt;4040,5 opcode, 69, 103 8284A,291 &lt;br /&gt;8008,5 operand, 75 8288,309 &lt;br /&gt;8080,5 operation command word, 450 8289,486 &lt;br /&gt;8085,6 OR,164-166 ADC-0804,421 &lt;br /&gt;8086,6 ORO, 132-133 DAC-0830, 420 &lt;br /&gt;8088,6 OUT, 126-127,363 Pentium, 680 &lt;br /&gt;80286, 7 output Pentium Pro, 697 &lt;br /&gt;80386, 7-8 characteristics, 287 SIMM,323 &lt;br /&gt;80486,8 enable, 314 TMS-4016,317 &lt;br /&gt;Pentium, 8-10 interface, basic, 366-367 TMS-4464, 320 &lt;br /&gt;Pentium Pro, 10 OUTS, 123-124,363 pin connections, description of &lt;br /&gt;Z-80, 6 overdrive, 8 16550,413-414 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mini-floppy disk, 500 overflow flag, 49 8086/8088,287-291 &lt;br /&gt;minimum mode, 307 80186/80188,588-591 &lt;br /&gt;MIPS, 6 page 80386,624-625 &lt;br /&gt;ML,216 directory, 62, 661 80486,665-669 &lt;br /&gt;MOD field, 103-104 frame, 16 8237,470-471 &lt;br /&gt;mouse, 237-243 table, 62, 662 8253/8254, 403 &lt;br /&gt;MOV, 69 paging, 60-64, 660-665 8259A, 448-449 &lt;br /&gt;MOVS,122 Pentium, 691 8279,395 &lt;br /&gt;MOVSX, 128 paragraph, 52 8284A,291-292 &lt;br /&gt;MOVZX, 128, 157 parameter 8288,309 &lt;br /&gt;MUL,155 passing, 209 8289,486-487 &lt;br /&gt;multiplication, 155-157 stacking, 202 Pentium, 681-684 &lt;br /&gt;mUltiprocessing, 483 parity, 48, 337 Pentium Pro, 699-703 &lt;br /&gt;multitasking, 483 Pascal, Blaise, 2 pixel, 7, 513 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PATH, 21 plug and play, 573, 578 &lt;br /&gt;near PC, 12 pointer, file, 258 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;call, 198 PCB, 594 POP, 112-113 &lt;br /&gt;jump, 182-183 PCI,12 POPA,112 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEAR,133 pel, 7 POPF,112 &lt;br /&gt;NEG,169 peripheral control block, 594-595 positional notation, 26-27 &lt;br /&gt;nested task flag, 50 physical address, 60 power save/down, 586 &lt;br /&gt;nibble, 4 pin-outs PPI,375 &lt;br /&gt;NMI, 439, 468 16550,413 prefixes, 102-103, 129-130 &lt;br /&gt;noise immunity, 287 2716,315 printer interface, 481-483 &lt;br /&gt;non-maskable interrupt, 439 41256,322 privilege level, 57 &lt;br /&gt;NOP,208 62256. 320 PROC. 133, 197 &lt;br /&gt;NOT, 169 8086.286 procedure. 133, 197-203 &lt;br /&gt;NRZ,502 8088.286 program &lt;br /&gt;null string, 256 80186.588 invisible registers, 59 &lt;br /&gt;number base, 26 80188.590 loader, 54 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;906 INDEX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory-addressing modes, &lt;br /&gt;90-92 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;segment prefix (PSP), 267 &lt;br /&gt;program examples, 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;arithmetic coprocessor &lt;br /&gt;area of circle, 551-552 &lt;br /&gt;displaying a floating-point &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;number, 555-557 &lt;br /&gt;quadratic equation, 553-554 &lt;br /&gt;reading a mixed number, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;557-558 &lt;br /&gt;resonant frequency, 552-553 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;calculator program, 263-264 &lt;br /&gt;chime, 273 &lt;br /&gt;DC motor speed and direction, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;411 &lt;br /&gt;display &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;character string, 234 &lt;br /&gt;current day of the week, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;249-250 &lt;br /&gt;extended memory, 653-659 &lt;br /&gt;hexadecimal number, 246 &lt;br /&gt;mouse pointer and coordi-&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;nates, 241-243 &lt;br /&gt;mouse version number, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;238-240 &lt;br /&gt;number, 244, 245 &lt;br /&gt;one character, 234 &lt;br /&gt;scanning an 8-digit LED &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;display, 381 &lt;br /&gt;time and date, 251-253 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;file &lt;br /&gt;append, 259 &lt;br /&gt;creation, 257 &lt;br /&gt;insertion, 259-261 &lt;br /&gt;opening and reading, 258 &lt;br /&gt;random access creation, 262 &lt;br /&gt;reading a record, 262-263 &lt;br /&gt;writing to, 257 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;hexadecimal file dump, &lt;br /&gt;267-270 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;home cursor and clear screen, &lt;br /&gt;235-237 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;initialization of 16550 and &lt;br /&gt;8259A, 455-457 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;keyboard scanning :-tnd &lt;br /&gt;debouncing, 386-387 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;keystroke counter, hot-key, &lt;br /&gt;276-280 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory fill with DMA, &lt;br /&gt;479-481 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory-to-memory DMA &lt;br /&gt;transfer, 478-479 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;read &lt;br /&gt;hexadecimal number, 247 &lt;br /&gt;key with echo, 232 &lt;br /&gt;key without echo, 232 &lt;br /&gt;lines from keyboard, 233 &lt;br /&gt;number, 246 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;real-time clock, 463-464 &lt;br /&gt;80186/80188,606-607 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;recording and playing back &lt;br /&gt;speech,424-426 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;register trace, 437-438 &lt;br /&gt;serial &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data reception, 419 &lt;br /&gt;data transmission, 418 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sorting numbers, 265-267 &lt;br /&gt;stepper motor control, 363 &lt;br /&gt;test for the mouse, 238 &lt;br /&gt;trap, enable/disable, 436 &lt;br /&gt;TSR alarm, 271-273 &lt;br /&gt;using the DISP macro, 237 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;programmable &lt;br /&gt;chip selection unit, 587, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;608-612 &lt;br /&gt;communications interface, 412 &lt;br /&gt;DMA controller, 487-489 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188,587,606-608 &lt;br /&gt;interrupt controller, 448 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188,587,595-601 &lt;br /&gt;interval timer, 402 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188,601-606 &lt;br /&gt;keyboard/display interface, 395 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;peripheral interface, 375 &lt;br /&gt;programming model, 46, 378 &lt;br /&gt;PROM,314 &lt;br /&gt;protected mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;interrupt operation, 435 &lt;br /&gt;memory addressing, 56-60 &lt;br /&gt;moving to, 647-659 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;PUBLIC, 217-218 &lt;br /&gt;PUSH, 110-111 &lt;br /&gt;PUSHA,112 &lt;br /&gt;PUSHF,IIO &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;queue, 445 &lt;br /&gt;status, 291 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;radix, 26 &lt;br /&gt;RAM, 15,312 &lt;br /&gt;raster line, 513 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RCL and RCR, 173 &lt;br /&gt;RD,288 &lt;br /&gt;read &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA,468 &lt;br /&gt;signal,288 &lt;br /&gt;timing, 300-303 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ready, 288,304 &lt;br /&gt;REAL4, REAL8, and REALlO, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;38 &lt;br /&gt;real mode &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memory addressing, 51-55 &lt;br /&gt;â¢ operation, 51 &lt;br /&gt;real numbers, 37-38 &lt;br /&gt;refresh, 353 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;control unit, 588 &lt;br /&gt;register &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addition, 145 &lt;br /&gt;addressing, 72-73 &lt;br /&gt;assignments, 104-105 &lt;br /&gt;indirect addressing, 77-81 &lt;br /&gt;relative addressing, 82-83, 181 &lt;br /&gt;size prefix, 102 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;registers, 47-51 &lt;br /&gt;control, 61, 636-637 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Pentium, 689-690 &lt;br /&gt;Pentium Pro, 705-706 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;debug and test, 637-639 &lt;br /&gt;default,52-53 &lt;br /&gt;descriptor, 59 &lt;br /&gt;list of, 72 &lt;br /&gt;multipurpose, 47-48 &lt;br /&gt;segment, 50-51 &lt;br /&gt;selector, 58 &lt;br /&gt;special-purpose, 48-50 &lt;br /&gt;task,60 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;relational operators, 191 &lt;br /&gt;relocation, 54-55, 183 &lt;br /&gt;remainder, 159-160 &lt;br /&gt;REP, 121-122 &lt;br /&gt;REPE and REPNE, 174 &lt;br /&gt;repeat-until loops, 196-197 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;conditional in macros, 224-225 &lt;br /&gt;reset, 289, 293-294 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;during DMA, 468 &lt;br /&gt;resume flag, 50 &lt;br /&gt;RET,201-203 &lt;br /&gt;return operation, 201-203 &lt;br /&gt;ROB,509 &lt;br /&gt;rigid disk, 504 &lt;br /&gt;RISC, 10 &lt;br /&gt;RLL,505 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;INDEX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RIM,105 &lt;br /&gt;ROL and ROR, 173 &lt;br /&gt;ROM, 312, 314-314 &lt;br /&gt;rotate instructions, 172-173 &lt;br /&gt;RPG,4 &lt;br /&gt;RS-232C, 462 &lt;br /&gt;run-length limited, 505-507 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SAHF,125 &lt;br /&gt;SAL and SAR, 171 &lt;br /&gt;SBB,153 &lt;br /&gt;scaled-index &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addressing, 87-88 &lt;br /&gt;byte, 106 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SCAS, 173-174 &lt;br /&gt;SCSI, 506 &lt;br /&gt;sector, 254, 500 &lt;br /&gt;segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;address, 51 &lt;br /&gt;default combinations, 52-53 &lt;br /&gt;descriptor, 641 &lt;br /&gt;limit, 56 &lt;br /&gt;override prefix, 129-130 &lt;br /&gt;registers, 50-51 &lt;br /&gt;task state (TSS), 645-647 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SEGMENT, 136 &lt;br /&gt;selector, 56, 639 &lt;br /&gt;shift instructions, 169-172 &lt;br /&gt;SHL and SHR, 171 &lt;br /&gt;SHLD and SHRD, 172 &lt;br /&gt;short jump, 181-182 &lt;br /&gt;sign &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;extension, 104, 128 &lt;br /&gt;flag, 49 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;signed integer, 34 &lt;br /&gt;small,77 &lt;br /&gt;SMM,692 &lt;br /&gt;sorting data, 264-267 &lt;br /&gt;source, 69 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;file, 216 &lt;br /&gt;index register, 48 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;speaker, 271 &lt;br /&gt;SRAM, 312, 316-317 &lt;br /&gt;stack &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;addressing, 53 &lt;br /&gt;frame with ENTER/LEA VE, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;209 &lt;br /&gt;initialization, 113-115 &lt;br /&gt;interrupt operation, 434 &lt;br /&gt;memory-addressing modes, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;92-95 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;operation for a POP, 113 &lt;br /&gt;operation for a PUSH, III &lt;br /&gt;operation with procedures, 199 &lt;br /&gt;pointer register, 48 &lt;br /&gt;segment, 78 &lt;br /&gt;segment register, SO, 53 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;standard floppy disk, 500 &lt;br /&gt;status bits, 288 &lt;br /&gt;STC, 206 &lt;br /&gt;stepper motor, 382 &lt;br /&gt;STI, 206, 436 &lt;br /&gt;STOS, 119-122 &lt;br /&gt;string &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;comparison instructions, &lt;br /&gt;173-175 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;data transfer instructions, &lt;br /&gt;118-124 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STRUC,88 &lt;br /&gt;SUB, 151 &lt;br /&gt;subroutine, 133, 197-203 &lt;br /&gt;subtraction, 150-153 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;with borrow, 152 &lt;br /&gt;SYS.COM.15 &lt;br /&gt;system &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;area, 12, 15-18 &lt;br /&gt;descriptor, 642 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;task &lt;br /&gt;register, 60, 645 &lt;br /&gt;state segment, 645-476 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TEST, 167-168 &lt;br /&gt;TEST, 288 &lt;br /&gt;TI bit, 57 &lt;br /&gt;timer, 271-272, 402-412 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188,601-606 &lt;br /&gt;time stamp counter, 695 &lt;br /&gt;timing &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;80186/80188,591-593 &lt;br /&gt;80386,633-636 &lt;br /&gt;80486,672-674 &lt;br /&gt;in general, 299-300 &lt;br /&gt;Pentium, 686-688 &lt;br /&gt;Pentium Pro, 704-705 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;TLB,62 &lt;br /&gt;TPA,12-15 &lt;br /&gt;track, 254, 500 &lt;br /&gt;transcendental operations, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;531-532 &lt;br /&gt;trap flag, 49 &lt;br /&gt;triple-clocked, 8 &lt;br /&gt;TSR,270 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;T-state,299 &lt;br /&gt;Turing, Alan, 3 &lt;br /&gt;Tw.304 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;uART.413 &lt;br /&gt;unsigned integer, 34 &lt;br /&gt;USEI6 and USE32, 137 &lt;br /&gt;USES, 134, 197 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;variable port, 126 &lt;br /&gt;VCPI, 19,657 &lt;br /&gt;vector, interrupt, 203 &lt;br /&gt;VESA,13 &lt;br /&gt;VGA, 7, 511 &lt;br /&gt;video &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;signals, 509 &lt;br /&gt;systems, 508-515 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;907 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;video display software, 233-237 &lt;br /&gt;virtual &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;8086 mode, 659-660 &lt;br /&gt;nags, 50 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;von Neumann machine, 4 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT,206 &lt;br /&gt;wait states, 304-306, 635 &lt;br /&gt;WE,314 &lt;br /&gt;Winchester disk drive, 504 &lt;br /&gt;word, 21 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sized data, 35-36 &lt;br /&gt;WORD PTR, 79, 148, 152 &lt;br /&gt;WORM, 507 &lt;br /&gt;WR,289 &lt;br /&gt;write, 289, 314 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DMA,468 &lt;br /&gt;timing, 303-304 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WYSIWYG,7 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XADD,150 &lt;br /&gt;XCHG, 124-125 &lt;br /&gt;XLAT, 125-126,249 &lt;br /&gt;XMS,12 &lt;br /&gt;XOR, 166-167 &lt;br /&gt;XT,12 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;zero &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;extension, 128 &lt;br /&gt;nag, 49 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Zuse, Konrad, 3 &lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;</Content>
</Section>
</Archive>
