<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE Archive SYSTEM "http://greenstone.org/dtd/Archive/1.0/Archive.dtd">
<Archive>
<Section>
  <Description>
    <Metadata name="gsdldoctype">indexed_doc</Metadata>
    <Metadata name="Language">en</Metadata>
    <Metadata name="Encoding">utf8</Metadata>
    <Metadata name="Title">ASSEMBLY LANGUAGE PROGRAMMING</Metadata>
    <Metadata name="URL">http://C:/Program Files/Greenstone/tmp/F667.html</Metadata>
    <Metadata name="UTF8URL">http://C:/Program Files/Greenstone/tmp/F667.html</Metadata>
    <Metadata name="gsdlsourcefilename">import\Chapter 2 .pdf</Metadata>
    <Metadata name="gsdlconvertedfilename">C:\Program Files\Greenstone\tmp\F667.html</Metadata>
    <Metadata name="OrigSource">F667.html</Metadata>
    <Metadata name="Source">Chapter 2 .pdf</Metadata>
    <Metadata name="SourceFile">Chapter 2 .pdf</Metadata>
    <Metadata name="Plugin">PDFPlugin</Metadata>
    <Metadata name="FileSize">498585</Metadata>
    <Metadata name="FilenameRoot">Chapter 2 </Metadata>
    <Metadata name="FileFormat">PDF</Metadata>
    <Metadata name="srcicon">_iconpdf_</Metadata>
    <Metadata name="srclink_file">doc.pdf</Metadata>
    <Metadata name="srclinkFile">doc.pdf</Metadata>
    <Metadata name="NumPages">55</Metadata>
    <Metadata name="dc.Creator">jj</Metadata>
    <Metadata name="dc.Subject">geography</Metadata>
    <Metadata name="dc.Title">Chapter 2 .pdf</Metadata>
    <Metadata name="dls.Organization">Social Science|Geography|Books</Metadata>
    <Metadata name="ex.ExifTool.ExifToolVersion">8.57</Metadata>
    <Metadata name="ex.File.Directory">C:\Program Files\Greenstone\collect\ebook\import</Metadata>
    <Metadata name="ex.File.FileModifyDate">2018:12:10 02:52:16-08:00</Metadata>
    <Metadata name="ex.File.FileName">Chapter 2 .pdf</Metadata>
    <Metadata name="ex.File.FilePermissions">666</Metadata>
    <Metadata name="ex.File.FileSize">498585</Metadata>
    <Metadata name="ex.File.FileType">PDF</Metadata>
    <Metadata name="ex.File.MIMEType">application/pdf</Metadata>
    <Metadata name="ex.PDF.Author">Mulu</Metadata>
    <Metadata name="ex.PDF.CreateDate">2018:07:19 23:11:03+03:00</Metadata>
    <Metadata name="ex.PDF.Creator">Microsoft® PowerPoint® 2016</Metadata>
    <Metadata name="ex.PDF.Language">en-US</Metadata>
    <Metadata name="ex.PDF.Linearized">false</Metadata>
    <Metadata name="ex.PDF.ModifyDate">2018:07:19 23:11:03+03:00</Metadata>
    <Metadata name="ex.PDF.PDFVersion">1.7</Metadata>
    <Metadata name="ex.PDF.PageCount">55</Metadata>
    <Metadata name="ex.PDF.Producer">Microsoft® PowerPoint® 2016</Metadata>
    <Metadata name="ex.PDF.TaggedPDF">true</Metadata>
    <Metadata name="ex.PDF.Title">ASSEMBLY LANGUAGE PROGRAMMING</Metadata>
    <Metadata name="ex.XMP.CreateDate">2018:07:19 23:11:03+03:00</Metadata>
    <Metadata name="ex.XMP.Creator">Microsoft® PowerPoint® 2016</Metadata>
    <Metadata name="ex.XMP.CreatorTool">Microsoft® PowerPoint® 2016</Metadata>
    <Metadata name="ex.XMP.DocumentID">uuid:3E13286B-C2B0-420C-BEE8-6F648E0AA0E2</Metadata>
    <Metadata name="ex.XMP.InstanceID">uuid:3E13286B-C2B0-420C-BEE8-6F648E0AA0E2</Metadata>
    <Metadata name="ex.XMP.ModifyDate">2018:07:19 23:11:03+03:00</Metadata>
    <Metadata name="ex.XMP.Producer">Microsoft® PowerPoint® 2016</Metadata>
    <Metadata name="ex.XMP.Title">ASSEMBLY LANGUAGE PROGRAMMING</Metadata>
    <Metadata name="ex.XMP.XMPToolkit">3.1-701</Metadata>
    <Metadata name="Identifier">HASH013c84cb137fbb1e438738d9</Metadata>
    <Metadata name="lastmodified">1544439136</Metadata>
    <Metadata name="lastmodifieddate">20181210</Metadata>
    <Metadata name="oailastmodified">1545141364</Metadata>
    <Metadata name="oailastmodifieddate">20181218</Metadata>
    <Metadata name="assocfilepath">HASH013c.dir</Metadata>
    <Metadata name="gsdlassocfile">doc.pdf:application/pdf:</Metadata>
  </Description>
  <Content>
&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Chapter 2 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assembly Language Programming&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Contents:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Intro to assembly Language programming&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Addressing Modes &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Data Transfer, Arithmetic and Logical &lt;br /&gt;Instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• String Instructions - Machine Control &lt;br /&gt;Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 1&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Introduction to assembly language &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• There are three language levels that can be used to &lt;br /&gt;write a program&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Machine Language:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– The binary form of the program is referred to as machine language &lt;br /&gt;because it is the form required by the machine.  &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Assembly Language is a low-level language. Deals directly &lt;br /&gt;with the internal structure of CPU.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Assembly Languages provided mnemonics for machine code &lt;br /&gt;instructions.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Mnemonics refer to codes and abbreviations to represent &lt;br /&gt;instructions and make it easier for the users to remember.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 2&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;• Assembler translates Assembly language program into machine &lt;br /&gt;code.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• In high-level languages, Pascal, Basic, C,C++,Java; the &lt;br /&gt;programmer does not have to be concerned with internal details of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the CPU. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Compilers translate the program into machine code.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;✓ However, it is difficult, if not impossible, for a programmer to&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;memorize the thousands of binary instruction codes for a CPU such &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;as the 8086.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;37/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Assignment of assembly language&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• In Java, assignment takes the form:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;x = 42 ;&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;y = 24;&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• In assembly language we carry out the same &lt;br /&gt;operation but we use an instruction to denote the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;assignment operator (“=” in Java).&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mov           x, 42&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mov            y, 24&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;47/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;• The mov instruction carries out assignment in &lt;br /&gt;8086 assembly language.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• It allows us to place a number in a register or in a &lt;br /&gt;memory location (a variable) i.e. it assigns a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;value to a register or variable.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example: Store the ASCII code for the letter A &lt;br /&gt;in register bx.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• A has ASCII code 65D (01000001B, 41H)&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• The following mov instruction carries out the &lt;br /&gt;task:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• mov bx, 65d&lt;br /&gt;57/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;• We could also write it as:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;mov bx, 41h&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or     mov bx, 01000001b&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;or     mov bx, ‘A’&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• All of the above are equivalent. They each carry out &lt;br /&gt;exactly the same task, namely the binary number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;representing the ASCII code of A is copied into the bx &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;register.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• we could also have written it as:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• mov bl, 65d&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• mov bl, ‘A’&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Since register bl represents the low-order byte of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;register bx.&lt;br /&gt;67/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;• Note: The 8086 Assembler converts a character &lt;br /&gt;constant i.e. a character in single quotes (e.g. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;‘A’) to its ASCII code automatically.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• This is a very useful feature and it means that &lt;br /&gt;you can specify many characters without having &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to look up their ASCII code. You simply enclose &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the character in single quotes.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;77/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Compilers, Assemblers, Linkers &amp;amp; Loaders &lt;br /&gt;Compilation Process &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;87/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Assembler and the Source Program&lt;br /&gt;✓Assembly language program (.asm) file—known as &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;“source code” converted to machine code by a process &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;called “assembling”.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;✓ Assembling performed by a software program — an &lt;br /&gt;“8088/8086 assembler”.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– “Machine (object ) code” that can be run on a PC is output in &lt;br /&gt;the executable (.exe) file.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;✓ MASM—Microsoft 80x86 macroassembler&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;allows a complete program to be assembled in one &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;step&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;97/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;❖ After typing the program save the file with appropriate file name &lt;br /&gt;with an extension .ASM&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Ex:      Add.ASM&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;❖Assembling an ALP&lt;br /&gt;➢ To assemble an ALP we need executable file called MASM.EXE. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Only if this file is in current working directory we can assemble &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the program. The command is: MASM&amp;lt;filename.ASM&amp;gt;&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;❖ If the program is free from all syntactical errors, this command &lt;br /&gt;will give the OBJECT file. In case of errors it list out the number &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;of errors, warnings and kind of error.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;❖ Note: No object file is created until all errors are rectified.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;❖ Linking:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;➢ After successful assembling of the program we have to link it to &lt;br /&gt;get Executable file. The command is LINK&amp;lt;File name.OBJ&amp;gt;&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;107/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;ADDRESSING MODES OF 8086&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Addressing modes describe the types of operands and the way they are &lt;br /&gt;accessed for executing an instruction.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• There are eight addressing modes for 8086 instructions to specify &lt;br /&gt;operand.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Register addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Immediate Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Direct Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Register Indirect Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Based Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Indexed addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Based Indexed Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Based Indexed Addressing with displacement&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 11&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;1. Register Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• In this mode of addressing an 8-bit or 16 bit &lt;br /&gt;general purpose register contains an operand. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example:  MOV BX,CX; move the content of CX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;reg.to BX reg.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,CH&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD CX,DX&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 12&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;2. Immediate Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• In this addressing mode, the operand is &lt;br /&gt;contained in the instruction itself.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– MOV AL,58H      ; move 58H to AL register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– MOV BX, 0354H  ; move 0354H  to BX  reg.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– ADD AX, 0395H  ; Add 0395H to the content of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AX reg.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 13&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3. Direct Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• This mode of addressing an effective address &lt;br /&gt;(or offset) is given in the instruction itself. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• MOV AL, [0300H]  ; this instruction will &lt;br /&gt;move the content of the offset address 0300H  &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;to AL.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• MOV [0401H], AX  ; this instruction will &lt;br /&gt;move the content of AX to the offset address &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0401H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 14&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4. Register Indirect Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The operand’s offset is in the base register, BX or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;base pointer BP or in an index register (SI or DI) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;specified in the instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example: ADD CX,[BX] ; this will add the &lt;br /&gt;contents of the memory locations addressed by &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;register BX to the register CX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DX,[SI]; the content of the memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;location addressed by SI will move to DX.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 15&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Offest&lt;br /&gt;• An offset is called effective address&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• The offset is determined by adding any &lt;br /&gt;combination of offset address elements &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Displacement, base and index.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– The combination depends on the addressing mode &lt;br /&gt;of the instruction to be executed.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Displacement: It is an 8-bit or 16-bit immediate &lt;br /&gt;value given in the instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Base: content of the base register, BX or BP.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Index: content of the index register, SI  or DI.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 16&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;5. Based Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• The operand’s offset is the sum of the contents &lt;br /&gt;of  the base register , BX or BP and an 8-bit or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;16-bit displacement.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Offset (effective address)= [BX or BP +8-bit &lt;br /&gt;or 16-bit displacement].&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• ADD AL, [BX + 04]; case of 8-bit &lt;br /&gt;displacement. Suppose, BX contains 0301H. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;So 0301 + 04 =0305H &amp;amp; stored in AL&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• ADD AL, [BX + 1243H]; case of 16-bit &lt;br /&gt;displacement.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 17&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;6. Indexed Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• the operand’s offset is computed by adding an &lt;br /&gt;8-bit or 16-bit displacement to the content of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;an index register  SI or DI.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Offset= [SI or DI  + 8-bit or 16-bit &lt;br /&gt;displacement].&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example:  ADD AX,  [SI + 08]&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX, [SI + 1523H].&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 18&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7. Based Indexed Addressing&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• The operand’s offset is computed by adding &lt;br /&gt;the contents of a base register to the contents &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;of an index register.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Off set = [BX or BP] + [SI or DI]. BX is used &lt;br /&gt;as a base register for stack segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example:- MOV AX, [BX + SI]&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD CX,   [BX + SI]&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 19&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;8. Based Indexed with Displacement&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• The operand’s offset is computed by adding a &lt;br /&gt;base register’s contents, an index register’s &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;contents and an 8-bit or 16-bit displacement.  &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Offset = [BX or BP] + [SI or DI] + &lt;br /&gt;Displacement. BX is used with data segment, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;where as BP is used with stack segment.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example:- MOV AX, [BX + SI + 05 ]&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD CX,   [BX + SI + 1212H] &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 20&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;INSTRUCTION SET OF 8086 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Data Transfer Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Arithmetic instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Bit Manipulation Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• String instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Program execution transfer instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Processor control instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;217/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Data Transfer Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• This type of instructions is used to transfer &lt;br /&gt;data from source operand to destination &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;operand. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• All the store, move, load, exchange, pop, &lt;br /&gt;push, input and output instructions belong to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;this category.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 22&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Byte Or Word Transfer Instructions (MOV-copy)&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• MOV D,S → (S) =&amp;gt; (D) &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX, 037AH         Put the immediate number 037AH in CX&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL, [437AH]         Copy byte in DS at offset 437AH to BL&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX, BX              Copy contents of register BX to AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DL, [BX]            Copy byte from memory at [BX] to DL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DS, BX              Copy word from BX to DS register&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV RESULTS[BP],AX Copy AX to two memory locations-AL to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the first location, AH to the second. EA of the first memory location is the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;sum of the displacement represented by RESULTS and contents of BP. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Physical address = EA + SS. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CS:RESULTS[BP],AX Same as the above instruction, but    &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;physical address = EA + CS because of the segment override prefix CS.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 23&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;XCHG instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• XCHG- exchanges the contents of a Reg with &lt;br /&gt;the contents of any other Reg or Mem &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;location.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• This instruction cannot exchange segment&lt;br /&gt;registers or memory–to- memory data.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• It can use any addressing modes except &lt;br /&gt;immediate addressing.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 24&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Examples&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG AX,DX       Exchange word in AX with &lt;br /&gt;word in DX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG BL,CH      Exchange byte in BL with byte in CH&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XCHG AL,PRICES [BX]         Exchange byte in AL with        &lt;br /&gt;byte in memory at EA = PRICES [BX] in DS&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;257/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;XLAT/XLATB-Translate a Byte in AL &lt;br /&gt;• The XLATB instruction is used to translate a byte from &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;one code to another code. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• The instruction replaces a byte in the AL register with &lt;br /&gt;a byte pointed to by BX in a lookup table in memory.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– It is used in -ASCII to 7-segment display &lt;br /&gt;conversion.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– ASCII-to-EBCDIC conversion.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• AL contains offset of the element to be accessed from &lt;br /&gt;the beginning of the lookup table.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(AL) ←( (DSx10) + (BX) + (AL) ) ; translate&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 26&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;XLAT/XLATB…&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– Before the XLATB execution, the lookup table containing &lt;br /&gt;the values for the new code must be put in memory, and the &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;offset of the starting address of the lookup table must be &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;loaded in BX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– The code byte to be translated is put in AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– To point to the desired byte in the lookup table, the XLATB &lt;br /&gt;instruction adds the byte in AL to the offset of the start of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;the table in BX.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;– It then copies the byte from the address pointed to by (BX &lt;br /&gt;+ AL) back into AL. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 27&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;E.g. Assume (DS)=0300H, (BX)=0100H, (AL)=41H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;(ASCII code for character A),&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EBCDIC code for A = C1H&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX, SEGTABLE; address of the segment &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;containing look-up table&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DS, AX ; is transferred to DS&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, CODE ; code of the pressed key (say A=41) as &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;offset is transferred in AL&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BX, OFFSET TABLE; offset of the code lookup &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;table in BX&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;XLAT(MOV AL,[AL][BX]) ; find the equivalent code and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;store in AL&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;287/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;PA=DSx10 + (BX) + (AL) = 03000+0100H &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;+ 41H = 03141H&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;then (AL) ← (03141H)&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;i.e., (AL)= C1H&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Note:-DS and BX must be initialized first &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;before executing XLAT.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;297/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;LEA, LDS, LES Instructions:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;307/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;7/19/2018 31&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Examples&lt;br /&gt;LDS BX, [4326] Copy contents of memory at displacement 4326H in DS to BL, &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;contents of 4327H to BH. Copy contents at displacement of 4328H &lt;br /&gt;and 4329H in DS to DS register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LDS SI, STRING_POINTER&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Copy contents of memory at displacements STRING_POINTER and &lt;br /&gt;STRING_POINTER+1 in DS to SI register. Copy contents of memory at &lt;br /&gt;displacements STRING_POINTER+2 and STRING POINTER+3 In DS to &lt;br /&gt;DS register. DS:SI now points at start of desired string.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LES BX, [789AH] Contents of memory at displacements 789AH and 789BH In DS &lt;br /&gt;copied to BX. Contents of memory at displacements 789CH and &lt;br /&gt;789DH in DS copied to ES register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LES DI, [BX] Copy contents of memory at offset [BX] and offset [BX+1] in DS &lt;br /&gt;to DI register. Copy contents of memory at offsets [BX + 2] and [BX + 3] to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ES register.&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Input-output instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• IN /OUT Ins:. -IN -input from the port. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;-OUT-Output to the port.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• AL and AX are the allowed destinations for 8-bit &lt;br /&gt;and 16-bit I/O operations.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• DX is the implicit address of I/O ports.&lt;br /&gt;• IN AL, 30H ; read from an 8-bit port whose address is 0030H in to AL&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• IN AX, 0400H;&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• IN AX ; read from a 16-bit port whose implicit address is in DX in to AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• IN AX, DX&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• OUT 30H;&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• OUT 0400H&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• OUT AX ;&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• OUT AX, DX&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;327/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;PUSH/POP instructions &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• PUSH- push to stack. Pushes the contents of the &lt;br /&gt;specified Reg/Mem location on to stack.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Higher byte is pushed first, then lower byte.&lt;br /&gt;• PUSH Reg16&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• PUSH Mem16&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• PUSH Seg       ; Seg can be any of CS, DS, ES, SS&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• PUSHA ; save all 16-bit registers except Seg registers &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• PUSHF ; save flags&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• POP:. performs the inverse operation of a PUSH instruction.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• POP Seg       ; Seg can be any of DS, ES, SS, but not CS&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Eg&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• POP CS ; invalid, CS cannot popped&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• POP [5000H]&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;337/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Arithmetic Instructions&lt;br /&gt;Addition Instructions:&lt;br /&gt;oADD   Add specified byte-to-byte or specified word to word.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;operand1 = operand1 + operand2&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 5 ; AL = 5&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL, -3 ; AL = 2&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;oADC-Add with Carry-ADC &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;operand1 = operand1 + operand2 + CF&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example: STC        ; set CF = 1&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 5              ; AL = 5&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADC AL, 1               ; AL = 7&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;347/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;oINC-increment- INC Destination&lt;br /&gt;• Format:&lt;br /&gt;• operand = operand + 1&lt;br /&gt;• Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL,   4&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INC AL      ; AL = 5&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o AAA-ASCII Adjust After Addition&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• This allows us to add the ASCII codes for two decimal digits.&lt;br /&gt;• After the addition, the AAA Instruction is used to make sure the result is the correct BCD&lt;br /&gt;• Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Assume AL = 0 0 1 1 0 1 0 1, ASCII 5 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BL = 0 0 1 1 1 0 0 1, ASCII 9 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL,BL         Result:   AL= 0 1 1 0 1 1 1 0 = 6EH, which is &lt;br /&gt;incorrect BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AAA                            14 decimal &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAA-Decimal Adjust  after BCD Addition &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Decimal adjust After Addition.&lt;br /&gt;• Corrects the result of addition of two  BCD values.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AL = 0101 1001 = 59 BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BL = 0011 0101 = 35 BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ADD AL, BL        AL = 1000 1110 = 8EH &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DAA                Add 01 10 because 1110 &amp;gt; 9 AL = 1001 0100 = 94 BCD &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;357/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Subtraction Instructions:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o SUB-Subtract&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Format:  &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• operand1 = operand1 - operand2&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example: &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 5&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SUB AL, 1          ; AL = 4&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o SBB-Subtract with Carry&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o Format:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o operand1 = operand1 - operand2 – CF&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STC&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 5&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SBB AL, 3           ; AL = 5 - 3 - 1 = 1&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;367/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;DEC-Decrement Destination Register or Memory&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• This Instruction subtracts 1 from the destination.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Format :&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• operand = operand – 1&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example1 : DEC CL        &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC BP       &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example2:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 255 ; AL = 255&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DEC AL ; AL =  254 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;377/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;NEG- (Form 2's Complement)&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Format: Invert all bits of the operand.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Add 1 to inverted operand.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEG AL                  &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NEG BX          &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o CMP-Compare Byte or Word&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The comparison is done by subtracting the source byte or word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;from the destination byte or word. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o Format: operand1 - operand2&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 5&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL, 5&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMP  AL, BL     ; ZF = 1&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;387/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Multiplication Instruction &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o MUL---Multiply Unsigned Bytes or Words&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• when operand is a byte:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• AX = AL * operand.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• when operand is a word:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• (DX  AX) = AX * operand.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;397/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Example: MUL BH           AL times BH, result in AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MUL CX            AX times CX, result high word &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;in DX, low word in AX&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o IMUL-Multiply Signed Numbers&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;This instruction multiplies a signed byte from some source times a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;signed byte in AL or a signed word from some source times a &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;signed word in AX.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example: IMUL BH Signed byte in AL times signed byte in      &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;BH, result in AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IMUL AX              AX times AX, result in DX and AX &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;407/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Division Instruction&lt;br /&gt;• DIV-Unsigned Divide&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• This instruction is used to divide an unsigned word by a byte or &lt;br /&gt;to divide an unsigned double word (32 bits) by a word. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example:&lt;br /&gt;MOV AX, 203 ; AX = 00CBh&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL, 4&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;DIV BL ; AL = 50 (32h), AH = 3&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IDIV-Divide by Signed Byte or Word&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• This instruction is used to divide a signed word by a signed byte, &lt;br /&gt;or to divide a signed double word (32 bits) by a signed word. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example:  MOV AX, -405    &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV BL, 4&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IDIV BL ; AL = -101 , AH = -1 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;417/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;3. Bit Manipulation Instructions:&lt;br /&gt;Logical Instructions:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• NOT- Invert each bit of the operand. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Format:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• If bit is 1 turn it to 0.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• If bit is 0 turn it to 1.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 00011011b&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOT AL ; AL = 11100100b&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• AND-Logical AND between all bits of two operands.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• These rules apply:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• 1 AND 1 = 1&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• 1 AND 0 = 0&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• 0 AND 1 = 0&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• 0 AND 0 = 0&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;427/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;• Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 'a'                    ; AL = 01100001b&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;AND AL, 11011111b       ; AL = 01000001b ('A')&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR- OR Logical between all bits of two operands.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• These rules apply:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• 1 OR 1 = 1&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• 1 OR 0 = 1&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• 0 OR 1 = 1&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• 0 OR 0 = 0&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 'A'                             ; AL = 01000001b&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;OR AL, 00100000b                   ; AL = 01100001b ('a')&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;437/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;oShift Instructions:&lt;br /&gt;o SHL-Shift Operand Bits Left, Put Zero in LSB(s)&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o CF     ←  MSB ← LSB ←     0&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example: MOV AL,   11100000b&lt;br /&gt;SHL AL, 1              ; AL = 11000000b, CF=1.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o SHR-Shift Operand Bits Right, Put Zero in MSB(s)&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0 →   MSB  →     LSB   →        CF&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CF contains the bit most recently shifted in from the LSB. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example1:&lt;br /&gt;MOV AL, 00000111b&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SHR AL, 1 ; AL = 00000011b, CF=1.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;447/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;o ROL-Rotate  Bits of Operand Left, MSB to LSB&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Example1:  ROL AX, 1       Word in AX 1bit position left, MSB to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LSB and CF &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Example2 :&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AL, 1Ch ; AL = 00011100b&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ROL AL, 1 ; AL = 00111000b, CF=0.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;RET&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;457/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;4. String Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• MOVS/MOVSB/MOVSW -Move String Byte or String Word&lt;br /&gt;This instruction copies a byte or a word from a location in the data &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;segment to a location in the extra segment. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The offset of the source byte or word in the data segment must be in &lt;br /&gt;the SI register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;The offset of the destination in the extra segment must be contained &lt;br /&gt;in the DI register. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;For multiple-byte or multiple-word moves, the number of elements &lt;br /&gt;to be moved is put in the CX register so that it can function as a &lt;br /&gt;counter. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt; After the byte or word is moved, SI and DI are automatically &lt;br /&gt;adjusted to point to the next source and the next destination. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;467/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Example&lt;br /&gt;MOV SI, OFFSET SOURCE_STRING  Load offset of start of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;source  string in DS into SI &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DI, OFFSET DESTINATION-STRING     Load offset of &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;start of destination string in ES into DI&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD   Clear direction flag to auto increment SI &amp;amp; DI after move &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV CX, 04H          Load length of string into CX as counter &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REP MOVSB      Decrement CX and copy string bytes until CX = 0 &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After the move, SI will be 1 greater than the offset of the last &lt;br /&gt;byte in the source string. DI will be 1 greater than the offset of &lt;br /&gt;the last byte in the destination string. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CX will be 0. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 47&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;o LODS/LODSB/LODSW Load String Byte into AL or &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Load String Word into AX&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;o This instruction copies a byte from a string location pointed to by &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;SI to AL, or a word from a string location pointed to by SI to AX.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;EXAMPLE:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD ;Clear direction flag so SI is auto incremented.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV SI,  0301H ;memory address in SI.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LODSB ; Load AL with the content of memory locations &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;specified by SI register.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;487/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;oSTOS/STOSB/STOSW-Store Byte or Word in String&lt;br /&gt; The STOS instruction copies a byte from AL or a word from AX to a memory &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;location in the extra segment pointed to by DI.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt; In effect, it replaces a string element with a byte from AL or a word from AX. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;After the copy, DI is automatically incremented or decremented to point to the next &lt;br /&gt;string element in memory. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt; If the direction flag (DF) is cleared, then DI will automatically be incremented by 1 &lt;br /&gt;for a byte string or incremented by 2 for a word string. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt; If the direction flag is set, DI will be automatically decremented by 1 for a byte &lt;br /&gt;string or decremented by 2 for a word string. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;❖ Store AL or AX in to the memory locations addressed by DI.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;❖ Example:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV AX,   7642H         ;Data in AX&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;MOV DI, 0302H             ; memory address in DI.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STOSW ; store [AX] in [DI].&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Result&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0302     42H&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;0303     76H&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;497/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;oREP/REPE/REPZ/REPNE/REPNZ- (Prefix) Repeat &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;String Instruction until Specified Conditions Exist&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REP is a prefix, which is written before one of the string instructions. It will &lt;br /&gt;cause the CX register to be decremented and the string instruction to be repeated &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;until CX = 0. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPE and REPZ are two mnemonics for the same prefix. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt; They stand for Repeat if Equal and Repeat if Zero, respectively.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPE or REPZ is often used with the Compare String instruction or with the &lt;br /&gt;Scan String instruction. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;REPE or REPZ will cause the string instruction to be repeated as long as the &lt;br /&gt;compared bytes or words are equal (ZF = 1) and CX is not yet counted down to &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;zero. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt; In other words, there are two conditions that will stop the repetition: CX = 0 or &lt;br /&gt;string bytes or words not equal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• RFPNE or REPNZ will cause the string instruction to be repeated until the &lt;br /&gt;compared bytes or words are equal (ZF = 1) or until CX = 0 (end of string).&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;507/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Program Execution Transfer Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Conditional Transfer Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Iteration Control Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Interrupt Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 51&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Conditional Transfer Instructions:&lt;br /&gt;JA/JNBE Jump if above/jump if not below or equal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JAE/JNB Jump if above or equal/jump if not below. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JB/JNAE Jump if below/jump if not above or equal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JBE/JNA Jump if below or equal/jump if not above. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JC Jump   if carry flag CF = 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JE/JZ Jump   if equal/jump if zero flag ZF = 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JG/JNLE Jump   if greater/jump if not less than or equal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JGE/JNL Jump if greater than or equal/ Jump if not less than. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JL/JNGE Jump if less than/jump if not greater than or-equal. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JLE/JNG Jump if less than or equal/jump if not greater than. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JNC Jump if no carry (CF = 0). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JNE/JNZ Jump if not equal/jump if not zero (ZF = 0). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JNO Jump if no overflow (overflow flag OF = 0). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JNP/JPO Jump if not parity/jump if parity odd (PF = 0). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JNS Jump if not sign (sign flag SF= 0). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JO Jump if overflow flag OF = 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JP/JPE Jump if parity/jump if parity even (PF = 1). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JS Jump if sign (SF=1)&lt;br /&gt;527/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;• Iteration Control Instructions:&lt;br /&gt;LOOP Loop through a sequence of instructions until CX = 0&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPE/LOOPZ Loop through a sequence of instructions while ZF=1 and CX ≠0&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOOPNE/LOOPNZ Loop through a sequence of instructions while ZF = 0 and &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CX ≠ 0. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;JCXZ Jump to specified address if CX = 0.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;• Interrupt Instructions:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INT Interrupt program execution, call service procedure (ISR-&lt;br /&gt;Interrupt  Service Routine). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;INTO Interrupt program execution if OF = 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;IRET Return from interrupt service procedure to main program.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;537/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;Process Control Instructions&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;Flag Set/Clear Instructions:&lt;br /&gt;STC Set carry flag CF to 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLC  Clear carry flag CF to 0. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CMC Complement the state of the carry flag CF. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STD Set direction flag DF to 1. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLD Clear direction flag DF to 0. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;STI  Set interrupt enable flag to 1 (enable INTR input). &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;CLI Clear interrupt enable flag to 0 (disable INTR input).&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;7/19/2018 54&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;a name=0&gt;&lt;/a&gt;&lt;div style=&quot;page-break-before:always; page-break-after:always&quot;&gt;&lt;div&gt;&lt;p&gt;o External Hardware Synchronization Instructions:&lt;br /&gt;HLT   Halt (do nothing) until interrupt or reset. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;WAIT Wait (do nothing) until signal on the TEST pin is low. &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;ESC Escape to external coprocessor such as 8087 or 8089&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;LOCK   An instruction prefix. Prevents another processor from &lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;taking the bus  (in MAX mode)&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;No Operation Instruction:&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;NOP No action except fetch and decode.&lt;br /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p&gt;557/19/2018&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;br /&gt;</Content>
</Section>
</Archive>
